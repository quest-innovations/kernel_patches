diff -uNr a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
--- a/drivers/input/misc/Kconfig	2017-07-03 01:07:02.000000000 +0200
+++ b/drivers/input/misc/Kconfig	2017-07-06 20:01:30.595563000 +0200
@@ -832,4 +832,6 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called hisi_powerkey.
 
+source "drivers/input/misc/st/Kconfig"
+
 endif
diff -uNr a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
--- a/drivers/input/misc/Makefile	2017-07-03 01:07:02.000000000 +0200
+++ b/drivers/input/misc/Makefile	2017-07-06 20:14:54.469136000 +0200
@@ -78,3 +78,4 @@
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+obj-$(CONFIG_INPUT_ST)			+= st/
diff -uNr a/drivers/input/misc/st/acc/ais328dq/ais328dq_acc.c b/drivers/input/misc/st/acc/ais328dq/ais328dq_acc.c
--- a/drivers/input/misc/st/acc/ais328dq/ais328dq_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais328dq/ais328dq_acc.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1232 @@
+/* Copyright (C) 2016 STMicroelectronics
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * File Name		: ais328dq_acc.c
+ * Authors		: VMA - Volume Mems & Analog Division
+ *			: Matteo Dameno (matteo.dameno@st.com)
+ *			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+ *			: Author is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V 1.0.1
+ * Date			: 2016/05/27
+ * Description		: AIS328DQ 3D accelerometer sensor LDD
+ *
+ ******************************************************************************
+ * Revision 1.0.0 2011/03/02
+ *	first release
+ * Revision 1.0.1 2012/10/07
+ *	corrects default permissions on sysfs files
+ *****************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include "ais328dq.h"
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_AIS328DQ_ACC	0x32	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS ADDRESSES	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define CTRL_REG1		0x20	/*				*/
+#define CTRL_REG2		0x21	/*				*/
+#define CTRL_REG3		0x22	/*				*/
+#define CTRL_REG4		0x23	/*				*/
+#define	CTRL_REG5		0x24	/*				*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+#define	INT_CFG2		0x34	/*	interrupt 2 config	*/
+#define	INT_SRC2		0x35	/*	interrupt 2 source	*/
+#define	INT_THS2		0x36	/*	interrupt 2 threshold	*/
+#define	INT_DUR2		0x37	/*	interrupt 2 duration	*/
+/*	end CONTROL REGISTRES ADDRESSES	*/
+
+#define AIS328DQ_ACC_ENABLE_ALL_AXES	0x07
+#define AIS328DQ_SELFTEST_EN		0x02
+#define AIS328DQ_SELFTEST_DIS		0x00
+#define AIS328DQ_SELFTEST_POS		0x00
+#define AIS328DQ_SELFTEST_NEG		0x08
+
+#define AIS328DQ_ACC_BDU_EN		0x80
+
+/* Accelerometer output data rate  */
+#define AIS328DQ_ACC_ODRHALF		0x40	/* 0.5Hz output data rate */
+#define AIS328DQ_ACC_ODR1		0x60	/* 1Hz output data rate */
+#define AIS328DQ_ACC_ODR2		0x80	/* 2Hz output data rate */
+#define AIS328DQ_ACC_ODR5		0xA0	/* 5Hz output data rate */
+#define AIS328DQ_ACC_ODR10		0xC0	/* 10Hz output data rate */
+#define AIS328DQ_ACC_ODR50		0x00	/* 50Hz output data rate */
+#define AIS328DQ_ACC_ODR100		0x08	/* 100Hz output data rate */
+#define AIS328DQ_ACC_ODR400		0x10	/* 400Hz output data rate */
+#define AIS328DQ_ACC_ODR1000		0x18	/* 1000Hz output data rate */
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_REFERENCE		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+#define	RES_INT_CFG2		9
+#define	RES_INT_THS2		10
+#define	RES_INT_DUR2		11
+
+/* end RESUME STATE INDICES */
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define MS_TO_NS(x)	((x)*1000000L)
+
+static struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} ais328dq_acc_odr_table[] = {
+	{1, AIS328DQ_ACC_PM_NORMAL | AIS328DQ_ACC_ODR1000},
+	{3, AIS328DQ_ACC_PM_NORMAL | AIS328DQ_ACC_ODR400},
+	{10, AIS328DQ_ACC_PM_NORMAL | AIS328DQ_ACC_ODR100},
+	{20, AIS328DQ_ACC_PM_NORMAL | AIS328DQ_ACC_ODR50},
+	/* low power settings, max low pass filter cut-off freq */
+	{100, AIS328DQ_ACC_ODR10 | AIS328DQ_ACC_ODR1000},
+	{200, AIS328DQ_ACC_ODR5 | AIS328DQ_ACC_ODR1000},
+	{5000, AIS328DQ_ACC_ODR2 | AIS328DQ_ACC_ODR1000 },
+	{1000, AIS328DQ_ACC_ODR1 | AIS328DQ_ACC_ODR1000 },
+	{2000, AIS328DQ_ACC_ODRHALF | AIS328DQ_ACC_ODR1000 },
+};
+
+static struct ais328dq_acc_platform_data def_pdata = {
+	.poll_interval = 100,
+	.min_interval = 1,
+	.g_range = 2,
+
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+
+	.gpio_int1 = -1,
+	.gpio_int2 = -1,
+};
+
+static inline s64 ais328dq_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int ais328dq_acc_hw_init(struct ais328dq_acc_data *acc)
+{
+	int err = -1;
+	u8 buf[4];
+
+	printk(KERN_INFO "%s: hw init start\n", AIS328DQ_ACC_DEV_NAME);
+
+	err = acc->tf->read(acc->dev, WHO_AM_I, 1, buf);
+	if (err < 0){
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			"available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+	if (buf[0] != WHOAMI_AIS328DQ_ACC) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_AIS328DQ_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_CTRL_REG1];
+	err = acc->tf->write(acc->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS1];
+	buf[1] = acc->resume_state[RES_INT_DUR1];
+	err = acc->tf->write(acc->dev, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG1];
+	err = acc->tf->write(acc->dev, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS2];
+	buf[1] = acc->resume_state[RES_INT_DUR2];
+	err = acc->tf->write(acc->dev, INT_THS2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG2];
+	err = acc->tf->write(acc->dev, INT_CFG2, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_CTRL_REG2];
+	buf[1] = acc->resume_state[RES_CTRL_REG3];
+	buf[2] = acc->resume_state[RES_CTRL_REG4];
+	buf[3] = acc->resume_state[RES_CTRL_REG5];
+	err = acc->tf->write(acc->dev, CTRL_REG2, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	printk(KERN_INFO "%s: hw init done\n", AIS328DQ_ACC_DEV_NAME);
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error 0x%x,0x%x: %d\n", buf[0],
+			buf[1], err);
+	return err;
+}
+
+static void ais328dq_acc_device_power_off(struct ais328dq_acc_data *acc)
+{
+	int err;
+	u8 buf[1] = {AIS328DQ_ACC_PM_OFF};
+
+	err = acc->tf->write(acc->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if(acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if(acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+
+}
+
+static int ais328dq_acc_device_power_on(struct ais328dq_acc_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+					"power_on failed: %d\n", err);
+			return err;
+		}
+		if(acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = ais328dq_acc_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			ais328dq_acc_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if(acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+	return 0;
+}
+
+static irqreturn_t ais328dq_acc_isr1(int irq, void *dev)
+{
+	struct ais328dq_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+	printk(KERN_INFO "%s: isr1 queued\n", AIS328DQ_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ais328dq_acc_isr2(int irq, void *dev)
+{
+	struct ais328dq_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+	printk(KERN_INFO "%s: isr2 queued\n", AIS328DQ_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void ais328dq_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct ais328dq_acc_data *acc =
+	container_of(work, struct ais328dq_acc_data, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:ais328dq_acc_get_int1_source(acc); */
+	;
+	/*  */
+	enable_irq(acc->irq1);
+}
+
+static void ais328dq_acc_irq2_work_func(struct work_struct *work)
+{
+
+	struct ais328dq_acc_data *acc =
+	container_of(work, struct ais328dq_acc_data, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:ais328dq_acc_get_tap_source(acc); */
+	;
+	/*  */
+
+	enable_irq(acc->irq2);
+}
+
+int ais328dq_acc_update_g_range(struct ais328dq_acc_data *acc, u8 range)
+{
+	int err = -1;
+
+	u8 sensitivity;
+	u8 buf[1];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val, new_g_range;
+	u8 mask = AIS328DQ_ACC_FS_MASK;
+
+	switch (range) {
+	case 2:
+		new_g_range = AIS328DQ_ACC_G_2G;
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case 4:
+		new_g_range = AIS328DQ_ACC_G_4G;
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case 8:
+		new_g_range = AIS328DQ_ACC_G_8G;
+		sensitivity = SENSITIVITY_8G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n", range);
+		return -EINVAL;
+	}
+
+	/* Set configuration register 4, which contains g range setting
+	 *  NOTE: this is a straight overwrite because this driver does
+	 *  not use any of the other configuration bits in this
+	 *  register.  Should this become untrue, we will have to read
+	 *  out the value and only change the relevant bits --XX----
+	 *  (marked by X) */
+	err = acc->tf->read(acc->dev, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+
+	init_val = buf[0];
+	new_val = new_g_range;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+
+	if (atomic_read(&acc->enabled)) {
+		buf[0] = updated_val;
+		err = acc->tf->write(acc->dev, CTRL_REG4, 1, buf);
+		if (err < 0)
+			goto error;
+	}
+
+	acc->resume_state[RES_CTRL_REG4] = updated_val;
+	acc->sensitivity = sensitivity;
+
+	return 0;
+
+error:
+	dev_err(acc->dev, "update g range failed 0x%x: %d\n",
+		buf[0], err);
+
+	return err;
+}
+
+int ais328dq_acc_update_odr(struct ais328dq_acc_data *acc,
+			    int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config[1];
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(ais328dq_acc_odr_table) - 1; i >= 0; i--) {
+		if (ais328dq_acc_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+
+	config[0] = ais328dq_acc_odr_table[i].mask;
+	config[0] |= AIS328DQ_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		err = acc->tf->write(acc->dev, CTRL_REG1, 1, config);
+		if (err < 0)
+			goto error;
+	}
+	acc->resume_state[RES_CTRL_REG1] = config[0];
+	acc->delta_ts = MS_TO_NS(poll_interval_ms);
+
+	return err;
+
+error:
+	dev_err(acc->dev, "update odr failed 0x%x: %d\n",
+		config[0], err);
+
+	return err;
+}
+
+static int ais328dq_acc_register_update(struct ais328dq_acc_data *acc,
+			u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = acc->tf->read(acc->dev, reg_address, 1, buf);
+	if (!(err < 0)) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | (~mask & init_val));
+		err = acc->tf->write(acc->dev, reg_address, 1, &updated_val);
+	}
+
+	return err;
+}
+
+
+
+static int ais328dq_acc_selftest(struct ais328dq_acc_data *acc, u8 enable)
+{
+	int err = -1;
+	u8 buf[2]={0x00,0x00};
+	char reg_address, mask, bit_values;
+
+	reg_address = CTRL_REG4;
+	mask = 0x0A;
+	if (enable > 0)
+		bit_values = AIS328DQ_SELFTEST_EN |
+						AIS328DQ_SELFTEST_POS;
+	else
+		bit_values = AIS328DQ_SELFTEST_DIS |
+						AIS328DQ_SELFTEST_POS;
+	if (atomic_read(&acc->enabled)) {
+		mutex_lock(&acc->lock);
+		err = ais328dq_acc_register_update(acc, buf, reg_address,
+				mask, bit_values);
+		acc->selftest_enabled = enable;
+		mutex_unlock(&acc->lock);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				( ~mask & acc->resume_state[RES_CTRL_REG4]));
+	}
+	return err;
+}
+
+static int ais328dq_acc_get_acceleration_data(struct ais328dq_acc_data *acc,
+					       int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc->dev, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x])
+		  : (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y])
+		  : (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
+		  : (hw_d[acc->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void ais328dq_acc_report_values(struct ais328dq_acc_data *acc,
+					int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    acc->timestamp >> 32);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    acc->timestamp & 0xffffffff);
+	input_sync(acc->input_dev);
+}
+
+int ais328dq_acc_enable(struct ais328dq_acc_data *acc)
+{
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&acc->lock);
+		err = ais328dq_acc_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			mutex_unlock(&acc->lock);
+			return err;
+		}
+
+		hrtimer_start(&acc->hr_timer, ktime_set(0, acc->delta_ts),
+			      HRTIMER_MODE_REL);
+
+		mutex_unlock(&acc->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ais328dq_acc_enable);
+
+int ais328dq_acc_disable(struct ais328dq_acc_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		mutex_lock(&acc->lock);
+		ais328dq_acc_device_power_off(acc);
+		mutex_unlock(&acc->lock);
+
+		cancel_work_sync(&acc->poll_work);
+		hrtimer_cancel(&acc->hr_timer);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ais328dq_acc_disable);
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	u8 data;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	int rc = 0;
+
+	mutex_lock(&acc->lock);
+	rc = acc->tf->read(acc->dev, reg, 1, &data);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return sprintf(buf, "0x%02x\n", data);
+
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg)
+{
+	int rc = 0;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	u8 x[1];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	x[0] = val;
+	rc = acc->tf->write(acc->dev, reg, 1, x);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return rc;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	acc->pdata->poll_interval = interval_ms;
+	ais328dq_acc_update_odr(acc, interval_ms);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&acc->lock);
+	range = acc->pdata->g_range ;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	int err;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	err = ais328dq_acc_update_g_range(acc, val);
+	if (err == 0)
+		acc->pdata->g_range = val;
+	mutex_unlock(&acc->lock);
+
+	return !err ? size : err;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		ais328dq_acc_enable(acc);
+	else
+		ais328dq_acc_disable(acc);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	mutex_lock(&acc->lock);
+	val = acc->selftest_enabled;
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	ais328dq_acc_selftest(acc, val);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_intconfig2(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_get_intconfig2(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_set_duration2(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_get_duration2(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_set_thresh2(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS2);
+}
+
+static ssize_t attr_get_thresh2(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS2);
+}
+static ssize_t attr_get_source2(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC2);
+}
+
+
+
+
+#ifdef AIS328DQ_DEBUG
+/* PAY ATTENTION: These AIS328DQ_DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	u8 x[2];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	x[0] = val;
+	rc = acc->tf->write(acc->dev, acc->reg_addr, 1, x);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t ret;
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&acc->lock);
+	err = acc->tf->read(acc->dev, acc->reg_addr, 1, &data);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	ret = sprintf(buf, "0x%02x\n", data);
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct ais328dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(enable_selftest, 0664, attr_get_selftest, attr_set_selftest),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(int2_config, 0664, attr_get_intconfig2, attr_set_intconfig2),
+	__ATTR(int2_duration, 0664, attr_get_duration2, attr_set_duration2),
+	__ATTR(int2_threshold, 0664, attr_get_thresh2, attr_set_thresh2),
+	__ATTR(int2_source, 0444, attr_get_source2, NULL),
+#ifdef AIS328DQ_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static enum hrtimer_restart ais328dq_timer_poll(struct hrtimer *timer)
+{
+	struct ais328dq_acc_data *acc;
+
+	acc = container_of((struct hrtimer *)timer, struct ais328dq_acc_data,
+			    hr_timer);
+
+	acc->timestamp = ais328dq_get_time_ns();
+
+	queue_work(acc->work_queue, &acc->poll_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void ais328dq_poll_work_func(struct work_struct *work)
+{
+	struct ais328dq_acc_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+	s64 ts, delta;
+
+	acc = container_of((struct work_struct *)work,
+			    struct ais328dq_acc_data, poll_work);
+
+	ts = ais328dq_get_time_ns();
+	delta = acc->delta_ts - (ts - acc->timestamp);
+	hrtimer_start(&acc->hr_timer, ktime_set(0, delta),
+		      HRTIMER_MODE_REL);
+
+	mutex_lock(&acc->lock);
+	err = ais328dq_acc_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_acceleration_data failed\n");
+	else
+		ais328dq_acc_report_values(acc, xyz);
+
+	mutex_unlock(&acc->lock);
+}
+
+static int ais328dq_acc_validate_pdata(struct ais328dq_acc_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 ||
+	    acc->pdata->axis_map_y > 2 || acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			acc->pdata->axis_map_x, acc->pdata->axis_map_y,
+			acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1 ||
+	    acc->pdata->negate_z > 1) {
+		dev_err(acc->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			acc->pdata->negate_x, acc->pdata->negate_y,
+			acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ais328dq_acc_input_init(struct ais328dq_acc_data *acc)
+{
+	int err;
+
+	acc->work_queue = create_workqueue("ais328dq_wq");
+	if (!acc->work_queue)
+		return -ENOMEM;
+
+	hrtimer_init(&acc->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	acc->hr_timer.function = &ais328dq_timer_poll;
+
+	INIT_WORK(&acc->poll_work, ais328dq_poll_work_func);
+
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "input device allocation failed\n");
+		goto err0;
+	}
+
+	acc->input_dev->name = AIS328DQ_ACC_DEV_NAME;
+	acc->input_dev->id.bustype = acc->bus_type;
+	acc->input_dev->dev.parent = acc->dev;
+
+	input_set_drvdata(acc->input_dev, acc);
+
+	set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_MSB, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, acc->input_dev->mscbit);
+
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev,
+			"unable to register input device %s\n",
+			acc->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(acc->input_dev);
+err0:
+	return err;
+}
+
+static void ais328dq_acc_input_cleanup(struct ais328dq_acc_data *acc)
+{
+	if (acc->work_queue) {
+		flush_workqueue(acc->work_queue);
+		destroy_workqueue(acc->work_queue);
+		acc->work_queue = NULL;
+	}
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+int ais328dq_acc_probe(struct ais328dq_acc_data *acc)
+{
+	int err = -1;
+
+	if (acc->dev->platform_data == NULL) {
+		dev_info(acc->dev,
+			 "platform data is NULL. using default one.\n");
+		acc->dev->platform_data = &def_pdata;
+	}
+
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kmalloc(sizeof(*acc->pdata), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+				"failed to allocate memory for pdata: %d\n",
+				err);
+		goto err_mutexunlock;
+	}
+
+	memcpy(acc->pdata, acc->dev->platform_data, sizeof(*acc->pdata));
+
+	err = ais328dq_acc_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if(acc->pdata->gpio_int1 >= 0){
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		printk(KERN_INFO "%s: %s has set irq1 to irq: %d "
+							"mapped on gpio:%d\n",
+		AIS328DQ_ACC_DEV_NAME, __func__, acc->irq1,
+							acc->pdata->gpio_int1);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		printk(KERN_INFO "%s: %s has set irq2 to irq: %d "
+						"mapped on gpio:%d\n",
+			AIS328DQ_ACC_DEV_NAME, __func__, acc->irq2,
+							acc->pdata->gpio_int2);
+	}
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+
+	acc->resume_state[RES_CTRL_REG1] = AIS328DQ_ACC_ENABLE_ALL_AXES;
+	acc->resume_state[RES_CTRL_REG4] = AIS328DQ_ACC_BDU_EN;
+
+	err = ais328dq_acc_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = ais328dq_acc_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_g_range failed\n");
+		goto err_power_off;
+	}
+
+	err = ais328dq_acc_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = ais328dq_acc_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+			"device AIS328DQ_ACC_DEV_NAME "
+						"sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	ais328dq_acc_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	if(acc->pdata->gpio_int1 >= 0){
+		INIT_WORK(&acc->irq1_work, ais328dq_acc_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("ais328dq_acc_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, ais328dq_acc_isr1,
+			IRQF_TRIGGER_RISING, "ais328dq_acc_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		INIT_WORK(&acc->irq2_work, ais328dq_acc_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("ais328dq_acc_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev,
+				"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, ais328dq_acc_isr2,
+			IRQF_TRIGGER_RISING, "ais328dq_acc_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+				goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	mutex_unlock(&acc->lock);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if(acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	ais328dq_acc_input_cleanup(acc);
+err_power_off:
+	ais328dq_acc_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(ais328dq_acc_probe);
+
+int ais328dq_acc_remove(struct ais328dq_acc_data *acc)
+{
+	if (acc->pdata->gpio_int1 >= 0){
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0){
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	ais328dq_acc_input_cleanup(acc);
+	ais328dq_acc_device_power_off(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+	kfree(acc->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(ais328dq_acc_remove);
+
+MODULE_DESCRIPTION("ais328dq accelerometer sysfs driver");
+MODULE_AUTHOR("Matteo Dameno, STMicroelectronics");
+MODULE_AUTHOR("Lorenzo Bianconi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/acc/ais328dq/ais328dq.h b/drivers/input/misc/st/acc/ais328dq/ais328dq.h
--- a/drivers/input/misc/st/acc/ais328dq/ais328dq.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais328dq/ais328dq.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,145 @@
+/* Copyright (C) 2014 STMicroelectronics
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * File Name		: ais328dq.h
+ * Authors		: VMA - Volume Mems & Analog Division
+ *			: Matteo Dameno (matteo.dameno@st.com)
+ *			: Author is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V 1.0.1
+ * Date			: 2012/10/07
+ * Description		: AIS328DQ 3D accelerometer sensor LDD
+ *
+ */
+
+#ifndef __AIS328DQ_H__
+#define __AIS328DQ_H__
+
+#define AIS328DQ_ACC_I2C_SAD_L		(0x18)
+#define AIS328DQ_ACC_I2C_SAD_H		(0x19)
+#define	AIS328DQ_ACC_DEV_NAME	"ais328dq_acc"
+
+
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define AIS328DQ_ACC_FS_MASK		0x30
+#define AIS328DQ_ACC_G_2G 		0x00
+#define AIS328DQ_ACC_G_4G 		0x10
+#define AIS328DQ_ACC_G_8G 		0x30
+
+/* Accelerometer Sensor Operating Mode */
+#define AIS328DQ_ACC_ENABLE		0x01
+#define AIS328DQ_ACC_DISABLE		0x00
+#define AIS328DQ_ACC_PM_NORMAL		0x20
+#define AIS328DQ_ACC_PM_OFF		AIS328DQ_ACC_DISABLE
+
+#ifdef __KERNEL__
+
+#if defined(CONFIG_INPUT_AIS328DQ_SPI) || \
+    defined(CONFIG_INPUT_AIS328DQ_SPI_MODULE)
+#define AIS328DQ_RX_MAX_LENGTH	500
+#define AIS328DQ_TX_MAX_LENGTH	500
+
+struct ais328dq_transfer_buffer {
+	u8 rx_buf[AIS328DQ_RX_MAX_LENGTH];
+	u8 tx_buf[AIS328DQ_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif
+
+struct ais328dq_transfer_function {
+	int (*write)(struct device *dev, u8 reg_addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+struct ais328dq_acc_platform_data {
+
+	int poll_interval;
+	int min_interval;
+
+	u8 g_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+#define	RESUME_ENTRIES		12
+
+struct ais328dq_acc_data {
+	const char *name;
+	struct device *dev;
+	u16 bus_type;
+	struct ais328dq_acc_platform_data *pdata;
+
+	struct mutex lock;
+	s64 timestamp, delta_ts;
+	struct hrtimer hr_timer;
+	struct workqueue_struct *work_queue;
+	struct work_struct poll_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	int selftest_enabled;
+
+	atomic_t enabled;
+
+	u8 sensitivity;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef AIS328DQ_DEBUG
+	u8 reg_addr;
+#endif
+#if defined(CONFIG_INPUT_AIS328DQ_SPI) || \
+    defined(CONFIG_INPUT_AIS328DQ_SPI_MODULE)
+	struct ais328dq_transfer_buffer tb;
+#endif
+	struct ais328dq_transfer_function *tf;
+};
+
+int ais328dq_acc_probe(struct ais328dq_acc_data *acc);
+int ais328dq_acc_remove(struct ais328dq_acc_data *acc);
+int ais328dq_acc_enable(struct ais328dq_acc_data *acc);
+int ais328dq_acc_disable(struct ais328dq_acc_data *acc);
+
+#endif /* __KERNEL__ */
+
+#endif  /* __AIS328DQ_H__ */
diff -uNr a/drivers/input/misc/st/acc/ais328dq/ais328dq_i2c.c b/drivers/input/misc/st/acc/ais328dq/ais328dq_i2c.c
--- a/drivers/input/misc/st/acc/ais328dq/ais328dq_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais328dq/ais328dq_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,191 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: ais328dq_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Lorenzo Bianconi <lorenzo.bianconi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.0
+* Date		: 2016/May/27
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "ais328dq.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+#define I2C_RETRIES		5
+#define I2C_RETRY_DELAY		5
+
+static int ais328dq_i2c_read(struct device *dev, u8 reg_addr,
+			     int len, u8 *data)
+{
+	int err = 0, tries = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags & I2C_M_TEN;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = (client->flags &I2C_M_TEN) | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while (err != 2 && ++tries < I2C_RETRIES);
+
+	return (err != 2) ? -EIO : err;
+}
+
+static int ais328dq_i2c_write(struct device *dev, u8 reg_addr,
+			      int len, u8 *data)
+{
+	int err = 0, tries = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags & I2C_M_TEN;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while (err != 1 && ++tries < I2C_RETRIES);
+
+	return (err != 1) ? -EIO : err;
+}
+
+static struct ais328dq_transfer_function ais328dq_tf_i2c = {
+	.write = ais328dq_i2c_write,
+	.read = ais328dq_i2c_read,
+};
+
+static int ais328dq_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	int err;
+	struct ais328dq_acc_data *acc;
+
+	acc = kmalloc(sizeof(struct ais328dq_acc_data), GFP_KERNEL);
+	if (!acc)
+		return -ENOMEM;
+
+	acc->dev = &client->dev;
+	acc->name = client->name;
+	acc->bus_type = BUS_I2C;
+	acc->tf = &ais328dq_tf_i2c;
+	i2c_set_clientdata(client, acc);
+
+	err = ais328dq_acc_probe(acc);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(acc);
+	return err;
+}
+
+static int ais328dq_i2c_remove(struct i2c_client *client)
+{
+	struct ais328dq_acc_data *acc = i2c_get_clientdata(client);
+
+	ais328dq_acc_remove(acc);
+	kfree(acc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ais328dq_suspend(struct device *dev)
+{
+	struct ais328dq_acc_data *acc = i2c_get_clientdata(to_i2c_client(dev));
+
+	return ais328dq_acc_disable(acc);
+}
+
+static int ais328dq_resume(struct device *dev)
+{
+	struct ais328dq_acc_data *acc = i2c_get_clientdata(to_i2c_client(dev));
+
+	return ais328dq_acc_enable(acc);
+}
+
+static const struct dev_pm_ops ais328dq_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ais328dq_suspend, ais328dq_resume)
+};
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id ais328dq_ids[] = {
+	{ AIS328DQ_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ais328dq_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id ais328dq_id_table[] = {
+	{ .compatible = "st,ais328dq", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ais328dq_id_table);
+#endif
+
+static struct i2c_driver ais328dq_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = AIS328DQ_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = &ais328dq_pm_ops,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = ais328dq_id_table,
+#endif
+	},
+	.remove = ais328dq_i2c_remove,
+	.probe = ais328dq_i2c_probe,
+	.id_table = ais328dq_ids,
+};
+
+module_i2c_driver(ais328dq_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics ais328dq i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/ais328dq/ais328dq_spi.c b/drivers/input/misc/st/acc/ais328dq/ais328dq_spi.c
--- a/drivers/input/misc/st/acc/ais328dq/ais328dq_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais328dq/ais328dq_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics ais328dq_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "ais328dq.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int ais328dq_spi_read(struct device *device, u8 addr,
+				    int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct ais328dq_acc_data *acc = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = acc->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = acc->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	acc->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, acc->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int ais328dq_spi_write(struct device *device, u8 addr,
+				     int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct ais328dq_acc_data *acc = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = acc->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= AIS328DQ_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	acc->tb.tx_buf[0] = addr;
+
+	memcpy(&acc->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct ais328dq_transfer_function ais328dq_spi_tf = {
+	.write = ais328dq_spi_write,
+	.read = ais328dq_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int ais328dq_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct ais328dq_acc_data *acc = spi_get_drvdata(spi);
+
+	return ais328dq_acc_enable(acc);
+}
+
+static int ais328dq_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct ais328dq_acc_data *acc = spi_get_drvdata(spi);
+
+	return ais328dq_acc_disable(acc);
+}
+
+static const struct dev_pm_ops ais328dq_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ais328dq_spi_suspend,
+				ais328dq_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int ais328dq_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct ais328dq_acc_data *acc;
+
+#ifdef AIS328DQ_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	acc = kzalloc(sizeof(struct ais328dq_acc_data), GFP_KERNEL);
+	if (!acc) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	acc->name = spi->modalias;
+	acc->bus_type = BUS_SPI;
+	acc->tf = &ais328dq_spi_tf;
+	acc->dev = &spi->dev;
+	spi_set_drvdata(spi, acc);
+
+	mutex_init(&acc->lock);
+
+	err = ais328dq_acc_probe(acc);
+	if (err < 0) {
+		kfree(acc);
+		return err;
+	}
+
+	return 0;
+}
+
+int ais328dq_spi_remove(struct spi_device *spi)
+{
+	struct ais328dq_acc_data *acc = spi_get_drvdata(spi);
+
+#ifdef AIS328DQ_DEBUG
+	dev_info(acc->dev, "driver removing\n");
+#endif
+
+	ais328dq_acc_remove(acc);
+	kfree(acc);
+
+	return 0;
+}
+
+static const struct spi_device_id ais328dq_spi_id[] = {
+	{ "ais328dq", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, ais328dq_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id ais328dq_spi_id_table[] = {
+	{ .compatible = "st,ais328dq" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ais328dq_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver ais328dq_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "ais328dq_spi",
+#ifdef CONFIG_PM
+		.pm = &ais328dq_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = ais328dq_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = ais328dq_spi_probe,
+	.remove = ais328dq_spi_remove,
+	.id_table = ais328dq_spi_id,
+};
+
+module_spi_driver(ais328dq_spi_driver);
+
+MODULE_DESCRIPTION("ais328dq acc spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/acc/ais328dq/Kconfig b/drivers/input/misc/st/acc/ais328dq/Kconfig
--- a/drivers/input/misc/st/acc/ais328dq/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais328dq/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_AIS328DQ
+	tristate "STMicroelectronics AIS328DQ sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_AIS328DQ_I2C if (I2C)
+	select INPUT_AIS328DQ_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics AIS328DQ sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called ais328dq.
+
+config INPUT_AIS328DQ_I2C
+	tristate
+	depends on INPUT_AIS328DQ
+	depends on I2C
+
+config INPUT_AIS328DQ_SPI
+	tristate
+	depends on INPUT_AIS328DQ
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/ais328dq/Makefile b/drivers/input/misc/st/acc/ais328dq/Makefile
--- a/drivers/input/misc/st/acc/ais328dq/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais328dq/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for the input misc STM acc lis2de driver
+#
+obj-$(CONFIG_INPUT_AIS328DQ) += ais328dq_acc.o
+obj-$(CONFIG_INPUT_AIS328DQ_I2C) += ais328dq_i2c.o
+obj-$(CONFIG_INPUT_AIS328DQ_SPI) += ais328dq_spi.o
diff -uNr a/drivers/input/misc/st/acc/ais3624dq/ais3624dq_acc.c b/drivers/input/misc/st/acc/ais3624dq/ais3624dq_acc.c
--- a/drivers/input/misc/st/acc/ais3624dq/ais3624dq_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais3624dq/ais3624dq_acc.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1166 @@
+/* Copyright (C) 2016 STMicroelectronics
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *
+ * File Name		: ais3624dq_acc.c
+ * Authors		: VMA - Volume Mems & Analog Division
+ *			: Matteo Dameno (matteo.dameno@st.com)
+ *			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+ *			: Mario Tesi (mario.tesi@st.com)
+ *			: Authors is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V 1.0.2
+ * Date			: 2016/06/06
+ * Description		: AIS3624DQ 3D accelerometer sensor
+ *
+ ******************************************************************************
+ * Revision 1.0.0 2011/03/02
+ *	first release
+ * Revision 1.0.1 2012/10/07
+ *	corrects default permissions on sysfs files
+ * Revision 1.0.2 2016/06/06
+ *	added spi support and suspend/resume capabilities
+ *****************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include "ais3624dq.h"
+
+#define SENSITIVITY_6G		1	/**	mg/LSB	*/
+#define SENSITIVITY_12G		2	/**	mg/LSB	*/
+#define SENSITIVITY_24G		4	/**	mg/LSB	*/
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_AIS3624DQ_ACC	0x32	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS ADDRESSES	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define CTRL_REG1		0x20	/*				*/
+#define CTRL_REG2		0x21	/*				*/
+#define CTRL_REG3		0x22	/*				*/
+#define CTRL_REG4		0x23	/*				*/
+#define	CTRL_REG5		0x24	/*				*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+#define	INT_CFG2		0x34	/*	interrupt 2 config	*/
+#define	INT_SRC2		0x35	/*	interrupt 2 source	*/
+#define	INT_THS2		0x36	/*	interrupt 2 threshold	*/
+#define	INT_DUR2		0x37	/*	interrupt 2 duration	*/
+/*	end CONTROL REGISTRES ADDRESSES	*/
+
+#define AIS3624DQ_ACC_ENABLE_ALL_AXES	0x07
+#define AIS3624DQ_SELFTEST_EN	0x02
+#define AIS3624DQ_SELFTEST_DIS	0x00
+#define AIS3624DQ_SELFTEST_POS	0x00
+#define AIS3624DQ_SELFTEST_NEG	0x08
+
+#define AIS3624DQ_ACC_BDU_EN	0x80
+
+/* Accelerometer output data rate  */
+#define AIS3624DQ_ACC_ODRHALF	0x40	/* 0.5Hz output data rate */
+#define AIS3624DQ_ACC_ODR1	0x60	/* 1Hz output data rate */
+#define AIS3624DQ_ACC_ODR2	0x80	/* 2Hz output data rate */
+#define AIS3624DQ_ACC_ODR5	0xA0	/* 5Hz output data rate */
+#define AIS3624DQ_ACC_ODR10	0xC0	/* 10Hz output data rate */
+#define AIS3624DQ_ACC_ODR50	0x00	/* 50Hz output data rate */
+#define AIS3624DQ_ACC_ODR100	0x08	/* 100Hz output data rate */
+#define AIS3624DQ_ACC_ODR400	0x10	/* 400Hz output data rate */
+#define AIS3624DQ_ACC_ODR1000	0x18	/* 1000Hz output data rate */
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1	0
+#define	RES_CTRL_REG2	1
+#define	RES_CTRL_REG3	2
+#define	RES_CTRL_REG4	3
+#define	RES_CTRL_REG5	4
+#define	RES_REFERENCE	5
+
+#define	RES_INT_CFG1	6
+#define	RES_INT_THS1	7
+#define	RES_INT_DUR1	8
+#define	RES_INT_CFG2	9
+#define	RES_INT_THS2	10
+#define	RES_INT_DUR2	11
+
+/* end RESUME STATE INDICES */
+
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+
+static struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} ais3624dq_acc_odr_table[] = {
+	{1, AIS3624DQ_ACC_PM_NORMAL | AIS3624DQ_ACC_ODR1000},
+	{3, AIS3624DQ_ACC_PM_NORMAL | AIS3624DQ_ACC_ODR400},
+	{10, AIS3624DQ_ACC_PM_NORMAL | AIS3624DQ_ACC_ODR100},
+	{20, AIS3624DQ_ACC_PM_NORMAL | AIS3624DQ_ACC_ODR50},
+	/* low power settings, max low pass filter cut-off freq */
+	{100, AIS3624DQ_ACC_ODR10 | AIS3624DQ_ACC_ODR1000},
+	{200, AIS3624DQ_ACC_ODR5 | AIS3624DQ_ACC_ODR1000},
+	{5000, AIS3624DQ_ACC_ODR2 | AIS3624DQ_ACC_ODR1000 },
+	{1000, AIS3624DQ_ACC_ODR1 | AIS3624DQ_ACC_ODR1000 },
+	{2000, AIS3624DQ_ACC_ODRHALF | AIS3624DQ_ACC_ODR1000 },
+};
+
+static int ais3624dq_acc_hw_init(struct ais3624dq_acc_data *acc)
+{
+	int err = -1;
+	u8 buf[4];
+
+	printk(KERN_INFO "%s: hw init start\n", AIS3624DQ_ACC_DEV_NAME);
+
+	err = acc->tf->read(acc->dev, WHO_AM_I, 1, buf);
+	if (err < 0){
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			"available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+	if (buf[0] != WHOAMI_AIS3624DQ_ACC) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_AIS3624DQ_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_CTRL_REG1];
+	err = acc->tf->write(acc->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS1];
+	buf[1] = acc->resume_state[RES_INT_DUR1];
+	err = acc->tf->write(acc->dev, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG1];
+	err = acc->tf->write(acc->dev, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS2];
+	buf[1] = acc->resume_state[RES_INT_DUR2];
+	err = acc->tf->write(acc->dev, INT_THS2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG2];
+	err = acc->tf->write(acc->dev, INT_CFG2, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_CTRL_REG2];
+	buf[1] = acc->resume_state[RES_CTRL_REG3];
+	buf[2] = acc->resume_state[RES_CTRL_REG4];
+	buf[3] = acc->resume_state[RES_CTRL_REG5];
+	err = acc->tf->write(acc->dev, CTRL_REG2, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	printk(KERN_INFO "%s: hw init done\n", AIS3624DQ_ACC_DEV_NAME);
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error 0x%x,0x%x: %d\n", buf[0],
+			buf[1], err);
+
+	return err;
+}
+
+static void ais3624dq_acc_device_power_off(struct ais3624dq_acc_data *acc)
+{
+	int err;
+	u8 buf[1] = {AIS3624DQ_ACC_PM_OFF};
+
+	err = acc->tf->write(acc->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if(acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if(acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int ais3624dq_acc_device_power_on(struct ais3624dq_acc_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+		if(acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = ais3624dq_acc_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			ais3624dq_acc_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if(acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	return 0;
+}
+
+static irqreturn_t ais3624dq_acc_isr1(int irq, void *dev)
+{
+	struct ais3624dq_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+	printk(KERN_INFO "%s: isr1 queued\n", AIS3624DQ_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ais3624dq_acc_isr2(int irq, void *dev)
+{
+	struct ais3624dq_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+	printk(KERN_INFO "%s: isr2 queued\n", AIS3624DQ_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void ais3624dq_acc_irq1_work_func(struct work_struct *work)
+{
+	struct ais3624dq_acc_data *acc =
+	container_of(work, struct ais3624dq_acc_data, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:ais3624dq_acc_get_int1_source(acc); */
+	enable_irq(acc->irq1);
+}
+
+static void ais3624dq_acc_irq2_work_func(struct work_struct *work)
+{
+	struct ais3624dq_acc_data *acc =
+	container_of(work, struct ais3624dq_acc_data, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:ais3624dq_acc_get_tap_source(acc); */
+	enable_irq(acc->irq2);
+}
+
+int ais3624dq_acc_update_g_range(struct ais3624dq_acc_data *acc, u8 new_g_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 buf[1];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = AIS3624DQ_ACC_FS_MASK;
+
+	switch (new_g_range) {
+	case AIS3624DQ_ACC_G_6G:
+		sensitivity = SENSITIVITY_6G;
+		break;
+	case AIS3624DQ_ACC_G_12G:
+		sensitivity = SENSITIVITY_12G;
+		break;
+	case AIS3624DQ_ACC_G_24G:
+		sensitivity = SENSITIVITY_24G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n",
+			new_g_range);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&acc->enabled)) {
+		/* Set configuration register 4, which contains g range setting
+		 *  NOTE: this is a straight overwrite because this driver does
+		 *  not use any of the other configuration bits in this
+		 *  register.  Should this become untrue, we will have to read
+		 *  out the value and only change the relevant bits --XX----
+		 *  (marked by X) */
+		err = acc->tf->read(acc->dev, CTRL_REG4, 1, buf);
+		if (err < 0)
+			goto error;
+
+		init_val = buf[0];
+		acc->resume_state[RES_CTRL_REG4] = init_val;
+		new_val = new_g_range;
+		updated_val = ((mask & new_val) | ((~mask) & init_val));
+		buf[0] = updated_val;
+		err = acc->tf->write(acc->dev, CTRL_REG4, 1, buf);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = updated_val;
+		acc->sensitivity = sensitivity;
+	}
+
+	return err;
+error:
+	dev_err(acc->dev, "update g range failed 0x%x: %d\n",
+		buf[0], err);
+
+	return err;
+}
+
+int ais3624dq_acc_update_odr(struct ais3624dq_acc_data *acc,
+			     int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(ais3624dq_acc_odr_table) - 1; i >= 0; i--) {
+		if (ais3624dq_acc_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+
+	config = ais3624dq_acc_odr_table[i].mask;
+	config |= AIS3624DQ_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		err = acc->tf->write(acc->dev, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+	}
+	acc->resume_state[RES_CTRL_REG1] = config;
+
+	return err;
+
+error:
+	dev_err(acc->dev, "update odr failed 0x%x: %d\n",
+		config, err);
+
+	return err;
+}
+
+static int ais3624dq_acc_register_update(struct ais3624dq_acc_data *acc,
+					 u8 *buf, u8 reg_address, u8 mask,
+					 u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+
+	err = acc->tf->read(acc->dev, reg_address, 1, buf);
+	if (!(err < 0)) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | (~mask & init_val));
+		err = acc->tf->write(acc->dev, reg_address, 1, &updated_val);
+	}
+
+	return err;
+}
+
+static int ais3624dq_acc_selftest(struct ais3624dq_acc_data *acc, u8 enable)
+{
+	int err = -1;
+	u8 buf[2] = {0x00, 0x00};
+	char reg_address = CTRL_REG4, mask = 0x0A, bit_values;
+
+	if (enable > 0)
+		bit_values = AIS3624DQ_SELFTEST_EN |
+			     AIS3624DQ_SELFTEST_POS;
+	else
+		bit_values = AIS3624DQ_SELFTEST_DIS |
+			     AIS3624DQ_SELFTEST_POS;
+
+	if (atomic_read(&acc->enabled)) {
+		mutex_lock(&acc->lock);
+		err = ais3624dq_acc_register_update(acc, buf, reg_address,
+						    mask, bit_values);
+		acc->selftest_enabled = enable;
+		mutex_unlock(&acc->lock);
+		if (err < 0)
+			return err;
+
+		acc->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				( ~mask & acc->resume_state[RES_CTRL_REG4]));
+	}
+
+	return err;
+}
+
+static int ais3624dq_acc_get_acceleration_data(struct ais3624dq_acc_data *acc,
+					       int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc->dev, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+	/* Out data is 12 bit left just. */
+	hw_d[0] = (((s16)((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16)((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16)((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x])
+		  : (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y])
+		  : (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
+		  : (hw_d[acc->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void ais3624dq_acc_report_values(struct ais3624dq_acc_data *acc,
+					int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+int ais3624dq_acc_enable(struct ais3624dq_acc_data *acc)
+{
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&acc->lock);
+		err = ais3624dq_acc_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			mutex_unlock(&acc->lock);
+			return err;
+		}
+		schedule_delayed_work(&acc->input_work,
+			msecs_to_jiffies(acc->pdata->poll_interval));
+		mutex_unlock(&acc->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ais3624dq_acc_enable);
+
+int ais3624dq_acc_disable(struct ais3624dq_acc_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&acc->input_work);
+
+		mutex_lock(&acc->lock);
+		ais3624dq_acc_device_power_off(acc);
+		mutex_unlock(&acc->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ais3624dq_acc_disable);
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	u8 data;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	int rc = 0;
+
+	mutex_lock(&acc->lock);
+	rc = acc->tf->read(acc->dev, reg, 1, &data);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg)
+{
+	int rc = 0;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	u8 x[1];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	x[0] = val;
+	rc = acc->tf->write(acc->dev, reg, 1, x);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return rc;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->poll_interval = interval_ms;
+	ais3624dq_acc_update_odr(acc, interval_ms);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->g_range ;
+	switch (val) {
+	case AIS3624DQ_ACC_G_6G:
+		range = 6;
+		break;
+	case AIS3624DQ_ACC_G_12G:
+		range = 12;
+		break;
+	case AIS3624DQ_ACC_G_24G:
+		range = 24;
+		break;
+	}
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->g_range = val;
+	ais3624dq_acc_update_g_range(acc, val);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		ais3624dq_acc_enable(acc);
+	else
+		ais3624dq_acc_disable(acc);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->selftest_enabled;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	ais3624dq_acc_selftest(acc, val);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_intconfig2(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_get_intconfig2(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_set_duration2(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_get_duration2(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_set_thresh2(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS2);
+}
+
+static ssize_t attr_get_thresh2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS2);
+}
+static ssize_t attr_get_source2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC2);
+}
+
+#ifdef AIS3624DQ_DEBUG
+/* PAY ATTENTION: These AIS3624DQ_DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	u8 x[2];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	x[0] = val;
+	rc = acc->tf->write(acc->dev, acc->reg_addr, 1, x);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&acc->lock);
+	err = acc->tf->read(acc->dev, acc->reg_addr, 1, &data);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	ret = sprintf(buf, "0x%02x\n", data);
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct ais3624dq_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] =
+{
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(enable_selftest, 0664, attr_get_selftest, attr_set_selftest),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(int2_config, 0664, attr_get_intconfig2, attr_set_intconfig2),
+	__ATTR(int2_duration, 0664, attr_get_duration2, attr_set_duration2),
+	__ATTR(int2_threshold, 0664, attr_get_thresh2, attr_set_thresh2),
+	__ATTR(int2_source, 0444, attr_get_source2, NULL),
+#ifdef AIS3624DQ_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void ais3624dq_acc_input_work_func(struct work_struct *work)
+{
+	struct ais3624dq_acc_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			   struct ais3624dq_acc_data, input_work);
+
+	mutex_lock(&acc->lock);
+	err = ais3624dq_acc_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_acceleration_data failed\n");
+	else
+		ais3624dq_acc_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work,
+			      msecs_to_jiffies(acc->pdata->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+static int ais3624dq_acc_validate_pdata(struct ais3624dq_acc_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 || acc->pdata->axis_map_y > 2 ||
+	    acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			acc->pdata->axis_map_x, acc->pdata->axis_map_y,
+			acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1 ||
+	    acc->pdata->negate_z > 1) {
+		dev_err(acc->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			acc->pdata->negate_x, acc->pdata->negate_y,
+			acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ais3624dq_acc_input_init(struct ais3624dq_acc_data *acc)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&acc->input_work, ais3624dq_acc_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		dev_err(acc->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	acc->input_dev->name = AIS3624DQ_ACC_DEV_NAME;
+	acc->input_dev->id.bustype = acc->bus_type;
+	acc->input_dev->dev.parent = acc->dev;
+
+	input_set_drvdata(acc->input_dev, acc);
+
+	set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev,
+			"unable to register input device %s\n",
+			acc->input_dev->name);
+		input_free_device(acc->input_dev);
+	}
+
+	return err;
+}
+
+static void ais3624dq_acc_input_cleanup(struct ais3624dq_acc_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+int ais3624dq_acc_probe(struct ais3624dq_acc_data *acc)
+{
+	int err = -1;
+
+	if (acc->dev->platform_data == NULL) {
+		dev_err(acc->dev, "platform data is NULL. exiting.\n");
+		return -ENODEV;
+	}
+
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kmalloc(sizeof(*acc->pdata), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+			"failed to allocate memory for pdata: %d\n",
+			err);
+		goto err_mutexunlock;
+	}
+
+	memcpy(acc->pdata, acc->dev->platform_data, sizeof(*acc->pdata));
+
+	err = ais3624dq_acc_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if(acc->pdata->gpio_int1 >= 0){
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		printk(KERN_INFO "%s: %s has set irq1 to irq: %d "
+		       "mapped on gpio:%d\n", AIS3624DQ_ACC_DEV_NAME,
+		       __func__, acc->irq1, acc->pdata->gpio_int1);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		printk(KERN_INFO "%s: %s has set irq2 to irq: %d "
+		       "mapped on gpio:%d\n", AIS3624DQ_ACC_DEV_NAME,
+		       __func__, acc->irq2, acc->pdata->gpio_int2);
+	}
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+
+	acc->resume_state[RES_CTRL_REG1] = AIS3624DQ_ACC_ENABLE_ALL_AXES;
+	acc->resume_state[RES_CTRL_REG4] = AIS3624DQ_ACC_BDU_EN;
+
+	err = ais3624dq_acc_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = ais3624dq_acc_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_g_range failed\n");
+		goto err_power_off;
+	}
+
+	err = ais3624dq_acc_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = ais3624dq_acc_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+			"device AIS3624DQ_ACC_DEV_NAME "
+			"sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	ais3624dq_acc_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	if(acc->pdata->gpio_int1 >= 0){
+		INIT_WORK(&acc->irq1_work, ais3624dq_acc_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("ais3624dq_acc_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev,
+				"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, ais3624dq_acc_isr1,
+				  IRQF_TRIGGER_RISING, "ais3624dq_acc_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		INIT_WORK(&acc->irq2_work, ais3624dq_acc_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("ais3624dq_acc_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev,
+				"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, ais3624dq_acc_isr2,
+			IRQF_TRIGGER_RISING, "ais3624dq_acc_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+				goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	mutex_unlock(&acc->lock);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if(acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	ais3624dq_acc_input_cleanup(acc);
+err_power_off:
+	ais3624dq_acc_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(ais3624dq_acc_probe);
+
+int ais3624dq_acc_remove(struct ais3624dq_acc_data *acc)
+{
+	if (acc->pdata->gpio_int1 >= 0){
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0){
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	ais3624dq_acc_input_cleanup(acc);
+	ais3624dq_acc_device_power_off(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+	kfree(acc->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(ais3624dq_acc_remove);
+
+MODULE_DESCRIPTION("ais3624dq accelerometer sysfs driver");
+MODULE_AUTHOR("Matteo Dameno, STMicroelectronics");
+MODULE_AUTHOR("Lorenzo Bianconi, STMicroelectronics");
+MODULE_AUTHOR("Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/ais3624dq/ais3624dq.h b/drivers/input/misc/st/acc/ais3624dq/ais3624dq.h
--- a/drivers/input/misc/st/acc/ais3624dq/ais3624dq.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais3624dq/ais3624dq.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,138 @@
+/* Copyright (C) 2014 STMicroelectronics
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * File Name		: ais3624dq.h
+ * Authors		: VMA - Volume Mems & Analog Division
+ *			: Matteo Dameno (matteo.dameno@st.com)
+ *			: Author is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V 1.0.1
+ * Date			: 2012/10/07
+ * Description		: AIS3624DQ 3D accelerometer sensor LDD
+ *
+ */
+
+#ifndef __AIS3624DQ_H__
+#define __AIS3624DQ_H__
+
+#define	AIS3624DQ_ACC_DEV_NAME	"ais3624dq_acc"
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale bit */
+#define AIS3624DQ_ACC_FS_MASK		0x30
+#define AIS3624DQ_ACC_G_6G 		0x00
+#define AIS3624DQ_ACC_G_12G 		0x10
+#define AIS3624DQ_ACC_G_24G 		0x30
+
+/* Accelerometer Sensor Operating Mode */
+#define AIS3624DQ_ACC_ENABLE		0x01
+#define AIS3624DQ_ACC_DISABLE		0x00
+#define AIS3624DQ_ACC_PM_NORMAL		0x20
+#define AIS3624DQ_ACC_PM_OFF		AIS3624DQ_ACC_DISABLE
+
+#ifdef __KERNEL__
+
+#if defined(CONFIG_INPUT_AIS3624DQ_SPI) || \
+    defined(CONFIG_INPUT_AIS3624DQ_SPI_MODULE)
+#define AIS3624DQ_RX_MAX_LENGTH	500
+#define AIS3624DQ_TX_MAX_LENGTH	500
+
+struct ais3624dq_transfer_buffer {
+	u8 rx_buf[AIS3624DQ_RX_MAX_LENGTH];
+	u8 tx_buf[AIS3624DQ_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif
+
+struct ais3624dq_transfer_function {
+	int (*write)(struct device *dev, u8 reg_addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+struct ais3624dq_acc_platform_data {
+	int poll_interval;
+	int min_interval;
+
+	u8 g_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+#define	RESUME_ENTRIES		12
+
+struct ais3624dq_acc_data {
+	const char *name;
+	struct device *dev;
+	u16 bus_type;
+	struct ais3624dq_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	int selftest_enabled;
+
+	atomic_t enabled;
+	u8 sensitivity;
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef AIS3624DQ_DEBUG
+	u8 reg_addr;
+#endif
+#if defined(CONFIG_INPUT_AIS3624DQ_SPI) || \
+    defined(CONFIG_INPUT_AIS3624DQ_SPI_MODULE)
+	struct ais3624dq_transfer_buffer tb;
+#endif
+	struct ais3624dq_transfer_function *tf;
+};
+
+int ais3624dq_acc_probe(struct ais3624dq_acc_data *acc);
+int ais3624dq_acc_remove(struct ais3624dq_acc_data *acc);
+#ifdef CONFIG_PM
+int ais3624dq_acc_enable(struct ais3624dq_acc_data *acc);
+int ais3624dq_acc_disable(struct ais3624dq_acc_data *acc);
+#endif
+
+#endif /* __KERNEL__ */
+
+#endif  /* __AIS3624DQ_H__ */
diff -uNr a/drivers/input/misc/st/acc/ais3624dq/ais3624dq_i2c.c b/drivers/input/misc/st/acc/ais3624dq/ais3624dq_i2c.c
--- a/drivers/input/misc/st/acc/ais3624dq/ais3624dq_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais3624dq/ais3624dq_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,191 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: ais3624dq_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Lorenzo Bianconi <lorenzo.bianconi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.0
+* Date		: 2016/May/27
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "ais3624dq.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+#define I2C_RETRIES		5
+#define I2C_RETRY_DELAY		5
+
+static int ais3624dq_i2c_read(struct device *dev, u8 reg_addr, int len,
+			      u8 *data)
+{
+	int err = 0, tries = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags & I2C_M_TEN;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = (client->flags &I2C_M_TEN) | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while (err != 2 && ++tries < I2C_RETRIES);
+
+	return (err != 2) ? -EIO : err;
+}
+
+static int ais3624dq_i2c_write(struct device *dev, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err = 0, tries = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags & I2C_M_TEN;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while (err != 1 && ++tries < I2C_RETRIES);
+
+	return (err != 1) ? -EIO : err;
+}
+
+static struct ais3624dq_transfer_function ais3624dq_tf_i2c = {
+	.write = ais3624dq_i2c_write,
+	.read = ais3624dq_i2c_read,
+};
+
+static int ais3624dq_i2c_probe(struct i2c_client *client,
+			       const struct i2c_device_id *id)
+{
+	int err;
+	struct ais3624dq_acc_data *acc;
+
+	acc = kmalloc(sizeof(struct ais3624dq_acc_data), GFP_KERNEL);
+	if (!acc)
+		return -ENOMEM;
+
+	acc->dev = &client->dev;
+	acc->name = client->name;
+	acc->bus_type = BUS_I2C;
+	acc->tf = &ais3624dq_tf_i2c;
+	i2c_set_clientdata(client, acc);
+
+	err = ais3624dq_acc_probe(acc);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(acc);
+	return err;
+}
+
+static int ais3624dq_i2c_remove(struct i2c_client *client)
+{
+	struct ais3624dq_acc_data *acc = i2c_get_clientdata(client);
+
+	ais3624dq_acc_remove(acc);
+	kfree(acc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ais3624dq_suspend(struct device *dev)
+{
+	struct ais3624dq_acc_data *acc = i2c_get_clientdata(to_i2c_client(dev));
+
+	return ais3624dq_acc_disable(acc);
+}
+
+static int ais3624dq_resume(struct device *dev)
+{
+	struct ais3624dq_acc_data *acc = i2c_get_clientdata(to_i2c_client(dev));
+
+	return ais3624dq_acc_enable(acc);
+}
+
+static const struct dev_pm_ops ais3624dq_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ais3624dq_suspend, ais3624dq_resume)
+};
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id ais3624dq_ids[] = {
+	{ AIS3624DQ_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ais3624dq_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id ais3624dq_id_table[] = {
+	{ .compatible = "st,ais3624dq", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ais3624dq_id_table);
+#endif
+
+static struct i2c_driver ais3624dq_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = AIS3624DQ_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = &ais3624dq_pm_ops,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = ais3624dq_id_table,
+#endif
+	},
+	.remove = ais3624dq_i2c_remove,
+	.probe = ais3624dq_i2c_probe,
+	.id_table = ais3624dq_ids,
+};
+
+module_i2c_driver(ais3624dq_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics ais3624dq i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/ais3624dq/ais3624dq_spi.c b/drivers/input/misc/st/acc/ais3624dq/ais3624dq_spi.c
--- a/drivers/input/misc/st/acc/ais3624dq/ais3624dq_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais3624dq/ais3624dq_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,198 @@
+/*
+ * STMicroelectronics ais3624dq_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "ais3624dq.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int ais3624dq_spi_read(struct device *device, u8 addr, int len,
+			      u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct ais3624dq_acc_data *acc = spi_get_drvdata(spi);
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = acc->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = acc->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	acc->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, acc->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int ais3624dq_spi_write(struct device *device, u8 addr, int len,
+			       u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct ais3624dq_acc_data *acc = spi_get_drvdata(spi);
+	struct spi_transfer xfers = {
+		.tx_buf = acc->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= AIS3624DQ_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	acc->tb.tx_buf[0] = addr;
+
+	memcpy(&acc->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(spi, &msg);
+}
+
+static struct ais3624dq_transfer_function ais3624dq_spi_tf = {
+	.write = ais3624dq_spi_write,
+	.read = ais3624dq_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int ais3624dq_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct ais3624dq_acc_data *acc = spi_get_drvdata(spi);
+
+	return ais3624dq_acc_enable(acc);
+}
+
+static int ais3624dq_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct ais3624dq_acc_data *acc = spi_get_drvdata(spi);
+
+	return ais3624dq_acc_disable(acc);
+}
+
+static const struct dev_pm_ops ais3624dq_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ais3624dq_spi_suspend,
+				ais3624dq_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int ais3624dq_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct ais3624dq_acc_data *acc;
+
+#ifdef AIS3624DQ_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	acc = kzalloc(sizeof(struct ais3624dq_acc_data), GFP_KERNEL);
+	if (!acc) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	acc->name = spi->modalias;
+	acc->bus_type = BUS_SPI;
+	acc->tf = &ais3624dq_spi_tf;
+	acc->dev = &spi->dev;
+	spi_set_drvdata(spi, acc);
+
+	mutex_init(&acc->lock);
+
+	err = ais3624dq_acc_probe(acc);
+	if (err < 0) {
+		kfree(acc);
+		return err;
+	}
+
+	return 0;
+}
+
+int ais3624dq_spi_remove(struct spi_device *spi)
+{
+	struct ais3624dq_acc_data *acc = spi_get_drvdata(spi);
+
+#ifdef AIS3624DQ_DEBUG
+	dev_info(acc->dev, "driver removing\n");
+#endif
+
+	ais3624dq_acc_remove(acc);
+	kfree(acc);
+
+	return 0;
+}
+
+static const struct spi_device_id ais3624dq_spi_id[] = {
+	{ AIS3624DQ_ACC_DEV_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, ais3624dq_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id ais3624dq_spi_id_table[] = {
+	{ .compatible = "st,ais3624dq" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ais3624dq_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver ais3624dq_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = AIS3624DQ_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = &ais3624dq_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = ais3624dq_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = ais3624dq_spi_probe,
+	.remove = ais3624dq_spi_remove,
+	.id_table = ais3624dq_spi_id,
+};
+
+module_spi_driver(ais3624dq_spi_driver);
+
+MODULE_DESCRIPTION("ais3624dq acc spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/acc/ais3624dq/Kconfig b/drivers/input/misc/st/acc/ais3624dq/Kconfig
--- a/drivers/input/misc/st/acc/ais3624dq/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais3624dq/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_AIS3624DQ
+	tristate "STMicroelectronics AIS3624DQ sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_AIS3624DQ_I2C if (I2C)
+	select INPUT_AIS3624DQ_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics AIS3624DQ sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called ais3624dq.
+
+config INPUT_AIS3624DQ_I2C
+	tristate
+	depends on INPUT_AIS3624DQ
+	depends on I2C
+
+config INPUT_AIS3624DQ_SPI
+	tristate
+	depends on INPUT_AIS3624DQ
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/ais3624dq/Makefile b/drivers/input/misc/st/acc/ais3624dq/Makefile
--- a/drivers/input/misc/st/acc/ais3624dq/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/ais3624dq/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for the input misc STM acc ais3624dq driver
+#
+obj-$(CONFIG_INPUT_AIS3624DQ) += ais3624dq_acc.o
+obj-$(CONFIG_INPUT_AIS3624DQ_I2C) += ais3624dq_i2c.o
+obj-$(CONFIG_INPUT_AIS3624DQ_SPI) += ais3624dq_spi.o
diff -uNr a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_core.c b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_core.c
--- a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_core.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1057 @@
+/*
+ * STMicroelectronics h3lis100dl Accelerometer driver
+ * Based on lis331dlh input driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "h3lis100dl.h"
+
+#define MS_TO_NS(msec)          ((msec) * 1000 * 1000)
+
+//#define	DEBUG	1
+
+#define SENSITIVITY_100G	780	/**	mg/LSB	*/
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_H3LIS100DL	0x32	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define CTRL_REG1		0x20	/*				*/
+#define CTRL_REG2		0x21	/*				*/
+#define CTRL_REG3		0x22	/*				*/
+#define CTRL_REG4		0x23	/*				*/
+#define	CTRL_REG5		0x24	/*				*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+#define	INT_CFG2		0x34	/*	interrupt 2 config	*/
+#define	INT_SRC2		0x35	/*	interrupt 2 source	*/
+#define	INT_THS2		0x36	/*	interrupt 2 threshold	*/
+#define	INT_DUR2		0x37	/*	interrupt 2 duration	*/
+/*	end CONTROL REGISTRES	*/
+
+#define H3LIS100DL_ENABLE_ALL_AXES	0x07
+#define H3LIS100DL_SELFTEST_EN	0x02
+#define H3LIS100DL_SELFTEST_DIS	0x00
+#define H3LIS100DL_SELFTEST_POS	0x00
+#define H3LIS100DL_SELFTEST_NEG	0x08
+
+/* Accelerometer output data rate  */
+#define H3LIS100DL_ODRHALF	0x40	/* 0.5Hz output data rate */
+#define H3LIS100DL_ODR1		0x60	/* 1Hz output data rate */
+#define H3LIS100DL_ODR2		0x80	/* 2Hz output data rate */
+#define H3LIS100DL_ODR5		0xA0	/* 5Hz output data rate */
+#define H3LIS100DL_ODR10	0xC0	/* 10Hz output data rate */
+#define H3LIS100DL_ODR50	0x00	/* 50Hz output data rate */
+#define H3LIS100DL_ODR100	0x08	/* 100Hz output data rate */
+#define H3LIS100DL_ODR400	0x10	/* 400Hz output data rate */
+#define H3LIS100DL_ODR1000	0x18	/* 1000Hz output data rate */
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_REFERENCE		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+#define	RES_INT_CFG2		9
+#define	RES_INT_THS2		10
+#define	RES_INT_DUR2		11
+
+/* end RESUME STATE INDICES */
+
+static struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} h3lis100dl_odr_table[] = {
+	{1, H3LIS100DL_PM_NORMAL | H3LIS100DL_ODR1000},
+	{3, H3LIS100DL_PM_NORMAL | H3LIS100DL_ODR400},
+	{10, H3LIS100DL_PM_NORMAL | H3LIS100DL_ODR100},
+	{20, H3LIS100DL_PM_NORMAL | H3LIS100DL_ODR50},
+	/* low power settings, max low pass filter cut-off freq */
+	{100, H3LIS100DL_ODR10 | H3LIS100DL_ODR1000},
+	{200, H3LIS100DL_ODR5 | H3LIS100DL_ODR1000},
+	{5000, H3LIS100DL_ODR2 | H3LIS100DL_ODR1000 },
+	{1000, H3LIS100DL_ODR1 | H3LIS100DL_ODR1000 },
+	{2000, H3LIS100DL_ODRHALF | H3LIS100DL_ODR1000 },
+};
+
+static inline int64_t h3lis100dl_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static struct workqueue_struct *h3lis100dl_workqueue;
+
+static int h3lis100dl_hw_init(struct h3lis100dl_data *acc)
+{
+	int err = -1;
+	u8 buf[6];
+
+#ifdef DEBUG
+	printk(KERN_INFO "%s: hw init start\n", H3LIS100DL_DEV_NAME);
+#endif
+
+	err = acc->tf->read(acc, WHO_AM_I, 1, buf);
+	if (err < 0){
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			 "available/working?\n");
+		goto err_firstread;
+	} else {
+		acc->hw_working = 1;
+	}
+	if (buf[0] != WHOAMI_H3LIS100DL) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_H3LIS100DL, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_CTRL_REG1];
+	err = acc->tf->write(acc, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS1];
+	buf[1] = acc->resume_state[RES_INT_DUR1];
+	err = acc->tf->write(acc, (AUTO_INCREMENT | INT_THS1), 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG1];
+	err = acc->tf->write(acc, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS2];
+	buf[1] = acc->resume_state[RES_INT_DUR2];
+	err = acc->tf->write(acc, (AUTO_INCREMENT | INT_THS2), 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG2];
+	err = acc->tf->write(acc, INT_CFG2, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_CTRL_REG2];
+	buf[1] = acc->resume_state[RES_CTRL_REG3];
+	buf[2] = acc->resume_state[RES_CTRL_REG4];
+	buf[3] = acc->resume_state[RES_CTRL_REG5];
+	err = acc->tf->write(acc, (AUTO_INCREMENT | CTRL_REG2), 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+
+#ifdef DEBUG
+	printk(KERN_INFO "%s: hw init done\n", H3LIS100DL_DEV_NAME);
+#endif
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error 0x%x,0x%x: %d\n", buf[0],
+		buf[1], err);
+	return err;
+}
+
+static void h3lis100dl_device_power_off(struct h3lis100dl_data *acc)
+{
+	int err;
+	u8 buf = H3LIS100DL_PM_OFF;
+
+	err = acc->tf->write(acc, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized)
+		acc->hw_initialized = 0;
+}
+
+static int h3lis100dl_device_power_on(struct h3lis100dl_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev, "power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	if (!acc->hw_initialized) {
+		err = h3lis100dl_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			h3lis100dl_device_power_off(acc);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * hrtimer callback - it is called every polling_rate msec.
+ */
+enum hrtimer_restart h3lis100dl_timer_func_queue_work(struct hrtimer *timer)
+{
+	struct h3lis100dl_data *acc;
+
+
+	acc = container_of((struct hrtimer *)timer,
+			   struct h3lis100dl_data, hr_timer);
+
+	acc->timestamp = h3lis100dl_get_time_ns();
+	queue_work(h3lis100dl_workqueue, &acc->input_work);
+
+	return HRTIMER_NORESTART;
+}
+
+int h3lis100dl_update_g_range(struct h3lis100dl_data *acc, u8 new_g_range)
+{
+	int err = -1;
+
+	u16 sensitivity;
+	u8 buf;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = H3LIS100DL_FS_MASK;
+
+	sensitivity = SENSITIVITY_100G;
+
+	if (atomic_read(&acc->enabled)) {
+		/* Set configuration register 4, which contains g range setting
+		 *  NOTE: this is a straight overwrite because this driver does
+		 *  not use any of the other configuration bits in this
+		 *  register.  Should this become untrue, we will have to read
+		 *  out the value and only change the relevant bits --XX----
+		 *  (marked by X) */
+		err = acc->tf->read(acc, CTRL_REG4, 1, &buf);
+		if (err < 0)
+			goto error;
+
+		init_val = buf;
+		acc->resume_state[RES_CTRL_REG4] = init_val;
+		new_val = new_g_range;
+		updated_val = ((mask & new_val) | ((~mask) & init_val));
+		buf = updated_val;
+		err = acc->tf->write(acc, CTRL_REG4, 1, &buf);
+		if (err < 0)
+			goto error;
+		acc->resume_state[RES_CTRL_REG4] = updated_val;
+		acc->sensitivity = sensitivity;
+	}
+
+	return err;
+error:
+	dev_err(acc->dev, "update g range failed 0x%x,0x%x: %d\n",
+		CTRL_REG4, buf, err);
+
+	return err;
+}
+
+int h3lis100dl_update_odr(struct h3lis100dl_data *acc,
+			  int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(h3lis100dl_odr_table) - 1; i >= 0; i--) {
+		if (h3lis100dl_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+	config = h3lis100dl_odr_table[i].mask;
+
+	config |= H3LIS100DL_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		flush_workqueue(h3lis100dl_workqueue);
+
+		err = acc->tf->write(acc, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+	}
+	acc->resume_state[RES_CTRL_REG1] = config;
+	acc->ktime = ktime_set(0, MS_TO_NS(poll_interval_ms));
+
+	return err;
+
+error:
+	dev_err(acc->dev, "update odr failed 0x%x,0x%x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int h3lis100dl_register_write(struct h3lis100dl_data *acc, u8 *buf,
+				     u8 reg_address, u8 new_value)
+{
+	int err = -1;
+
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+	err = acc->tf->write(acc, reg_address, 1, buf);
+	if (err < 0)
+		return err;
+
+	return err;
+}
+
+static int h3lis100dl_register_read(struct h3lis100dl_data *acc, u8 *buf,
+				    u8 reg_address)
+{
+
+	int err = -1;
+
+	err = acc->tf->read(acc, reg_address, 1, buf);
+
+	return err;
+}
+
+static int h3lis100dl_register_update(struct h3lis100dl_data *acc,
+				      u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = h3lis100dl_register_read(acc, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = h3lis100dl_register_write(acc, buf, reg_address,
+						updated_val);
+	}
+	return err;
+}
+
+static int h3lis100dl_selftest(struct h3lis100dl_data *acc, u8 enable)
+{
+	int err = -1;
+	u8 buf[2] = { 0x00, 0x00 };
+	char reg_address, mask, bit_values;
+
+	reg_address = CTRL_REG4;
+	mask = 0x0A;
+	if (enable > 0)
+		bit_values = H3LIS100DL_SELFTEST_EN |
+			     H3LIS100DL_SELFTEST_POS;
+	else
+		bit_values = H3LIS100DL_SELFTEST_DIS |
+			     H3LIS100DL_SELFTEST_POS;
+	if (atomic_read(&acc->enabled)) {
+		mutex_lock(&acc->lock);
+		err = h3lis100dl_register_update(acc, buf, reg_address,
+						 mask, bit_values);
+		acc->selftest_enabled = enable;
+		mutex_unlock(&acc->lock);
+		if (err < 0)
+			return err;
+		acc->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				(~mask & acc->resume_state[RES_CTRL_REG4]));
+	}
+	return err;
+}
+
+static int h3lis100dl_get_acceleration_data(struct h3lis100dl_data *acc,
+					    int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc, (AUTO_INCREMENT | AXISDATA_REG), 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s8)acc_data[1];
+	hw_d[1] = (s8)acc_data[3];
+	hw_d[2] = (s8)acc_data[5];
+
+	xyz[0] = hw_d[0] * acc->sensitivity;
+	xyz[1] = hw_d[1] * acc->sensitivity;
+	xyz[2] = hw_d[2] * acc->sensitivity;
+
+#ifdef DEBUG
+	printk(KERN_INFO "%s read x=%d, y=%d, z=%d\n",
+	       H3LIS100DL_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+#endif
+	return err;
+}
+
+static void h3lis100dl_report_values(struct h3lis100dl_data *acc,
+				     int *xyz)
+{
+	struct input_dev  *input = acc->input_dev;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    acc->timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    acc->timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static int h3lis100dl_enable(struct h3lis100dl_data *acc)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		err = h3lis100dl_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+
+		hrtimer_start(&acc->hr_timer, acc->ktime, HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+
+static int h3lis100dl_disable(struct h3lis100dl_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_work_sync(&acc->input_work);
+		hrtimer_cancel(&acc->hr_timer);
+		h3lis100dl_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	int rc = 0;
+	u8 data;
+
+	rc = acc->tf->read(acc, reg, 1, &data);
+	/*TODO: error need to be managed */
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg)
+{
+	int rc = 0;
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 x[2];
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x[0] = val;
+	rc = acc->tf->write(acc, reg, 1, x);
+	/*TODO: error need to be managed */
+	return rc;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	acc->pdata->poll_interval = interval_ms;
+	h3lis100dl_update_odr(acc, interval_ms);
+	mutex_unlock(&acc->lock);
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		h3lis100dl_enable(acc);
+	else
+		h3lis100dl_disable(acc);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->selftest_enabled;
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	h3lis100dl_selftest(acc, val);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_intconfig2(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_get_intconfig2(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_set_duration2(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_get_duration2(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_set_thresh2(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS2);
+}
+
+static ssize_t attr_get_thresh2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS2);
+}
+static ssize_t attr_get_source2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC2);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	u8 reg;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+
+	rc = acc->tf->write(acc, reg, 1, &val);
+	/*TODO: error need to be managed */
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	int rc;
+	u8 reg, val;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	rc = acc->tf->read(acc, reg, 1, val);
+	/*TODO: error need to be managed */
+	ret = sprintf(buf, "0x%02x\n", val);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct h3lis100dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(enable_selftest, 0664, attr_get_selftest, attr_set_selftest),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(int2_config, 0664, attr_get_intconfig2, attr_set_intconfig2),
+	__ATTR(int2_duration, 0664, attr_get_duration2, attr_set_duration2),
+	__ATTR(int2_threshold, 0664, attr_get_thresh2, attr_set_thresh2),
+	__ATTR(int2_source, 0444, attr_get_source2, NULL),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+/*
+ * Workqueue callback - it is called as soon as a job in the queue
+ * is scheduled.
+ */
+static void h3lis100dl_input_work_func(struct work_struct *work)
+{
+	struct h3lis100dl_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct work_struct *)work,
+			   struct h3lis100dl_data, input_work);
+
+	hrtimer_start(&acc->hr_timer, acc->ktime, HRTIMER_MODE_REL);
+
+	err = h3lis100dl_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_acceleration_data failed\n");
+	else
+		h3lis100dl_report_values(acc, xyz);
+}
+
+static int h3lis100dl_validate_pdata(struct h3lis100dl_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int h3lis100dl_input_init(struct h3lis100dl_data *acc)
+{
+	int err;
+
+	if (!h3lis100dl_workqueue)
+		h3lis100dl_workqueue = create_workqueue(acc->name);
+
+	if (!h3lis100dl_workqueue)
+		return -EINVAL;
+
+	INIT_WORK(&acc->input_work, h3lis100dl_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "input device allocation failed\n");
+		goto err0;
+	}
+
+	acc->input_dev->name = H3LIS100DL_DEV_NAME;
+	acc->input_dev->id.bustype = acc->bustype;
+	acc->input_dev->dev.parent = acc->dev;
+
+	input_set_drvdata(acc->input_dev, acc);
+
+	set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, acc->input_dev->mscbit);
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev,
+			"unable to register input device %s\n",
+			acc->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(acc->input_dev);
+err0:
+	return err;
+}
+
+static void h3lis100dl_input_cleanup(struct h3lis100dl_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 h3lis100dl_parse_dt(struct h3lis100dl_data *cdata, struct device* dev)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "poll-interval", &val))
+		cdata->pdata->poll_interval = val;
+	else
+		cdata->pdata->poll_interval = 10;
+
+	cdata->pdata->init = NULL;
+	cdata->pdata->exit = NULL;
+	cdata->pdata->power_on = NULL;
+	cdata->pdata->power_off = NULL;
+
+	return 0;
+}
+#endif
+
+int h3lis100dl_common_probe(struct h3lis100dl_data *acc)
+{
+	int err = -1;
+
+	pr_info("%s: probe start.\n", H3LIS100DL_DEV_NAME);
+
+#ifndef CONFIG_OF
+	if (acc->dev->platform_data == NULL) {
+		dev_err(acc->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+
+	}
+#else
+	acc->dev->platform_data = NULL;
+#endif
+
+	mutex_init(&acc->lock);
+	mutex_init(&acc->tb.buf_lock);
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kzalloc(sizeof(struct h3lis100dl_platform_data), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+#ifdef CONFIG_OF
+	h3lis100dl_parse_dt(acc, acc->dev);
+#else
+	memcpy(acc->pdata, acc->dev->platform_data, sizeof(*acc->pdata));
+#endif
+
+	err = h3lis100dl_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	acc->pdata->g_range = H3LIS100DL_G_100G;
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+
+	acc->resume_state[RES_CTRL_REG1] = H3LIS100DL_ENABLE_ALL_AXES;
+
+	err = h3lis100dl_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = h3lis100dl_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = h3lis100dl_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_g_range failed\n");
+		goto err_power_off;
+	}
+
+	err = h3lis100dl_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+			"device H3LIS100DL_DEV_NAME "
+			"sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	h3lis100dl_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	hrtimer_init(&acc->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	acc->hr_timer.function = &h3lis100dl_timer_func_queue_work;
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(acc->dev, "%s: probed\n", H3LIS100DL_DEV_NAME);
+
+	return 0;
+
+err_input_cleanup:
+	h3lis100dl_input_cleanup(acc);
+err_power_off:
+	h3lis100dl_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+	printk(KERN_ERR "%s: Driver Init failed\n", H3LIS100DL_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(h3lis100dl_common_probe);
+
+int h3lis100dl_common_remove(struct h3lis100dl_data *acc)
+{
+	h3lis100dl_input_cleanup(acc);
+	h3lis100dl_device_power_off(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+	kfree(acc->pdata);
+
+	if(h3lis100dl_workqueue) {
+		flush_workqueue(h3lis100dl_workqueue);
+		destroy_workqueue(h3lis100dl_workqueue);
+		h3lis100dl_workqueue = NULL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(h3lis100dl_common_remove);
+
+#ifdef CONFIG_PM
+int h3lis100dl_common_resume(struct h3lis100dl_data *acc)
+{
+	if (acc->on_before_suspend)
+		return h3lis100dl_enable(acc);
+	return 0;
+}
+EXPORT_SYMBOL(h3lis100dl_common_resume);
+
+int h3lis100dl_common_suspend(struct h3lis100dl_data *acc)
+{
+	acc->on_before_suspend = atomic_read(&acc->enabled);
+	return h3lis100dl_disable(acc);
+}
+EXPORT_SYMBOL(h3lis100dl_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("h3lis100dl accelerometer driver");
+MODULE_AUTHOR("Armando Visconti, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl.h b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl.h
--- a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,123 @@
+ /*
+  * STMicroelectronics h3lis100dl Accelerometer driver
+  * Based on lis331dlh input driver
+  *
+  * Copyright 2016 STMicroelectronics Inc.
+  *
+  * Armando Visconti <armando.visconti@st.com>
+  *
+  * Licensed under the GPL-2.
+  */
+
+#ifndef __H3LIS100DL_H__
+#define __H3LIS100DL_H__
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define SAD0L				0x00
+#define SAD0H				0x01
+#define H3LIS100DL_I2C_SADROOT		0x0C
+#define H3LIS100DL_I2C_SAD_L		((H3LIS100DL_I2C_SADROOT<<1)|SAD0L)
+#define H3LIS100DL_I2C_SAD_H		((H3LIS100DL_I2C_SADROOT<<1)|SAD0H)
+#define	H3LIS100DL_DEV_NAME		"h3lis100dl"
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	H3LIS100DL_FS_MASK		0x30
+#define H3LIS100DL_G_100G 		0x00
+
+/* Accelerometer Sensor Operating Mode */
+#define H3LIS100DL_ENABLE		0x01
+#define H3LIS100DL_DISABLE		0x00
+#define H3LIS100DL_PM_NORMAL		0x20
+#define H3LIS100DL_PM_OFF		H3LIS100DL_DISABLE
+
+#define H3LIS100DL_RX_MAX_LENGTH	500
+#define H3LIS100DL_TX_MAX_LENGTH	500
+
+#define AUTO_INCREMENT			0x80
+
+#define	RESUME_ENTRIES			12
+
+#ifdef __KERNEL__
+
+struct h3lis100dl_data;
+
+struct h3lis100dl_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[H3LIS100DL_RX_MAX_LENGTH];
+	u8 tx_buf[H3LIS100DL_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct h3lis100dl_transfer_function {
+	int (*write)(struct h3lis100dl_data *cdata, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct h3lis100dl_data *cdata, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct h3lis100dl_platform_data {
+	int poll_interval;
+	int min_interval;
+
+	u8 g_range;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct h3lis100dl_data {
+	const char *name;
+	struct device *dev;
+	struct h3lis100dl_platform_data *pdata;
+
+	struct mutex lock;
+	struct work_struct input_work;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+
+	struct input_dev *input_dev;
+	u16 bustype;
+
+	int64_t timestamp;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	int selftest_enabled;
+
+	atomic_t enabled;
+	int on_before_suspend;
+
+	u16 sensitivity;
+
+	u8 resume_state[RESUME_ENTRIES];
+	const struct h3lis100dl_transfer_function *tf;
+	struct h3lis100dl_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+int h3lis100dl_common_probe(struct h3lis100dl_data *acc);
+int h3lis100dl_common_remove(struct h3lis100dl_data *acc);
+
+#ifdef CONFIG_PM
+int h3lis100dl_common_resume(struct h3lis100dl_data *cdata);
+int h3lis100dl_common_suspend(struct h3lis100dl_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* __KERNEL__ */
+#endif  /* __H3LIS100DL_H__ */
diff -uNr a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_i2c.c b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_i2c.c
--- a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,192 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics *******************
+*
+* File Name          : h3lis100dl_i2c.c
+* Authors            : AMS - VMU - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.1.0
+* Date               : 2016/Apr/26
+* Description        : h3lis100dl i2c driver
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+
+#include "h3lis100dl.h"
+
+/* I2C conf. parameter */
+#define I2C_RETRY_DELAY		5
+#define I2C_RETRIES		5
+
+static int h3lis100dl_i2c_read(struct h3lis100dl_data *cdata, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+	int tries = 0;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int h3lis100dl_i2c_write(struct h3lis100dl_data *cdata, u8 reg_addr, int len,
+				u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static const struct h3lis100dl_transfer_function h3lis100dl_tf_i2c = {
+	.write = h3lis100dl_i2c_write,
+	.read = h3lis100dl_i2c_read,
+};
+
+static int h3lis100dl_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int err;
+	struct h3lis100dl_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bustype = BUS_I2C;
+	cdata->tf = &h3lis100dl_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = h3lis100dl_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int h3lis100dl_i2c_remove(struct i2c_client *client)
+{
+	struct h3lis100dl_data *cdata = i2c_get_clientdata(client);
+
+	h3lis100dl_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", H3LIS100DL_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h3lis100dl_suspend(struct device *dev)
+{
+	struct h3lis100dl_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return h3lis100dl_common_suspend(cdata);
+}
+
+static int h3lis100dl_resume(struct device *dev)
+{
+	struct h3lis100dl_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return h3lis100dl_common_resume(cdata);
+}
+
+static const struct dev_pm_ops h3lis100dl_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(h3lis100dl_suspend, h3lis100dl_resume)
+};
+
+#define H3LIS100DL_PM_OPS		(&h3lis100dl_pm_ops)
+#else /* CONFIG_PM */
+#define H3LIS100DL_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+
+static const struct i2c_device_id h3lis100dl_ids[] = {
+	{H3LIS100DL_DEV_NAME, 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, h3lis100dl_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id h3lis100dl_id_i2c_table[] = {
+	{ .compatible = "st,h3lis100dl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, h3lis100dl_id_i2c_table);
+#endif
+
+static struct i2c_driver h3lis100dl_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = H3LIS100DL_DEV_NAME,
+		.pm = H3LIS100DL_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = h3lis100dl_id_i2c_table,
+#endif
+	},
+	.probe    = h3lis100dl_i2c_probe,
+	.remove   = h3lis100dl_i2c_remove,
+	.id_table = h3lis100dl_ids,
+};
+
+module_i2c_driver(h3lis100dl_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics h3lis100dl i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_spi.c b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_spi.c
--- a/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis100dl/h3lis100dl_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,213 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics *******************
+*
+* File Name          : h3lis100dl_spi.c
+* Authors            : AMS - VMU - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.1.0
+* Date               : 2016/Apr/26
+* Description        : h3lis100dl spi driver
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "h3lis100dl.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* Set auto increment accordingly */
+static inline u8 fill_autoinc(u8 reg_addr)
+{
+	return reg_addr | ((reg_addr & AUTO_INCREMENT) ? SPI_AUTO_INCREMENT : 0);
+}
+
+static int h3lis100dl_spi_read(struct h3lis100dl_data *cdata, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = fill_autoinc(reg_addr) | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int h3lis100dl_spi_write(struct h3lis100dl_data *cdata, u8 reg_addr, int len,
+				u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= H3LIS100DL_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = fill_autoinc(reg_addr);
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+
+static const struct h3lis100dl_transfer_function h3lis100dl_tf_spi = {
+	.write = h3lis100dl_spi_write,
+	.read = h3lis100dl_spi_read,
+};
+
+static int h3lis100dl_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct h3lis100dl_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->bustype = BUS_SPI;
+	cdata->tf = &h3lis100dl_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = h3lis100dl_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int h3lis100dl_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct h3lis100dl_data *cdata = spi_get_drvdata(spi);
+
+	h3lis100dl_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", H3LIS100DL_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h3lis100dl_suspend(struct device *dev)
+{
+	struct h3lis100dl_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return h3lis100dl_common_suspend(cdata);
+}
+
+static int h3lis100dl_resume(struct device *dev)
+{
+	struct h3lis100dl_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return h3lis100dl_common_resume(cdata);
+}
+
+static const struct dev_pm_ops h3lis100dl_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(h3lis100dl_suspend, h3lis100dl_resume)
+};
+
+#define H3LIS100DL_PM_OPS		(&h3lis100dl_pm_ops)
+#else /* CONFIG_PM */
+#define H3LIS100DL_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct spi_device_id h3lis100dl_ids[] = {
+	{H3LIS100DL_DEV_NAME, 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, h3lis100dl_ids);
+
+static const struct of_device_id h3lis100dl_id_spi_table[] = {
+	{.compatible = "st,h3lis100dl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, h3lis100dl_id_spi_table);
+#endif
+
+static struct spi_driver h3lis100dl_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = H3LIS100DL_DEV_NAME,
+		.pm = H3LIS100DL_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = h3lis100dl_id_spi_table,
+#endif
+	},
+	.probe    = h3lis100dl_spi_probe,
+	.remove   = h3lis100dl_spi_remove,
+	.id_table = h3lis100dl_ids,
+};
+
+module_spi_driver(h3lis100dl_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics h3lis100dl spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/h3lis100dl/Kconfig b/drivers/input/misc/st/acc/h3lis100dl/Kconfig
--- a/drivers/input/misc/st/acc/h3lis100dl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis100dl/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_H3LIS100DL
+	tristate "STMicroelectronics H3LIS100DL sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_H3LIS100DL_I2C if (I2C)
+	select INPUT_H3LIS100DL_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics H3LIS100DL sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called h3lis100dl.
+
+config INPUT_H3LIS100DL_I2C
+	tristate
+	depends on INPUT_H3LIS100DL
+	depends on I2C
+
+config INPUT_H3LIS100DL_SPI
+	tristate
+	depends on INPUT_H3LIS100DL
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/h3lis100dl/Makefile b/drivers/input/misc/st/acc/h3lis100dl/Makefile
--- a/drivers/input/misc/st/acc/h3lis100dl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis100dl/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc h3lis100dl driver
+#
+h3lis100dl-core-y += h3lis100dl_core.o
+obj-$(CONFIG_INPUT_H3LIS100DL) += h3lis100dl-core.o
+obj-$(CONFIG_INPUT_H3LIS100DL_I2C) += h3lis100dl_i2c.o
+obj-$(CONFIG_INPUT_H3LIS100DL_SPI) += h3lis100dl_spi.o
diff -uNr a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_core.c b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_core.c
--- a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_core.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1168 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: h3lis331dl_core.c
+* Authors		: MSH - Motion Mems BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.0.1
+* Date			: 2016/05/30
+* Description		: H3LIS331DL 3D accelerometer sensor API starting from
+* 			: lis331dlh driver
+*
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************
+ Revision 1.0.1 2016/05/30:
+  First porting from lis331dlh driver impl.
+******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "h3lis331dl.h"
+
+#define G_MAX	8000
+
+#define SENSITIVITY_100G	50	/** mg/LSB */
+#define SENSITIVITY_200G	100	/** mg/LSB */
+#define SENSITIVITY_400G	200	/** mg/LSB */
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_H3LIS331DL_ACC	0x32	/* Expctd content for WAI */
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/* WhoAmI register */
+#define CTRL_REG1		0x20
+#define CTRL_REG2		0x21
+#define CTRL_REG3		0x22
+#define CTRL_REG4		0x23
+#define	CTRL_REG5		0x24
+
+#define	INT_CFG1		0x30	/* interrupt 1 config */
+#define	INT_SRC1		0x31	/* interrupt 1 source */
+#define	INT_THS1		0x32	/* interrupt 1 threshold */
+#define	INT_DUR1		0x33	/* interrupt 1 duration */
+
+#define	INT_CFG2		0x34	/* interrupt 2 config */
+#define	INT_SRC2		0x35	/* interrupt 2 source */
+#define	INT_THS2		0x36	/* interrupt 2 threshold */
+#define	INT_DUR2		0x37	/* interrupt 2 duration */
+/*	end CONTROL REGISTRES	*/
+
+#define H3LIS331DL_ACC_ENABLE_ALL_AXES	0x07
+
+/* Accelerometer output data rate  */
+#define H3LIS331DL_ACC_ODRHALF		0x40	/* 0.5Hz output data rate */
+#define H3LIS331DL_ACC_ODR1		0x60	/* 1Hz output data rate */
+#define H3LIS331DL_ACC_ODR2		0x80	/* 2Hz output data rate */
+#define H3LIS331DL_ACC_ODR5		0xA0	/* 5Hz output data rate */
+#define H3LIS331DL_ACC_ODR10		0xC0	/* 10Hz output data rate */
+#define H3LIS331DL_ACC_ODR50		0x00	/* 50Hz output data rate */
+#define H3LIS331DL_ACC_ODR100		0x08	/* 100Hz output data rate */
+#define H3LIS331DL_ACC_ODR400		0x10	/* 400Hz output data rate */
+#define H3LIS331DL_ACC_ODR1000		0x18	/* 1000Hz output data rate */
+
+#define FUZZ		0
+#define FLAT		0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1	0
+#define	RES_CTRL_REG2	1
+#define	RES_CTRL_REG3	2
+#define	RES_CTRL_REG4	3
+#define	RES_CTRL_REG5	4
+#define	RES_REFERENCE	5
+
+#define	RES_INT_CFG1	6
+#define	RES_INT_THS1	7
+#define	RES_INT_DUR1	8
+#define	RES_INT_CFG2	9
+#define	RES_INT_THS2	10
+#define	RES_INT_DUR2	11
+/* end RESUME STATE INDICES */
+
+static struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} h3lis331dl_odr_table[] = {
+	{ 1, H3LIS331DL_ACC_PM_NORMAL | H3LIS331DL_ACC_ODR1000 },
+	{ 3, H3LIS331DL_ACC_PM_NORMAL | H3LIS331DL_ACC_ODR400 },
+	{ 10, H3LIS331DL_ACC_PM_NORMAL | H3LIS331DL_ACC_ODR100 },
+	{ 20, H3LIS331DL_ACC_PM_NORMAL | H3LIS331DL_ACC_ODR50},
+	/* low power settings, max low pass filter cut-off freq */
+	{ 100, H3LIS331DL_ACC_ODR10 | H3LIS331DL_ACC_ODR1000 },
+	{ 200, H3LIS331DL_ACC_ODR5 | H3LIS331DL_ACC_ODR1000 },
+	{ 5000, H3LIS331DL_ACC_ODR2 | H3LIS331DL_ACC_ODR1000 },
+	{ 1000, H3LIS331DL_ACC_ODR1 | H3LIS331DL_ACC_ODR1000 },
+	{ 2000, H3LIS331DL_ACC_ODRHALF | H3LIS331DL_ACC_ODR1000 },
+};
+
+static struct h3lis331dl_platform_data default_h3lis331dl_pdata = {
+	.g_range = H3LIS331DL_ACC_G_100G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = H3LIS331DL_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = H3LIS331DL_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = H3LIS331DL_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int h3lis331dl_hw_init(struct h3lis331dl_data *acc)
+{
+	int err = -1;
+	u8 buf[5];
+
+	printk(KERN_INFO "%s: hw init start\n", H3LIS331DL_ACC_DEV_NAME);
+
+	err = acc->tf->read(acc, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			 "available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+	if (buf[0] != WHOAMI_H3LIS331DL_ACC) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_H3LIS331DL_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_CTRL_REG1];
+	err = acc->tf->write(acc, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS1];
+	buf[1] = acc->resume_state[RES_INT_DUR1];
+	err = acc->tf->write(acc, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG1];
+	err = acc->tf->write(acc, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS2];
+	buf[1] = acc->resume_state[RES_INT_DUR2];
+	err = acc->tf->write(acc, INT_THS2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG2];
+	err = acc->tf->write(acc, INT_CFG2, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_CTRL_REG2];
+	buf[1] = acc->resume_state[RES_CTRL_REG3];
+	buf[2] = acc->resume_state[RES_CTRL_REG4];
+	buf[3] = acc->resume_state[RES_CTRL_REG5];
+	err = acc->tf->write(acc, CTRL_REG2, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	printk(KERN_INFO "%s: hw init done\n", H3LIS331DL_ACC_DEV_NAME);
+
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error: %d\n", err);
+
+	return err;
+}
+
+static void h3lis331dl_device_power_off(struct h3lis331dl_data *acc)
+{
+	int err;
+	u8 buf = H3LIS331DL_ACC_PM_OFF;
+
+	err = acc->tf->write(acc, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int h3lis331dl_device_power_on(struct h3lis331dl_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = h3lis331dl_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			h3lis331dl_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+	return 0;
+}
+
+static irqreturn_t h3lis331dl_isr1(int irq, void *dev)
+{
+	struct h3lis331dl_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+	printk(KERN_INFO "%s: isr1 queued\n", H3LIS331DL_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t h3lis331dl_isr2(int irq, void *dev)
+{
+	struct h3lis331dl_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+	printk(KERN_INFO "%s: isr2 queued\n", H3LIS331DL_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void h3lis331dl_irq1_work_func(struct work_struct *work)
+{
+	struct h3lis331dl_data *acc =
+
+	container_of(work, struct h3lis331dl_data, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:h3lis331dl_get_int1_source(acc); */
+	printk(KERN_INFO "%s: IRQ1 triggered\n", H3LIS331DL_ACC_DEV_NAME);
+	enable_irq(acc->irq1);
+}
+
+static void h3lis331dl_irq2_work_func(struct work_struct *work)
+{
+	struct h3lis331dl_data *acc =
+
+	container_of(work, struct h3lis331dl_data, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:h3lis331dl_get_tap_source(acc); */
+	printk(KERN_INFO "%s: IRQ2 triggered\n", H3LIS331DL_ACC_DEV_NAME);
+	enable_irq(acc->irq2);
+}
+
+int h3lis331dl_update_g_range(struct h3lis331dl_data *acc, u8 new_g_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+
+	switch (new_g_range) {
+	case H3LIS331DL_ACC_G_100G:
+		sensitivity = SENSITIVITY_100G;
+		break;
+	case H3LIS331DL_ACC_G_200G:
+		sensitivity = SENSITIVITY_200G;
+		break;
+	case H3LIS331DL_ACC_G_400G:
+		sensitivity = SENSITIVITY_400G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n",
+			new_g_range);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&acc->enabled)) {
+		/* Set configuration register 4, which contains g range setting
+		 *  NOTE: this is a straight overwrite because this driver does
+		 *  not use any of the other configuration bits in this
+		 *  register.  Should this become untrue, we will have to read
+		 *  out the value and only change the relevant bits --XX----
+		 *  (marked by X) */
+		err = acc->tf->read(acc, CTRL_REG4, 1, &init_val);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = init_val;
+		new_val = new_g_range;
+		updated_val = ((H3LIS331DL_ACC_FS_MASK & new_val) |
+			       ((~H3LIS331DL_ACC_FS_MASK) & init_val));
+		err = acc->tf->write(acc, CTRL_REG4, 1, &updated_val);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = updated_val;
+		acc->sensitivity = sensitivity;
+	}
+
+	return err;
+error:
+	dev_err(acc->dev, "update g range failed 0x%x,0x%x: %d\n",
+		CTRL_REG4, updated_val, err);
+
+	return err;
+}
+
+int h3lis331dl_update_odr(struct h3lis331dl_data *acc, int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(h3lis331dl_odr_table) - 1; i >= 0; i--) {
+		if (h3lis331dl_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+	config = h3lis331dl_odr_table[i].mask | H3LIS331DL_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		err = acc->tf->write(acc, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+		acc->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+
+error:
+	dev_err(acc->dev, "update odr failed 0x%x,0x%x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int h3lis331dl_get_acceleration_data(struct h3lis331dl_data *acc, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x]) :
+		  (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y]) :
+		  (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z]) :
+		  (hw_d[acc->pdata->axis_map_z]));
+
+#ifdef DEBUG
+		printk(KERN_INFO "%s read x=%d, y=%d, z=%d\n",
+		       H3LIS331DL_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+#endif
+
+	return err;
+}
+
+static void h3lis331dl_report_values(struct h3lis331dl_data *acc, int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static int h3lis331dl_enable(struct h3lis331dl_data *acc)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		err = h3lis331dl_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+		/* Android:
+		 * Udpate polling rate in case odr was changed while sensor disabled */
+		h3lis331dl_update_odr(acc, acc->pdata->poll_interval);
+		schedule_delayed_work(&acc->input_work,
+				msecs_to_jiffies(acc->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int h3lis331dl_disable(struct h3lis331dl_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work(&acc->input_work);
+		h3lis331dl_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	int rc = 0;
+	u8 data;
+
+	rc = acc->tf->read(acc, reg, 1, &data);
+	if (rc < 0)
+		return rc;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x = val;
+
+	return acc->tf->write(acc, reg, 1, &x);
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->poll_interval = interval_ms;
+	h3lis331dl_update_odr(acc, interval_ms);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->g_range ;
+	switch (val) {
+	case H3LIS331DL_ACC_G_100G:
+		range = 2;
+		break;
+	case H3LIS331DL_ACC_G_200G:
+		range = 4;
+		break;
+	case H3LIS331DL_ACC_G_400G:
+		range = 8;
+		break;
+	}
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->g_range = val;
+	h3lis331dl_update_g_range(acc, val);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	
+	if (val)
+		h3lis331dl_enable(acc);
+	else
+		h3lis331dl_disable(acc);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_intconfig2(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_get_intconfig2(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_set_duration2(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_get_duration2(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_set_thresh2(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t size)
+{
+	return write_reg(dev, buf, INT_THS2);
+}
+
+static ssize_t attr_get_thresh2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS2);
+}
+static ssize_t attr_get_source2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC2);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	u8 reg;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	rc = acc->tf->write(acc, x, 1, (u8 *)&val);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 reg;
+
+	mutex_lock(&stat->lock);
+	reg = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	ret = stat->tf->read(stat, reg, 1, buf);
+
+	return ret;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	int ret;
+	u8 reg;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	ret = acc->tf->read(acc, &reg, 1, buf);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct h3lis331dl_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(int2_config, 0664, attr_get_intconfig2, attr_set_intconfig2),
+	__ATTR(int2_duration, 0664, attr_get_duration2, attr_set_duration2),
+	__ATTR(int2_threshold, 0664, attr_get_thresh2, attr_set_thresh2),
+	__ATTR(int2_source, 0444, attr_get_source2, NULL),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void h3lis331dl_input_work_func(struct work_struct *work)
+{
+	struct h3lis331dl_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			    struct h3lis331dl_data, input_work);
+
+	mutex_lock(&acc->lock);
+	err = h3lis331dl_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_acceleration_data failed\n");
+	else
+		h3lis331dl_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work,
+			      msecs_to_jiffies(acc->pdata->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+#ifdef H3LIS331DL_EN_OPEN
+int h3lis331dl_input_open(struct input_dev *input)
+{
+	struct h3lis331dl_data *acc = input_get_drvdata(input);
+
+	return h3lis331dl_enable(acc);
+}
+
+void h3lis331dl_input_close(struct input_dev *dev)
+{
+	struct h3lis331dl_data *acc = input_get_drvdata(dev);
+
+	h3lis331dl_disable(acc);
+}
+#endif /* H3LIS331DL_EN_OPEN */
+
+static int h3lis331dl_validate_pdata(struct h3lis331dl_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 || acc->pdata->axis_map_y > 2 ||
+	    acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			acc->pdata->axis_map_x, acc->pdata->axis_map_y,
+			acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1 ||
+	    acc->pdata->negate_z > 1) {
+		dev_err(acc->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			acc->pdata->negate_x, acc->pdata->negate_y,
+			acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int h3lis331dl_input_init(struct h3lis331dl_data *acc)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&acc->input_work, h3lis331dl_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "input device allocation failed\n");
+		return err;
+	}
+
+#ifdef H3LIS331DL_EN_OPEN
+	acc->input_dev->open = h3lis331dl_input_open;
+	acc->input_dev->close = h3lis331dl_input_close;
+#else /* H3LIS331DL_EN_OPEN */
+	acc->input_dev->open = NULL;
+	acc->input_dev->close = NULL;
+#endif /* H3LIS331DL_EN_OPEN */
+	acc->input_dev->name = acc->name;
+	acc->input_dev->id.bustype = acc->bustype;
+	acc->input_dev->dev.parent = acc->dev;
+	input_set_drvdata(acc->input_dev, acc);
+
+	/* Set Misc event type */
+	__set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev,
+			"unable to register input device %s\n",
+			acc->input_dev->name);
+		input_free_device(acc->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void h3lis331dl_input_cleanup(struct h3lis331dl_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 h3lis331dl_parse_dt(struct h3lis331dl_data *acc)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = acc->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "gpio_int1", &val))
+		acc->pdata->gpio_int1 = (u8)val;
+	if (!of_property_read_u32(np, "gpio_int2", &val))
+		acc->pdata->gpio_int2 = (u8)val;
+
+	return 0;
+}
+#endif
+
+int h3lis331dl_common_probe(struct h3lis331dl_data *acc)
+{
+	int err = -1;
+
+	pr_info("%s: probe start.\n", H3LIS331DL_ACC_DEV_NAME);
+
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kzalloc(sizeof(struct h3lis331dl_platform_data), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (acc->dev->platform_data == NULL) {
+		memcpy(acc->pdata, &default_h3lis331dl_pdata,
+		       sizeof(struct h3lis331dl_platform_data));
+		dev_info(acc->dev, "using default plaform_data\n");
+	} else {
+		memcpy(acc->pdata, acc->dev->platform_data,
+		       sizeof(struct h3lis331dl_platform_data));
+	}
+
+#ifdef CONFIG_OF
+	/* override default gpio_irq[1,2] if required */
+	h3lis331dl_parse_dt(acc);
+#endif
+
+	err = h3lis331dl_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		printk(KERN_INFO "%s: %s has set irq1 to irq: %d "
+		       "mapped on gpio:%d\n", H3LIS331DL_ACC_DEV_NAME, __func__,
+		        acc->irq1, acc->pdata->gpio_int1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		printk(KERN_INFO "%s: %s has set irq2 to irq: %d "
+		       "mapped on gpio:%d\n", H3LIS331DL_ACC_DEV_NAME, __func__,
+		       acc->irq2, acc->pdata->gpio_int2);
+	}
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+
+	acc->resume_state[RES_CTRL_REG1] = H3LIS331DL_ACC_ENABLE_ALL_AXES;
+
+	err = h3lis331dl_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = h3lis331dl_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_g_range failed\n");
+		goto err_power_off;
+	}
+
+	err = h3lis331dl_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = h3lis331dl_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+			"device %s register failed\n",  H3LIS331DL_ACC_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	h3lis331dl_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&acc->irq1_work, h3lis331dl_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("h3lis331dl_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, h3lis331dl_isr1,
+				  IRQF_TRIGGER_RISING, "h3lis331dl_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&acc->irq2_work, h3lis331dl_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("h3lis331dl_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, h3lis331dl_isr2,
+				  IRQF_TRIGGER_RISING, "h3lis331dl_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+				goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(acc->dev, "%s: probed\n", H3LIS331DL_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if(acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	h3lis331dl_input_cleanup(acc);
+err_power_off:
+	h3lis331dl_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+	printk(KERN_ERR "%s: Driver Init failed\n", H3LIS331DL_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(h3lis331dl_common_probe);
+
+int h3lis331dl_common_remove(struct h3lis331dl_data *acc)
+{
+	if(acc->pdata->gpio_int1 >= 0){
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	h3lis331dl_input_cleanup(acc);
+	h3lis331dl_device_power_off(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+	kfree(acc->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(h3lis331dl_common_remove);
+
+#ifdef CONFIG_PM
+int h3lis331dl_common_resume(struct h3lis331dl_data *acc)
+{
+	if (acc->on_before_suspend)
+		return h3lis331dl_enable(acc);
+
+	return 0;
+}
+EXPORT_SYMBOL(h3lis331dl_common_resume);
+
+int h3lis331dl_common_suspend(struct h3lis331dl_data *acc)
+{
+	acc->on_before_suspend = atomic_read(&acc->enabled);
+
+	return h3lis331dl_disable(acc);
+}
+EXPORT_SYMBOL(h3lis331dl_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("h3lis331dl accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno, Carmine Iascone, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl.h b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl.h
--- a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,167 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: h3lis331dl.h
+* Authors		: MSH - Motion Mems BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+* Version		: V 1.7.1
+* Date			: 2012/10/07
+* Description		: H3LIS331DL 3D accelerometer sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#ifndef __H3LIS331DL_H__
+#define __H3LIS331DL_H__
+
+/*
+#define	DEBUG
+*/
+
+/* Uncomment if want Enable/Disable sensor on Open/Close input device
+#define H3LIS331DL_EN_OPEN
+*/
+
+/* Device support autoincrement address on spi/i2c interface */
+#define HAS_IF_AUTO_INCREMENT
+
+#define	H3LIS331DL_ACC_DEV_NAME	"h3lis331dl"
+
+#define	H3LIS331DL_ACC_MIN_POLL_PERIOD_MS 1
+
+/* to set gpios numb connected to interrupt pins,
+* the unused ones have to be set to -EINVAL
+*/
+#define H3LIS331DL_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define H3LIS331DL_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	H3LIS331DL_ACC_FS_MASK	0x30
+#define H3LIS331DL_ACC_G_100G 	0x00
+#define H3LIS331DL_ACC_G_200G 	0x10
+#define H3LIS331DL_ACC_G_400G 	0x30
+
+/* Accelerometer Sensor Operating Mode */
+#define H3LIS331DL_ACC_ENABLE	0x01
+#define H3LIS331DL_ACC_DISABLE	0x00
+#define H3LIS331DL_ACC_PM_NORMAL	0x20
+#define H3LIS331DL_ACC_PM_OFF	H3LIS331DL_ACC_DISABLE
+
+#define BUFF_RX_MAX_LENGTH	500
+#define BUFF_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		12
+
+#ifdef __KERNEL__
+
+struct h3lis331dl_data;
+
+struct h3lis331dl_platform_data {
+	int poll_interval;
+	int min_interval;
+
+	u8 g_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct h3lis331dl_transfer_buffer {
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct h3lis331dl_transfer_function {
+	int (*write)(struct h3lis331dl_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct h3lis331dl_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct h3lis331dl_data {
+	const char *name;
+	struct h3lis331dl_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+
+	atomic_t enabled;
+	int on_before_suspend;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct h3lis331dl_transfer_function *tf;
+	struct h3lis331dl_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+/* Input events used by lis2dh driver */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int h3lis331dl_common_probe(struct h3lis331dl_data *stat);
+int h3lis331dl_common_remove(struct h3lis331dl_data *stat);
+
+#ifdef CONFIG_PM
+int h3lis331dl_common_resume(struct h3lis331dl_data *stat);
+int h3lis331dl_common_suspend(struct h3lis331dl_data *stat);
+#endif /* CONFIG_PM */
+
+#endif /* __KERNEL__ */
+
+#endif  /* __H3LIS331DL_H__ */
diff -uNr a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_i2c.c b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_i2c.c
--- a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,213 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: h3lis331dl_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "h3lis331dl.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define	I2C_AUTO_INCREMENT	0x80
+#endif
+
+static int h3lis331dl_i2c_read(struct h3lis331dl_data *stat, u8 reg_addr,
+			       int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int h3lis331dl_i2c_write(struct h3lis331dl_data *stat, u8 reg_addr,
+				int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct h3lis331dl_transfer_function h3lis331dl_tf_i2c = {
+	.write = h3lis331dl_i2c_write,
+	.read = h3lis331dl_i2c_read,
+};
+
+static int h3lis331dl_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int err;
+	struct h3lis331dl_data *stat;
+
+	stat = kzalloc(sizeof(struct h3lis331dl_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &h3lis331dl_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = h3lis331dl_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int h3lis331dl_i2c_remove(struct i2c_client *client)
+{
+	struct h3lis331dl_data *stat = i2c_get_clientdata(client);
+
+	h3lis331dl_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h3lis331dl_suspend(struct device *dev)
+{
+	struct h3lis331dl_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return h3lis331dl_common_suspend(stat);
+}
+
+static int h3lis331dl_resume(struct device *dev)
+{
+	struct h3lis331dl_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return h3lis331dl_common_resume(stat);
+}
+
+static const struct dev_pm_ops h3lis331dl_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(h3lis331dl_suspend, h3lis331dl_resume)
+};
+
+#define H3LIS331DL_PM_OPS	(&h3lis331dl_pm_ops)
+#else /* CONFIG_PM */
+#define H3LIS331DL_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id h3lis331dl_ids[] = {
+	{ H3LIS331DL_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, h3lis331dl_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id h3lis331dl_id_table[] = {
+	{ .compatible = "st,h3lis331dl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, h3lis331dl_id_table);
+#endif
+
+static struct i2c_driver h3lis331dl_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = H3LIS331DL_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = H3LIS331DL_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = h3lis331dl_id_table,
+#endif
+	},
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0)
+	.remove = __devexit_p(h3lis331dl_i2c_remove),
+#else
+	.remove = h3lis331dl_i2c_remove,
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0) */
+	.probe    = h3lis331dl_i2c_probe,
+	.id_table = h3lis331dl_ids,
+};
+
+module_i2c_driver(h3lis331dl_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics h3lis331dl i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_spi.c b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_spi.c
--- a/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis331dl/h3lis331dl_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,203 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: h3lis331dl_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "h3lis331dl.h"
+
+#define SENSORS_SPI_READ	0x80
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define SPI_AUTO_INCREMENT	0x40
+#endif
+
+static int h3lis331dl_spi_read(struct h3lis331dl_data *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len);
+
+	return len;
+}
+
+static int h3lis331dl_spi_write(struct h3lis331dl_data *stat, u8 reg_addr, int len,
+				u8 *data)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	memcpy(&stat->tb.tx_buf[1], data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(to_spi_device(stat->dev), &msg);
+}
+
+static struct h3lis331dl_transfer_function h3lis331dl_tf_spi = {
+	.write = h3lis331dl_spi_write,
+	.read = h3lis331dl_spi_read,
+};
+
+static int h3lis331dl_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct h3lis331dl_data *stat;
+
+	stat = kzalloc(sizeof(struct h3lis331dl_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &h3lis331dl_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = h3lis331dl_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int h3lis331dl_spi_remove(struct spi_device *spi)
+{
+	struct h3lis331dl_data *stat = spi_get_drvdata(spi);
+
+	h3lis331dl_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int h3lis331dl_suspend(struct device *dev)
+{
+	struct h3lis331dl_data *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return h3lis331dl_common_suspend(stat);
+}
+
+static int h3lis331dl_resume(struct device *dev)
+{
+	struct h3lis331dl_data *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return h3lis331dl_common_resume(stat);
+}
+
+static const struct dev_pm_ops h3lis331dl_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(h3lis331dl_suspend, h3lis331dl_resume)
+};
+
+#define H3LIS331DL_PM_OPS	(&h3lis331dl_pm_ops)
+#else /* CONFIG_PM */
+#define H3LIS331DL_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id h3lis331dl_ids[] = {
+	{ H3LIS331DL_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, h3lis331dl_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id h3lis331dl_id_table[] = {
+	{ .compatible = "st,h3lis331dl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, h3lis331dl_id_table);
+#endif
+
+static struct spi_driver h3lis331dl_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = H3LIS331DL_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = H3LIS331DL_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = h3lis331dl_id_table,
+#endif
+	},
+	.remove = h3lis331dl_spi_remove,
+	.probe    = h3lis331dl_spi_probe,
+	.id_table = h3lis331dl_ids,
+};
+
+module_spi_driver(h3lis331dl_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics h3lis331dl spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/h3lis331dl/Kconfig b/drivers/input/misc/st/acc/h3lis331dl/Kconfig
--- a/drivers/input/misc/st/acc/h3lis331dl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis331dl/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_H3LIS331DL
+	tristate "STMicroelectronics H3LIS331DL sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_H3LIS331DL_I2C if (I2C)
+	select INPUT_H3LIS331DL_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics H3LIS331DL sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called h3lis331dl.
+
+config INPUT_H3LIS331DL_I2C
+	tristate
+	depends on INPUT_H3LIS331DL
+	depends on I2C
+
+config INPUT_H3LIS331DL_SPI
+	tristate
+	depends on INPUT_H3LIS331DL
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/h3lis331dl/Makefile b/drivers/input/misc/st/acc/h3lis331dl/Makefile
--- a/drivers/input/misc/st/acc/h3lis331dl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/h3lis331dl/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc h3lis331dl driver
+#
+h3lis331dl-core-y += h3lis331dl_core.o
+obj-$(CONFIG_INPUT_H3LIS331DL) += h3lis331dl-core.o
+obj-$(CONFIG_INPUT_H3LIS331DL_I2C) += h3lis331dl_i2c.o
+obj-$(CONFIG_INPUT_H3LIS331DL_SPI) += h3lis331dl_spi.o
diff -uNr a/drivers/input/misc/st/acc/Kconfig b/drivers/input/misc/st/acc/Kconfig
--- a/drivers/input/misc/st/acc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,23 @@
+
+menuconfig INPUT_ACC
+	tristate "accelerometer"
+
+if INPUT_ACC
+
+source "drivers/input/misc/st/acc/ais328dq/Kconfig"
+source "drivers/input/misc/st/acc/ais3624dq/Kconfig"
+source "drivers/input/misc/st/acc/lis2dh/Kconfig"
+source "drivers/input/misc/st/acc/lis2de/Kconfig"
+source "drivers/input/misc/st/acc/lis2ds/Kconfig"
+source "drivers/input/misc/st/acc/h3lis100dl/Kconfig"
+source "drivers/input/misc/st/acc/lis3dsh/Kconfig"
+source "drivers/input/misc/st/acc/lis2hh12/Kconfig"
+source "drivers/input/misc/st/acc/lis3de/Kconfig"
+source "drivers/input/misc/st/acc/lis331dlh/Kconfig"
+source "drivers/input/misc/st/acc/lis331hh/Kconfig"
+source "drivers/input/misc/st/acc/h3lis331dl/Kconfig"
+source "drivers/input/misc/st/acc/lis3dh/Kconfig"
+source "drivers/input/misc/st/acc/n2dm/Kconfig"
+source "drivers/input/misc/st/acc/lis2dw12/Kconfig"
+
+endif # INPUT_ACC
diff -uNr a/drivers/input/misc/st/acc/lis2de/Kconfig b/drivers/input/misc/st/acc/lis2de/Kconfig
--- a/drivers/input/misc/st/acc/lis2de/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2de/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS2DE
+	tristate "STMicroelectronics LIS2DE/LIS2DE12 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS2DE_I2C if (I2C)
+	select INPUT_LIS2DE_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS2DE/LIS2DE12 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis2de.
+
+config INPUT_LIS2DE_I2C
+	tristate
+	depends on INPUT_LIS2DE
+	depends on I2C
+
+config INPUT_LIS2DE_SPI
+	tristate
+	depends on INPUT_LIS2DE
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis2de/lis2de_acc.c b/drivers/input/misc/st/acc/lis2de/lis2de_acc.c
--- a/drivers/input/misc/st/acc/lis2de/lis2de_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2de/lis2de_acc.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1291 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : lis2de_acc.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Mario Tesi <mario.tesi@st.com>
+ *		      : Authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.15
+ * Date               : 2016/Oct/26
+ * Description        : LIS2DE accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ *******************************************************************************/
+/*******************************************************************************
+Version History.
+ Revision 1.0.6 15/11/2010
+  first revision
+  supports sysfs;
+  no more support for ioctl;
+ Revision 1.0.7 26/11/2010
+  checks for availability of interrupts pins
+  correction on FUZZ and FLAT values;
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7
+ Revision 1.0.9: 2011/May/23
+  update_odr func correction;
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+ Revision 1.0.15: 2016/Oct/26
+  added timestamp support and fixed sensitivity
+******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lis2de.h"
+
+#define	G_MAX			16000
+
+#define SENSITIVITY_2G		15	/**	mg/LSB	*/
+#define SENSITIVITY_4G		31	/**	mg/LSB	*/
+#define SENSITIVITY_8G		62	/**	mg/LSB	*/
+#define SENSITIVITY_16G		187	/**	mg/LSB	*/
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS2DE_ACC_ENABLE	0x01
+#define LIS2DE_ACC_DISABLE	0x00
+
+#define	HIGH_RESOLUTION		0x08
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_LIS2DE_ACC	0x33	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define	TEMP_CFG_REG		0x1F	/*	temper sens control reg	*/
+/* ctrl 1: ODR3 ODR2 ODR ODR0 LPen Zenable Yenable Zenable */
+#define	CTRL_REG1		0x20	/*	control reg 1		*/
+#define	CTRL_REG2		0x21	/*	control reg 2		*/
+#define	CTRL_REG3		0x22	/*	control reg 3		*/
+#define	CTRL_REG4		0x23	/*	control reg 4		*/
+#define	CTRL_REG5		0x24	/*	control reg 5		*/
+#define	CTRL_REG6		0x25	/*	control reg 6		*/
+
+#define	FIFO_CTRL_REG		0x2E	/*	FiFo control reg	*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+
+#define	TT_CFG			0x38	/*	tap config		*/
+#define	TT_SRC			0x39	/*	tap source		*/
+#define	TT_THS			0x3A	/*	tap threshold		*/
+#define	TT_LIM			0x3B	/*	tap time limit		*/
+#define	TT_TLAT			0x3C	/*	tap time latency	*/
+#define	TT_TW			0x3D	/*	tap time window		*/
+/*	end CONTROL REGISTRES	*/
+
+
+#define ENABLE_HIGH_RESOLUTION	1
+#define ALL_ZEROES		0x00
+
+#define LIS2DE_ACC_PM_OFF	0x00
+#define LIS2DE_ACC_ENABLE_ALL_AXES	0x07
+
+#define PMODE_MASK		0x08
+#define ODR_MASK		0XF0
+
+#define LIS2DE_ACC_ODR1		0x10  /* 1Hz output data rate */
+#define LIS2DE_ACC_ODR10	0x20  /* 10Hz output data rate */
+#define LIS2DE_ACC_ODR25	0x30  /* 25Hz output data rate */
+#define LIS2DE_ACC_ODR50	0x40  /* 50Hz output data rate */
+#define LIS2DE_ACC_ODR100	0x50  /* 100Hz output data rate */
+#define LIS2DE_ACC_ODR200	0x60  /* 200Hz output data rate */
+#define LIS2DE_ACC_ODR400	0x70  /* 400Hz output data rate */
+#define LIS2DE_ACC_ODR1250	0x90  /* 1250Hz output data rate */
+
+#define	IA			0x40
+#define	ZH			0x20
+#define	ZL			0x10
+#define	YH			0x08
+#define	YL			0x04
+#define	XH			0x02
+#define	XL			0x01
+/* */
+/* CTRL REG BITS*/
+#define	CTRL_REG3_I1_AOI1	0x40
+#define	CTRL_REG4_BDU_ENABLE	0x80
+#define	CTRL_REG4_BDU_MASK	0x80
+#define	CTRL_REG6_I2_TAPEN	0x80
+#define	CTRL_REG6_HLACTIVE	0x02
+/* */
+#define NO_MASK			0xFF
+#define INT1_DURATION_MASK	0x7F
+#define	INT1_THRESHOLD_MASK	0x7F
+#define TAP_CFG_MASK		0x3F
+#define	TAP_THS_MASK		0x7F
+#define	TAP_TLIM_MASK		0x7F
+#define	TAP_TLAT_MASK		NO_MASK
+#define	TAP_TW_MASK		NO_MASK
+
+
+/* TAP_SOURCE_REG BIT */
+#define	DTAP			0x20
+#define	STAP			0x10
+#define	SIGNTAP			0x08
+#define	ZTAP			0x04
+#define	YTAP			0x02
+#define	XTAZ			0x01
+
+#define	FUZZ			0
+#define	FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+
+/* end RESUME STATE INDICES */
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis2de_acc_odr_table[] = {
+		{    1, LIS2DE_ACC_ODR1250 },
+		{    3, LIS2DE_ACC_ODR400  },
+		{    5, LIS2DE_ACC_ODR200  },
+		{   10, LIS2DE_ACC_ODR100  },
+		{   20, LIS2DE_ACC_ODR50   },
+		{   40, LIS2DE_ACC_ODR25   },
+		{  100, LIS2DE_ACC_ODR10   },
+		{ 1000, LIS2DE_ACC_ODR1    },
+};
+
+static int int1_gpio = LIS2DE_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LIS2DE_ACC_DEFAULT_INT2_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+module_param(int2_gpio, int, S_IRUGO);
+
+static struct lis2de_acc_platform_data default_lis2de_acc_pdata = {
+	.fs_range = LIS2DE_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS2DE_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS2DE_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS2DE_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lis2de_acc_hw_init(struct lis2de_acc_status *stat)
+{
+	int err = -1;
+	u8 buf[6];
+
+	pr_info("%s: hw init start\n", LIS2DE_ACC_DEV_NAME);
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TEMP_CFG_REG];
+	err = stat->tf->write(stat, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_THS];
+	buf[1] = stat->resume_state[RES_TT_LIM];
+	buf[2] = stat->resume_state[RES_TT_TLAT];
+	buf[3] = stat->resume_state[RES_TT_TW];
+	err = stat->tf->write(stat, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_CFG];
+	err = stat->tf->write(stat, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THS1];
+	buf[1] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	buf[3] = stat->resume_state[RES_CTRL_REG5];
+	buf[4] = stat->resume_state[RES_CTRL_REG6];
+	err = stat->tf->write(stat, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LIS2DE_ACC_DEV_NAME);
+
+	return 0;
+
+	stat->hw_working = 0;
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+		buf[1], err);
+
+	return err;
+}
+
+static void lis2de_acc_device_power_off(struct lis2de_acc_status *stat)
+{
+	int err;
+	u8 buf = LIS2DE_ACC_PM_OFF;
+
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->hw_initialized = 0;
+	}
+}
+
+static int lis2de_acc_device_power_on(struct lis2de_acc_status *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"power_on failed: %d\n", err);
+
+			return err;
+		}
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	if (!stat->hw_initialized) {
+		err = lis2de_acc_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lis2de_acc_device_power_off(stat);
+
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	return 0;
+}
+
+static irqreturn_t lis2de_acc_isr1(int irq, void *dev)
+{
+	struct lis2de_acc_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", LIS2DE_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis2de_acc_isr2(int irq, void *dev)
+{
+	struct lis2de_acc_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", LIS2DE_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lis2de_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct lis2de_acc_status *stat =
+	container_of(work, struct lis2de_acc_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis2de_acc_get_int1_source(stat); */
+	pr_debug("%s: IRQ1 triggered\n", LIS2DE_ACC_DEV_NAME);
+	enable_irq(stat->irq1);
+}
+
+static void lis2de_acc_irq2_work_func(struct work_struct *work)
+{
+	struct lis2de_acc_status *stat =
+	container_of(work, struct lis2de_acc_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis2de_acc_get_tap_source(stat); */
+	pr_debug("%s: IRQ2 triggered\n", LIS2DE_ACC_DEV_NAME);
+	enable_irq(stat->irq2);
+}
+
+static int lis2de_acc_update_fs_range(struct lis2de_acc_status *stat,
+				      u8 new_fs_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = LIS2DE_ACC_FS_MASK | HIGH_RESOLUTION;
+
+	switch (new_fs_range) {
+	case LIS2DE_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LIS2DE_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LIS2DE_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case LIS2DE_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4, which contains fs range setting */
+	err = stat->tf->read(stat, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+
+	init_val = buf[0];
+	stat->resume_state[RES_CTRL_REG4] = init_val;
+	new_val = new_fs_range | HIGH_RESOLUTION;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+	err = stat->tf->write(stat, CTRL_REG4, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG4] = updated_val;
+	stat->sensitivity = sensitivity;
+
+	return err;
+
+error:
+	dev_err(stat->dev,
+		"update fs range failed 0x%02x,0x%02x: %d\n",
+		buf[0], buf[1], err);
+
+	return err;
+}
+
+static int lis2de_acc_update_odr(struct lis2de_acc_status *stat,
+				 int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis2de_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lis2de_acc_odr_table[i].cutoff_ms <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+	config = lis2de_acc_odr_table[i].mask | LIS2DE_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+
+		stat->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed 0x%02x,0x%02x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int lis2de_acc_register_write(struct lis2de_acc_status *stat,
+				     u8 *buf, u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return stat->tf->write(stat, reg_address, 1, buf);
+}
+
+static int lis2de_acc_get_acceleration_data(struct lis2de_acc_status *stat,
+					    int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	s16 acc_data[3];
+	/* x,y,z hardware data 8 bit */
+	s16 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat, AXISDATA_REG, sizeof(acc_data), (u8 *)acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((acc_data[0] >> 8) * stat->sensitivity);
+	hw_d[1] = ((acc_data[1] >> 8) * stat->sensitivity);
+	hw_d[2] = ((acc_data[2] >> 8) * stat->sensitivity);
+
+	xyz[0] = (int)((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = (int)((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = (int)((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+	return err;
+}
+
+/* Input events chenged to EV_MSC */
+static void lis2de_acc_report_values(struct lis2de_acc_status *stat, int *xyz)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    stat->timestamp >> 32);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    stat->timestamp & 0xffffffff);
+	input_sync(stat->input_dev);
+}
+
+static int lis2de_acc_enable(struct lis2de_acc_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = lis2de_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+
+			return err;
+		}
+		lis2de_acc_update_odr(stat, stat->pdata->poll_interval);
+		schedule_delayed_work(&stat->input_work,
+				      msecs_to_jiffies(stat->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lis2de_acc_disable(struct lis2de_acc_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&stat->input_work);
+		lis2de_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat, reg, 1, &data);
+	if (err < 0)
+		return err;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		     u8 mask, int resumeIndex)
+{
+	int err = -1;
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = lis2de_acc_register_write(stat, x, reg, new_val);
+	if (err >= 0)
+		stat->resume_state[resumeIndex] = new_val;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	lis2de_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range ;
+	switch (val) {
+	case LIS2DE_ACC_G_2G:
+		range = 2;
+		break;
+	case LIS2DE_ACC_G_4G:
+		range = 4;
+		break;
+	case LIS2DE_ACC_G_8G:
+		range = 8;
+		break;
+	case LIS2DE_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LIS2DE_ACC_G_2G;
+		break;
+	case 4:
+		range = LIS2DE_ACC_G_4G;
+		break;
+	case 8:
+		range = LIS2DE_ACC_G_8G;
+		break;
+	case 16:
+		range = LIS2DE_ACC_G_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lis2de_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis2de_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis2de_acc_enable(stat);
+	else
+		lis2de_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1, INT1_THRESHOLD_MASK, RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+							attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static inline int64_t lis2de_acc_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static void lis2de_acc_input_work_func(struct work_struct *work)
+{
+	struct lis2de_acc_status *stat;
+
+	int xyz[3] = { 0 };
+	int err;
+
+	stat = container_of((struct delayed_work *)work,
+			    struct lis2de_acc_status, input_work);
+
+	mutex_lock(&stat->lock);
+	stat->timestamp = lis2de_acc_get_time_ns();
+	err = lis2de_acc_get_acceleration_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_acceleration_data failed\n");
+	else
+		lis2de_acc_report_values(stat, xyz);
+
+	schedule_delayed_work(&stat->input_work, msecs_to_jiffies(
+			stat->pdata->poll_interval));
+	mutex_unlock(&stat->lock);
+}
+
+#ifdef LIS2DE_EN_OPEN_CLOSE
+static int lis2de_acc_input_open(struct input_dev *input)
+{
+	struct lis2de_acc_status *stat = input_get_drvdata(input);
+
+	return lis2de_acc_enable(stat);
+}
+
+static void lis2de_acc_input_close(struct input_dev *dev)
+{
+	struct lis2de_acc_status *stat = input_get_drvdata(dev);
+
+	lis2de_acc_disable(stat);
+}
+#endif
+
+static int lis2de_acc_validate_pdata(struct lis2de_acc_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)LIS2DE_ACC_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					 stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 || stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y, stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", stat->pdata->negate_x,
+			stat->pdata->negate_y, stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis2de_acc_input_init(struct lis2de_acc_status *stat)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&stat->input_work, lis2de_acc_input_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		dev_err(stat->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	stat->input_dev->name = LIS2DE_ACC_DEV_NAME;
+#ifdef LIS2DE_EN_OPEN_CLOSE
+	stat->input_dev->open = lis2de_acc_input_open;
+	stat->input_dev->close = lis2de_acc_input_close;
+#endif
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+	}
+
+	return err;
+}
+
+static void lis2de_acc_input_cleanup(struct lis2de_acc_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+/*
+ * struct lis2de_acc_status *stat is allocated/freed in tf probing
+ * so let it manage this stuff
+ */
+int lis2de_acc_probe(struct lis2de_acc_status *stat)
+{
+	int err = -1;
+	u8 wai = 0;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+
+	/* Check device ID and bus connection */
+	err = stat->tf->read(stat, WHO_AM_I, 1, &wai);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I:"
+			 " is device available/working?\n");
+
+		return err;
+	}
+
+	if (wai != WHOAMI_LIS2DE_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_LIS2DE_ACC, wai);
+
+		return -ENODEV;
+	}
+
+	mutex_lock(&stat->lock);
+	
+	stat->hw_working = 1;
+	stat->pdata = kmalloc(sizeof(struct lis2de_acc_platform_data), GFP_KERNEL);
+	if (!stat->pdata) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_lis2de_acc_pdata.gpio_int1 = int1_gpio;
+		default_lis2de_acc_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_lis2de_acc_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = lis2de_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		stat->irq1 = gpio_to_irq(stat->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, "
+			"mapped on gpio:%d\n", LIS2DE_ACC_DEV_NAME,
+			__func__, stat->irq1, stat->pdata->gpio_int1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d, "
+			"mapped on gpio:%d\n", LIS2DE_ACC_DEV_NAME,
+			__func__, stat->irq2, stat->pdata->gpio_int2);
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = (ALL_ZEROES |
+					     LIS2DE_ACC_ENABLE_ALL_AXES);
+	stat->resume_state[RES_CTRL_REG4] = (ALL_ZEROES | CTRL_REG4_BDU_ENABLE);
+
+	err = lis2de_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lis2de_acc_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis2de_acc_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis2de_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device LIS2DE_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lis2de_acc_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&stat->irq1_work, lis2de_acc_irq1_work_func);
+		stat->irq1_work_queue =
+			create_singlethread_workqueue("lis2de_acc_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, lis2de_acc_isr1,
+			IRQF_TRIGGER_RISING, "lis2de_acc_irq1", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&stat->irq2_work, lis2de_acc_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("lis2de_acc_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, lis2de_acc_isr2,
+			IRQF_TRIGGER_RISING, "lis2de_acc_irq2", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", LIS2DE_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if (stat->pdata->gpio_int2 >= 0)
+		destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	if (stat->pdata->gpio_int1 >= 0)
+		destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	lis2de_acc_input_cleanup(stat);
+err_power_off:
+	lis2de_acc_device_power_off(stat);
+err_pdata_init:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	pr_err("%s: Driver Init failed\n", LIS2DE_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis2de_acc_probe);
+
+int lis2de_acc_remove(struct lis2de_acc_status *stat)
+{
+	dev_info(stat->dev, "driver removing\n");
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lis2de_acc_disable(stat);
+	lis2de_acc_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+	kfree(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2de_acc_remove);
+
+#ifdef CONFIG_PM
+int lis2de_acc_common_resume(struct lis2de_acc_status *stat)
+{
+	if (stat->on_before_suspend)
+		return lis2de_acc_enable(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2de_acc_common_resume);
+
+int lis2de_acc_common_suspend(struct lis2de_acc_status *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	return lis2de_acc_disable(stat);
+}
+EXPORT_SYMBOL(lis2de_acc_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis2de accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Mario tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2de/lis2de.h b/drivers/input/misc/st/acc/lis2de/lis2de.h
--- a/drivers/input/misc/st/acc/lis2de/lis2de.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2de/lis2de.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,170 @@
+
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2de_acc.h
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Mario Tesi <mario.tesi@st.com>
+* Version	: V.1.0.15
+* Date		: 2016/Oct/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.10: 2011/Aug/16
+
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+  renamed field g_range to fs_range in lis2de_acc_platform_data;
+  replaced defines SA0L and SA0H with LIS2DE_SAD0x
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+ Revision 1.0.15: 2016/Oct/26
+  added timestamp support and fixed sensitivity
+*******************************************************************************/
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+
+#ifndef	__LIS2DE_H__
+#define	__LIS2DE_H__
+
+/* Uncomment if want enable/disable on open/close input device */
+//#define LIS2DE_EN_OPEN_CLOSE
+
+#define	LIS2DE_ACC_DEV_NAME		"lis2de_acc"
+
+#define	LIS2DE_ACC_MIN_POLL_PERIOD_MS	1
+
+#ifdef __KERNEL__
+
+#define LIS2DE_SAD0L			0x00
+#define LIS2DE_SAD0H			0x01
+
+#define LIS2DE_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS2DE_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS2DE_ACC_FS_MASK		0x30
+#define LIS2DE_ACC_G_2G			0x00
+#define LIS2DE_ACC_G_4G			0x10
+#define LIS2DE_ACC_G_8G			0x20
+#define LIS2DE_ACC_G_16G		0x30
+
+#define BUFF_RX_MAX_LENGTH		16
+#define BUFF_TX_MAX_LENGTH		16
+
+#define	RESUME_ENTRIES			17
+
+struct lis2de_acc_status;
+
+struct lis2de_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis2de_acc_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis2de_acc_transfer_function {
+	int (*write)(struct lis2de_acc_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis2de_acc_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis2de_acc_status {
+	const char *name;
+	struct lis2de_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+	int64_t timestamp;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	int use_smbus;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	struct lis2de_acc_transfer_function *tf;
+	struct lis2de_acc_transfer_buffer tb;
+};
+
+/* Input events used by lis2de driver */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int lis2de_acc_probe(struct lis2de_acc_status *stat);
+int lis2de_acc_remove(struct lis2de_acc_status *stat);
+
+#ifdef CONFIG_PM
+int lis2de_acc_common_resume(struct lis2de_acc_status *stat);
+int lis2de_acc_common_suspend(struct lis2de_acc_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LIS2DE_H__ */
diff -uNr a/drivers/input/misc/st/acc/lis2de/lis2de_i2c.c b/drivers/input/misc/st/acc/lis2de/lis2de_i2c.c
--- a/drivers/input/misc/st/acc/lis2de/lis2de_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2de/lis2de_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,194 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2de_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.15
+* Date		: 2016/Oct/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis2de.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int lis2de_acc_i2c_read(struct lis2de_acc_status *stat, u8 reg_addr,
+			       int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(stat->dev);
+	int tries = 0;
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis2de_acc_i2c_write(struct lis2de_acc_status *stat, u8 reg_addr,
+				int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static struct lis2de_acc_transfer_function lis2de_acc_tf_i2c = {
+	.write = lis2de_acc_i2c_write,
+	.read = lis2de_acc_i2c_read,
+};
+
+static int lis2de_acc_i2c_probe(struct i2c_client *client,
+			        const struct i2c_device_id *id)
+{
+	int err;
+	struct lis2de_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct lis2de_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis2de_acc_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis2de_acc_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+	return err;
+}
+
+static int lis2de_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lis2de_acc_status *stat = i2c_get_clientdata(client);
+
+	lis2de_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2de_acc_suspend(struct device *dev)
+{
+	struct lis2de_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2de_acc_common_suspend(stat);
+}
+
+static int lis2de_acc_resume(struct device *dev)
+{
+	struct lis2de_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2de_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis2de_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2de_acc_suspend, lis2de_acc_resume)
+};
+
+#define LIS2DE_PM_OPS		(&lis2de_acc_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DE_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis2de_acc_ids[] = {
+	{ LIS2DE_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis2de_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2de_acc_id_table[] = {
+	{ .compatible = "st,lis2de", },
+	{ .compatible = "st,lis2de12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2de_acc_id_table);
+#endif
+
+static struct i2c_driver lis2de_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DE_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS2DE_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis2de_acc_id_table,
+#endif
+	},
+	.remove = lis2de_acc_i2c_remove,
+	.probe = lis2de_acc_i2c_probe,
+	.id_table = lis2de_acc_ids,
+};
+
+module_i2c_driver(lis2de_acc_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2de i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2de/lis2de_spi.c b/drivers/input/misc/st/acc/lis2de/lis2de_spi.c
--- a/drivers/input/misc/st/acc/lis2de/lis2de_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2de/lis2de_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,212 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2de_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.15
+* Date		: 2016/Oct/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis2de.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int lis2de_acc_spi_read(struct lis2de_acc_status *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(stat->dev);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, stat->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static int lis2de_acc_spi_write(struct lis2de_acc_status *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(stat->dev);
+
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(spi, &msg);
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static struct lis2de_acc_transfer_function lis2de_acc_tf_spi = {
+	.write = lis2de_acc_spi_write,
+	.read = lis2de_acc_spi_read,
+};
+
+static int lis2de_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis2de_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct lis2de_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis2de_acc_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis2de_acc_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis2de_acc_spi_remove(struct spi_device *spi)
+{
+	struct lis2de_acc_status *stat = spi_get_drvdata(spi);
+
+	lis2de_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2de_acc_suspend(struct device *dev)
+{
+	struct lis2de_acc_status *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis2de_acc_common_suspend(stat);
+}
+
+static int lis2de_acc_resume(struct device *dev)
+{
+	struct lis2de_acc_status *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2de_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis2de_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2de_acc_suspend, lis2de_acc_resume)
+};
+
+#define LIS2DE_PM_OPS		(&lis2de_acc_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DE_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis2de_acc_ids[] = {
+	{ LIS2DE_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis2de_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2de_acc_id_table[] = {
+	{ .compatible = "st,lis2de", },
+	{ .compatible = "st,lis2de12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2de_acc_id_table);
+#endif
+
+static struct spi_driver lis2de_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DE_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS2DE_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis2de_acc_id_table,
+#endif
+	},
+	.remove = lis2de_acc_spi_remove,
+	.probe = lis2de_acc_spi_probe,
+	.id_table = lis2de_acc_ids,
+};
+
+module_spi_driver(lis2de_acc_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2de spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2de/Makefile b/drivers/input/misc/st/acc/lis2de/Makefile
--- a/drivers/input/misc/st/acc/lis2de/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2de/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis2de driver
+#
+lis2de-acc-y += lis2de_acc.o
+obj-$(CONFIG_INPUT_LIS2DE) += lis2de-acc.o
+obj-$(CONFIG_INPUT_LIS2DE_I2C) += lis2de_i2c.o
+obj-$(CONFIG_INPUT_LIS2DE_SPI) += lis2de_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis2dh/Kconfig b/drivers/input/misc/st/acc/lis2dh/Kconfig
--- a/drivers/input/misc/st/acc/lis2dh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dh/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS2DH
+	tristate "STMicroelectronics LIS2DH/LIS2DH12 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS2DH_I2C if (I2C)
+	select INPUT_LIS2DH_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS2DH/LIS2DH12 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis2dh.
+
+config INPUT_LIS2DH_I2C
+	tristate
+	depends on INPUT_LIS2DH
+	depends on I2C
+
+config INPUT_LIS2DH_SPI
+	tristate
+	depends on INPUT_LIS2DH
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis2dh/lis2dh_acc.c b/drivers/input/misc/st/acc/lis2dh/lis2dh_acc.c
--- a/drivers/input/misc/st/acc/lis2dh/lis2dh_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dh/lis2dh_acc.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1154 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : lis2dh_acc.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Mario Tesi <mario.tesi@st.com>
+ *		      : Both authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.14
+ * Date               : 2016/Apr/26
+ * Description        : LIS2DH accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ *******************************************************************************/
+/*******************************************************************************
+Version History.
+ Revision 1.0.6 15/11/2010
+  first revision
+  supports sysfs;
+  no more support for ioctl;
+ Revision 1.0.7 26/11/2010
+  checks for availability of interrupts pins
+  correction on FUZZ and FLAT values;
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7
+ Revision 1.0.9: 2011/May/23
+  update_odr func correction;
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lis2dh.h"
+
+#define MS_TO_NS(x)		(x*1000000L)
+#define	G_MAX			16000
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+#define SENSITIVITY_16G		12	/**	mg/LSB	*/
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS2DH_ACC_ENABLE	0x01
+#define LIS2DH_ACC_DISABLE	0x00
+
+#define	HIGH_RESOLUTION		0x08
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_LIS2DH_ACC	0x33	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define	TEMP_CFG_REG		0x1F	/*	temper sens control reg	*/
+/* ctrl 1: ODR3 ODR2 ODR ODR0 LPen Zenable Yenable Zenable */
+#define	CTRL_REG1		0x20	/*	control reg 1		*/
+#define	CTRL_REG2		0x21	/*	control reg 2		*/
+#define	CTRL_REG3		0x22	/*	control reg 3		*/
+#define	CTRL_REG4		0x23	/*	control reg 4		*/
+#define	CTRL_REG5		0x24	/*	control reg 5		*/
+#define	CTRL_REG6		0x25	/*	control reg 6		*/
+
+#define	FIFO_CTRL_REG		0x2E	/*	FiFo control reg	*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+
+#define	TT_CFG			0x38	/*	tap config		*/
+#define	TT_SRC			0x39	/*	tap source		*/
+#define	TT_THS			0x3A	/*	tap threshold		*/
+#define	TT_LIM			0x3B	/*	tap time limit		*/
+#define	TT_TLAT			0x3C	/*	tap time latency	*/
+#define	TT_TW			0x3D	/*	tap time window		*/
+/*	end CONTROL REGISTRES	*/
+
+
+#define ENABLE_HIGH_RESOLUTION	1
+#define ALL_ZEROES		0x00
+
+#define LIS2DH_ACC_PM_OFF	0x00
+#define LIS2DH_ACC_ENABLE_ALL_AXES	0x07
+
+#define PMODE_MASK		0x08
+#define ODR_MASK		0XF0
+
+#define LIS2DH_ACC_ODR1		0x10  /* 1Hz output data rate */
+#define LIS2DH_ACC_ODR10	0x20  /* 10Hz output data rate */
+#define LIS2DH_ACC_ODR25	0x30  /* 25Hz output data rate */
+#define LIS2DH_ACC_ODR50	0x40  /* 50Hz output data rate */
+#define LIS2DH_ACC_ODR100	0x50  /* 100Hz output data rate */
+#define LIS2DH_ACC_ODR200	0x60  /* 200Hz output data rate */
+#define LIS2DH_ACC_ODR400	0x70  /* 400Hz output data rate */
+#define LIS2DH_ACC_ODR1250	0x90  /* 1250Hz output data rate */
+
+#define	IA			0x40
+#define	ZH			0x20
+#define	ZL			0x10
+#define	YH			0x08
+#define	YL			0x04
+#define	XH			0x02
+#define	XL			0x01
+/* */
+/* CTRL REG BITS*/
+#define	CTRL_REG3_I1_AOI1	0x40
+#define	CTRL_REG4_BDU_ENABLE	0x80
+#define	CTRL_REG4_BDU_MASK	0x80
+#define	CTRL_REG6_I2_TAPEN	0x80
+#define	CTRL_REG6_HLACTIVE	0x02
+/* */
+#define NO_MASK			0xFF
+#define INT1_DURATION_MASK	0x7F
+#define	INT1_THRESHOLD_MASK	0x7F
+#define TAP_CFG_MASK		0x3F
+#define	TAP_THS_MASK		0x7F
+#define	TAP_TLIM_MASK		0x7F
+#define	TAP_TLAT_MASK		NO_MASK
+#define	TAP_TW_MASK		NO_MASK
+
+
+/* TAP_SOURCE_REG BIT */
+#define	DTAP			0x20
+#define	STAP			0x10
+#define	SIGNTAP			0x08
+#define	ZTAP			0x04
+#define	YTAP			0x02
+#define	XTAZ			0x01
+
+#define	FUZZ			0
+#define	FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+
+/* end RESUME STATE INDICES */
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis2dh_acc_odr_table[] = {
+		{    1, LIS2DH_ACC_ODR1250 },
+		{    3, LIS2DH_ACC_ODR400  },
+		{    5, LIS2DH_ACC_ODR200  },
+		{   10, LIS2DH_ACC_ODR100  },
+		{   20, LIS2DH_ACC_ODR50   },
+		{   40, LIS2DH_ACC_ODR25   },
+		{  100, LIS2DH_ACC_ODR10   },
+		{ 1000, LIS2DH_ACC_ODR1    },
+};
+
+static struct lis2dh_acc_platform_data default_lis2dh_acc_pdata = {
+	.fs_range = LIS2DH_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS2DH_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS2DH_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS2DH_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lis2dh_acc_hw_init(struct lis2dh_acc_status *stat)
+{
+	int err = -1;
+	u8 buf[6];
+
+	pr_info("%s: hw init start\n", LIS2DH_ACC_DEV_NAME);
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TEMP_CFG_REG];
+	err = stat->tf->write(stat, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_THS];
+	buf[1] = stat->resume_state[RES_TT_LIM];
+	buf[2] = stat->resume_state[RES_TT_TLAT];
+	buf[3] = stat->resume_state[RES_TT_TW];
+	err = stat->tf->write(stat, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_CFG];
+	err = stat->tf->write(stat, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THS1];
+	buf[1] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	buf[3] = stat->resume_state[RES_CTRL_REG5];
+	buf[4] = stat->resume_state[RES_CTRL_REG6];
+	err = stat->tf->write(stat, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LIS2DH_ACC_DEV_NAME);
+
+	return 0;
+
+	stat->hw_working = 0;
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+		buf[1], err);
+
+	return err;
+}
+
+static void lis2dh_acc_device_power_off(struct lis2dh_acc_status *stat)
+{
+	int err;
+	u8 buf = LIS2DH_ACC_PM_OFF;
+
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	stat->hw_initialized = 0;
+}
+
+static int lis2dh_acc_device_power_on(struct lis2dh_acc_status *stat)
+{
+	int err = -1;
+
+	if (!stat->hw_initialized) {
+		err = lis2dh_acc_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lis2dh_acc_device_power_off(stat);
+
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lis2dh_acc_update_fs_range(struct lis2dh_acc_status *stat,
+				      u8 new_fs_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = LIS2DH_ACC_FS_MASK | HIGH_RESOLUTION;
+
+	switch (new_fs_range) {
+	case LIS2DH_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LIS2DH_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LIS2DH_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case LIS2DH_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4, which contains fs range setting */
+	err = stat->tf->read(stat, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+
+	init_val = buf[0];
+	stat->resume_state[RES_CTRL_REG4] = init_val;
+	new_val = new_fs_range | HIGH_RESOLUTION;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+	err = stat->tf->write(stat, CTRL_REG4, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG4] = updated_val;
+	stat->sensitivity = sensitivity;
+
+	return err;
+
+error:
+	dev_err(stat->dev,
+		"update fs range failed 0x%02x,0x%02x: %d\n",
+		buf[0], buf[1], err);
+
+	return err;
+}
+
+static int lis2dh_acc_update_odr(struct lis2dh_acc_status *stat,
+				 int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis2dh_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lis2dh_acc_odr_table[i].cutoff_ms <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+	config = lis2dh_acc_odr_table[i].mask | LIS2DH_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat, CTRL_REG1, 1, &config);
+		if (err >= 0)
+			stat->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	stat->ktime = ktime_set(0, MS_TO_NS(poll_interval_ms));
+	
+	return err;
+}
+
+static int lis2dh_acc_register_write(struct lis2dh_acc_status *stat,
+				     u8 *buf, u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return stat->tf->write(stat, reg_address, 1, buf);
+}
+
+static inline int64_t lis2dh_acc_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static enum hrtimer_restart lis2dh_acc_poll_function_read(struct hrtimer *timer)
+{
+	struct lis2dh_acc_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+			    struct lis2dh_acc_status, hr_timer);
+	stat->timestamp = lis2dh_acc_get_time_ns();
+	queue_work(stat->acc_workqueue, &stat->polling_task);
+
+	return HRTIMER_NORESTART;
+}
+
+static int lis2dh_acc_get_acceleration_data(struct lis2dh_acc_status *stat,
+					    int *xyz)
+{
+	int err = -1;
+	u8 acc_data[6];
+	s16 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * stat->sensitivity;
+	hw_d[1] = hw_d[1] * stat->sensitivity;
+	hw_d[2] = hw_d[2] * stat->sensitivity;
+
+	xyz[0] = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+	return err;
+}
+
+/* Input events chenged to EV_MSC */
+static void lis2dh_acc_report_values(struct lis2dh_acc_status *stat,
+				     int *xyz)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    stat->timestamp >> 32);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    stat->timestamp & 0xffffffff);
+	input_sync(stat->input_dev);
+}
+
+static int lis2dh_acc_enable(struct lis2dh_acc_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = lis2dh_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			return err;
+		}
+
+		lis2dh_acc_update_odr(stat, stat->pdata->poll_interval);
+		hrtimer_start(&(stat->hr_timer), stat->ktime, HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+
+static int lis2dh_acc_disable(struct lis2dh_acc_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		hrtimer_cancel(&stat->hr_timer);
+		lis2dh_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat, reg, 1, &data);
+	if (err < 0)
+		return err;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		     u8 mask, int resumeIndex)
+{
+	int err = -1;
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = lis2dh_acc_register_write(stat, x, reg, new_val);
+	if (err >= 0)
+		stat->resume_state[resumeIndex] = new_val;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	lis2dh_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range ;
+	switch (val) {
+	case LIS2DH_ACC_G_2G:
+		range = 2;
+		break;
+	case LIS2DH_ACC_G_4G:
+		range = 4;
+		break;
+	case LIS2DH_ACC_G_8G:
+		range = 8;
+		break;
+	case LIS2DH_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LIS2DH_ACC_G_2G;
+		break;
+	case 4:
+		range = LIS2DH_ACC_G_4G;
+		break;
+	case 8:
+		range = LIS2DH_ACC_G_8G;
+		break;
+	case 16:
+		range = LIS2DH_ACC_G_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lis2dh_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis2dh_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis2dh_acc_enable(stat);
+	else
+		lis2dh_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1, INT1_THRESHOLD_MASK, RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+							attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lis2dh_acc_input_work_func(struct work_struct *work)
+{
+	struct lis2dh_acc_status *stat;
+	int xyz[3] = { 0 };
+	int err;
+	ktime_t tmpkt;
+
+	stat = container_of((struct work_struct *)work,
+			    struct lis2dh_acc_status, polling_task);
+
+	/* Adjust new timeout */
+	tmpkt = ktime_sub(stat->ktime,
+			  ktime_set(0, 
+			  (lis2dh_acc_get_time_ns() - stat->timestamp)));
+	/* Reschedule timer */
+	hrtimer_start(&stat->hr_timer, tmpkt, HRTIMER_MODE_REL);
+	mutex_lock(&stat->lock);
+	err = lis2dh_acc_get_acceleration_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_acceleration_data failed\n");
+	else
+		lis2dh_acc_report_values(stat, xyz);
+	mutex_unlock(&stat->lock);
+}
+
+#ifdef LIS2DH_EN_OPEN_CLOSE
+static int lis2dh_acc_input_open(struct input_dev *input)
+{
+	struct lis2dh_acc_status *stat = input_get_drvdata(input);
+
+	return lis2dh_acc_enable(stat);
+}
+
+static void lis2dh_acc_input_close(struct input_dev *dev)
+{
+	struct lis2dh_acc_status *stat = input_get_drvdata(dev);
+
+	lis2dh_acc_disable(stat);
+}
+#endif
+
+static int lis2dh_acc_validate_pdata(struct lis2dh_acc_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)LIS2DH_ACC_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					 stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 || stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y, stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", stat->pdata->negate_x,
+			stat->pdata->negate_y, stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis2dh_acc_input_init(struct lis2dh_acc_status *stat)
+{
+	int err;
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		dev_err(stat->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	stat->input_dev->name = LIS2DH_ACC_DEV_NAME;
+#ifdef LIS2DH_EN_OPEN_CLOSE
+	stat->input_dev->open = lis2dh_acc_input_open;
+	stat->input_dev->close = lis2dh_acc_input_close;
+#endif
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit );
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+	}
+
+	return err;
+}
+
+static void lis2dh_acc_input_cleanup(struct lis2dh_acc_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+/*
+ * struct lis2dh_acc_status *stat is allocated/freed in tf probing
+ * so let it manage this stuff
+ */
+int lis2dh_acc_probe(struct lis2dh_acc_status *stat)
+{
+	int err = -1;
+	u8 wai = 0;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+
+	/* Check device ID and bus connection */
+	err = stat->tf->read(stat, WHO_AM_I, 1, &wai);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I:"
+			 " is device available/working?\n");
+
+		return err;
+	}
+
+	if (wai != WHOAMI_LIS2DH_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_LIS2DH_ACC, wai);
+
+		return -ENODEV;
+	}
+
+	mutex_lock(&stat->lock);
+	
+	stat->hw_working = 1;
+	stat->pdata = kmalloc(sizeof(struct lis2dh_acc_platform_data), GFP_KERNEL);
+	if (!stat->pdata) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata, &default_lis2dh_acc_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = lis2dh_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+	stat->resume_state[RES_CTRL_REG1] = (ALL_ZEROES |
+					     LIS2DH_ACC_ENABLE_ALL_AXES);
+	stat->resume_state[RES_CTRL_REG4] = (ALL_ZEROES | CTRL_REG4_BDU_ENABLE);
+
+	err = lis2dh_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto exit_kfree_pdata;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lis2dh_acc_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis2dh_acc_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis2dh_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device LIS2DH_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lis2dh_acc_device_power_off(stat);
+
+	mutex_unlock(&stat->lock);
+
+	stat->acc_workqueue = create_workqueue("lis2dh_acc_workqueue");
+	if (!stat->acc_workqueue)
+		goto err_remove_sysfs_int;
+
+	hrtimer_init(&stat->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer.function = &lis2dh_acc_poll_function_read;
+
+	INIT_WORK(&stat->polling_task, lis2dh_acc_input_work_func);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	dev_info(stat->dev, "%s: probed\n", LIS2DH_ACC_DEV_NAME);
+
+	return 0;
+
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	lis2dh_acc_input_cleanup(stat);
+err_power_off:
+	lis2dh_acc_device_power_off(stat);
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	pr_err("%s: Driver Init failed\n", LIS2DH_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis2dh_acc_probe);
+
+int lis2dh_acc_remove(struct lis2dh_acc_status *stat)
+{
+	dev_info(stat->dev, "driver removing\n");
+
+	cancel_work_sync(&stat->polling_task);
+	if (stat->acc_workqueue) {
+		destroy_workqueue(stat->acc_workqueue);
+		stat->acc_workqueue = NULL;
+	}
+
+	lis2dh_acc_disable(stat);
+	lis2dh_acc_input_cleanup(stat);
+	remove_sysfs_interfaces(stat->dev);
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2dh_acc_remove);
+
+#ifdef CONFIG_PM
+int lis2dh_acc_common_resume(struct lis2dh_acc_status *stat)
+{
+	int err = 0;
+
+	if (stat->on_before_suspend) {
+		err = lis2dh_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+
+			return err;
+		}
+
+		lis2dh_acc_update_odr(stat, stat->pdata->poll_interval);
+		hrtimer_start(&stat->hr_timer, stat->ktime, HRTIMER_MODE_REL);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(lis2dh_acc_common_resume);
+
+int lis2dh_acc_common_suspend(struct lis2dh_acc_status *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	if (stat->on_before_suspend) {
+		mutex_lock(&stat->lock);
+		hrtimer_cancel(&stat->hr_timer);
+		lis2dh_acc_device_power_off(stat);
+		mutex_unlock(&stat->lock);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lis2dh_acc_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis2dh accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Mario tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2dh/lis2dh.h b/drivers/input/misc/st/acc/lis2dh/lis2dh.h
--- a/drivers/input/misc/st/acc/lis2dh/lis2dh.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dh/lis2dh.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,163 @@
+
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2dh_acc.h
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Mario Tesi <mario.tesi@st.com>
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.10: 2011/Aug/16
+
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+  renamed field g_range to fs_range in lis2dh_acc_platform_data;
+  replaced defines SA0L and SA0H with LIS2DH_SAD0x
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+*******************************************************************************/
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+
+#ifndef	__LIS2DH_H__
+#define	__LIS2DH_H__
+
+/* Uncomment if want enable/disable on open/close input device */
+//#define LIS2DH_EN_OPEN_CLOSE
+
+#define	LIS2DH_ACC_DEV_NAME		"lis2dh_acc"
+
+#define	LIS2DH_ACC_MIN_POLL_PERIOD_MS	1
+
+#ifdef __KERNEL__
+
+#define LIS2DH_SAD0L			0x00
+#define LIS2DH_SAD0H			0x01
+
+#define LIS2DH_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS2DH_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS2DH_ACC_FS_MASK		0x30
+#define LIS2DH_ACC_G_2G			0x00
+#define LIS2DH_ACC_G_4G			0x10
+#define LIS2DH_ACC_G_8G			0x20
+#define LIS2DH_ACC_G_16G		0x30
+
+#define BUFF_RX_MAX_LENGTH		500
+#define BUFF_TX_MAX_LENGTH		500
+
+#define	RESUME_ENTRIES			17
+
+struct lis2dh_acc_status;
+
+struct lis2dh_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis2dh_acc_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis2dh_acc_transfer_function {
+	int (*write)(struct lis2dh_acc_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis2dh_acc_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis2dh_acc_status {
+	const char *name;
+	struct lis2dh_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct workqueue_struct *acc_workqueue;
+	struct input_dev *input_dev;
+	int64_t timestamp;
+
+	int hw_initialized;
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+	struct work_struct polling_task;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+	struct lis2dh_acc_transfer_function *tf;
+	struct lis2dh_acc_transfer_buffer tb;
+};
+
+/* Input events used by lis2dh driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+int lis2dh_acc_probe(struct lis2dh_acc_status *stat);
+int lis2dh_acc_remove(struct lis2dh_acc_status *stat);
+
+#ifdef CONFIG_PM
+int lis2dh_acc_common_resume(struct lis2dh_acc_status *stat);
+int lis2dh_acc_common_suspend(struct lis2dh_acc_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LIS2DH_H__ */
diff -uNr a/drivers/input/misc/st/acc/lis2dh/lis2dh_i2c.c b/drivers/input/misc/st/acc/lis2dh/lis2dh_i2c.c
--- a/drivers/input/misc/st/acc/lis2dh/lis2dh_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dh/lis2dh_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,194 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2dh_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis2dh.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int lis2dh_acc_i2c_read(struct lis2dh_acc_status *stat, u8 reg_addr,
+			       int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(stat->dev);
+	int tries = 0;
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis2dh_acc_i2c_write(struct lis2dh_acc_status *stat, u8 reg_addr,
+				int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static struct lis2dh_acc_transfer_function lis2dh_acc_tf_i2c = {
+	.write = lis2dh_acc_i2c_write,
+	.read = lis2dh_acc_i2c_read,
+};
+
+static int lis2dh_acc_i2c_probe(struct i2c_client *client,
+			        const struct i2c_device_id *id)
+{
+	int err;
+	struct lis2dh_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct lis2dh_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis2dh_acc_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis2dh_acc_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+	return err;
+}
+
+static int lis2dh_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lis2dh_acc_status *stat = i2c_get_clientdata(client);
+
+	lis2dh_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2dh_acc_suspend(struct device *dev)
+{
+	struct lis2dh_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2dh_acc_common_suspend(stat);
+}
+
+static int lis2dh_acc_resume(struct device *dev)
+{
+	struct lis2dh_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2dh_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis2dh_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2dh_acc_suspend, lis2dh_acc_resume)
+};
+
+#define LIS2DH_PM_OPS		(&lis2dh_acc_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DH_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis2dh_acc_ids[] = {
+	{ LIS2DH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis2dh_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2dh_acc_id_table[] = {
+	{ .compatible = "st,lis2dh", },
+	{ .compatible = "st,lis2dh12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2dh_acc_id_table);
+#endif
+
+static struct i2c_driver lis2dh_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS2DH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis2dh_acc_id_table,
+#endif
+	},
+	.remove = lis2dh_acc_i2c_remove,
+	.probe = lis2dh_acc_i2c_probe,
+	.id_table = lis2dh_acc_ids,
+};
+
+module_i2c_driver(lis2dh_acc_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2dh i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2dh/lis2dh_spi.c b/drivers/input/misc/st/acc/lis2dh/lis2dh_spi.c
--- a/drivers/input/misc/st/acc/lis2dh/lis2dh_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dh/lis2dh_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,212 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2dh_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis2dh.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int lis2dh_acc_spi_read(struct lis2dh_acc_status *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(stat->dev);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, stat->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static int lis2dh_acc_spi_write(struct lis2dh_acc_status *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(stat->dev);
+
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(spi, &msg);
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static struct lis2dh_acc_transfer_function lis2dh_acc_tf_spi = {
+	.write = lis2dh_acc_spi_write,
+	.read = lis2dh_acc_spi_read,
+};
+
+static int lis2dh_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis2dh_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct lis2dh_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis2dh_acc_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis2dh_acc_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis2dh_acc_spi_remove(struct spi_device *spi)
+{
+	struct lis2dh_acc_status *stat = spi_get_drvdata(spi);
+
+	lis2dh_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2dh_acc_suspend(struct device *dev)
+{
+	struct lis2dh_acc_status *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis2dh_acc_common_suspend(stat);
+}
+
+static int lis2dh_acc_resume(struct device *dev)
+{
+	struct lis2dh_acc_status *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2dh_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis2dh_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2dh_acc_suspend, lis2dh_acc_resume)
+};
+
+#define LIS2DH_PM_OPS		(&lis2dh_acc_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DH_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis2dh_acc_ids[] = {
+	{ LIS2DH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis2dh_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2dh_acc_id_table[] = {
+	{ .compatible = "st,lis2dh", },
+	{ .compatible = "st,lis2dh12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2dh_acc_id_table);
+#endif
+
+static struct spi_driver lis2dh_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS2DH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis2dh_acc_id_table,
+#endif
+	},
+	.remove = lis2dh_acc_spi_remove,
+	.probe = lis2dh_acc_spi_probe,
+	.id_table = lis2dh_acc_ids,
+};
+
+module_spi_driver(lis2dh_acc_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2dh spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2dh/Makefile b/drivers/input/misc/st/acc/lis2dh/Makefile
--- a/drivers/input/misc/st/acc/lis2dh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dh/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis2dh driver
+#
+lis2dh-acc-y += lis2dh_acc.o
+obj-$(CONFIG_INPUT_LIS2DH) += lis2dh-acc.o
+obj-$(CONFIG_INPUT_LIS2DH_I2C) += lis2dh_i2c.o
+obj-$(CONFIG_INPUT_LIS2DH_SPI) += lis2dh_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis2ds/Kconfig b/drivers/input/misc/st/acc/lis2ds/Kconfig
--- a/drivers/input/misc/st/acc/lis2ds/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2ds/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS2DS
+	tristate "STMicroelectronics LIS2DS/LIS2DS12 sensors"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS2DS_I2C if (I2C)
+	select INPUT_LIS2DS_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS2DS/LIS2DS12 sensors.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis2ds.
+
+config INPUT_LIS2DS_I2C
+	tristate
+	depends on INPUT_LIS2DS
+	depends on I2C
+
+config INPUT_LIS2DS_SPI
+	tristate
+	depends on INPUT_LIS2DS
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis2ds/lis2ds_core.c b/drivers/input/misc/st/acc/lis2ds/lis2ds_core.c
--- a/drivers/input/misc/st/acc/lis2ds/lis2ds_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2ds/lis2ds_core.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1591 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lis2ds_core.c
+* Authors            : AMS - VMU - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Lorenzo Bianconi <lorenzo.bianconi@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.1.1
+* Date               : 2016/May/03
+* Description        : LIS2DS driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lis2ds_core.h"
+
+#define LIS2DS_SENSORHUB_OUT1_ADDR		0x06
+#define LIS2DS_SENSORHUB_OUT2_ADDR		0x07
+#define LIS2DS_SENSORHUB_OUT3_ADDR		0x08
+#define LIS2DS_SENSORHUB_OUT4_ADDR		0x09
+#define LIS2DS_SENSORHUB_OUT5_ADDR		0x0a
+#define LIS2DS_SENSORHUB_OUT6_ADDR		0x0b
+#define LIS2DS_MODULE_8_ADDR			0x0c
+#define LIS2DS_WHO_AM_I_ADDR			0x0f
+#define LIS2DS_WHO_AM_I_DEF			0x43
+#define LIS2DS_CTRL1_ADDR			0x20
+#define LIS2DS_CTRL2_ADDR			0x21
+#define LIS2DS_CTRL3_ADDR			0x22
+#define LIS2DS_CTRL4_INT1_PAD_ADDR		0x23
+#define LIS2DS_CTRL5_INT2_PAD_ADDR		0x24
+#define LIS2DS_FIFO_CTRL_ADDR			0x25
+#define LIS2DS_OUT_T_ADDR			0x26
+#define LIS2DS_STATUS_ADDR			0x27
+#define LIS2DS_OUTX_L_ADDR			0x28
+#define LIS2DS_FIFO_THR_ADDR			0x2e
+#define LIS2DS_FIFO_SRC_ADDR			0x2f
+#define LIS2DS_FIFO_SAMPLE_ADDR			0x30
+#define LIS2DS_TAP_THS_6D_ADDR			0x31
+#define LIS2DS_INT_DUR_ADDR			0x32
+#define LIS2DS_WAKE_UP_THS_ADDR			0x33
+#define LIS2DS_WAKE_UP_DUR_ADDR			0x34
+#define LIS2DS_FREE_FALL_ADDR			0x35
+#define LIS2DS_STATUS_DUP_ADDR			0x36
+#define LIS2DS_WAKE_UP_SRC_ADDR			0x37
+#define LIS2DS_TAP_SRC_ADDR			0x38
+#define LIS2DS_6D_SRC_ADDR			0x39
+#define LIS2DS_STEP_C_MINTHS_ADDR		0x3a
+#define LIS2DS_STEP_C_MINTHS_RST_NSTEP_MASK	0x80
+#define LIS2DS_STEP_C_OUT_L_ADDR		0x3b
+#define LIS2DS_STEP_C_OUT_SIZE			2
+
+#define LIS2DS_FUNC_CK_GATE_ADDR		0x3d
+#define LIS2DS_FUNC_CK_GATE_TILT_INT_MASK	0x80
+#define LIS2DS_FUNC_CK_GATE_SIGN_M_DET_MASK	0x10
+#define LIS2DS_FUNC_CK_GATE_RST_SIGN_M_MASK	0x08
+#define LIS2DS_FUNC_CK_GATE_RST_PEDO_MASK	0x04
+#define LIS2DS_FUNC_CK_GATE_STEP_D_MASK		0x02
+#define LIS2DS_FUNC_CK_GATE_MASK		(LIS2DS_FUNC_CK_GATE_TILT_INT_MASK | \
+						LIS2DS_FUNC_CK_GATE_SIGN_M_DET_MASK | \
+						LIS2DS_FUNC_CK_GATE_STEP_D_MASK)
+
+#define LIS2DS_FUNC_SRC_ADDR			0x3e
+
+#define LIS2DS_FUNC_CTRL_ADDR			0x3f
+#define LIS2DS_FUNC_CTRL_TILT_MASK		0x10
+#define LIS2DS_FUNC_CTRL_SIGN_MOT_MASK		0x02
+#define LIS2DS_FUNC_CTRL_STEP_CNT_MASK		0x01
+#define LIS2DS_FUNC_CTRL_EV_MASK		(LIS2DS_FUNC_CTRL_TILT_MASK | \
+						LIS2DS_FUNC_CTRL_SIGN_MOT_MASK | \
+						LIS2DS_FUNC_CTRL_STEP_CNT_MASK)
+
+#define LIS2DS_FIFO_THS_ADDR			LIS2DS_STATUS_ADDR
+#define LIS2DS_FIFO_THS_MASK			0x80
+
+#define LIS2DS_INT_STATUS_ADDR			LIS2DS_STATUS_ADDR
+#define LIS2DS_WAKE_UP_IA_MASK			0x40
+#define LIS2DS_DOUBLE_TAP_MASK			0x10
+#define LIS2DS_SINGLE_TAP_MASK			0x08
+#define LIS2DS_6D_IA_MASK			0x04
+#define LIS2DS_FF_IA_MASK			0x02
+#define LIS2DS_DRDY_MASK			0x01
+#define LIS2DS_EVENT_MASK			(LIS2DS_WAKE_UP_IA_MASK | \
+						LIS2DS_DOUBLE_TAP_MASK | \
+						LIS2DS_SINGLE_TAP_MASK | \
+						LIS2DS_6D_IA_MASK | \
+						LIS2DS_FF_IA_MASK)
+
+#define LIS2DS_ODR_ADDR				LIS2DS_CTRL1_ADDR
+#define LIS2DS_ODR_MASK				0xf0
+#define LIS2DS_ODR_POWER_OFF_VAL		0x00
+#define LIS2DS_ODR_1HZ_LP_VAL			0x08
+#define LIS2DS_ODR_12HZ_LP_VAL			0x09
+#define LIS2DS_ODR_25HZ_LP_VAL			0x0a
+#define LIS2DS_ODR_50HZ_LP_VAL			0x0b
+#define LIS2DS_ODR_100HZ_LP_VAL			0x0c
+#define LIS2DS_ODR_200HZ_LP_VAL			0x0d
+#define LIS2DS_ODR_400HZ_LP_VAL			0x0e
+#define LIS2DS_ODR_800HZ_LP_VAL			0x0f
+#define LIS2DS_ODR_LP_LIST_NUM			9
+
+#define LIS2DS_ODR_12_5HZ_HR_VAL		0x01
+#define LIS2DS_ODR_25HZ_HR_VAL			0x02
+#define LIS2DS_ODR_50HZ_HR_VAL			0x03
+#define LIS2DS_ODR_100HZ_HR_VAL			0x04
+#define LIS2DS_ODR_200HZ_HR_VAL			0x05
+#define LIS2DS_ODR_400HZ_HR_VAL			0x06
+#define LIS2DS_ODR_800HZ_HR_VAL			0x07
+#define LIS2DS_ODR_HR_LIST_NUM			8
+
+#define LIS2DS_FS_ADDR				LIS2DS_CTRL1_ADDR
+#define LIS2DS_FS_MASK				0x0c
+#define LIS2DS_FS_2G_VAL			0x00
+#define LIS2DS_FS_4G_VAL			0x02
+#define LIS2DS_FS_8G_VAL			0x03
+#define LIS2DS_FS_16G_VAL			0x01
+
+/*
+ * Sensitivity sets in LP mode [ug]
+ */
+#define LIS2DS_FS_2G_GAIN_LP			3906
+#define LIS2DS_FS_4G_GAIN_LP			7813
+#define LIS2DS_FS_8G_GAIN_LP			15625
+#define LIS2DS_FS_16G_GAIN_LP			31250
+
+/*
+ * Sensitivity sets in HR mode [ug]
+ */
+#define LIS2DS_FS_2G_GAIN_HR			244
+#define LIS2DS_FS_4G_GAIN_HR			488
+#define LIS2DS_FS_8G_GAIN_HR			976
+#define LIS2DS_FS_16G_GAIN_HR			1952
+
+#define LIS2DS_FS_LIST_NUM			4
+enum {
+	LIS2DS_LP_MODE = 0,
+	LIS2DS_HR_MODE,
+	LIS2DS_MODE_COUNT,
+};
+#define LIS2DS_MODE_DEFAULT			LIS2DS_LP_MODE	
+
+#define LIS2DS_INT1_SHUB_DRDY_MASK		0x80
+#define LIS2DS_INT1_S_TAP_MASK			0x40
+#define LIS2DS_INT1_WAKEUP_MASK			0x20
+#define LIS2DS_INT1_FREE_FALL_MASK		0x10
+#define LIS2DS_INT1_TAP_MASK			0x08
+#define LIS2DS_INT1_6D_MASK			0x04
+#define LIS2DS_INT1_FTH_MASK			0x02
+#define LIS2DS_INT1_DRDY_MASK			0x01
+#define LIS2DS_INT1_EVENTS_MASK			(LIS2DS_INT1_S_TAP_MASK | \
+						LIS2DS_INT1_WAKEUP_MASK | \
+						LIS2DS_INT1_FREE_FALL_MASK | \
+						LIS2DS_INT1_TAP_MASK | \
+						LIS2DS_INT1_6D_MASK | \
+						LIS2DS_INT1_FTH_MASK | \
+						LIS2DS_INT1_DRDY_MASK)
+
+#define LIS2DS_INT2_ON_INT1_MASK		0x20
+#define LIS2DS_INT2_TILT_MASK			0x10
+#define LIS2DS_INT2_SIG_MOT_DET_MASK		0x08
+#define LIS2DS_INT2_STEP_DET_MASK		0x04
+#define LIS2DS_INT2_EVENTS_MASK			(LIS2DS_INT2_TILT_MASK | \
+						LIS2DS_INT2_SIG_MOT_DET_MASK | \
+						LIS2DS_INT2_STEP_DET_MASK)
+
+#define LIS2DS_INT_DUR_SHOCK_MASK		0x03
+#define LIS2DS_INT_DUR_QUIET_MASK		0x0c
+#define LIS2DS_INT_DUR_LAT_MASK			0xf0
+#define LIS2DS_INT_DUR_MASK			(LIS2DS_INT_DUR_SHOCK_MASK | \
+						LIS2DS_INT_DUR_QUIET_MASK | \
+						LIS2DS_INT_DUR_LAT_MASK)
+#define LIS2DS_INT_DUR_STAP_DEFAULT		0x06
+#define LIS2DS_INT_DUR_DTAP_DEFAULT		0x7f
+
+#define LIS2DS_WAKE_UP_THS_S_D_TAP_MASK		0x80
+#define LIS2DS_WAKE_UP_THS_SLEEP_MASK		0x40
+#define LIS2DS_WAKE_UP_THS_WU_MASK		0x3f
+#define LIS2DS_WAKE_UP_THS_WU_DEFAULT		0x02
+
+#define LIS2DS_FREE_FALL_THS_MASK		0x07
+#define LIS2DS_FREE_FALL_DUR_MASK		0xF8
+#define LIS2DS_FREE_FALL_THS_DEFAULT		0x01
+#define LIS2DS_FREE_FALL_DUR_DEFAULT		0x01
+
+#define LIS2DS_WAKE_UP_THS_MASK			0x3f
+#define LIS2DS_WAKE_UP_SD_TAP_MASK		0x80
+
+#define LIS2DS_HF_ODR_ADDR			LIS2DS_CTRL1_ADDR
+#define LIS2DS_HF_ODR_MASK			0x02
+#define LIS2DS_BDU_ADDR				LIS2DS_CTRL1_ADDR
+#define LIS2DS_BDU_MASK				0x01
+
+#define LIS2DS_SOFT_RESET_ADDR			LIS2DS_CTRL2_ADDR
+#define LIS2DS_SOFT_RESET_MASK			0x40
+
+#define LIS2DS_LIR_ADDR				LIS2DS_CTRL3_ADDR
+#define LIS2DS_LIR_MASK				0x04
+
+#define LIS2DS_TAP_AXIS_ADDR			LIS2DS_CTRL3_ADDR
+#define LIS2DS_TAP_AXIS_MASK			0x38
+#define LIS2DS_TAP_AXIS_ANABLE_ALL		0x07
+
+#define LIS2DS_SELF_TEST_ADDR			LIS2DS_CTRL3_ADDR
+#define LIS2DS_SELF_TEST_MASK			0xc0
+#define LIS2DS_SELF_TEST_NORM_M			0
+#define LIS2DS_SELF_TEST_POS_SIGN		1
+#define LIS2DS_SELF_TEST_NEG_SIGN		2
+#define LIS2DS_TT_AXIS_EN_ADDR			LIS2DS_CTRL3_ADDR
+#define LIS2DS_TT_AXIS_EN_MASK			0x38
+#define LIS2DS_TT_AXIS_EN_VAL			0x07
+#define LIS2DS_TAP_THS_ADDR			LIS2DS_TAP_THS_6D_ADDR
+#define LIS2DS_TAP_THS_MASK			0x1f
+#define LIS2DS_TAP_THS_DEFAULT			0x09
+
+#define LIS2DS_INT2_ON_INT1_ADDR		LIS2DS_CTRL5_INT2_PAD_ADDR
+#define LIS2DS_INT2_ON_INT1_MASK		0x20
+
+#define LIS2DS_FIFO_MODE_ADDR			LIS2DS_FIFO_CTRL_ADDR
+#define LIS2DS_FIFO_MODE_MASK			0xe0
+#define LIS2DS_FIFO_MODE_BYPASS			0x00
+#define LIS2DS_FIFO_MODE_STOP_ON_FULL		0x01
+#define LIS2DS_FIFO_MODE_CONTINUOS		0x06
+
+#define LIS2DS_ACCEL_STD			1
+#define LIS2DS_ACCEL_STD_FROM_PD		2
+#define LIS2DS_OUT_XYZ_SIZE			8
+#define LIS2DS_EN_BIT				0x01
+#define LIS2DS_DIS_BIT				0x00
+
+#define LIS2DS_ACCEL_BIT			(1 << LIS2DS_ACCEL)
+#define LIS2DS_FF_BIT				(1 << LIS2DS_FF)
+#define LIS2DS_TAP_BIT				(1 << LIS2DS_TAP)
+#define LIS2DS_WAKEUP_BIT			(1 << LIS2DS_WAKEUP)
+#define LIS2DS_ACTIVITY_BIT			(1 << LIS2DS_ACTIVITY)
+#define LIS2DS_ALL_EVENT_BIT_MASK		(LIS2DS_FF_BIT | \
+						LIS2DS_TAP_BIT | \
+						LIS2DS_WAKEUP_BIT | \
+						LIS2DS_ACTIVITY_BIT)
+
+#define LIS2DS_EVENT_FF_CODE			(1 << LIS2DS_EVENT_FF)
+#define LIS2DS_EVENT_TAP_CODE			(1 << LIS2DS_EVENT_TAP)
+#define LIS2DS_EVENT_DOUBLE_TAP_CODE		(1 << LIS2DS_EVENT_DOUBLE_TAP)
+#define LIS2DS_EVENT_STEP_D_CODE 		(1 << LIS2DS_EVENT_STEP_D)
+#define LIS2DS_EVENT_TILT_CODE			(1 << LIS2DS_EVENT_TILT)
+#define LIS2DS_EVENT_SIGN_M_CODE		(1 << LIS2DS_EVENT_SIGN_M)
+#define LIS2DS_EVENT_WAKEUP_CODE		(1 << LIS2DS_EVENT_WAKEUP)
+#define LIS2DS_EVENT_ACTIVITY_CODE		(1 << LIS2DS_EVENT_ACTIVITY)
+#define LIS2DS_EVENT_ALL_CODE			(LIS2DS_EVENT_FF_CODE | \
+						LIS2DS_EVENT_TAP_CODE | \
+						LIS2DS_EVENT_DOUBLE_TAP_CODE | \
+						LIS2DS_EVENT_STEP_D_CODE | \
+						LIS2DS_EVENT_TILT_CODE | \
+						LIS2DS_EVENT_SIGN_M_CODE | \
+						LIS2DS_EVENT_WAKEUP_CODE | \
+						LIS2DS_EVENT_ACTIVITY_CODE)
+
+#define LIS2DS_ACCEL_ODR			1
+#define LIS2DS_ACCEL_FS				2
+#define LIS2DS_FF_ODR				25
+#define LIS2DS_STEP_D_ODR			25
+#define LIS2DS_TILT_ODR				25
+#define LIS2DS_SIGN_M_ODR			25
+#define LIS2DS_TAP_ODR				400
+#define LIS2DS_WAKEUP_ODR			25
+#define LIS2DS_ACTIVITY_ODR			12
+
+#define LIS2DS_FIFO_ELEMENT_LEN_BYTE		2
+#define LIS2DS_FIFO_BYTE_FOR_SAMPLE		6
+#define LIS2DS_MAX_FIFO_LENGHT			256
+#define LIS2DS_MAX_FIFO_SIZE			(LIS2DS_MAX_FIFO_LENGHT * \
+						LIS2DS_FIFO_BYTE_FOR_SAMPLE)
+#define LIS2DS_MIN_EVENT_ODR			25
+#ifndef MAX
+#define MAX(a, b)				(((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a, b)				(((a) < (b)) ? (a) : (b))
+#endif
+
+#define CHECK_BIT(x,y)				(x & (1 << y))
+
+static const struct lis2ds_sensor_name {
+	const char *name;
+	const char *description;
+} lis2ds_sensor_name[LIS2DS_SENSORS_NUMB] = {
+	[LIS2DS_ACCEL] = {
+			.name = "accel",
+			.description = "ST LIS2DS Accelerometer Sensor",
+	},
+	[LIS2DS_STEP_C] = {
+			.name = "step_c",
+			.description = "ST LIS2DS Step Counter Sensor",
+	},
+	[LIS2DS_FF] = {
+			.name = "free_fall",
+			.description = "ST LIS2DS Free Fall Sensor",
+	},
+	[LIS2DS_TAP] = {
+			.name = "tap",
+			.description = "ST LIS2DS Tap Sensor",
+	},
+	[LIS2DS_DOUBLE_TAP] = {
+			.name = "double_tap",
+			.description = "ST LIS2DS Double Tap Sensor",
+	},
+	[LIS2DS_STEP_D] = {
+			.name = "step_d",
+			.description = "ST LIS2DS Step Detector Sensor",
+	},
+	[LIS2DS_TILT] = {
+			.name = "tilt",
+			.description = "ST LIS2DS Tilt Sensor",
+	},
+	[LIS2DS_SIGN_M] = {
+			.name = "sign_m",
+			.description = "ST LIS2DS Significant Motion Sensor",
+	},
+	[LIS2DS_WAKEUP] = {
+			.name = "wake_up",
+			.description = "ST LIS2DS Wake Up Sensor",
+	},
+	[LIS2DS_ACTIVITY] = {
+			.name = "act",
+			.description = "ST LIS2DS Activity Sensor",
+	},
+};
+
+struct lis2ds_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+static const struct lis2ds_odr_table_t {
+	u8 addr;
+	u8 mask;
+	struct lis2ds_odr_reg odr_avl[LIS2DS_MODE_COUNT][LIS2DS_ODR_LP_LIST_NUM];
+} lis2ds_odr_table = {
+	.addr = LIS2DS_ODR_ADDR,
+	.mask = LIS2DS_ODR_MASK,
+
+	.odr_avl[LIS2DS_LP_MODE][0] = { .hz = 0,
+					.value = LIS2DS_ODR_POWER_OFF_VAL },
+	.odr_avl[LIS2DS_LP_MODE][1] = { .hz = 1,
+					.value = LIS2DS_ODR_1HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][2] = { .hz = 12,
+					.value = LIS2DS_ODR_12HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][3] = { .hz = 25,
+					.value = LIS2DS_ODR_25HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][4] = { .hz = 50,
+					.value = LIS2DS_ODR_50HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][5] = { .hz = 100,
+					.value = LIS2DS_ODR_100HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][6] = { .hz = 200,
+					.value = LIS2DS_ODR_200HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][7] = { .hz = 400,
+					.value = LIS2DS_ODR_400HZ_LP_VAL },
+	.odr_avl[LIS2DS_LP_MODE][8] = { .hz = 800,
+					.value = LIS2DS_ODR_800HZ_LP_VAL },
+
+	.odr_avl[LIS2DS_HR_MODE][0] = { .hz = 0,
+					.value = LIS2DS_ODR_POWER_OFF_VAL },
+	.odr_avl[LIS2DS_HR_MODE][1] = { .hz = 12,
+					.value = LIS2DS_ODR_12_5HZ_HR_VAL },
+	.odr_avl[LIS2DS_HR_MODE][2] = { .hz = 25,
+					.value = LIS2DS_ODR_25HZ_HR_VAL },
+	.odr_avl[LIS2DS_HR_MODE][3] = { .hz = 50,
+					.value = LIS2DS_ODR_50HZ_HR_VAL },
+	.odr_avl[LIS2DS_HR_MODE][4] = { .hz = 100,
+					.value = LIS2DS_ODR_100HZ_HR_VAL },
+	.odr_avl[LIS2DS_HR_MODE][5] = { .hz = 200,
+					.value = LIS2DS_ODR_200HZ_HR_VAL },
+	.odr_avl[LIS2DS_HR_MODE][6] = { .hz = 400,
+					.value = LIS2DS_ODR_400HZ_HR_VAL },
+	.odr_avl[LIS2DS_HR_MODE][7] = { .hz = 800,
+					.value = LIS2DS_ODR_800HZ_HR_VAL },
+};
+
+struct lis2ds_fs_reg {
+	unsigned int gain[LIS2DS_MODE_COUNT];
+	u8 value;
+	int urv;
+};
+
+static struct lis2ds_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lis2ds_fs_reg fs_avl[LIS2DS_FS_LIST_NUM];
+} lis2ds_fs_table = {
+	.addr = LIS2DS_FS_ADDR,
+	.mask = LIS2DS_FS_MASK,
+	.fs_avl[0] = { .gain = {LIS2DS_FS_2G_GAIN_LP, LIS2DS_FS_2G_GAIN_HR,},
+			.value = LIS2DS_FS_2G_VAL,
+			.urv = 2, },
+	.fs_avl[1] = { .gain = {LIS2DS_FS_4G_GAIN_LP, LIS2DS_FS_4G_GAIN_HR,},
+			.value = LIS2DS_FS_4G_VAL,
+			.urv = 4, },
+	.fs_avl[2] = { .gain = {LIS2DS_FS_8G_GAIN_LP, LIS2DS_FS_8G_GAIN_LP,},
+			.value = LIS2DS_FS_8G_VAL,
+			.urv = 8, },
+	.fs_avl[3] = { .gain = {LIS2DS_FS_16G_GAIN_LP, LIS2DS_FS_16G_GAIN_HR,},
+			.value = LIS2DS_FS_16G_VAL,
+			.urv = 16, },
+};
+
+static inline s64 lis2ds_get_time_ns(void)
+{
+	struct timespec ts;
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int lis2ds_write_data_with_mask(struct lis2ds_data *cdata,
+				       u8 reg_addr, u8 mask, u8 data,
+				       bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+
+static int lis2ds_input_init(struct lis2ds_sensor_data *sdata, u16 bustype)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = lis2ds_sensor_name[sdata->sindex].description;
+	sdata->input_dev->id.bustype = bustype;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if (sdata->sindex == LIS2DS_ACCEL) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+			sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lis2ds_input_cleanup(struct lis2ds_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lis2ds_report_3axes_event(struct lis2ds_sensor_data *sdata,
+				      s32 *xyz, s64 timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static void lis2ds_report_single_event(struct lis2ds_sensor_data *sdata,
+				       s32 data)
+{
+	struct input_dev  *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    sdata->timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    sdata->timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static int lis2ds_report_step_c_data(struct lis2ds_data *cdata)
+{
+	int err = 0;
+	s32 steps = 0;
+	u8 data[2];
+
+	err = cdata->tf->read(cdata, LIS2DS_STEP_C_OUT_L_ADDR,
+			      LIS2DS_STEP_C_OUT_SIZE, data, true);
+	if (err < 0)
+		return err;
+
+	steps = (s32)((u16)(data[1] << 8) | data[0]);
+	lis2ds_report_single_event(&cdata->sensors[LIS2DS_STEP_C], steps);
+
+	return 0;
+}
+
+static inline s32 lis2ds_data_align_bit(u8 ms, u8 ls, u8 power_mode)
+{
+	if (power_mode == LIS2DS_LP_MODE)
+		return (s32)(((s16)(ls | ms << 8)) >> 6);
+	else
+		return (s32)(((s16)(ls | ms << 8)) >> 2);
+}
+
+static void lis2ds_get_acc_data(struct lis2ds_data *cdata)
+{
+	u8 data[6];
+	int err, xyz[3];
+	struct lis2ds_sensor_data *sdata = &cdata->sensors[LIS2DS_ACCEL];
+
+	err = cdata->tf->read(cdata, LIS2DS_OUTX_L_ADDR, LIS2DS_OUT_XYZ_SIZE,
+			      data, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "get acc data failed %d\n", err);
+	} else {
+		if (++sdata->skip_cnt < sdata->dec_cnt)
+			return;
+
+		sdata->skip_cnt = 0;
+
+		xyz[0] = lis2ds_data_align_bit(data[1], data[0],
+					       cdata->power_mode);
+		xyz[1] = lis2ds_data_align_bit(data[3], data[2],
+					       cdata->power_mode);
+		xyz[2] = lis2ds_data_align_bit(data[5], data[4],
+					       cdata->power_mode);
+
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+
+		lis2ds_report_3axes_event(sdata, xyz, cdata->timestamp);
+	}
+}
+
+static u8 lis2ds_event_irq1_value(struct lis2ds_data *cdata)
+{
+	u8 value = 0x0;
+
+	if (cdata->sensors[LIS2DS_FF].enabled)
+		value |= LIS2DS_INT1_FREE_FALL_MASK;
+
+	if (cdata->sensors[LIS2DS_DOUBLE_TAP].enabled)
+		value |= LIS2DS_INT1_TAP_MASK;
+
+	if (cdata->sensors[LIS2DS_TAP].enabled)
+		value |= LIS2DS_INT1_S_TAP_MASK | LIS2DS_INT1_TAP_MASK;
+
+	if (cdata->sensors[LIS2DS_WAKEUP].enabled)
+		value |= LIS2DS_INT1_WAKEUP_MASK;
+
+	return value;
+}
+
+static u8 lis2ds_event_irq2_value(struct lis2ds_data *cdata)
+{
+	u8 value = 0x0;
+
+	if (cdata->sensors[LIS2DS_TILT].enabled)
+		value |= LIS2DS_INT2_TILT_MASK;
+
+	if (cdata->sensors[LIS2DS_SIGN_M].enabled)
+		value |= LIS2DS_INT2_SIG_MOT_DET_MASK;
+
+	if ((cdata->sensors[LIS2DS_STEP_C].enabled) ||
+	    (cdata->sensors[LIS2DS_STEP_D].enabled))
+		value |= LIS2DS_INT2_STEP_DET_MASK;
+
+	return value;
+}
+
+/*
+static int lis2ds_set_enable_function(struct lis2ds_data *cdata, bool state,
+			       u8 func_bit_mask)
+{
+	int err = 0;
+
+	err = lis2ds_write_data_with_mask(cdata,
+					  LIS2DS_FUNC_CTRL_ADDR,
+					  func_bit_mask,
+					  state >> __ffs(func_bit_mask),
+					  true);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+*/
+static int lis2ds_update_drdy_irq(struct lis2ds_sensor_data *sdata)
+{
+	u8 reg_addr, reg_val, reg_mask;
+
+	switch (sdata->sindex) {
+	case LIS2DS_FF:
+	case LIS2DS_TAP:
+	case LIS2DS_DOUBLE_TAP:
+	case LIS2DS_WAKEUP:
+	case LIS2DS_ACTIVITY:
+		reg_val = lis2ds_event_irq1_value(sdata->cdata);
+		reg_addr = LIS2DS_CTRL4_INT1_PAD_ADDR;
+		reg_mask = LIS2DS_INT1_EVENTS_MASK;
+		break;
+	case LIS2DS_SIGN_M:
+	case LIS2DS_TILT:
+	case LIS2DS_STEP_D:
+	case LIS2DS_STEP_C:
+		reg_val = lis2ds_event_irq2_value(sdata->cdata);
+		reg_addr = LIS2DS_CTRL5_INT2_PAD_ADDR;
+		reg_mask = LIS2DS_INT2_EVENTS_MASK;
+		break;
+	case LIS2DS_ACCEL:
+		reg_val = (sdata->cdata->sensors[LIS2DS_ACCEL].enabled)
+				? LIS2DS_INT1_DRDY_MASK : 0;
+		reg_addr = LIS2DS_CTRL4_INT1_PAD_ADDR;
+		reg_mask = LIS2DS_INT1_DRDY_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lis2ds_write_data_with_mask(sdata->cdata, reg_addr, reg_mask,
+					   reg_val >> __ffs(reg_mask),
+					   true);
+}
+
+static int lis2ds_set_fs(struct lis2ds_sensor_data *sdata, unsigned int fs)
+{
+	int err, i;
+
+	for (i = 0; i < LIS2DS_FS_LIST_NUM; i++) {
+		if (lis2ds_fs_table.fs_avl[i].urv == fs)
+			break;
+	}
+
+	if (i == LIS2DS_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  lis2ds_fs_table.addr,
+					  lis2ds_fs_table.mask,
+					  lis2ds_fs_table.fs_avl[i].value,
+					  true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = lis2ds_fs_table.fs_avl[i].gain[sdata->cdata->power_mode];
+
+	return 0;
+}
+
+static irqreturn_t lis2ds_save_timestamp(int irq, void *private)
+{
+	struct lis2ds_data *cdata = private;
+
+	cdata->timestamp = lis2ds_get_time_ns();
+
+	disable_irq_nosync(irq);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static void lis2ds_event_management(struct lis2ds_data *cdata, u8 int_reg_val,
+			     u8 ck_gate_val)
+{
+	if ((cdata->sensors[LIS2DS_TAP].enabled) &&
+	    (int_reg_val & LIS2DS_SINGLE_TAP_MASK)) {
+		cdata->sensors[LIS2DS_TAP].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_TAP], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_DOUBLE_TAP].enabled) &&
+	    (int_reg_val & LIS2DS_DOUBLE_TAP_MASK)) {
+		cdata->sensors[LIS2DS_DOUBLE_TAP].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_DOUBLE_TAP], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_FF].enabled) &&
+	    (int_reg_val & LIS2DS_FF_IA_MASK)) {
+		cdata->sensors[LIS2DS_FF].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_FF], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_WAKEUP].enabled) &&
+	    (int_reg_val & LIS2DS_WAKE_UP_IA_MASK)) {
+		cdata->sensors[LIS2DS_WAKEUP].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_WAKEUP], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_STEP_D].enabled) &&
+	    (ck_gate_val & LIS2DS_FUNC_CK_GATE_STEP_D_MASK)) {
+		cdata->sensors[LIS2DS_STEP_D].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_STEP_D], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_TILT].enabled) &&
+	    (ck_gate_val & LIS2DS_FUNC_CK_GATE_TILT_INT_MASK)) {
+		cdata->sensors[LIS2DS_TILT].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_TILT], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_SIGN_M].enabled) &&
+	    (ck_gate_val & LIS2DS_FUNC_CK_GATE_SIGN_M_DET_MASK)) {
+		cdata->sensors[LIS2DS_SIGN_M].timestamp = cdata->timestamp;
+		lis2ds_report_single_event(&cdata->sensors[LIS2DS_SIGN_M], 1);
+	}
+
+	if ((cdata->sensors[LIS2DS_STEP_C].enabled) &&
+	    (ck_gate_val & LIS2DS_FUNC_CK_GATE_STEP_D_MASK)) {
+		cdata->sensors[LIS2DS_STEP_C].timestamp = cdata->timestamp;
+		lis2ds_report_step_c_data(cdata);
+	}
+}
+
+static irqreturn_t lis2ds_thread_fn(int irq, void *private)
+{
+	u8 status[4], func[2];
+	struct lis2ds_data *cdata = (struct lis2ds_data *)private;
+
+	cdata->tf->read(cdata, LIS2DS_STATUS_DUP_ADDR, 4, status, true);
+	cdata->tf->read(cdata, LIS2DS_FUNC_CK_GATE_ADDR, 2, func, true);
+
+	if ((status[0] & LIS2DS_EVENT_MASK) ||
+	    (func[0] & LIS2DS_FUNC_CK_GATE_MASK))
+		/* Detected an event! Decode and report it */
+		lis2ds_event_management(cdata, status[0], func[0]);
+
+	cdata->tf->read(cdata, LIS2DS_STATUS_ADDR, 1, status, true);
+	if (status[0] & 0x01)
+		lis2ds_get_acc_data(cdata);
+
+	enable_irq(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int lis2ds_write_max_odr(struct lis2ds_sensor_data *sdata)
+{
+	int err, i;
+	u32 max_odr = 0;
+	struct lis2ds_data *cdata = sdata->cdata;
+
+	for (i = 0; i < LIS2DS_SENSORS_NUMB; i++)
+		if (sdata->cdata->sensors[i].enabled)
+			if (cdata->sensors[i].c_odr > max_odr)
+				max_odr = cdata->sensors[i].c_odr;
+
+	if (max_odr != cdata->common_odr) {
+		u16 real_odr;
+
+		for (i = 0; i < LIS2DS_ODR_LP_LIST_NUM; i++) {
+			if (lis2ds_odr_table.odr_avl[cdata->power_mode][i].hz >= max_odr)
+				break;
+		}
+		if (i == LIS2DS_ODR_LP_LIST_NUM)
+			return -EINVAL;
+
+		real_odr = lis2ds_odr_table.odr_avl[cdata->power_mode][i].hz;
+		err = lis2ds_write_data_with_mask(sdata->cdata,
+						  lis2ds_odr_table.addr,
+						  lis2ds_odr_table.mask,
+						  lis2ds_odr_table.odr_avl[cdata->power_mode][i].value,
+						  true);
+		if (err < 0)
+			return err;
+
+		cdata->common_odr = max_odr;
+		sdata->dec_cnt = real_odr / sdata->c_odr;
+		sdata->skip_cnt = 0;
+	}
+
+	return 0;
+}
+
+/*
+static int lis2ds_configure_tap_event(struct lis2ds_sensor_data *sdata,
+			       bool single_tap)
+{
+	u8 err = 0;
+
+	if (single_tap) {
+		err = lis2ds_write_data_with_mask(sdata->cdata,
+						  LIS2DS_INT_DUR_ADDR,
+						  LIS2DS_INT_DUR_MASK,
+						  LIS2DS_INT_DUR_STAP_DEFAULT,
+						  true);
+		if (err < 0)
+			return err;
+
+		err = lis2ds_write_data_with_mask(sdata->cdata,
+						  LIS2DS_WAKE_UP_THS_ADDR,
+						  LIS2DS_WAKE_UP_THS_S_D_TAP_MASK,
+						  LIS2DS_DIS_BIT, true);
+		if (err < 0)
+			return err;
+	} else {
+		err = lis2ds_write_data_with_mask(sdata->cdata,
+						  LIS2DS_INT_DUR_ADDR,
+						  LIS2DS_INT_DUR_MASK,
+						  LIS2DS_INT_DUR_DTAP_DEFAULT,
+						  true);
+		if (err < 0)
+			return err;
+
+		err = lis2ds_write_data_with_mask(sdata->cdata,
+						  LIS2DS_WAKE_UP_THS_ADDR,
+						  LIS2DS_WAKE_UP_THS_S_D_TAP_MASK,
+						  LIS2DS_EN_BIT, true);
+		if (err < 0)
+			return err;
+	}
+
+	return err;
+}
+*/
+
+static int lis2ds_update_event_functions(struct lis2ds_data *cdata)
+{
+	u8 reg_val = 0;
+
+	if (cdata->sensors[LIS2DS_SIGN_M].enabled)
+		reg_val |= LIS2DS_FUNC_CTRL_SIGN_MOT_MASK;
+
+	if (cdata->sensors[LIS2DS_TILT].enabled)
+		reg_val |= LIS2DS_FUNC_CTRL_TILT_MASK;
+
+	if ((cdata->sensors[LIS2DS_STEP_D].enabled) ||
+	    (cdata->sensors[LIS2DS_STEP_C].enabled))
+		reg_val |= LIS2DS_FUNC_CTRL_STEP_CNT_MASK;
+
+	return lis2ds_write_data_with_mask(cdata,
+					   LIS2DS_FUNC_CTRL_ADDR,
+					   LIS2DS_FUNC_CTRL_EV_MASK,
+					   reg_val >> __ffs(LIS2DS_FUNC_CTRL_EV_MASK),
+					   true);
+}
+
+static int _lis2ds_enable_sensors(struct lis2ds_sensor_data *sdata)
+{
+	int err = 0;
+
+	switch (sdata->sindex) {
+	case LIS2DS_TAP:
+		if (sdata->cdata->sensors[LIS2DS_DOUBLE_TAP].enabled)
+			return -EINVAL;
+		break;
+	case LIS2DS_DOUBLE_TAP:
+		if (sdata->cdata->sensors[LIS2DS_TAP].enabled)
+			return -EINVAL;
+		break;
+	case LIS2DS_FF:
+	case LIS2DS_WAKEUP:
+	case LIS2DS_ACTIVITY:
+	case LIS2DS_ACCEL:
+		break;
+	case LIS2DS_TILT:
+	case LIS2DS_SIGN_M:
+	case LIS2DS_STEP_D:
+	case LIS2DS_STEP_C:
+		err = lis2ds_update_event_functions(sdata->cdata);
+		if (err < 0)
+			return err;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lis2ds_update_drdy_irq(sdata);
+	if (err < 0)
+		return err;
+
+	err = lis2ds_write_max_odr(sdata);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lis2ds_enable_sensors(struct lis2ds_sensor_data *sdata)
+{
+	int err = 0;
+	
+	if (sdata->enabled)
+		return 0;
+
+	sdata->enabled = true;
+	err = _lis2ds_enable_sensors(sdata);
+	if (err < 0)
+		sdata->enabled = false;
+
+	return err;
+}
+
+static int _lis2ds_disable_sensors(struct lis2ds_sensor_data *sdata)
+{
+	int err;
+
+	switch (sdata->sindex) {
+	case LIS2DS_TILT:
+	case LIS2DS_SIGN_M:
+	case LIS2DS_STEP_D:
+	case LIS2DS_STEP_C:
+		err = lis2ds_update_event_functions(sdata->cdata);
+		if (err < 0)
+			return err;
+	case LIS2DS_ACCEL:
+	case LIS2DS_FF:
+	case LIS2DS_TAP:
+	case LIS2DS_DOUBLE_TAP:
+	case LIS2DS_WAKEUP:
+	case LIS2DS_ACTIVITY:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lis2ds_update_drdy_irq(sdata);
+	if (err < 0)
+		return err;
+
+	err = lis2ds_write_max_odr(sdata);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lis2ds_disable_sensors(struct lis2ds_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	sdata->enabled = false;
+	err = _lis2ds_disable_sensors(sdata);
+	if (err < 0)
+		sdata->enabled = true;
+
+	return err;
+}
+
+static int lis2ds_init_sensors(struct lis2ds_data *cdata)
+{
+	int err, i;
+	struct lis2ds_sensor_data *sdata;
+
+	for (i = 0; i < LIS2DS_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+
+		err = lis2ds_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+
+		if (sdata->sindex == LIS2DS_ACCEL) {
+			err = lis2ds_set_fs(sdata, LIS2DS_ACCEL_FS);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	cdata->selftest_status = 0;
+
+	/*
+	 * Soft reset the device on power on.
+	 */
+	err = lis2ds_write_data_with_mask(cdata,
+					  LIS2DS_SOFT_RESET_ADDR,
+					  LIS2DS_SOFT_RESET_MASK,
+					  LIS2DS_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Enable latched interrupt mode.
+	 */
+	err = lis2ds_write_data_with_mask(cdata,
+					  LIS2DS_LIR_ADDR,
+					  LIS2DS_LIR_MASK,
+					  LIS2DS_EN_BIT, true);
+	if (err < 0)
+		return err;
+	/*
+	 * Enable block data update feature.
+	 */
+	err = lis2ds_write_data_with_mask(cdata,
+					  LIS2DS_BDU_ADDR,
+					  LIS2DS_BDU_MASK,
+					  LIS2DS_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Route interrupt from INT2 to INT1 pin.
+	 */
+	err = lis2ds_write_data_with_mask(cdata,
+					  LIS2DS_INT2_ON_INT1_ADDR,
+					  LIS2DS_INT2_ON_INT1_MASK,
+					  LIS2DS_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default free fall event threshold.
+	 */
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  LIS2DS_FREE_FALL_ADDR,
+					  LIS2DS_FREE_FALL_THS_MASK,
+					  LIS2DS_FREE_FALL_THS_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default free fall event duration.
+	 */
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  LIS2DS_FREE_FALL_ADDR,
+					  LIS2DS_FREE_FALL_DUR_MASK,
+					  LIS2DS_FREE_FALL_DUR_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure Tap event recognition on all direction (X, Y and Z axes).
+	 */
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  LIS2DS_TAP_AXIS_ADDR,
+					  LIS2DS_TAP_AXIS_MASK,
+					  LIS2DS_TAP_AXIS_ANABLE_ALL, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default threshold for Tap event recognition.
+	 */
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  LIS2DS_TAP_THS_ADDR,
+					  LIS2DS_TAP_THS_MASK,
+					  LIS2DS_TAP_THS_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default threshold for Wake Up event recognition.
+	 */
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  LIS2DS_WAKE_UP_THS_ADDR,
+					  LIS2DS_WAKE_UP_THS_WU_MASK,
+					  LIS2DS_WAKE_UP_THS_WU_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static ssize_t lis2ds_get_enable(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t lis2ds_set_enable(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	int err;
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = lis2ds_enable_sensors(sdata);
+	else
+		err = lis2ds_disable_sensors(sdata);
+
+	return count;
+}
+
+static ssize_t lis2ds_get_resolution_mode(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%s\n", 
+		(sdata->cdata->power_mode == LIS2DS_LP_MODE) ? "low" : "high");
+}
+
+static ssize_t lis2ds_set_resolution_mode(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	int err, i;
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LIS2DS_FS_LIST_NUM; i++) {
+		if (sdata->c_gain ==
+			lis2ds_fs_table.fs_avl[i].gain[sdata->cdata->power_mode])
+			break;
+	}
+
+	if (!strncmp(buf, "low", count - 1))
+		sdata->cdata->power_mode = LIS2DS_LP_MODE;
+	else if (!strncmp(buf, "high", count - 1))
+		sdata->cdata->power_mode = LIS2DS_HR_MODE;
+	else
+		return -EINVAL;
+
+	err = lis2ds_write_max_odr(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = lis2ds_fs_table.fs_avl[i].gain[sdata->cdata->power_mode];
+
+	return count;
+}
+
+static ssize_t lis2ds_get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", 1000 / sdata->c_odr);
+}
+
+static ssize_t lis2ds_set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	sdata->c_odr = 1000 / polling_rate;
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	err = lis2ds_write_max_odr(sdata);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+static ssize_t lis2ds_get_scale_avail(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LIS2DS_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lis2ds_fs_table.fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t lis2ds_get_cur_scale(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LIS2DS_FS_LIST_NUM; i++)
+		if (sdata->c_gain ==
+			lis2ds_fs_table.fs_avl[i].gain[sdata->cdata->power_mode])
+			break;
+
+	return sprintf(buf, "%d\n", lis2ds_fs_table.fs_avl[i].urv);
+}
+
+static ssize_t lis2ds_set_cur_scale(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int urv, err;
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	err = lis2ds_set_fs(sdata, urv);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+static ssize_t lis2ds_reset_step_counter(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	int err;
+	struct lis2ds_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = lis2ds_write_data_with_mask(sdata->cdata,
+					  LIS2DS_STEP_C_MINTHS_ADDR,
+					  LIS2DS_STEP_C_MINTHS_RST_NSTEP_MASK,
+					  LIS2DS_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+static DEVICE_ATTR(enable,
+		   S_IWUSR | S_IRUGO,
+		   lis2ds_get_enable,
+		   lis2ds_set_enable);
+
+static DEVICE_ATTR(resolution,
+		   S_IWUSR | S_IRUGO,
+		   lis2ds_get_resolution_mode,
+		   lis2ds_set_resolution_mode);
+
+static DEVICE_ATTR(polling_rate,
+		   S_IWUSR | S_IRUGO,
+		   lis2ds_get_polling_rate,
+		   lis2ds_set_polling_rate);
+
+static DEVICE_ATTR(scale_avail,
+		   S_IRUGO,
+		   lis2ds_get_scale_avail,
+		   NULL);
+
+static DEVICE_ATTR(scale,
+		   S_IWUSR | S_IRUGO,
+		   lis2ds_get_cur_scale,
+		   lis2ds_set_cur_scale);
+
+static DEVICE_ATTR(reset_steps,
+		   S_IWUSR,
+		   NULL,
+		   lis2ds_reset_step_counter);
+
+static struct attribute *lis2ds_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_resolution.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_step_c_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_reset_steps.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_step_ff_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_tap_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_double_tap_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_step_d_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_tilt_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_sign_m_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_wakeup_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2ds_act_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lis2ds_attribute_groups[] = {
+	[LIS2DS_ACCEL] = {
+		.attrs = lis2ds_accel_attribute,
+		.name = "accel",
+	},
+	[LIS2DS_STEP_C] = {
+		.attrs = lis2ds_step_c_attribute,
+		.name = "step_c",
+	},
+	[LIS2DS_FF] = {
+		.attrs = lis2ds_step_ff_attribute,
+		.name = "free_fall",
+	},
+	[LIS2DS_TAP] = {
+		.name = "tap",
+		.attrs = lis2ds_tap_attribute,
+	},
+	[LIS2DS_DOUBLE_TAP] = {
+		.name = "double_tap",
+		.attrs = lis2ds_double_tap_attribute,
+	},
+	[LIS2DS_STEP_D] = {
+		.name = "step_d",
+		.attrs = lis2ds_step_d_attribute,
+	},
+	[LIS2DS_TILT] = {
+		.name = "tilt",
+		.attrs = lis2ds_tilt_attribute,
+	},
+	[LIS2DS_SIGN_M] = {
+		.name = "sign_m",
+		.attrs = lis2ds_sign_m_attribute,
+	},
+	[LIS2DS_WAKEUP] = {
+		.name = "wake_up",
+		.attrs = lis2ds_wakeup_attribute,
+	},
+	[LIS2DS_ACTIVITY] = {
+		.name = "act",
+		.attrs = lis2ds_act_attribute,
+	},
+};
+
+#ifdef CONFIG_OF
+static u32 lis2ds_parse_dt(struct lis2ds_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+	    (val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	return 0;
+}
+#endif
+
+int lis2ds_common_probe(struct lis2ds_data *cdata, int irq, u16 bustype)
+{
+	/* TODO: add errors management */
+	int32_t err, i;
+	u8 wai = 0;
+	struct lis2ds_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->tb.buf_lock);
+
+	err = cdata->tf->read(cdata, LIS2DS_WHO_AM_I_ADDR, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		return err;
+	}
+	if (wai != LIS2DS_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+
+	mutex_init(&cdata->lock);
+
+	if (irq > 0) {
+#ifdef CONFIG_OF
+		err = lis2ds_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lis2ds_platform_data *)
+				cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) ||
+			    (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else
+			cdata->drdy_int_pin = 1;
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+			 cdata->drdy_int_pin);
+	}
+
+	cdata->common_odr = 0;
+	cdata->power_mode = LIS2DS_LP_MODE;
+
+	for (i = 0; i < LIS2DS_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lis2ds_sensor_name[i].name;
+		switch(i) {
+		case LIS2DS_ACCEL:
+			sdata->c_odr = LIS2DS_ACCEL_ODR;
+
+			break;
+		case LIS2DS_STEP_C:
+		case LIS2DS_STEP_D:
+		case LIS2DS_SIGN_M:
+			sdata->c_odr = LIS2DS_STEP_D_ODR;
+
+			break;
+		case LIS2DS_FF:
+			sdata->c_odr = LIS2DS_FF_ODR;
+
+			break;
+		case LIS2DS_TAP:
+		case LIS2DS_DOUBLE_TAP:
+			sdata->c_odr = LIS2DS_TAP_ODR;
+
+			break;
+		case LIS2DS_TILT:
+			sdata->c_odr = LIS2DS_TILT_ODR;
+
+			break;
+		case LIS2DS_WAKEUP:
+			sdata->c_odr = LIS2DS_WAKEUP_ODR;
+
+			break;
+		case LIS2DS_ACTIVITY:
+			sdata->c_odr = LIS2DS_ACTIVITY_ODR;
+
+			break;
+		}
+
+		lis2ds_input_init(sdata, bustype);
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+				       &lis2ds_attribute_groups[i])) {
+			dev_err(cdata->dev, "failed to create sysfs group for "
+					"sensor %s", sdata->name);
+
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+	}
+
+	err = lis2ds_init_sensors(cdata);
+	if (err < 0)
+		return err;
+
+	if (irq > 0) {
+		cdata->irq = irq;
+
+		err = request_threaded_irq(cdata->irq, lis2ds_save_timestamp,
+					   lis2ds_thread_fn,
+					   IRQF_TRIGGER_RISING,
+					   cdata->name, cdata);
+		if (err)
+			return err;
+	}
+
+	dev_info(cdata->dev, "%s: probed\n", LIS2DS_DEV_NAME);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2ds_common_probe);
+
+void lis2ds_common_remove(struct lis2ds_data *cdata, int irq)
+{
+	u8 i;
+
+	for (i = 0; i < LIS2DS_SENSORS_NUMB; i++) {
+		lis2ds_disable_sensors(&cdata->sensors[i]);
+		lis2ds_input_cleanup(&cdata->sensors[i]);
+	}
+}
+EXPORT_SYMBOL(lis2ds_common_remove);
+
+#ifdef CONFIG_PM
+static int lis2ds_resume_sensors(struct lis2ds_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lis2ds_enable_sensors(sdata);
+}
+
+static int lis2ds_suspend_sensors(struct lis2ds_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lis2ds_disable_sensors(sdata);
+}
+
+int lis2ds_common_suspend(struct lis2ds_data *cdata)
+{
+	lis2ds_suspend_sensors(&cdata->sensors[LIS2DS_ACCEL]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2ds_common_suspend);
+
+int lis2ds_common_resume(struct lis2ds_data *cdata)
+{
+	lis2ds_resume_sensors(&cdata->sensors[LIS2DS_ACCEL]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2ds_common_resume);
+
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics lis2ds driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2ds/lis2ds_core.h b/drivers/input/misc/st/acc/lis2ds/lis2ds_core.h
--- a/drivers/input/misc/st/acc/lis2ds/lis2ds_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2ds/lis2ds_core.h	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,141 @@
+/******************** (C) COPYRIGHT 2015 STMicroelectronics ********************
+*
+* File Name          : lis2ds_core.h
+* Authors            : AMS - VMU - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.1.0
+* Date               : 2015/Apr/17
+* Description        : LIS2DS driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#ifndef DRIVERS_INPUT_MISC_LIS2DS_CORE_H_
+#define DRIVERS_INPUT_MISC_LIS2DS_CORE_H_
+
+#define LIS2DS_DEV_NAME			"lis2ds"
+#define LIS2DS_I2C_ADDR			0x1e
+
+#define HZ_TO_PERIOD_NSEC(hz)		(1000 * 1000 * 1000 / ((u32)(hz)))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+enum {
+	LIS2DS_ACCEL = 0,
+	LIS2DS_STEP_C,
+	LIS2DS_FF,
+	LIS2DS_TAP,
+	LIS2DS_DOUBLE_TAP,
+	LIS2DS_STEP_D,
+	LIS2DS_TILT,
+	LIS2DS_SIGN_M,
+	LIS2DS_WAKEUP,
+	LIS2DS_ACTIVITY,
+	LIS2DS_SENSORS_NUMB,
+};
+
+enum fifo_mode {
+	BYPASS = 0,
+	CONTINUOS,
+};
+
+#define DEF_ZERO			0x00
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define LIS2DS_RX_MAX_LENGTH		500
+#define LIS2DS_TX_MAX_LENGTH		500
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lis2ds_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LIS2DS_RX_MAX_LENGTH];
+	u8 tx_buf[LIS2DS_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lis2ds_data;
+
+struct lis2ds_transfer_function {
+	int (*write) (struct lis2ds_data *cdata, u8 reg_addr, int len, u8 *data,
+		      bool b_lock);
+	int (*read) (struct lis2ds_data *cdata, u8 reg_addr, int len, u8 *data,
+		     bool b_lock);
+};
+
+struct lis2ds_sensor_data {
+	struct lis2ds_data *cdata;
+	const char* name;
+	s64 timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 dec_cnt;
+	u8 skip_cnt;
+	struct input_dev *input_dev;
+};
+
+struct lis2ds_data {
+	const char *name;
+	u8 drdy_int_pin;
+	u8 selftest_status;
+	u8 power_mode;
+	u32 common_odr;
+	struct mutex lock;
+	int irq;
+	s64 timestamp;
+	struct work_struct input_work;
+	struct device *dev;
+	struct lis2ds_sensor_data sensors[LIS2DS_SENSORS_NUMB];
+	struct mutex bank_registers_lock;
+	const struct lis2ds_transfer_function *tf;
+	struct lis2ds_transfer_buffer tb;
+};
+
+int lis2ds_common_probe(struct lis2ds_data *cdata, int irq, u16 bustype);
+void lis2ds_common_remove(struct lis2ds_data *cdata, int irq);
+
+#ifdef CONFIG_PM
+int lis2ds_common_suspend(struct lis2ds_data *cdata);
+int lis2ds_common_resume(struct lis2ds_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* DRIVERS_INPUT_MISC_LIS2DS_CORE_H_ */
diff -uNr a/drivers/input/misc/st/acc/lis2ds/lis2ds_i2c.c b/drivers/input/misc/st/acc/lis2ds/lis2ds_i2c.c
--- a/drivers/input/misc/st/acc/lis2ds/lis2ds_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2ds/lis2ds_i2c.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,191 @@
+/******************** (C) COPYRIGHT 2015 STMicroelectronics ********************
+*
+* File Name          : lis2ds_i2c.c
+* Authors            : AMS - VMU - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.1.0
+* Date               : 2015/Apr/17
+* Description        : LIS2DS driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lis2ds_core.h"
+
+static int lis2ds_i2c_read(struct lis2ds_data *cdata, u8 reg_addr, int len,
+			   u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int lis2ds_i2c_write(struct lis2ds_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+
+static const struct lis2ds_transfer_function lis2ds_tf_i2c = {
+	.write = lis2ds_i2c_write,
+	.read = lis2ds_i2c_read,
+};
+
+static int lis2ds_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct lis2ds_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &lis2ds_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = lis2ds_common_probe(cdata, client->irq, BUS_I2C);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lis2ds_i2c_remove(struct i2c_client *client)
+{
+	struct lis2ds_data *cdata = i2c_get_clientdata(client);
+
+	lis2ds_common_remove(cdata, client->irq);
+	dev_info(cdata->dev, "%s: removed\n", LIS2DS_DEV_NAME);
+	kfree(cdata);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2ds_suspend(struct device *dev)
+{
+	struct lis2ds_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2ds_common_suspend(cdata);
+}
+
+static int lis2ds_resume(struct device *dev)
+{
+	struct lis2ds_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2ds_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lis2ds_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2ds_suspend, lis2ds_resume)
+};
+
+#define LIS2DS_PM_OPS	(&lis2ds_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DS_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+
+static const struct i2c_device_id lis2ds_ids[] = {
+	{ LIS2DS_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis2ds_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2ds_id_table[] = {
+	{ .compatible = "st,lis2ds", },
+	{ .compatible = "st,lis2ds12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2ds_id_table);
+#endif
+
+static struct i2c_driver lis2ds_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DS_DEV_NAME,
+		.pm = LIS2DS_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lis2ds_id_table,
+#endif
+	},
+	.probe    = lis2ds_i2c_probe,
+	.remove   = lis2ds_i2c_remove,
+	.id_table = lis2ds_ids,
+};
+
+module_i2c_driver(lis2ds_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2ds i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2ds/lis2ds_spi.c b/drivers/input/misc/st/acc/lis2ds/lis2ds_spi.c
--- a/drivers/input/misc/st/acc/lis2ds/lis2ds_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2ds/lis2ds_spi.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,221 @@
+/******************** (C) COPYRIGHT 2015 STMicroelectronics ********************
+*
+* File Name          : lis2ds_spi.c
+* Authors            : AMS - VMU - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.1.0
+* Date               : 2015/Apr/17
+* Description        : LIS2DS driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lis2ds_core.h"
+
+#define SENSORS_SPI_READ			0x80
+
+static int lis2ds_spi_read(struct lis2ds_data *cdata, u8 reg_addr, int len,
+			   u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lis2ds_spi_write(struct lis2ds_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LIS2DS_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+
+static const struct lis2ds_transfer_function lis2ds_tf_spi = {
+	.write = lis2ds_spi_write,
+	.read = lis2ds_spi_read,
+};
+
+static int lis2ds_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis2ds_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &lis2ds_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = lis2ds_common_probe(cdata, spi->irq, BUS_SPI);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lis2ds_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lis2ds_data *cdata = spi_get_drvdata(spi);
+
+	lis2ds_common_remove(cdata, spi->irq);
+	dev_info(cdata->dev, "%s: removed\n", LIS2DS_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2ds_suspend(struct device *dev)
+{
+	struct lis2ds_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2ds_common_suspend(cdata);
+}
+
+static int lis2ds_resume(struct device *dev)
+{
+	struct lis2ds_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2ds_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lis2ds_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2ds_suspend, lis2ds_resume)
+};
+
+#define LIS2DS_PM_OPS		(&lis2ds_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DS_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct spi_device_id lis2ds_ids[] = {
+	{ LIS2DS_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis2ds_ids);
+
+static const struct of_device_id lis2ds_id_table[] = {
+	{ .compatible = "st,lis2ds", },
+	{ .compatible = "st,lis2ds12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2ds_id_table);
+#endif
+
+static struct spi_driver lis2ds_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DS_DEV_NAME,
+		.pm = LIS2DS_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lis2ds_id_table,
+#endif
+	},
+	.probe    = lis2ds_spi_probe,
+	.remove   = lis2ds_spi_remove,
+	.id_table = lis2ds_ids,
+};
+
+module_spi_driver(lis2ds_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2ds spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2ds/Makefile b/drivers/input/misc/st/acc/lis2ds/Makefile
--- a/drivers/input/misc/st/acc/lis2ds/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2ds/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis2ds driver
+#
+lis2ds-core-y += lis2ds_core.o
+obj-$(CONFIG_INPUT_LIS2DS) += lis2ds-core.o
+obj-$(CONFIG_INPUT_LIS2DS_I2C) += lis2ds_i2c.o
+obj-$(CONFIG_INPUT_LIS2DS_SPI) += lis2ds_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis2dw12/Kconfig b/drivers/input/misc/st/acc/lis2dw12/Kconfig
--- a/drivers/input/misc/st/acc/lis2dw12/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dw12/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS2DW12
+	tristate "STMicroelectronics LIS2DW12 sensors"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS2DW12_I2C if (I2C)
+	select INPUT_LIS2DW12_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS2DW12 sensors.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis2dw12.
+
+config INPUT_LIS2DW12_I2C
+	tristate
+	depends on INPUT_LIS2DW12
+	depends on I2C
+
+config INPUT_LIS2DW12_SPI
+	tristate
+	depends on INPUT_LIS2DW12
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.c b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.c
--- a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.c	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,1310 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lis2dw12_core.c
+* Authors            : AMG - Application Team
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.0
+* Date               : 2016/Oct/18
+* Description        : LIS2DW12 driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lis2dw12_core.h"
+
+#define LIS2DW12_WHO_AM_I_ADDR		0x0f
+#define LIS2DW12_WHO_AM_I_DEF		0x44
+
+#define LIS2DW12_CTRL1_ADDR		0x20
+#define LIS2DW12_CTRL2_ADDR		0x21
+#define LIS2DW12_CTRL3_ADDR		0x22
+#define LIS2DW12_CTRL4_INT1_PAD_ADDR	0x23
+#define LIS2DW12_CTRL5_INT2_PAD_ADDR	0x24
+#define LIS2DW12_CTRL6_ADDR		0x25
+#define LIS2DW12_OUT_T_ADDR		0x26
+#define LIS2DW12_STATUS_ADDR		0x27
+#define LIS2DW12_OUTX_L_ADDR		0x28
+
+#define LIS2DW12_TAP_THS_X_ADDR		0x30
+#define LIS2DW12_TAP_THS_Y_ADDR		0x31
+#define LIS2DW12_TAP_THS_Z_ADDR		0x32
+#define LIS2DW12_INT_DUR_ADDR		0x33
+#define LIS2DW12_WAKE_UP_THS_ADDR		0x34
+#define LIS2DW12_WAKE_UP_DUR_ADDR		0x35
+#define LIS2DW12_FREE_FALL_ADDR		0x36
+#define LIS2DW12_STATUS_DUP_ADDR		0x37
+#define LIS2DW12_WAKE_UP_SRC_ADDR		0x38
+#define LIS2DW12_TAP_SRC_ADDR		0x39
+#define LIS2DW12_6D_SRC_ADDR		0x3a
+#define LIS2DW12_ALL_INT_ADDR		0x3b
+
+#define LIS2DW12_WAKE_UP_IA_MASK		0x40
+#define LIS2DW12_DOUBLE_TAP_MASK		0x10
+#define LIS2DW12_SINGLE_TAP_MASK		0x08
+#define LIS2DW12_6D_IA_MASK		0x04
+#define LIS2DW12_FF_IA_MASK		0x02
+#define LIS2DW12_DRDY_MASK		0x01
+#define LIS2DW12_EVENT_MASK		(LIS2DW12_WAKE_UP_IA_MASK | \
+					 LIS2DW12_DOUBLE_TAP_MASK | \
+					 LIS2DW12_SINGLE_TAP_MASK | \
+					 LIS2DW12_6D_IA_MASK | \
+					 LIS2DW12_FF_IA_MASK)
+
+#define LIS2DW12_ODR_MASK			0xf0
+#define LIS2DW12_ODR_POWER_OFF_VAL	0x00
+#define LIS2DW12_ODR_1HZ_LP_VAL		0x01
+#define LIS2DW12_ODR_12HZ_LP_VAL		0x02
+#define LIS2DW12_ODR_25HZ_LP_VAL		0x03
+#define LIS2DW12_ODR_50HZ_LP_VAL		0x04
+#define LIS2DW12_ODR_100HZ_LP_VAL		0x05
+#define LIS2DW12_ODR_200HZ_LP_VAL		0x06
+#define LIS2DW12_ODR_400HZ_LP_VAL		0x06
+#define LIS2DW12_ODR_800HZ_LP_VAL		0x06
+#define LIS2DW12_ODR_LP_LIST_NUM		9
+
+#define LIS2DW12_ODR_12_5HZ_HR_VAL	0x02
+#define LIS2DW12_ODR_25HZ_HR_VAL		0x03
+#define LIS2DW12_ODR_50HZ_HR_VAL		0x04
+#define LIS2DW12_ODR_100HZ_HR_VAL		0x05
+#define LIS2DW12_ODR_200HZ_HR_VAL		0x06
+#define LIS2DW12_ODR_400HZ_HR_VAL		0x07
+#define LIS2DW12_ODR_800HZ_HR_VAL		0x08
+#define LIS2DW12_ODR_HR_LIST_NUM		8
+
+#define LIS2DW12_LP_MODE_MASK			0x03
+#define LIS2DW12_POWER_MODE_MASK		0x0c
+
+#define LIS2DW12_FS_MASK			0x30
+#define LIS2DW12_FS_2G_VAL		0x00
+#define LIS2DW12_FS_4G_VAL		0x01
+#define LIS2DW12_FS_8G_VAL		0x02
+#define LIS2DW12_FS_16G_VAL		0x03
+
+/*
+ * Sensitivity sets in LP mode [ug]
+ */
+#define LIS2DW12_FS_2G_GAIN_LP		976
+#define LIS2DW12_FS_4G_GAIN_LP		1952
+#define LIS2DW12_FS_8G_GAIN_LP		3904
+#define LIS2DW12_FS_16G_GAIN_LP		7808
+
+/*
+ * Sensitivity sets in HR mode [ug]
+ */
+#define LIS2DW12_FS_2G_GAIN_HR		244
+#define LIS2DW12_FS_4G_GAIN_HR		488
+#define LIS2DW12_FS_8G_GAIN_HR		976
+#define LIS2DW12_FS_16G_GAIN_HR		1952
+
+#define LIS2DW12_FS_LIST_NUM		4
+
+#define LIS2DW12_INT1_6D_MASK		0x80
+#define LIS2DW12_INT1_S_TAP_MASK		0x40
+#define LIS2DW12_INT1_WAKEUP_MASK		0x20
+#define LIS2DW12_INT1_FREE_FALL_MASK	0x10
+#define LIS2DW12_INT1_TAP_MASK		0x08
+#define LIS2DW12_INT1_DRDY_MASK		0x01
+#define LIS2DW12_INT2_SLEEP_MASK		0x40
+#define LIS2DW12_INT1_EVENTS_MASK		(LIS2DW12_INT1_S_TAP_MASK | \
+					 LIS2DW12_INT1_WAKEUP_MASK | \
+					 LIS2DW12_INT1_FREE_FALL_MASK | \
+					 LIS2DW12_INT1_TAP_MASK | \
+					 LIS2DW12_INT1_6D_MASK)
+
+#define LIS2DW12_INT_DUR_SHOCK_MASK	0x03
+#define LIS2DW12_INT_DUR_QUIET_MASK	0x0c
+#define LIS2DW12_INT_DUR_LAT_MASK		0xf0
+#define LIS2DW12_INT_DUR_MASK		(LIS2DW12_INT_DUR_SHOCK_MASK | \
+					 LIS2DW12_INT_DUR_QUIET_MASK | \
+					 LIS2DW12_INT_DUR_LAT_MASK)
+
+#define LIS2DW12_INT_DUR_STAP_DEFAULT	0x06
+#define LIS2DW12_INT_DUR_DTAP_DEFAULT	0x7f
+
+#define LIS2DW12_WAKE_UP_THS_S_D_TAP_MASK	0x80
+#define LIS2DW12_WAKE_UP_THS_SLEEP_MASK	0x40
+#define LIS2DW12_WAKE_UP_THS_WU_MASK	0x3f
+#define LIS2DW12_WAKE_UP_THS_WU_DEFAULT	0x02
+
+#define LIS2DW12_FREE_FALL_THS_MASK	0x07
+#define LIS2DW12_FREE_FALL_DUR_MASK	0xf8
+#define LIS2DW12_FREE_FALL_THS_DEFAULT	0x01
+#define LIS2DW12_FREE_FALL_DUR_DEFAULT	0x01
+
+#define LIS2DW12_BDU_MASK			0x08
+#define LIS2DW12_SOFT_RESET_MASK		0x40
+#define LIS2DW12_LIR_MASK			0x10
+
+#define LIS2DW12_TAP_AXIS_MASK		0xe0
+#define LIS2DW12_TAP_AXIS_ANABLE_ALL	0xe0
+#define LIS2DW12_TAP_THS_MASK		0x1f
+#define LIS2DW12_TAP_THS_DEFAULT		0x09
+#define LIS2DW12_INT2_ON_INT1_MASK	0x20
+
+#define LIS2DW12_OUT_XYZ_SIZE		6
+#define LIS2DW12_EN_BIT			0x01
+#define LIS2DW12_DIS_BIT			0x00
+#define LIS2DW12_EN_LP_MODE_02	0x01
+
+#define LIS2DW12_ACCEL_FS			2
+#define LIS2DW12_FF_ODR			25
+#define LIS2DW12_TAP_ODR			400
+#define LIS2DW12_WAKEUP_ODR		25
+
+#define LIS2DW12_MIN_EVENT_ODR		25
+
+enum {
+	LIS2DW12_LP_MODE = 0,
+	LIS2DW12_HR_MODE,
+	LIS2DW12_MODE_COUNT,
+};
+
+static struct workqueue_struct *lis2dw12_workqueue;
+
+static const struct lis2dw12_sensor_name {
+	const char *name;
+	const char *description;
+} lis2dw12_sensor_name[LIS2DW12_SENSORS_NUMB] = {
+	[LIS2DW12_ACCEL] = {
+		.name = "accel",
+		.description = "ST LIS2DW12 Accelerometer Sensor",
+	},
+	[LIS2DW12_FF] = {
+		.name = "free_fall",
+		.description = "ST LIS2DW12 Free Fall Sensor",
+	},
+	[LIS2DW12_TAP] = {
+		.name = "tap",
+		.description = "ST LIS2DW12 Tap Sensor",
+	},
+	[LIS2DW12_DOUBLE_TAP] = {
+		.name = "double_tap",
+		.description = "ST LIS2DW12 Double Tap Sensor",
+	},
+	[LIS2DW12_WAKEUP] = {
+		.name = "wake_up",
+		.description = "ST LIS2DW12 Wake Up Sensor",
+	},
+};
+
+struct lis2dw12_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+static const struct lis2dw12_odr_table_t {
+	struct lis2dw12_odr_reg odr_avl[LIS2DW12_MODE_COUNT][LIS2DW12_ODR_LP_LIST_NUM];
+} lis2dw12_odr_table = {
+	.odr_avl[LIS2DW12_LP_MODE][0] = {
+		.hz = 0,
+		.value = LIS2DW12_ODR_POWER_OFF_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][1] = {
+		.hz = 1,
+		.value = LIS2DW12_ODR_1HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][2] = {
+		.hz = 12,
+		.value = LIS2DW12_ODR_12HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][3] = {
+		.hz = 25,
+		.value = LIS2DW12_ODR_25HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][4] = {
+		.hz = 50,
+		.value = LIS2DW12_ODR_50HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][5] = {
+		.hz = 100,
+		.value = LIS2DW12_ODR_100HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][6] = {
+		.hz = 200,
+		.value = LIS2DW12_ODR_200HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][7] = {
+		.hz = 400,
+		.value = LIS2DW12_ODR_400HZ_LP_VAL
+	},
+	.odr_avl[LIS2DW12_LP_MODE][8] = {
+		.hz = 800,
+		.value = LIS2DW12_ODR_800HZ_LP_VAL
+	},
+
+	.odr_avl[LIS2DW12_HR_MODE][0] = {
+		.hz = 0,
+		.value = LIS2DW12_ODR_POWER_OFF_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][1] = {
+		.hz = 12,
+		.value = LIS2DW12_ODR_12_5HZ_HR_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][2] = {
+		.hz = 25,
+		.value = LIS2DW12_ODR_25HZ_HR_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][3] = {
+		.hz = 50,
+		.value = LIS2DW12_ODR_50HZ_HR_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][4] = {
+		.hz = 100,
+		.value = LIS2DW12_ODR_100HZ_HR_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][5] = {
+		.hz = 200,
+		.value = LIS2DW12_ODR_200HZ_HR_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][6] = {
+		.hz = 400,
+		.value = LIS2DW12_ODR_400HZ_HR_VAL
+	},
+	.odr_avl[LIS2DW12_HR_MODE][7] = {
+		.hz = 800,
+		.value = LIS2DW12_ODR_800HZ_HR_VAL
+	},
+};
+
+struct lis2dw12_fs_reg {
+	unsigned int gain[LIS2DW12_MODE_COUNT];
+	u8 value;
+	int urv;
+};
+
+static struct lis2dw12_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lis2dw12_fs_reg fs_avl[LIS2DW12_FS_LIST_NUM];
+} lis2dw12_fs_table = {
+	.addr = LIS2DW12_CTRL6_ADDR,
+	.mask = LIS2DW12_FS_MASK,
+	.fs_avl[0] = {
+		.gain = {
+			LIS2DW12_FS_2G_GAIN_LP,
+			LIS2DW12_FS_2G_GAIN_HR,
+		},
+		.value = LIS2DW12_FS_2G_VAL,
+		.urv = 2, 
+	},
+	.fs_avl[1] = {
+		.gain = {
+			LIS2DW12_FS_4G_GAIN_LP,
+			LIS2DW12_FS_4G_GAIN_HR,
+		},
+		.value = LIS2DW12_FS_4G_VAL,
+		.urv = 4,
+	},
+	.fs_avl[2] = {
+		.gain = {
+			LIS2DW12_FS_8G_GAIN_LP,
+			LIS2DW12_FS_8G_GAIN_LP,
+		},
+		.value = LIS2DW12_FS_8G_VAL,
+		.urv = 8,
+	},
+	.fs_avl[3] = {
+		.gain = {
+			LIS2DW12_FS_16G_GAIN_LP,
+			LIS2DW12_FS_16G_GAIN_HR,
+		},
+		.value = LIS2DW12_FS_16G_VAL,
+		.urv = 16,
+	},
+};
+
+static int lis2dw12_write_data_with_mask(struct lis2dw12_data *cdata,
+				       u8 reg_addr, u8 mask, u8 data,
+				       bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+
+static int lis2dw12_input_init(struct lis2dw12_sensor_data *sdata, u16 bustype)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = lis2dw12_sensor_name[sdata->sindex].description;
+	sdata->input_dev->id.bustype = bustype;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if (sdata->sindex == LIS2DW12_ACCEL) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+			sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lis2dw12_input_cleanup(struct lis2dw12_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lis2dw12_report_3axes_event(struct lis2dw12_sensor_data *sdata,
+				      s32 *xyz, s64 timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static void lis2dw12_report_single_event(struct lis2dw12_sensor_data *sdata,
+				       s32 data)
+{
+	struct input_dev  *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    sdata->timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    sdata->timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static inline s32 lis2dw12_data_align_bit(u8 ms, u8 ls, u8 power_mode)
+{
+	if (power_mode == LIS2DW12_LP_MODE)
+		return (s32)(((s16)(ls | ms << 8)) >> 4);
+
+	return (s32)(((s16)(ls | ms << 8)) >> 2);
+}
+
+static u8 lis2dw12_event_irq1_value(struct lis2dw12_data *cdata)
+{
+	u8 value = 0x0;
+
+	if (cdata->sensors[LIS2DW12_FF].enabled)
+		value |= LIS2DW12_INT1_FREE_FALL_MASK;
+
+	if (cdata->sensors[LIS2DW12_DOUBLE_TAP].enabled)
+		value |= LIS2DW12_INT1_TAP_MASK;
+
+	if (cdata->sensors[LIS2DW12_TAP].enabled)
+		value |= LIS2DW12_INT1_S_TAP_MASK | LIS2DW12_INT1_TAP_MASK;
+
+	if (cdata->sensors[LIS2DW12_WAKEUP].enabled)
+		value |= LIS2DW12_INT1_WAKEUP_MASK;
+
+	return value;
+}
+
+static int lis2dw12_update_drdy_irq(struct lis2dw12_sensor_data *sdata)
+{
+	u8 reg_addr = LIS2DW12_CTRL4_INT1_PAD_ADDR, reg_val, reg_mask;
+
+	switch (sdata->sindex) {
+	case LIS2DW12_FF:
+	case LIS2DW12_TAP:
+	case LIS2DW12_DOUBLE_TAP:
+	case LIS2DW12_WAKEUP:
+		reg_val = lis2dw12_event_irq1_value(sdata->cdata);
+		reg_mask = LIS2DW12_INT1_EVENTS_MASK;
+		break;
+	case LIS2DW12_ACCEL:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	return lis2dw12_write_data_with_mask(sdata->cdata, reg_addr, reg_mask,
+					   reg_val >> __ffs(reg_mask), true);
+}
+
+static int lis2dw12_set_fs(struct lis2dw12_sensor_data *sdata, unsigned int fs)
+{
+	int err, i;
+
+	for (i = 0; i < LIS2DW12_FS_LIST_NUM; i++) {
+		if (lis2dw12_fs_table.fs_avl[i].urv == fs)
+			break;
+	}
+
+	if (i == LIS2DW12_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata, lis2dw12_fs_table.addr,
+					  lis2dw12_fs_table.mask,
+					  lis2dw12_fs_table.fs_avl[i].value, true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = lis2dw12_fs_table.fs_avl[i].gain[sdata->cdata->power_mode];
+
+	return 0;
+}
+
+static inline int64_t lis2dw12_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+/* Acc data */
+static int lis2dw12_get_acc_data(struct lis2dw12_data *cdata)
+{
+	u8 data[LIS2DW12_OUT_XYZ_SIZE];
+	int err, xyz[3];
+	struct lis2dw12_sensor_data *sdata = &cdata->sensors[LIS2DW12_ACCEL];
+
+	err = cdata->tf->read(cdata, LIS2DW12_OUTX_L_ADDR, LIS2DW12_OUT_XYZ_SIZE,
+			      data, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "get acc data failed %d\n", err);
+		return err;
+	} else {
+		xyz[0] = lis2dw12_data_align_bit(data[1], data[0], cdata->power_mode);
+		xyz[1] = lis2dw12_data_align_bit(data[3], data[2], cdata->power_mode);
+		xyz[2] = lis2dw12_data_align_bit(data[5], data[4], cdata->power_mode);
+
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+
+		lis2dw12_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+	
+	return 0;
+}
+
+static void lis2dw12_acc_poll_function_work(struct work_struct *input_work)
+{
+	struct lis2dw12_sensor_data *sdata;
+	sdata = container_of((struct work_struct *)input_work,
+			     struct lis2dw12_sensor_data, input_work);
+
+	lis2dw12_get_acc_data(sdata->cdata);
+}
+
+static enum hrtimer_restart lis2dw12_hrtimer_acc_callback(struct hrtimer *timer)
+{
+	struct lis2dw12_sensor_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct lis2dw12_sensor_data,
+			     hr_timer);
+
+	sdata->timestamp = lis2dw12_get_time_ns();
+	queue_work(lis2dw12_workqueue, &sdata->input_work);
+	hrtimer_forward(timer, ktime_get(), sdata->oldktime);
+
+	return HRTIMER_RESTART;
+}
+
+/* Events data */
+static irqreturn_t lis2dw12_thread_fn(int irq, void *private)
+{
+	u8 status;
+	struct lis2dw12_data *cdata = private;
+
+	cdata->tf->read(cdata, LIS2DW12_STATUS_ADDR, 1, &status, true);
+
+	if (status & LIS2DW12_EVENT_MASK) {
+		if ((cdata->sensors[LIS2DW12_TAP].enabled) &&
+			(status & LIS2DW12_SINGLE_TAP_MASK)) {
+			cdata->sensors[LIS2DW12_TAP].timestamp = cdata->timestamp;
+			lis2dw12_report_single_event(&cdata->sensors[LIS2DW12_TAP], 1);
+		}
+
+		if ((cdata->sensors[LIS2DW12_DOUBLE_TAP].enabled) &&
+			(status & LIS2DW12_DOUBLE_TAP_MASK)) {
+			cdata->sensors[LIS2DW12_DOUBLE_TAP].timestamp = cdata->timestamp;
+			lis2dw12_report_single_event(&cdata->sensors[LIS2DW12_DOUBLE_TAP], 1);
+		}
+
+		if ((cdata->sensors[LIS2DW12_FF].enabled) &&
+			(status & LIS2DW12_FF_IA_MASK)) {
+			cdata->sensors[LIS2DW12_FF].timestamp = cdata->timestamp;
+			lis2dw12_report_single_event(&cdata->sensors[LIS2DW12_FF], 1);
+		}
+
+		if ((cdata->sensors[LIS2DW12_WAKEUP].enabled) &&
+			(status & LIS2DW12_WAKE_UP_IA_MASK)) {
+			cdata->sensors[LIS2DW12_WAKEUP].timestamp = cdata->timestamp;
+			lis2dw12_report_single_event(&cdata->sensors[LIS2DW12_WAKEUP], 1);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis2dw12_save_timestamp(int irq, void *private)
+{
+	struct lis2dw12_data *cdata = (struct lis2dw12_data *)private;
+
+	cdata->timestamp = lis2dw12_get_time_ns();
+
+	return IRQ_WAKE_THREAD;
+}
+
+static int lis2dw12_update_hw_odr(struct lis2dw12_sensor_data *sdata, int odr)
+{
+	int err, i;
+	struct lis2dw12_data *cdata = sdata->cdata;
+	u8 num_aval;
+
+	/* odr num. may differs for LP and HR mode */
+	num_aval = (cdata->power_mode == LIS2DW12_LP_MODE) ?
+			LIS2DW12_ODR_LP_LIST_NUM : LIS2DW12_ODR_HR_LIST_NUM;
+
+	for (i = 0; i < num_aval; i++) {
+		if (lis2dw12_odr_table.odr_avl[cdata->power_mode][i].hz >= odr)
+			break;
+	}
+
+	if (i == num_aval)
+		return -EINVAL;
+
+	if (sdata->c_odr == lis2dw12_odr_table.odr_avl[cdata->power_mode][i].hz)
+		return 0;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata,
+					  LIS2DW12_CTRL1_ADDR,
+					  LIS2DW12_ODR_MASK,
+					  lis2dw12_odr_table.odr_avl[cdata->power_mode][i].value,
+					  true);
+	if (err < 0)
+		return err;
+
+	sdata->c_odr = lis2dw12_odr_table.odr_avl[cdata->power_mode][i].hz;
+
+	return 0;
+}
+
+static int lis2dw12_configure_tap_event(struct lis2dw12_sensor_data *sdata,
+				      bool single_tap)
+{
+	u8 err = 0;
+
+	if (single_tap) {
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+						  LIS2DW12_INT_DUR_ADDR,
+						  LIS2DW12_INT_DUR_MASK,
+						  LIS2DW12_INT_DUR_STAP_DEFAULT,
+						  true);
+		if (err < 0)
+			return err;
+
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+						  LIS2DW12_WAKE_UP_THS_ADDR,
+						  LIS2DW12_WAKE_UP_THS_S_D_TAP_MASK,
+						  LIS2DW12_DIS_BIT, true);
+		if (err < 0)
+			return err;
+	} else {
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+						  LIS2DW12_INT_DUR_ADDR,
+						  LIS2DW12_INT_DUR_MASK,
+						  LIS2DW12_INT_DUR_DTAP_DEFAULT,
+						  true);
+		if (err < 0)
+			return err;
+
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+						  LIS2DW12_WAKE_UP_THS_ADDR,
+						  LIS2DW12_WAKE_UP_THS_S_D_TAP_MASK,
+						  LIS2DW12_EN_BIT, true);
+		if (err < 0)
+			return err;
+	}
+
+	return err;
+}
+
+static int _lis2dw12_enable_sensors(struct lis2dw12_sensor_data *sdata)
+{
+	int err = 0, i;
+	struct lis2dw12_data *cdata = sdata->cdata;
+	u8 num_aval;
+	int64_t newTime;
+
+	err = lis2dw12_update_drdy_irq(sdata);
+	if (err < 0)
+		return err;
+
+	switch (sdata->sindex) {
+	case LIS2DW12_ACCEL:
+		num_aval = (cdata->power_mode == LIS2DW12_LP_MODE) ?
+			LIS2DW12_ODR_LP_LIST_NUM : LIS2DW12_ODR_HR_LIST_NUM;
+
+		for (i = 0; i < num_aval; i++) {
+			if (lis2dw12_odr_table.odr_avl[cdata->power_mode][i].hz >= sdata->c_odr)
+				break;
+		}
+
+		if (i == num_aval)
+			return -EINVAL;
+
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+						LIS2DW12_CTRL1_ADDR,
+						LIS2DW12_ODR_MASK,
+						lis2dw12_odr_table.odr_avl[cdata->power_mode][i].value,
+						true);
+		if (err < 0)
+			return err;
+
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+						LIS2DW12_CTRL1_ADDR,
+						LIS2DW12_POWER_MODE_MASK,
+						cdata->power_mode,
+						true);
+		if (err < 0)
+			return err;
+
+		sdata->c_odr = lis2dw12_odr_table.odr_avl[cdata->power_mode][i].hz;
+		newTime = MS_TO_NS(sdata->poll_ms);
+		sdata->oldktime = ktime_set(0, newTime);
+		hrtimer_start(&sdata->hr_timer, sdata->oldktime, HRTIMER_MODE_REL);
+		break;
+	case LIS2DW12_TAP:
+		lis2dw12_configure_tap_event(sdata, 1);
+		break;
+	case LIS2DW12_DOUBLE_TAP:
+		lis2dw12_configure_tap_event(sdata, 0);
+		break;
+	case LIS2DW12_FF:
+	case LIS2DW12_WAKEUP:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis2dw12_enable_sensors(struct lis2dw12_sensor_data *sdata)
+{
+	int err = 0;
+	
+	if (sdata->enabled)
+		return 0;
+
+	sdata->enabled = true;
+	err = _lis2dw12_enable_sensors(sdata);
+	if (err < 0)
+		sdata->enabled = false;
+
+	return err;
+}
+
+static int _lis2dw12_disable_sensors(struct lis2dw12_sensor_data *sdata)
+{
+	int err;
+
+	switch (sdata->sindex) {
+	case LIS2DW12_ACCEL:
+		err = lis2dw12_write_data_with_mask(sdata->cdata,
+					LIS2DW12_CTRL1_ADDR,
+					LIS2DW12_ODR_MASK,
+					lis2dw12_odr_table.odr_avl[sdata->cdata->power_mode][0].value,
+					true);
+		if (err < 0)
+			return err;
+
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+		break;
+	case LIS2DW12_FF:
+	case LIS2DW12_TAP:
+	case LIS2DW12_DOUBLE_TAP:
+	case LIS2DW12_WAKEUP:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lis2dw12_update_drdy_irq(sdata);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lis2dw12_disable_sensors(struct lis2dw12_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	sdata->enabled = false;
+	err = _lis2dw12_disable_sensors(sdata);
+	if (err < 0)
+		sdata->enabled = true;
+
+	return err;
+}
+
+static int lis2dw12_allocate_workqueue(struct lis2dw12_data *cdata)
+{
+	if (!lis2dw12_workqueue)
+		lis2dw12_workqueue = create_workqueue(cdata->name);
+
+	if (!lis2dw12_workqueue)
+		return -EINVAL;
+
+	return devm_request_threaded_irq(cdata->dev, cdata->irq,
+					 lis2dw12_save_timestamp,
+					 lis2dw12_thread_fn,
+					 IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					 cdata->name, cdata);
+}
+
+static int lis2dw12_init_sensors(struct lis2dw12_data *cdata)
+{
+	int err, i;
+	struct lis2dw12_sensor_data *sdata;
+
+	for (i = 0; i < LIS2DW12_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+
+		err = lis2dw12_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+
+		if (sdata->sindex == LIS2DW12_ACCEL) {
+			err = lis2dw12_set_fs(sdata, LIS2DW12_ACCEL_FS);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	hrtimer_init(&cdata->sensors[LIS2DW12_ACCEL].hr_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	cdata->sensors[LIS2DW12_ACCEL].hr_timer.function =
+					&lis2dw12_hrtimer_acc_callback;
+	cdata->selftest_status = 0;
+	err = lis2dw12_write_data_with_mask(cdata,
+					  LIS2DW12_CTRL2_ADDR,
+					  LIS2DW12_SOFT_RESET_MASK,
+					  LIS2DW12_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(cdata,
+					  LIS2DW12_CTRL1_ADDR,
+					  LIS2DW12_LP_MODE_MASK,
+					  LIS2DW12_EN_LP_MODE_02, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(cdata,
+					  LIS2DW12_CTRL3_ADDR,
+					  LIS2DW12_LIR_MASK,
+					  LIS2DW12_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(cdata,
+					  LIS2DW12_CTRL2_ADDR,
+					  LIS2DW12_BDU_MASK,
+					  LIS2DW12_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata,
+					  LIS2DW12_FREE_FALL_ADDR,
+					  LIS2DW12_FREE_FALL_THS_MASK,
+					  LIS2DW12_FREE_FALL_THS_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata,
+					  LIS2DW12_FREE_FALL_ADDR,
+					  LIS2DW12_FREE_FALL_DUR_MASK,
+					  LIS2DW12_FREE_FALL_DUR_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata,
+					  LIS2DW12_TAP_THS_Z_ADDR,
+					  LIS2DW12_TAP_AXIS_MASK,
+					  LIS2DW12_TAP_AXIS_ANABLE_ALL, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata,
+					  LIS2DW12_TAP_THS_X_ADDR,
+					  LIS2DW12_TAP_THS_MASK,
+					  LIS2DW12_TAP_THS_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_write_data_with_mask(sdata->cdata,
+					  LIS2DW12_WAKE_UP_THS_ADDR,
+					  LIS2DW12_WAKE_UP_THS_WU_MASK,
+					  LIS2DW12_WAKE_UP_THS_WU_DEFAULT, true);
+	if (err < 0)
+		return err;
+
+	cdata->sensors[LIS2DW12_ACCEL].oldktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LIS2DW12_ACCEL].poll_ms));
+	INIT_WORK(&cdata->sensors[LIS2DW12_ACCEL].input_work,
+		  lis2dw12_acc_poll_function_work);
+
+	return 0;
+}
+
+static ssize_t lis2dw12_get_enable(struct device *dev,
+							struct device_attribute *attr, char *buf)
+{
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t lis2dw12_set_enable(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (kstrtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		lis2dw12_enable_sensors(sdata);
+	else
+		lis2dw12_disable_sensors(sdata);
+
+	return count;
+}
+
+static ssize_t lis2dw12_get_resolution_mode(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%s\n", 
+		(sdata->cdata->power_mode == LIS2DW12_LP_MODE) ? "low" : "high");
+}
+
+static ssize_t lis2dw12_set_resolution_mode(struct device *dev,
+					  struct device_attribute *attr, const char *buf,
+					  size_t count)
+{
+	int i;
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LIS2DW12_FS_LIST_NUM; i++) {
+		if (sdata->c_gain ==
+			lis2dw12_fs_table.fs_avl[i].gain[sdata->cdata->power_mode])
+			break;
+	}
+
+	if (!strncmp(buf, "low", count - 1))
+		sdata->cdata->power_mode = LIS2DW12_LP_MODE;
+	else if (!strncmp(buf, "high", count - 1))
+		sdata->cdata->power_mode = LIS2DW12_HR_MODE;
+	else
+		return -EINVAL;
+
+	sdata->c_gain = lis2dw12_fs_table.fs_avl[i].gain[sdata->cdata->power_mode];
+
+	return count;
+}
+
+static ssize_t lis2dw12_get_polling_rate(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", 1000 / sdata->c_odr);
+}
+
+static ssize_t lis2dw12_set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+	int64_t newTime;
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	err = lis2dw12_update_hw_odr(sdata, 1000 / polling_rate);
+	if (err < 0)
+		goto err_poll;
+
+	sdata->poll_ms = polling_rate;
+	newTime = MS_TO_NS(1000 / sdata->c_odr);
+	sdata->oldktime = ktime_set(0, newTime);
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return count;
+
+err_poll:
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return err;
+}
+
+static ssize_t lis2dw12_get_scale_avail(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LIS2DW12_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lis2dw12_fs_table.fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t lis2dw12_get_cur_scale(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LIS2DW12_FS_LIST_NUM; i++)
+		if (sdata->c_gain ==
+			lis2dw12_fs_table.fs_avl[i].gain[sdata->cdata->power_mode])
+			break;
+
+	return sprintf(buf, "%d\n", lis2dw12_fs_table.fs_avl[i].urv);
+}
+
+static ssize_t lis2dw12_set_cur_scale(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	int urv, err;
+	struct lis2dw12_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	err = lis2dw12_set_fs(sdata, urv);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+static DEVICE_ATTR(enable,
+		   S_IWUSR | S_IRUGO,
+		   lis2dw12_get_enable,
+		   lis2dw12_set_enable);
+
+static DEVICE_ATTR(resolution,
+		   S_IWUSR | S_IRUGO,
+		   lis2dw12_get_resolution_mode,
+		   lis2dw12_set_resolution_mode);
+
+static DEVICE_ATTR(polling_rate,
+		   S_IWUSR | S_IRUGO,
+		   lis2dw12_get_polling_rate,
+		   lis2dw12_set_polling_rate);
+
+static DEVICE_ATTR(scale_avail,
+		   S_IRUGO,
+		   lis2dw12_get_scale_avail,
+		   NULL);
+
+static DEVICE_ATTR(scale,
+		   S_IWUSR | S_IRUGO,
+		   lis2dw12_get_cur_scale,
+		   lis2dw12_set_cur_scale);
+
+static struct attribute *lis2dw12_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_resolution.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lis2dw12_step_ff_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2dw12_tap_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2dw12_double_tap_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lis2dw12_wakeup_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lis2dw12_attribute_groups[] = {
+	[LIS2DW12_ACCEL] = {
+		.attrs = lis2dw12_accel_attribute,
+		.name = "accel",
+	},
+	[LIS2DW12_FF] = {
+		.attrs = lis2dw12_step_ff_attribute,
+		.name = "free_fall",
+	},
+	[LIS2DW12_TAP] = {
+		.name = "tap",
+		.attrs = lis2dw12_tap_attribute,
+	},
+	[LIS2DW12_DOUBLE_TAP] = {
+		.name = "double_tap",
+		.attrs = lis2dw12_double_tap_attribute,
+	},
+	[LIS2DW12_WAKEUP] = {
+		.name = "wake_up",
+		.attrs = lis2dw12_wakeup_attribute,
+	},
+};
+
+#ifdef CONFIG_OF
+static u32 lis2dw12_parse_dt(struct lis2dw12_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+	    (val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	return 0;
+}
+#endif /* CONFIG_OF */
+
+int lis2dw12_common_probe(struct lis2dw12_data *cdata, int irq, u16 bustype)
+{
+	int32_t err, i;
+	u8 wai = 0;
+	struct lis2dw12_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->tb.buf_lock);
+
+	err = cdata->tf->read(cdata, LIS2DW12_WHO_AM_I_ADDR, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		return err;
+	}
+	if (wai != LIS2DW12_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+
+	if (irq > 0) {
+#ifdef CONFIG_OF
+		err = lis2dw12_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lis2dw12_platform_data *)
+				cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) || (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else {
+			cdata->drdy_int_pin = 1;
+		}
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+			 cdata->drdy_int_pin);
+	}
+
+	cdata->power_mode = LIS2DW12_LP_MODE;
+
+	for (i = 0; i < LIS2DW12_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lis2dw12_sensor_name[i].name;
+
+		if (i == LIS2DW12_ACCEL) {
+			sdata->c_odr = lis2dw12_odr_table.odr_avl[cdata->power_mode][1].hz;
+			sdata->poll_ms = 1000 / sdata->c_odr;
+		}
+
+		lis2dw12_input_init(sdata, bustype);
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+				       &lis2dw12_attribute_groups[i])) {
+			dev_err(cdata->dev, "failed to create sysfs group for sensor %s",
+					sdata->name);
+
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+	}
+
+	err = lis2dw12_init_sensors(cdata);
+	if (err < 0)
+		return err;
+
+	if (irq > 0) {
+		cdata->irq = irq;
+
+		err = lis2dw12_allocate_workqueue(cdata);
+		if (err)
+			return err;
+	}
+
+	dev_info(cdata->dev, "%s: probed\n", LIS2DW12_DEV_NAME);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2dw12_common_probe);
+
+void lis2dw12_common_remove(struct lis2dw12_data *cdata, int irq)
+{
+	u8 i;
+
+	for (i = 0; i < LIS2DW12_SENSORS_NUMB; i++) {
+		lis2dw12_disable_sensors(&cdata->sensors[i]);
+		lis2dw12_input_cleanup(&cdata->sensors[i]);
+	}
+
+	if(lis2dw12_workqueue) {
+		flush_workqueue(lis2dw12_workqueue);
+		destroy_workqueue(lis2dw12_workqueue);
+		lis2dw12_workqueue = NULL;
+	}
+}
+EXPORT_SYMBOL(lis2dw12_common_remove);
+
+#ifdef CONFIG_PM
+static int lis2dw12_resume_sensors(struct lis2dw12_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lis2dw12_enable_sensors(sdata);
+}
+EXPORT_SYMBOL(lis2dw12_resume_sensors);
+
+static int lis2dw12_suspend_sensors(struct lis2dw12_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lis2dw12_disable_sensors(sdata);
+}
+EXPORT_SYMBOL(lis2dw12_suspend_sensors);
+
+int lis2dw12_common_suspend(struct lis2dw12_data *cdata)
+{
+	lis2dw12_suspend_sensors(&cdata->sensors[LIS2DW12_ACCEL]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2dw12_common_suspend);
+
+int lis2dw12_common_resume(struct lis2dw12_data *cdata)
+{
+	lis2dw12_resume_sensors(&cdata->sensors[LIS2DW12_ACCEL]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2dw12_common_resume);
+
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics lis2dw12 driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.h b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.h
--- a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_core.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,128 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lis2dw12_core.h
+* Authors            : AMG - Application Team
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.0
+* Date               : 2016/Oct/18
+* Description        : LIS2DW12 driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#ifndef DRIVERS_INPUT_MISC_LIS2DW12_CORE_H_
+#define DRIVERS_INPUT_MISC_LIS2DW12_CORE_H_
+
+#define LIS2DW12_DEV_NAME		"lis2dw12"
+
+#define HZ_TO_PERIOD_NSEC(hz)	(1000 * 1000 * 1000 / ((u32)(hz)))
+#define MS_TO_US(x)		({ typeof(x) _x = (x); ((_x) * \
+				 ((typeof(x)) 1000));})
+#define US_TO_NS(x)		(MS_TO_US(x))
+#define MS_TO_NS(x)		(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)		({ typeof(x) _x = (x); ((_x) / \
+				 ((typeof(x)) 1000));})
+#define NS_TO_US(x)		(US_TO_MS(x))
+#define NS_TO_MS(x)		(US_TO_MS(NS_TO_US(x)))
+
+enum {
+	LIS2DW12_ACCEL = 0,
+	LIS2DW12_FF,
+	LIS2DW12_TAP,
+	LIS2DW12_DOUBLE_TAP,
+	LIS2DW12_WAKEUP,
+	LIS2DW12_SENSORS_NUMB,
+};
+
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+#define LIS2DW12_RX_MAX_LENGTH	16
+#define LIS2DW12_TX_MAX_LENGTH	16
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lis2dw12_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LIS2DW12_RX_MAX_LENGTH];
+	u8 tx_buf[LIS2DW12_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lis2dw12_data;
+
+struct lis2dw12_transfer_function {
+	int (*write)(struct lis2dw12_data *cdata, u8 reg_addr,
+		     int len, u8 *data, bool b_lock);
+	int (*read)(struct lis2dw12_data *cdata, u8 reg_addr, int len, u8 *data,
+		    bool b_lock);
+};
+
+struct lis2dw12_sensor_data {
+	struct lis2dw12_data *cdata;
+	const char* name;
+	s64 timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	unsigned int poll_ms;
+	struct input_dev *input_dev;
+	struct hrtimer hr_timer;
+	struct work_struct input_work;
+	ktime_t oldktime;
+};
+
+struct lis2dw12_data {
+	const char *name;
+	u8 drdy_int_pin;
+	u8 selftest_status;
+	u8 power_mode;
+	int irq;
+	s64 timestamp;
+	struct device *dev;
+	struct lis2dw12_sensor_data sensors[LIS2DW12_SENSORS_NUMB];
+	struct mutex bank_registers_lock;
+	const struct lis2dw12_transfer_function *tf;
+	struct lis2dw12_transfer_buffer tb;
+};
+
+int lis2dw12_common_probe(struct lis2dw12_data *cdata, int irq, u16 bustype);
+void lis2dw12_common_remove(struct lis2dw12_data *cdata, int irq);
+
+#ifdef CONFIG_PM
+int lis2dw12_common_suspend(struct lis2dw12_data *cdata);
+int lis2dw12_common_resume(struct lis2dw12_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* DRIVERS_INPUT_MISC_LIS2DW12_CORE_H_ */
diff -uNr a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_i2c.c b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_i2c.c
--- a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,189 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lis2dw12_i2c.c
+* Authors            : AMG - Application Team
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.0
+* Date               : 2016/Oct/18
+* Description        : LIS2DW12 driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lis2dw12_core.h"
+
+static int lis2dw12_i2c_read(struct lis2dw12_data *cdata, u8 reg_addr, int len,
+			   u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else {
+		err = i2c_transfer(client->adapter, msg, 2);
+	}
+
+	return err;
+}
+
+static int lis2dw12_i2c_write(struct lis2dw12_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else {
+		err = i2c_transfer(client->adapter, &msg, 1);
+	}
+
+	return err;
+}
+
+static const struct lis2dw12_transfer_function lis2dw12_tf_i2c = {
+	.write = lis2dw12_i2c_write,
+	.read = lis2dw12_i2c_read,
+};
+
+static int lis2dw12_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct lis2dw12_data *cdata;
+
+	cdata = devm_kzalloc(&client->dev, sizeof(struct lis2dw12_data),
+			     GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &lis2dw12_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = lis2dw12_common_probe(cdata, client->irq, BUS_I2C);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lis2dw12_i2c_remove(struct i2c_client *client)
+{
+	struct lis2dw12_data *cdata = i2c_get_clientdata(client);
+
+	lis2dw12_common_remove(cdata, client->irq);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2dw12_suspend(struct device *dev)
+{
+	struct lis2dw12_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2dw12_common_suspend(cdata);
+}
+
+static int lis2dw12_resume(struct device *dev)
+{
+	struct lis2dw12_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2dw12_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lis2dw12_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2dw12_suspend, lis2dw12_resume)
+};
+
+#define LIS2DW12_PM_OPS	(&lis2dw12_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DW12_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+
+static const struct i2c_device_id lis2dw12_ids[] = {
+	{ LIS2DW12_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis2dw12_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2dw12_id_table[] = {
+	{ .compatible = "st,lis2dw12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2dw12_id_table);
+#endif
+
+static struct i2c_driver lis2dw12_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DW12_DEV_NAME,
+		.pm = LIS2DW12_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lis2dw12_id_table,
+#endif
+	},
+	.probe    = lis2dw12_i2c_probe,
+	.remove   = lis2dw12_i2c_remove,
+	.id_table = lis2dw12_ids,
+};
+
+module_i2c_driver(lis2dw12_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2dw12 i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_spi.c b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_spi.c
--- a/drivers/input/misc/st/acc/lis2dw12/lis2dw12_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dw12/lis2dw12_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,209 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lis2dw12_spi.c
+* Authors            : AMG - Application Team
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+*		     : point for the driver.
+* Version            : V.1.0
+* Date               : 2016/Oct/18
+* Description        : LIS2DW12 driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lis2dw12_core.h"
+
+#define SENSORS_SPI_READ	0x80
+
+static int lis2dw12_spi_read(struct lis2dw12_data *cdata, u8 reg_addr, int len,
+			   u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lis2dw12_spi_write(struct lis2dw12_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LIS2DW12_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+
+static const struct lis2dw12_transfer_function lis2dw12_tf_spi = {
+	.write = lis2dw12_spi_write,
+	.read = lis2dw12_spi_read,
+};
+
+static int lis2dw12_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis2dw12_data *cdata;
+
+	cdata = devm_kzalloc(&spi->dev, sizeof(struct lis2dw12_data), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &lis2dw12_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = lis2dw12_common_probe(cdata, spi->irq, BUS_SPI);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lis2dw12_spi_remove(struct spi_device *spi)
+{
+	struct lis2dw12_data *cdata = spi_get_drvdata(spi);
+
+	lis2dw12_common_remove(cdata, spi->irq);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2dw12_suspend(struct device *dev)
+{
+	struct lis2dw12_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2dw12_common_suspend(cdata);
+}
+
+static int lis2dw12_resume(struct device *dev)
+{
+	struct lis2dw12_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2dw12_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lis2dw12_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2dw12_suspend, lis2dw12_resume)
+};
+
+#define LIS2DW12_PM_OPS		(&lis2dw12_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2DW12_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct spi_device_id lis2dw12_ids[] = {
+	{ LIS2DW12_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis2dw12_ids);
+
+static const struct of_device_id lis2dw12_id_table[] = {
+	{ .compatible = "st,lis2dw12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2dw12_id_table);
+#endif
+
+static struct spi_driver lis2dw12_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2DW12_DEV_NAME,
+		.pm = LIS2DW12_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lis2dw12_id_table,
+#endif
+	},
+	.probe    = lis2dw12_spi_probe,
+	.remove   = lis2dw12_spi_remove,
+	.id_table = lis2dw12_ids,
+};
+
+module_spi_driver(lis2dw12_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2dw12 spi driver");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2dw12/Makefile b/drivers/input/misc/st/acc/lis2dw12/Makefile
--- a/drivers/input/misc/st/acc/lis2dw12/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2dw12/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis2dw12 driver
+#
+lis2dw12-core-y += lis2dw12_core.o
+obj-$(CONFIG_INPUT_LIS2DW12) += lis2dw12-core.o
+obj-$(CONFIG_INPUT_LIS2DW12_I2C) += lis2dw12_i2c.o
+obj-$(CONFIG_INPUT_LIS2DW12_SPI) += lis2dw12_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis2hh12/Kconfig b/drivers/input/misc/st/acc/lis2hh12/Kconfig
--- a/drivers/input/misc/st/acc/lis2hh12/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2hh12/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS2HH12
+	tristate "STMicroelectronics LIS2HH12 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS2HH12_I2C if (I2C)
+	select INPUT_LIS2HH12_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS2HH12 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis2hh12.
+
+config INPUT_LIS2HH12_I2C
+	tristate
+	depends on INPUT_LIS2HH12
+	depends on I2C
+
+config INPUT_LIS2HH12_SPI
+	tristate
+	depends on INPUT_LIS2HH12
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis2hh12/lis2hh12_core.c b/drivers/input/misc/st/acc/lis2hh12/lis2hh12_core.c
--- a/drivers/input/misc/st/acc/lis2hh12/lis2hh12_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2hh12/lis2hh12_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1383 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics ********************
+ *
+ * File Name          : lis2hh12_core.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Mario Tesi (mario.tesi@st.com)
+ *		      : Both authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.1.1
+ * Date               : 2016/May/5
+ * Description        : LIS2HH12 accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ ******************************************************************************
+ Revision 1.0.0 25/Feb/2013
+  first revision
+  supports sysfs;
+ Revision 1.1.0 28/Mar/2013
+  introduces hr_timers for polling;
+ Revision 1.1.1 05/May/2016
+  introduces spi device;
+ ******************************************************************************/
+
+#include	<linux/err.h>
+#include	<linux/errno.h>
+#include	<linux/delay.h>
+#include	<linux/fs.h>
+#include	<linux/input.h>
+#include	<linux/uaccess.h>
+#include	<linux/workqueue.h>
+#include	<linux/irq.h>
+#include	<linux/gpio.h>
+#include	<linux/interrupt.h>
+#include	<linux/slab.h>
+#include	<linux/kernel.h>
+#include	<linux/device.h>
+#include	<linux/module.h>
+#include	<linux/moduleparam.h>
+#include	<linux/version.h>
+
+#include	"lis2hh12.h"
+
+//#define DEBUG		1
+
+#define G_MAX			7995148 /* (SENSITIVITY_8G*(2^15-1)) */
+#define G_MIN			- 7995392 /* (-SENSITIVITY_8G*(2^15)   */
+#define FUZZ			0
+#define FLAT			0
+
+#define MS_TO_NS(x)		(x*1000000L)
+
+#define SENSITIVITY_2G		 61	/**	ug/LSB	*/
+#define SENSITIVITY_4G		122	/**	ug/LSB	*/
+#define SENSITIVITY_8G		244	/**	ug/LSB	*/
+
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS2HH12_ACC_ENABLE	(0x01)
+#define LIS2HH12_ACC_DISABLE	(0x00)
+
+#define AXISDATA_REG		(0x28)
+#define WHOAMI_LIS2HH12_ACC	(0x41)	/*	Expctd content for WAI	*/
+#define ALL_ZEROES		(0x00)
+#define LIS2HH12_ACC_PM_OFF	(0x00)
+#define ACC_ENABLE_ALL_AXES	(0x07)
+
+/*	CONTROL REGISTERS	*/
+#define TEMP_L			(0x0B)
+#define TEMP_H			(0x0C)
+#define WHO_AM_I		(0x0F)	/*	WhoAmI register		*/
+#define ACT_THS			(0x1E)	/*	Activity Threshold	*/
+#define ACT_DUR			(0x1F)	/*	Activity Duration	*/
+/* ctrl 1: HR ODR2 ODR1 ODR0 BDU Zenable Yenable Xenable */
+#define CTRL1			(0x20)	/*	control reg 1		*/
+#define CTRL2			(0x21)	/*	control reg 2		*/
+#define CTRL3			(0x22)	/*	control reg 3		*/
+#define CTRL4			(0x23)	/*	control reg 4		*/
+#define CTRL5			(0x24)	/*	control reg 5		*/
+#define CTRL6			(0x25)	/*	control reg 6		*/
+#define CTRL7			(0x26)	/*	control reg 7		*/
+
+#define FIFO_CTRL		(0x2E)	/*	fifo control reg	*/
+
+#define INT_CFG1		(0x30)	/*	interrupt 1 config	*/
+#define INT_SRC1		(0x31)	/*	interrupt 1 source	*/
+#define INT_THSX1		(0x32)	/*	interrupt 1 threshold x	*/
+#define INT_THSY1		(0x33)	/*	interrupt 1 threshold y	*/
+#define INT_THSZ1		(0x34)	/*	interrupt 1 threshold z	*/
+#define INT_DUR1		(0x35)	/*	interrupt 1 duration	*/
+
+#define INT_CFG2		(0x36)	/*	interrupt 2 config	*/
+#define INT_SRC2		(0x37)	/*	interrupt 2 source	*/
+#define INT_THS2		(0x38)	/*	interrupt 2 threshold	*/
+#define INT_DUR2		(0x39)	/*	interrupt 2 duration	*/
+
+#define REF_XL			(0x3A)	/*	reference_l_x		*/
+#define REF_XH			(0x3B)	/*	reference_h_x		*/
+#define REF_YL			(0x3C)	/*	reference_l_y		*/
+#define REF_YH			(0x3D)	/*	reference_h_y		*/
+#define REF_ZL			(0x3E)	/*	reference_l_z		*/
+#define REF_ZH			(0x3F)	/*	reference_h_z		*/
+/*	end CONTROL REGISTRES	*/
+
+
+
+#define ACC_ODR10		(0x10)	/*   10Hz output data rate */
+#define ACC_ODR50		(0x20)	/*   50Hz output data rate */
+#define ACC_ODR100		(0x30)	/*  100Hz output data rate */
+#define ACC_ODR200		(0x40)	/*  200Hz output data rate */
+#define ACC_ODR400		(0x50)	/*  400Hz output data rate */
+#define ACC_ODR800		(0x60)	/*  800Hz output data rate */
+#define ACC_ODR_MASK		(0X70)
+
+/* Registers configuration Mask and settings */
+/* CTRL1 */
+#define CTRL1_HR_DISABLE	(0x00)
+#define CTRL1_HR_ENABLE		(0x80)
+#define CTRL1_HR_MASK		(0x80)
+#define CTRL1_BDU_ENABLE	(0x08)
+#define CTRL1_BDU_MASK		(0x08)
+
+/* CTRL2 */
+#define CTRL2_IG1_INT1		(0x08)
+
+/* CTRL3 */
+#define CTRL3_IG1_INT1		(0x08)
+#define CTRL3_DRDY_INT1
+
+/* CTRL4 */
+#define CTRL4_IF_ADD_INC_EN	(0x04)
+#define CTRL4_BW_SCALE_ODR_AUT	(0x00)
+#define CTRL4_BW_SCALE_ODR_SEL	(0x08)
+#define CTRL4_ANTALIAS_BW_400	(0x00)
+#define CTRL4_ANTALIAS_BW_200	(0x40)
+#define CTRL4_ANTALIAS_BW_100	(0x80)
+#define CTRL4_ANTALIAS_BW_50	(0xC0)
+#define CTRL4_ANTALIAS_BW_MASK	(0xC0)
+
+/* CTRL5 */
+#define CTRL5_HLACTIVE_L	(0x02)
+#define CTRL5_HLACTIVE_H	(0x00)
+
+/* CTRL6 */
+#define CTRL6_IG2_INT2		(0x10)
+#define CTRL6_DRDY_INT2		(0x01)
+
+/* CTRL7 */
+#define CTRL7_LIR2		(0x08)
+#define CTRL7_LIR1		(0x04)
+/* */
+
+#define NO_MASK			(0xFF)
+
+#define INT1_DURATION_MASK	(0x7F)
+#define INT1_THRESHOLD_MASK	(0x7F)
+
+
+
+/* RESUME STATE INDICES */
+#define RES_CTRL1		0
+#define RES_CTRL2		1
+#define RES_CTRL3		2
+#define RES_CTRL4		3
+#define RES_CTRL5		4
+#define RES_CTRL6		5
+#define RES_CTRL7		6
+
+#define RES_INT_CFG1		7
+#define RES_INT_THSX1		8
+#define RES_INT_THSY1		9
+#define RES_INT_THSZ1		10
+#define RES_INT_DUR1		11
+
+
+#define RES_INT_CFG2		12
+#define RES_INT_THS2		13
+#define RES_INT_DUR2		14
+
+#define RES_TEMP_CFG_REG	15
+#define RES_REFERENCE_REG	16
+#define RES_FIFO_CTRL		17
+
+/* end RESUME STATE INDICES */
+
+#define OUTPUT_ALWAYS_ANTI_ALIASED 1
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis2hh12_acc_odr_table[] = {
+		{   2, ACC_ODR800 },
+		{   3, ACC_ODR400 },
+		{   5, ACC_ODR200 },
+		{  10, ACC_ODR100 },
+#if(!OUTPUT_ALWAYS_ANTI_ALIASED)
+		{  20, ACC_ODR50  },
+		{ 100, ACC_ODR10  },
+#endif
+};
+
+static inline int64_t lis2hh12_acc_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int int1_gpio = LIS2HH12_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LIS2HH12_ACC_DEFAULT_INT2_GPIO;
+
+static struct lis2hh12_platform_data default_lis2hh12_acc_pdata = {
+	.fs_range = LIS2HH12_ACC_FS_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS2HH12_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS2HH12_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS2HH12_ACC_DEFAULT_INT2_GPIO,
+};
+
+/* sets default init values to be written in registers at probe stage */
+static void lis2hh12_acc_set_init_register_values(struct lis2hh12_status *stat)
+{
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL1] = (ALL_ZEROES | \
+					 CTRL1_HR_DISABLE | \
+					 CTRL1_BDU_ENABLE | \
+					 ACC_ENABLE_ALL_AXES);
+
+	if(stat->pdata->gpio_int1 >= 0)
+		stat->resume_state[RES_CTRL3] =
+			(stat->resume_state[RES_CTRL3] | \
+			 CTRL3_IG1_INT1);
+
+	stat->resume_state[RES_CTRL4] = (ALL_ZEROES | \
+					 CTRL4_IF_ADD_INC_EN);
+
+	stat->resume_state[RES_CTRL5] = (ALL_ZEROES | \
+					 CTRL5_HLACTIVE_H);
+
+	if(stat->pdata->gpio_int2 >= 0)
+		stat->resume_state[RES_CTRL6] =
+			(stat->resume_state[RES_CTRL6] | \
+			 CTRL6_IG2_INT2);
+
+	stat->resume_state[RES_CTRL7] = (ALL_ZEROES | \
+					 CTRL7_LIR2 | CTRL7_LIR1);
+}
+
+static int lis2hh12_acc_hw_init(struct lis2hh12_status *stat)
+{
+	int err = -1;
+	u8 buf[7];
+
+	pr_info("%s: hw init start\n", LIS2HH12_ACC_DEV_NAME);
+
+	err = stat->tf->read(stat, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I:"
+			 " is device available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+
+	if (buf[0] != WHOAMI_LIS2HH12_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n",
+			WHOAMI_LIS2HH12_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL];
+	err = stat->tf->write(stat, FIFO_CTRL, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THSX1];
+	buf[1] = stat->resume_state[RES_INT_THSY1];
+	buf[2] = stat->resume_state[RES_INT_THSZ1];
+	buf[3] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat, INT_THSX1, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL2];
+	buf[1] = stat->resume_state[RES_CTRL3];
+	buf[2] = stat->resume_state[RES_CTRL4];
+	buf[3] = stat->resume_state[RES_CTRL5];
+	buf[4] = stat->resume_state[RES_CTRL6];
+	buf[5] = stat->resume_state[RES_CTRL7];
+	err = stat->tf->write(stat, CTRL2, 6, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL1];
+	err = stat->tf->write(stat, CTRL1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LIS2HH12_ACC_DEV_NAME);
+
+	return 0;
+
+err_firstread:
+	stat->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+		buf[1], err);
+
+	return err;
+}
+
+static void lis2hh12_acc_device_power_off(struct lis2hh12_status *stat)
+{
+	int err;
+	u8 buf = LIS2HH12_ACC_PM_OFF;
+
+	err = stat->tf->write(stat, CTRL1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->hw_initialized = 0;
+	}
+}
+
+static int lis2hh12_acc_device_power_on(struct lis2hh12_status *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	if (!stat->hw_initialized) {
+		err = lis2hh12_acc_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lis2hh12_acc_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	return 0;
+}
+
+static int lis2hh12_acc_update_fs_range(struct lis2hh12_status *stat,
+					u8 new_fs_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+
+	switch (new_fs_range) {
+	case LIS2HH12_ACC_FS_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LIS2HH12_ACC_FS_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LIS2HH12_ACC_FS_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4,
+	* which contains fs range setting */
+	err = stat->tf->read(stat, CTRL4, 1, &init_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL4] = init_val;
+	new_val = new_fs_range;
+	updated_val = ((LIS2HH12_ACC_FS_MASK & new_val) |
+		       ((~LIS2HH12_ACC_FS_MASK) & init_val));
+	err = stat->tf->write(stat, CTRL4, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL4] = updated_val;
+	stat->sensitivity = sensitivity;
+
+	return err;
+
+error:
+	dev_err(stat->dev,
+		"update fs range failed 0x%02x,0x%02x: %d\n",
+		CTRL4, updated_val, err);
+
+	return err;
+}
+
+static int lis2hh12_acc_update_odr(struct lis2hh12_status *stat,
+				   int poll_interval_ms)
+{
+	int err;
+	int i;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis2hh12_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lis2hh12_acc_odr_table[i].cutoff_ms <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+	new_val = lis2hh12_acc_odr_table[i].mask;
+
+	/* Updates configuration register 1,
+	* which contains odr range setting if enabled,
+	* otherwise updates RES_CTRL1 for when it will */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->read(stat, CTRL1, 1, &init_val);
+		if (err < 0)
+			goto error;
+
+		stat->resume_state[RES_CTRL1] = init_val;
+		updated_val = ((ACC_ODR_MASK & new_val) |
+			       ((~ACC_ODR_MASK) & init_val));
+		err = stat->tf->write(stat, CTRL1, 1, &updated_val);
+		if (err < 0)
+			goto error;
+
+		stat->resume_state[RES_CTRL1] = updated_val;
+
+		return err;
+	} else {
+		init_val = stat->resume_state[RES_CTRL1];
+		updated_val = ((ACC_ODR_MASK & new_val) |
+			       ((~ACC_ODR_MASK) & init_val));
+		stat->resume_state[RES_CTRL1] = updated_val;
+
+		return 0;
+	}
+
+error:
+	dev_err(stat->dev,
+		"update odr failed 0x%02x,0x%02x: %d\n",
+		CTRL1, updated_val, err);
+
+	return err;
+}
+
+static int lis2hh12_acc_register_write(struct lis2hh12_status *stat,
+				       u8 *buf, u8 reg_address, u8 new_value)
+{
+	u8 val = new_value;
+
+	return stat->tf->write(stat, reg_address, 1, &val);
+}
+
+
+static int lis2hh12_acc_get_data(struct lis2hh12_status *stat, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s16) ((acc_data[1] << 8) | acc_data[0]));
+	hw_d[1] = ((s16) ((acc_data[3] << 8) | acc_data[2]));
+	hw_d[2] = ((s16) ((acc_data[5] << 8) | acc_data[4]));
+
+	hw_d[0] = hw_d[0] * stat->sensitivity;
+	hw_d[1] = hw_d[1] * stat->sensitivity;
+	hw_d[2] = hw_d[2] * stat->sensitivity;
+
+	xyz[0] = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+//#ifdef DEBUG
+
+	pr_info("%s read x=%d, y=%d, z=%d\n",
+		LIS2HH12_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+
+//#endif
+	return err;
+}
+
+static void lis2hh12_acc_report_values(struct lis2hh12_status *stat,
+				       int *xyz, int64_t timestamp)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(stat->input_dev);
+}
+
+static void lis2hh12_acc_report_triple(struct lis2hh12_status *stat)
+{
+	int err;
+	int xyz[3];
+
+	err = lis2hh12_acc_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_data failed\n");
+	else {
+		if (stat->sample_to_discard) {
+			stat->sample_to_discard--;
+			return;
+		}
+
+		lis2hh12_acc_report_values(stat, xyz, stat->timestamp);
+	}
+}
+
+static irqreturn_t lis2hh12_acc_isr1(int irq, void *dev)
+{
+	struct lis2hh12_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", LIS2HH12_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis2hh12_acc_isr2(int irq, void *dev)
+{
+	struct lis2hh12_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", LIS2HH12_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lis2hh12_acc_irq1_work_func(struct work_struct *work)
+{
+	struct lis2hh12_status *stat =
+
+	container_of(work, struct lis2hh12_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis2hh12_acc_get_int1_source(stat); */
+	pr_debug("%s: IRQ1 served\n", LIS2HH12_ACC_DEV_NAME);
+	enable_irq(stat->irq1);
+}
+
+static void lis2hh12_acc_irq2_work_func(struct work_struct *work)
+{
+	struct lis2hh12_status *stat =
+
+	container_of(work, struct lis2hh12_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis2hh12_acc_get_tap_source(stat); */
+	pr_debug("%s: IRQ2 served\n", LIS2HH12_ACC_DEV_NAME);
+	enable_irq(stat->irq2);
+}
+
+static int lis2hh12_acc_enable(struct lis2hh12_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = lis2hh12_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			return err;
+		}
+		/* Dischard first samples. */
+		stat->sample_to_discard = 10;
+		stat->polling_ktime = ktime_set(stat->pdata->poll_interval / 1000,
+				MS_TO_NS(stat->pdata->poll_interval % 1000));
+		hrtimer_start(&stat->hr_timer_poll,
+			      stat->polling_ktime, HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+
+static int lis2hh12_acc_disable(struct lis2hh12_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_work_sync(&stat->input_poll_work);
+		lis2hh12_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat, reg, 1, &data);
+	if (err < 0)
+		return err;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		     u8 mask, int resumeIndex)
+{
+	int err = -1;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = lis2hh12_acc_register_write(stat, x, reg, new_val);
+	if (err < 0)
+		return err;
+	stat->resume_state[resumeIndex] = new_val;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int err;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	err = lis2hh12_acc_update_odr(stat, interval_ms);
+	if (err >= 0) {
+		stat->pdata->poll_interval = interval_ms;
+		stat->polling_ktime = ktime_set(stat->pdata->poll_interval / 1000,
+				MS_TO_NS(stat->pdata->poll_interval % 1000));
+	}
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range ;
+	switch (val) {
+	case LIS2HH12_ACC_FS_2G:
+		range = 2;
+		break;
+	case LIS2HH12_ACC_FS_4G:
+		range = 4;
+		break;
+	case LIS2HH12_ACC_FS_8G:
+		range = 8;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LIS2HH12_ACC_FS_2G;
+		break;
+	case 4:
+		range = LIS2HH12_ACC_FS_4G;
+		break;
+	case 8:
+		range = LIS2HH12_ACC_FS_8G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lis2hh12_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis2hh12_acc_enable(stat);
+	else
+		lis2hh12_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_threshx1(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THSX1, INT1_THRESHOLD_MASK, RES_INT_THSX1);
+}
+
+static ssize_t attr_get_threshx1(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THSX1);
+}
+
+static ssize_t attr_set_threshy1(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THSY1, INT1_THRESHOLD_MASK, RES_INT_THSY1);
+}
+
+static ssize_t attr_get_threshy1(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THSY1);
+}
+
+static ssize_t attr_set_threshz1(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THSZ1, INT1_THRESHOLD_MASK, RES_INT_THSZ1);
+}
+
+static ssize_t attr_get_threshz1(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THSZ1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG functions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x = val;
+	rc = stat->tf->write(stat, stat->reg_addr, 1, &x);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	rc = stat->tf->read(stat, stat->reg_addr, 1, &data);
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lis2hh12_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	stat->reg_addr = val;
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_thresholdx, 0664, attr_get_threshx1, attr_set_threshx1),
+	__ATTR(int1_thresholdy, 0664, attr_get_threshy1, attr_set_threshy1),
+	__ATTR(int1_thresholdz, 0664, attr_get_threshz1, attr_set_threshz1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lis2hh12_acc_input_poll_work_func(struct work_struct *work)
+{
+	struct lis2hh12_status *stat;
+	ktime_t tmpkt, ktdelta;
+
+	stat = container_of((struct work_struct *) work,
+			    struct lis2hh12_status, input_poll_work);
+
+	if (atomic_read(&stat->enabled)) {
+		/* Adjust new timeout. */
+		ktdelta = ktime_set(0, lis2hh12_acc_get_time_ns() - stat->timestamp);
+		/* Avoid negative value in case of High ODR. */
+		if (stat->polling_ktime.tv64 > ktdelta.tv64)
+			tmpkt = ktime_sub(stat->polling_ktime, ktdelta);
+		else
+			tmpkt = stat->polling_ktime;
+
+		hrtimer_start(&stat->hr_timer_poll, tmpkt, HRTIMER_MODE_REL);
+	}
+
+	lis2hh12_acc_report_triple(stat);
+}
+
+enum hrtimer_restart lis2hh12_acc_hr_timer_poll_function(struct hrtimer *timer)
+{
+	struct lis2hh12_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+			    struct lis2hh12_status, hr_timer_poll);
+
+	stat->timestamp = lis2hh12_acc_get_time_ns();
+
+	queue_work(stat->hr_timer_poll_work_queue, &stat->input_poll_work);
+
+	return HRTIMER_NORESTART;
+}
+
+#ifdef LIS2HH_EN_OPEN
+int lis2hh12_acc_input_open(struct input_dev *input)
+{
+	struct lis2hh12_status *stat = input_get_drvdata(input);
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	return lis2hh12_acc_enable(stat);
+}
+
+void lis2hh12_acc_input_close(struct input_dev *dev)
+{
+	struct lis2hh12_status *stat = input_get_drvdata(dev);
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+	lis2hh12_acc_disable(stat);
+}
+#endif /* LIS2HH_EN_OPEN */
+
+static int lis2hh12_acc_validate_pdata(struct lis2hh12_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)LIS2HH12_ACC_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					 stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", stat->pdata->negate_x,
+			stat->pdata->negate_y, stat->pdata->negate_z);
+
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis2hh12_acc_input_init(struct lis2hh12_status *stat)
+{
+	int err;
+
+	INIT_WORK(&stat->input_poll_work, lis2hh12_acc_input_poll_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "input device allocation failed\n");
+		return err;
+	}
+
+#ifdef LIS2HH_EN_OPEN
+	stat->input_dev->open = lis2hh12_acc_input_open;
+	stat->input_dev->close = lis2hh12_acc_input_close;
+#else /* LIS2HH_EN_OPEN */
+	stat->input_dev->open = NULL;
+	stat->input_dev->close = NULL;
+#endif /* LIS2HH_EN_OPEN */
+	stat->input_dev->name = stat->name;
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	/* Set Misc event type */
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+	}
+
+	return 0;
+}
+
+static void lis2hh12_acc_input_cleanup(struct lis2hh12_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+int lis2hh12_common_probe(struct lis2hh12_status *stat)
+{
+	int err = -1;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+	mutex_lock(&stat->lock);
+
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_lis2hh12_acc_pdata.gpio_int1 = int1_gpio;
+		default_lis2hh12_acc_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_lis2hh12_acc_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+	stat->hr_timer_poll_work_queue = NULL;
+
+	err = lis2hh12_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		stat->irq1 = gpio_to_irq(stat->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, "
+			"mapped on gpio:%d\n",
+			LIS2HH12_ACC_DEV_NAME, __func__, stat->irq1,
+			stat->pdata->gpio_int1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d, "
+			"mapped on gpio:%d\n",
+			LIS2HH12_ACC_DEV_NAME, __func__, stat->irq2,
+			stat->pdata->gpio_int2);
+	}
+
+	lis2hh12_acc_set_init_register_values(stat);
+
+	err = lis2hh12_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lis2hh12_acc_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis2hh12_acc_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	stat->hr_timer_poll_work_queue = 
+			create_workqueue("lis2hh12_acc_hr_timer_poll_wq");
+	hrtimer_init(&stat->hr_timer_poll, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_poll.function = &lis2hh12_acc_hr_timer_poll_function;
+
+	err = lis2hh12_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_remove_hr_work_queue;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+		   	"device %s sysfs register failed\n",
+			LIS2HH12_ACC_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lis2hh12_acc_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&stat->irq1_work, lis2hh12_acc_irq1_work_func);
+		stat->irq1_work_queue =
+			create_singlethread_workqueue("lis2hh12_acc_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, lis2hh12_acc_isr1,
+			IRQF_TRIGGER_RISING, "lis2hh12_acc_irq1", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&stat->irq2_work, lis2hh12_acc_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("lis2hh12_acc_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, lis2hh12_acc_isr2,
+			IRQF_TRIGGER_RISING, "lis2hh12_acc_irq2", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", LIS2HH12_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if (stat->pdata->gpio_int2 >= 0)
+		destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	if (stat->pdata->gpio_int1 >= 0)
+		destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	lis2hh12_acc_input_cleanup(stat);
+err_remove_hr_work_queue:
+	if (!stat->hr_timer_poll_work_queue) {
+		flush_workqueue(stat->hr_timer_poll_work_queue);
+		destroy_workqueue(stat->hr_timer_poll_work_queue);
+		stat->hr_timer_poll_work_queue = NULL;
+	}
+err_power_off:
+	lis2hh12_acc_device_power_off(stat);
+err_pdata_init:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	pr_err("%s: Driver Init failed\n", LIS2HH12_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis2hh12_common_probe);
+
+int lis2hh12_common_remove(struct lis2hh12_status *stat)
+{
+	dev_info(stat->dev, "driver removing\n");
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lis2hh12_acc_disable(stat);
+	lis2hh12_acc_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	if (!stat->hr_timer_poll_work_queue) {
+		flush_workqueue(stat->hr_timer_poll_work_queue);
+		destroy_workqueue(stat->hr_timer_poll_work_queue);
+		stat->hr_timer_poll_work_queue = NULL;
+	}
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2hh12_common_remove);
+
+#ifdef CONFIG_PM
+int lis2hh12_common_resume(struct lis2hh12_status *stat)
+{
+	if (stat->on_before_suspend)
+		return lis2hh12_acc_enable(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2hh12_common_resume);
+
+int lis2hh12_common_suspend(struct lis2hh12_status *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	return lis2hh12_acc_disable(stat);
+}
+EXPORT_SYMBOL(lis2hh12_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis2hh12 accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno, Denis Ciocca, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2hh12/lis2hh12.h b/drivers/input/misc/st/acc/lis2hh12/lis2hh12.h
--- a/drivers/input/misc/st/acc/lis2hh12/lis2hh12.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2hh12/lis2hh12.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,173 @@
+
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2hh12.h
+* Authors	: AMS - Motion Mems Division - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Mario Tesi (mario.tesi@st.com)
+* Version	: V.1.1.1
+* Date		: 2016/May/05
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.0 25/Feb/2013
+  first revision
+  supports sysfs;
+ Revision 1.1.0 28/Mar/2013
+  introduces hr_timers for polling;
+ Revision 1.1.1 05/May/2016
+  introduces transfer function block
+*******************************************************************************/
+
+#ifndef	__LIS2HH12_H__
+#define	__LIS2HH12_H__
+
+/* Uncomment if want Enable/Disable sensor on Open/Close input device
+ * #define LIS2HH_EN_OPEN
+ */
+
+#define	LIS2HH12_ACC_DEV_NAME		"lis2hh12_acc"
+
+#define	LIS2HH12_ACC_MIN_POLL_PERIOD_MS	2
+
+#ifdef __KERNEL__
+
+#define LIS2HH12_ACC_SAD0L		0x10
+#define LIS2HH12_ACC_SAD0H		0x01
+#define LIS2HH12_ACC_I2C_SADROOT	0x07
+
+/* I2C address if acc SA0 pin to GND */
+#define LIS2HH12_ACC_I2C_SAD_L		((LIS2HH12_ACC_I2C_SADROOT<<2)| \
+					 LIS2HH12_ACC_SAD0L)
+
+/* I2C address if acc SA0 pin to Vdd */
+#define LIS2HH12_ACC_I2C_SAD_H		((LIS2HH12_ACC_I2C_SADROOT<<2)| \
+					 LIS2HH12_ACC_SAD0H)
+
+/* to set gpios numb connected to interrupt pins,
+ * the unused ones have to be set to -EINVAL
+ */
+#define LIS2HH12_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS2HH12_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS2HH12_ACC_FS_MASK		0x30
+#define LIS2HH12_ACC_FS_2G		0x00
+#define LIS2HH12_ACC_FS_4G		0x20
+#define LIS2HH12_ACC_FS_8G		0x30
+
+#define BUFF_RX_MAX_LENGTH		500
+#define BUFF_TX_MAX_LENGTH		500
+
+#define RESUME_ENTRIES			18
+struct lis2hh12_status;
+
+struct lis2hh12_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis2hh12_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis2hh12_transfer_function {
+	int (*write)(struct lis2hh12_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis2hh12_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis2hh12_status {
+	const char *name;
+	struct lis2hh12_platform_data *pdata;
+	struct mutex lock;
+	struct work_struct input_poll_work;
+	struct hrtimer hr_timer_poll;
+	ktime_t polling_ktime;
+	struct workqueue_struct *hr_timer_poll_work_queue;
+	s64 timestamp;
+	u8 sample_to_discard;
+	struct input_dev *input_dev;
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+	u8 resume_state[RESUME_ENTRIES];
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct lis2hh12_transfer_function *tf;
+	struct lis2hh12_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+/* Input events used by lis2dh driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+int lis2hh12_common_probe(struct lis2hh12_status *stat);
+int lis2hh12_common_remove(struct lis2hh12_status *stat);
+
+#ifdef CONFIG_PM
+int lis2hh12_common_resume(struct lis2hh12_status *stat);
+int lis2hh12_common_suspend(struct lis2hh12_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LIS2HH12_H__ */
+
diff -uNr a/drivers/input/misc/st/acc/lis2hh12/lis2hh12_i2c.c b/drivers/input/misc/st/acc/lis2hh12/lis2hh12_i2c.c
--- a/drivers/input/misc/st/acc/lis2hh12/lis2hh12_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2hh12/lis2hh12_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,206 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2hh12_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis2hh12.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int lis2hh12_i2c_read(struct lis2hh12_status *stat, u8 reg_addr,
+			     int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis2hh12_i2c_write(struct lis2hh12_status *stat, u8 reg_addr,
+			      int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct lis2hh12_transfer_function lis2hh12_tf_i2c = {
+	.write = lis2hh12_i2c_write,
+	.read = lis2hh12_i2c_read,
+};
+
+static int lis2hh12_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	int err;
+	struct lis2hh12_status *stat;
+
+	stat = kmalloc(sizeof(struct lis2hh12_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis2hh12_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis2hh12_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis2hh12_i2c_remove(struct i2c_client *client)
+{
+	struct lis2hh12_status *stat = i2c_get_clientdata(client);
+
+	lis2hh12_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2hh12_suspend(struct device *dev)
+{
+	struct lis2hh12_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2hh12_common_suspend(stat);
+}
+
+static int lis2hh12_resume(struct device *dev)
+{
+	struct lis2hh12_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis2hh12_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis2hh12_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2hh12_suspend, lis2hh12_resume)
+};
+
+#define LIS2HH12_PM_OPS	(&lis2hh12_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2HH12_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis2hh12_ids[] = {
+	{ LIS2HH12_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis2hh12_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2hh12_id_table[] = {
+	{ .compatible = "st,lis2hh12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2hh12_id_table);
+#endif
+
+static struct i2c_driver lis2hh12_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2HH12_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS2HH12_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis2hh12_id_table,
+#endif
+	},
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0)
+	.remove = __devexit_p(lis2hh12_i2c_remove),
+#else
+	.remove = lis2hh12_i2c_remove,
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0) */
+	.probe    = lis2hh12_i2c_probe,
+	.id_table = lis2hh12_ids,
+};
+
+module_i2c_driver(lis2hh12_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2hh12 i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2hh12/lis2hh12_spi.c b/drivers/input/misc/st/acc/lis2hh12/lis2hh12_spi.c
--- a/drivers/input/misc/st/acc/lis2hh12/lis2hh12_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2hh12/lis2hh12_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,213 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis2hh12_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis2hh12.h"
+
+#define SENSORS_SPI_READ	0x80
+
+/* Not all devices has auto increment flags */
+#ifdef SPI_HAS_AUTOINCREMENT
+#define SPI_AUTO_INCREMENT	0x40
+#endif
+
+static int lis2hh12_spi_read(struct lis2hh12_status *stat, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+#ifdef SPI_HAS_AUTOINCREMENT
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+#endif
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len*sizeof(u8));
+
+	return len;
+}
+
+static int lis2hh12_spi_write(struct lis2hh12_status *stat, u8 reg_addr, int len,
+			      u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+#ifdef SPI_HAS_AUTOINCREMENT
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+
+	return err;
+}
+
+static struct lis2hh12_transfer_function lis2hh12_tf_spi = {
+	.write = lis2hh12_spi_write,
+	.read = lis2hh12_spi_read,
+};
+
+static int lis2hh12_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis2hh12_status *stat;
+
+	stat = kmalloc(sizeof(struct lis2hh12_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis2hh12_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis2hh12_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis2hh12_spi_remove(struct spi_device *spi)
+{
+	struct lis2hh12_status *stat = spi_get_drvdata(spi);
+
+	lis2hh12_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis2hh12_suspend(struct device *dev)
+{
+	struct lis2hh12_status *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis2hh12_common_suspend(stat);
+}
+
+static int lis2hh12_resume(struct device *dev)
+{
+	struct lis2hh12_status *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis2hh12_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis2hh12_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2hh12_suspend, lis2hh12_resume)
+};
+
+#define LIS2HH12_PM_OPS	(&lis2hh12_pm_ops)
+#else /* CONFIG_PM */
+#define LIS2HH12_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis2hh12_ids[] = {
+	{ LIS2HH12_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis2hh12_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2hh12_id_table[] = {
+	{ .compatible = "st,lis2hh12", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2hh12_id_table);
+#endif
+
+static struct spi_driver lis2hh12_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2HH12_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS2HH12_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis2hh12_id_table,
+#endif
+	},
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0)
+	.remove = __devexit_p(lis2hh12_spi_remove),
+#else
+	.remove = lis2hh12_spi_remove,
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0) */
+	.probe    = lis2hh12_spi_probe,
+	.id_table = lis2hh12_ids,
+};
+
+module_spi_driver(lis2hh12_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2hh12 spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis2hh12/Makefile b/drivers/input/misc/st/acc/lis2hh12/Makefile
--- a/drivers/input/misc/st/acc/lis2hh12/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis2hh12/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis2hh12 driver
+#
+lis2hh12-core-y += lis2hh12_core.o
+obj-$(CONFIG_INPUT_LIS2HH12) += lis2hh12-core.o
+obj-$(CONFIG_INPUT_LIS2HH12_I2C) += lis2hh12_i2c.o
+obj-$(CONFIG_INPUT_LIS2HH12_SPI) += lis2hh12_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis331dlh/Kconfig b/drivers/input/misc/st/acc/lis331dlh/Kconfig
--- a/drivers/input/misc/st/acc/lis331dlh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331dlh/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS331DLH
+	tristate "STMicroelectronics LIS331DLH sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS331DLH_I2C if (I2C)
+	select INPUT_LIS331DLH_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS331DLH sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis331dlh.
+
+config INPUT_LIS331DLH_I2C
+	tristate
+	depends on INPUT_LIS331DLH
+	depends on I2C
+
+config INPUT_LIS331DLH_SPI
+	tristate
+	depends on INPUT_LIS331DLH
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis331dlh/lis331dlh_core.c b/drivers/input/misc/st/acc/lis331dlh/lis331dlh_core.c
--- a/drivers/input/misc/st/acc/lis331dlh/lis331dlh_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331dlh/lis331dlh_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1277 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lis331dlh_core.c
+* Authors		: MSH - Motion Mems BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.7.2
+* Date			: 2012/10/07
+* Description		: LIS331DLH 3D accelerometer sensor API
+*
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************
+
+ Revision 1.5.0 2010/09/05:
+	lis331dlh_acc_device_power_off now calling CTRL_REG1 to set power off
+	manages 2 interrupts;
+	correction to update_g_range;
+	modified_get_acceleration_data function
+	modified update_odr function and lis331dlh_acc_odr_table;
+	don't support ioclt;
+	supports sysfs;
+ Revision 1.6.0 2011/02/28
+	checks for availability of interrupts pins
+ Revision 1.7.0 2011/03/02
+	adds self test enable/disable
+ Revision 1.7.1 2012/10/07
+	corrects default permissions on sys fs files
+ Revision 1.7.2 2016/05/09
+	added spi support and default platform data
+******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lis331dlh.h"
+
+#define G_MAX	8000
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_LIS331DLH_ACC	0x32	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define CTRL_REG1		0x20	/*				*/
+#define CTRL_REG2		0x21	/*				*/
+#define CTRL_REG3		0x22	/*				*/
+#define CTRL_REG4		0x23	/*				*/
+#define	CTRL_REG5		0x24	/*				*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+#define	INT_CFG2		0x34	/*	interrupt 2 config	*/
+#define	INT_SRC2		0x35	/*	interrupt 2 source	*/
+#define	INT_THS2		0x36	/*	interrupt 2 threshold	*/
+#define	INT_DUR2		0x37	/*	interrupt 2 duration	*/
+/*	end CONTROL REGISTRES	*/
+
+#define LIS331DLH_ACC_ENABLE_ALL_AXES	0x07
+#define LIS331DLH_SELFTEST_EN		0x02
+#define LIS331DLH_SELFTEST_DIS		0x00
+#define LIS331DLH_SELFTEST_POS		0x00
+#define LIS331DLH_SELFTEST_NEG		0x08
+
+/* Accelerometer output data rate  */
+#define LIS331DLH_ACC_ODRHALF		0x40	/* 0.5Hz output data rate */
+#define LIS331DLH_ACC_ODR1		0x60	/* 1Hz output data rate */
+#define LIS331DLH_ACC_ODR2		0x80	/* 2Hz output data rate */
+#define LIS331DLH_ACC_ODR5		0xA0	/* 5Hz output data rate */
+#define LIS331DLH_ACC_ODR10		0xC0	/* 10Hz output data rate */
+#define LIS331DLH_ACC_ODR50		0x00	/* 50Hz output data rate */
+#define LIS331DLH_ACC_ODR100		0x08	/* 100Hz output data rate */
+#define LIS331DLH_ACC_ODR400		0x10	/* 400Hz output data rate */
+#define LIS331DLH_ACC_ODR1000		0x18	/* 1000Hz output data rate */
+
+#define FUZZ			0
+#define FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_REFERENCE		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+#define	RES_INT_CFG2		9
+#define	RES_INT_THS2		10
+#define	RES_INT_DUR2		11
+/* end RESUME STATE INDICES */
+
+static struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis331dlh_odr_table[] = {
+	{ 1, LIS331DLH_ACC_PM_NORMAL | LIS331DLH_ACC_ODR1000 },
+	{ 3, LIS331DLH_ACC_PM_NORMAL | LIS331DLH_ACC_ODR400 },
+	{ 10, LIS331DLH_ACC_PM_NORMAL | LIS331DLH_ACC_ODR100 },
+	{ 20, LIS331DLH_ACC_PM_NORMAL | LIS331DLH_ACC_ODR50},
+	/* low power settings, max low pass filter cut-off freq */
+	{ 100, LIS331DLH_ACC_ODR10 | LIS331DLH_ACC_ODR1000 },
+	{ 200, LIS331DLH_ACC_ODR5 | LIS331DLH_ACC_ODR1000 },
+	{ 5000, LIS331DLH_ACC_ODR2 | LIS331DLH_ACC_ODR1000 },
+	{ 1000, LIS331DLH_ACC_ODR1 | LIS331DLH_ACC_ODR1000 },
+	{ 2000, LIS331DLH_ACC_ODRHALF | LIS331DLH_ACC_ODR1000 },
+};
+
+static struct lis331dlh_platform_data default_lis331dlh_pdata = {
+	.g_range = LIS331DLH_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS331DLH_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS331DLH_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS331DLH_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lis331dlh_hw_init(struct lis331dlh_data *acc)
+{
+	int err = -1;
+	u8 buf[5];
+
+	printk(KERN_INFO "%s: hw init start\n", LIS331DLH_ACC_DEV_NAME);
+
+	err = acc->tf->read(acc, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			"available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+	if (buf[0] != WHOAMI_LIS331DLH_ACC) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_LIS331DLH_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_CTRL_REG1];
+	err = acc->tf->write(acc, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS1];
+	buf[1] = acc->resume_state[RES_INT_DUR1];
+	err = acc->tf->write(acc, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG1];
+	err = acc->tf->write(acc, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS2];
+	buf[1] = acc->resume_state[RES_INT_DUR2];
+	err = acc->tf->write(acc, INT_THS2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG2];
+	err = acc->tf->write(acc, INT_CFG2, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_CTRL_REG2];
+	buf[1] = acc->resume_state[RES_CTRL_REG3];
+	buf[2] = acc->resume_state[RES_CTRL_REG4];
+	buf[3] = acc->resume_state[RES_CTRL_REG5];
+	err = acc->tf->write(acc, CTRL_REG2, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	printk(KERN_INFO "%s: hw init done\n", LIS331DLH_ACC_DEV_NAME);
+
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error: %d\n", err);
+
+	return err;
+}
+
+static void lis331dlh_device_power_off(struct lis331dlh_data *acc)
+{
+	int err;
+	u8 buf = LIS331DLH_ACC_PM_OFF;
+
+	err = acc->tf->write(acc, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int lis331dlh_device_power_on(struct lis331dlh_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+					"power_on failed: %d\n", err);
+			return err;
+		}
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = lis331dlh_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			lis331dlh_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+	return 0;
+}
+
+static irqreturn_t lis331dlh_isr1(int irq, void *dev)
+{
+	struct lis331dlh_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+	printk(KERN_INFO "%s: isr1 queued\n", LIS331DLH_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis331dlh_isr2(int irq, void *dev)
+{
+	struct lis331dlh_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+	printk(KERN_INFO "%s: isr2 queued\n", LIS331DLH_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lis331dlh_irq1_work_func(struct work_struct *work)
+{
+	struct lis331dlh_data *acc =
+
+	container_of(work, struct lis331dlh_data, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis331dlh_get_int1_source(acc); */
+	printk(KERN_INFO "%s: IRQ1 triggered\n", LIS331DLH_ACC_DEV_NAME);
+	enable_irq(acc->irq1);
+}
+
+static void lis331dlh_irq2_work_func(struct work_struct *work)
+{
+	struct lis331dlh_data *acc =
+
+	container_of(work, struct lis331dlh_data, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis331dlh_get_tap_source(acc); */
+	printk(KERN_INFO "%s: IRQ2 triggered\n", LIS331DLH_ACC_DEV_NAME);
+	enable_irq(acc->irq2);
+}
+
+int lis331dlh_update_g_range(struct lis331dlh_data *acc, u8 new_g_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+
+	switch (new_g_range) {
+	case LIS331DLH_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LIS331DLH_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LIS331DLH_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n",
+				new_g_range);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&acc->enabled)) {
+		/* Set configuration register 4, which contains g range setting
+		 *  NOTE: this is a straight overwrite because this driver does
+		 *  not use any of the other configuration bits in this
+		 *  register.  Should this become untrue, we will have to read
+		 *  out the value and only change the relevant bits --XX----
+		 *  (marked by X) */
+		err = acc->tf->read(acc, CTRL_REG4, 1, &init_val);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = init_val;
+		new_val = new_g_range;
+		updated_val = ((LIS331DLH_ACC_FS_MASK & new_val) |
+					  ((~LIS331DLH_ACC_FS_MASK) & init_val));
+		err = acc->tf->write(acc, CTRL_REG4, 1, &updated_val);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = updated_val;
+		acc->sensitivity = sensitivity;
+	}
+
+	return err;
+error:
+	dev_err(acc->dev, "update g range failed 0x%x,0x%x: %d\n",
+			CTRL_REG4, updated_val, err);
+
+	return err;
+}
+
+int lis331dlh_update_odr(struct lis331dlh_data *acc, int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis331dlh_odr_table) - 1; i >= 0; i--) {
+		if (lis331dlh_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+	config = lis331dlh_odr_table[i].mask | LIS331DLH_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		err = acc->tf->write(acc, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+		acc->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+
+error:
+	dev_err(acc->dev, "update odr failed 0x%x,0x%x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int lis331dlh_register_write(struct lis331dlh_data *acc, u8 *buf,
+				    u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return acc->tf->write(acc, reg_address, 1, buf);
+}
+
+static int lis331dlh_register_read(struct lis331dlh_data *acc, u8 *buf,
+				   u8 reg_address)
+{
+	return acc->tf->read(acc, reg_address, 1, buf);
+}
+
+/* This function must be called with acc->lock taken */
+static int lis331dlh_register_update(struct lis331dlh_data *acc, u8 *buf,
+				     u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	u8 init_val;
+	u8 updated_val;
+	int err = lis331dlh_register_read(acc, buf, reg_address);
+
+	if (err >= 0) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = lis331dlh_register_write(acc, buf, reg_address, updated_val);
+	}
+
+	return err;
+}
+
+static int lis331dlh_selftest(struct lis331dlh_data *acc, u8 enable)
+{
+	int err = -1;
+	u8 buf[2] = { 0x00, 0x00 };
+	char reg_address, mask, bit_values;
+
+	reg_address = CTRL_REG4;
+	mask = 0x0A;
+	if (enable > 0)
+		bit_values = LIS331DLH_SELFTEST_EN | LIS331DLH_SELFTEST_POS;
+	else
+		bit_values = LIS331DLH_SELFTEST_DIS | LIS331DLH_SELFTEST_POS;
+
+	if (atomic_read(&acc->enabled)) {
+		mutex_lock(&acc->lock);
+		err = lis331dlh_register_update(acc, buf, reg_address, mask,
+						bit_values);
+		acc->selftest_enabled = enable;
+		mutex_unlock(&acc->lock);
+		if (err < 0)
+			return err;
+
+		acc->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				( ~mask & acc->resume_state[RES_CTRL_REG4]));
+	}
+
+	return err;
+}
+
+static int lis331dlh_get_acceleration_data(struct lis331dlh_data *acc, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x])
+		  : (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y])
+		  : (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
+		  : (hw_d[acc->pdata->axis_map_z]));
+
+#ifdef DEBUG
+		printk(KERN_INFO "%s read x=%d, y=%d, z=%d\n",
+		       LIS331DLH_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+#endif
+
+	return err;
+}
+
+static void lis331dlh_report_values(struct lis331dlh_data *acc, int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static int lis331dlh_enable(struct lis331dlh_data *acc)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		err = lis331dlh_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+		/* Android:
+		 * Udpate polling rate in case odr was changed while sensor disabled */
+		lis331dlh_update_odr(acc, acc->pdata->poll_interval);
+		schedule_delayed_work(&acc->input_work,
+			msecs_to_jiffies(acc->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lis331dlh_disable(struct lis331dlh_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work(&acc->input_work);
+		lis331dlh_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	int rc = 0;
+	u8 data;
+
+	rc = acc->tf->read(acc, reg, 1, &data);
+	if (rc < 0)
+		return rc;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x = val;
+
+	return acc->tf->write(acc, reg, 1, &x);
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->poll_interval = interval_ms;
+	lis331dlh_update_odr(acc, interval_ms);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->g_range ;
+	switch (val) {
+	case LIS331DLH_ACC_G_2G:
+		range = 2;
+		break;
+	case LIS331DLH_ACC_G_4G:
+		range = 4;
+		break;
+	case LIS331DLH_ACC_G_8G:
+		range = 8;
+		break;
+	}
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->g_range = val;
+	lis331dlh_update_g_range(acc, val);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	
+	if (val)
+		lis331dlh_enable(acc);
+	else
+		lis331dlh_disable(acc);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->selftest_enabled;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	lis331dlh_selftest(acc, val);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_intconfig2(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_get_intconfig2(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_set_duration2(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_get_duration2(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_set_thresh2(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t size)
+{
+	return write_reg(dev, buf, INT_THS2);
+}
+
+static ssize_t attr_get_thresh2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS2);
+}
+static ssize_t attr_get_source2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC2);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	u8 reg;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	rc = acc->tf->write(acc, x, 1, (u8 *)&val);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 reg;
+
+	mutex_lock(&stat->lock);
+	reg = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	ret = stat->tf->read(stat, reg, 1, buf);
+
+	return ret;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	int ret;
+	u8 reg;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	ret = acc->tf->read(acc, &reg, 1, buf);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lis331dlh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(enable_selftest, 0664, attr_get_selftest, attr_set_selftest),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(int2_config, 0664, attr_get_intconfig2, attr_set_intconfig2),
+	__ATTR(int2_duration, 0664, attr_get_duration2, attr_set_duration2),
+	__ATTR(int2_threshold, 0664, attr_get_thresh2, attr_set_thresh2),
+	__ATTR(int2_source, 0444, attr_get_source2, NULL),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lis331dlh_input_work_func(struct work_struct *work)
+{
+	struct lis331dlh_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			    struct lis331dlh_data, input_work);
+
+	mutex_lock(&acc->lock);
+	err = lis331dlh_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_acceleration_data failed\n");
+	else
+		lis331dlh_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work,
+			      msecs_to_jiffies(acc->pdata->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+#ifdef LIS331DLH_EN_OPEN
+int lis331dlh_input_open(struct input_dev *input)
+{
+	struct lis331dlh_data *acc = input_get_drvdata(input);
+
+	return lis331dlh_enable(acc);
+}
+
+void lis331dlh_input_close(struct input_dev *dev)
+{
+	struct lis331dlh_data *acc = input_get_drvdata(dev);
+
+	lis331dlh_disable(acc);
+}
+#endif /* LIS331DLH_EN_OPEN */
+
+static int lis331dlh_validate_pdata(struct lis331dlh_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 || acc->pdata->axis_map_y > 2 ||
+	    acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			acc->pdata->axis_map_x, acc->pdata->axis_map_y,
+			acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1 ||
+	    acc->pdata->negate_z > 1) {
+		dev_err(acc->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			acc->pdata->negate_x, acc->pdata->negate_y,
+			acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis331dlh_input_init(struct lis331dlh_data *acc)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&acc->input_work, lis331dlh_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "input device allocation failed\n");
+		return err;
+	}
+
+#ifdef LIS331DLH_EN_OPEN
+	acc->input_dev->open = lis331dlh_input_open;
+	acc->input_dev->close = lis331dlh_input_close;
+#else /* LIS331DLH_EN_OPEN */
+	acc->input_dev->open = NULL;
+	acc->input_dev->close = NULL;
+#endif /* LIS331DLH_EN_OPEN */
+	acc->input_dev->name = acc->name;
+	acc->input_dev->id.bustype = acc->bustype;
+	acc->input_dev->dev.parent = acc->dev;
+	input_set_drvdata(acc->input_dev, acc);
+
+	/* Set Misc event type */
+	__set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev,
+			"unable to register input device %s\n",
+			acc->input_dev->name);
+		input_free_device(acc->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lis331dlh_input_cleanup(struct lis331dlh_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 lis331dlh_parse_dt(struct lis331dlh_data *acc)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = acc->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "gpio_int1", &val))
+		acc->pdata->gpio_int1 = (u8)val;
+	if (!of_property_read_u32(np, "gpio_int2", &val))
+		acc->pdata->gpio_int2 = (u8)val;
+
+	return 0;
+}
+#endif
+
+int lis331dlh_common_probe(struct lis331dlh_data *acc)
+{
+	int err = -1;
+
+	pr_info("%s: probe start.\n", LIS331DLH_ACC_DEV_NAME);
+
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kzalloc(sizeof(struct lis331dlh_platform_data), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (acc->dev->platform_data == NULL) {
+		memcpy(acc->pdata, &default_lis331dlh_pdata,
+		       sizeof(struct lis331dlh_platform_data));
+		dev_info(acc->dev, "using default plaform_data\n");
+	} else {
+		memcpy(acc->pdata, acc->dev->platform_data,
+		       sizeof(struct lis331dlh_platform_data));
+	}
+
+#ifdef CONFIG_OF
+	/* override default gpio_irq[1,2] if required */
+	lis331dlh_parse_dt(acc);
+#endif
+
+	err = lis331dlh_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		printk(KERN_INFO "%s: %s has set irq1 to irq: %d "
+		       "mapped on gpio:%d\n", LIS331DLH_ACC_DEV_NAME, __func__,
+		        acc->irq1, acc->pdata->gpio_int1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		printk(KERN_INFO "%s: %s has set irq2 to irq: %d "
+		       "mapped on gpio:%d\n", LIS331DLH_ACC_DEV_NAME, __func__,
+		       acc->irq2, acc->pdata->gpio_int2);
+	}
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+
+	acc->resume_state[RES_CTRL_REG1] = LIS331DLH_ACC_ENABLE_ALL_AXES;
+
+	err = lis331dlh_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = lis331dlh_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_g_range failed\n");
+		goto err_power_off;
+	}
+
+	err = lis331dlh_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = lis331dlh_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+			"device %s register failed\n",  LIS331DLH_ACC_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lis331dlh_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&acc->irq1_work, lis331dlh_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("lis331dlh_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, lis331dlh_isr1,
+				  IRQF_TRIGGER_RISING, "lis331dlh_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&acc->irq2_work, lis331dlh_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("lis331dlh_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, lis331dlh_isr2,
+				  IRQF_TRIGGER_RISING, "lis331dlh_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+				goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(acc->dev, "%s: probed\n", LIS331DLH_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if(acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	lis331dlh_input_cleanup(acc);
+err_power_off:
+	lis331dlh_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+	printk(KERN_ERR "%s: Driver Init failed\n", LIS331DLH_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis331dlh_common_probe);
+
+int lis331dlh_common_remove(struct lis331dlh_data *acc)
+{
+	if(acc->pdata->gpio_int1 >= 0){
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	lis331dlh_input_cleanup(acc);
+	lis331dlh_device_power_off(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+	kfree(acc->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis331dlh_common_remove);
+
+#ifdef CONFIG_PM
+int lis331dlh_common_resume(struct lis331dlh_data *acc)
+{
+	if (acc->on_before_suspend)
+		return lis331dlh_enable(acc);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis331dlh_common_resume);
+
+int lis331dlh_common_suspend(struct lis331dlh_data *acc)
+{
+	acc->on_before_suspend = atomic_read(&acc->enabled);
+
+	return lis331dlh_disable(acc);
+}
+EXPORT_SYMBOL(lis331dlh_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis331dlh accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno, Carmine Iascone, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis331dlh/lis331dlh.h b/drivers/input/misc/st/acc/lis331dlh/lis331dlh.h
--- a/drivers/input/misc/st/acc/lis331dlh/lis331dlh.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331dlh/lis331dlh.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,168 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lis331dlh.h
+* Authors		: MSH - Motion Mems BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+* Version		: V 1.7.1
+* Date			: 2012/10/07
+* Description		: LIS331DLH 3D accelerometer sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#ifndef __LIS331DLH_H__
+#define __LIS331DLH_H__
+
+/*
+#define	DEBUG
+*/
+
+/* Uncomment if want Enable/Disable sensor on Open/Close input device
+#define LIS331DLH_EN_OPEN
+*/
+
+/* Device support autoincrement address on spi/i2c interface */
+#define HAS_IF_AUTO_INCREMENT
+
+#define	LIS331DLH_ACC_DEV_NAME	"lis331dlh"
+
+#define	LIS331DLH_ACC_MIN_POLL_PERIOD_MS 1
+
+/* to set gpios numb connected to interrupt pins,
+* the unused ones have to be set to -EINVAL
+*/
+#define LIS331DLH_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS331DLH_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS331DLH_ACC_FS_MASK	0x30
+#define LIS331DLH_ACC_G_2G 	0x00
+#define LIS331DLH_ACC_G_4G 	0x10
+#define LIS331DLH_ACC_G_8G 	0x30
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS331DLH_ACC_ENABLE	0x01
+#define LIS331DLH_ACC_DISABLE	0x00
+#define LIS331DLH_ACC_PM_NORMAL	0x20
+#define LIS331DLH_ACC_PM_OFF	LIS331DLH_ACC_DISABLE
+
+#define BUFF_RX_MAX_LENGTH	500
+#define BUFF_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		12
+
+#ifdef __KERNEL__
+
+struct lis331dlh_data;
+
+struct lis331dlh_platform_data {
+	int poll_interval;
+	int min_interval;
+
+	u8 g_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis331dlh_transfer_buffer {
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis331dlh_transfer_function {
+	int (*write)(struct lis331dlh_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis331dlh_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis331dlh_data {
+	const char *name;
+	struct lis331dlh_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	int selftest_enabled;
+
+	atomic_t enabled;
+	int on_before_suspend;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct lis331dlh_transfer_function *tf;
+	struct lis331dlh_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+/* Input events used by lis2dh driver */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int lis331dlh_common_probe(struct lis331dlh_data *stat);
+int lis331dlh_common_remove(struct lis331dlh_data *stat);
+
+#ifdef CONFIG_PM
+int lis331dlh_common_resume(struct lis331dlh_data *stat);
+int lis331dlh_common_suspend(struct lis331dlh_data *stat);
+#endif /* CONFIG_PM */
+
+#endif /* __KERNEL__ */
+
+#endif  /* __LIS331DLH_H__ */
diff -uNr a/drivers/input/misc/st/acc/lis331dlh/lis331dlh_i2c.c b/drivers/input/misc/st/acc/lis331dlh/lis331dlh_i2c.c
--- a/drivers/input/misc/st/acc/lis331dlh/lis331dlh_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331dlh/lis331dlh_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,213 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis331dlh_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis331dlh.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define	I2C_AUTO_INCREMENT	0x80
+#endif
+
+static int lis331dlh_i2c_read(struct lis331dlh_data *stat, u8 reg_addr,
+			      int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis331dlh_i2c_write(struct lis331dlh_data *stat, u8 reg_addr,
+			       int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct lis331dlh_transfer_function lis331dlh_tf_i2c = {
+	.write = lis331dlh_i2c_write,
+	.read = lis331dlh_i2c_read,
+};
+
+static int lis331dlh_i2c_probe(struct i2c_client *client,
+			       const struct i2c_device_id *id)
+{
+	int err;
+	struct lis331dlh_data *stat;
+
+	stat = kzalloc(sizeof(struct lis331dlh_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis331dlh_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis331dlh_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis331dlh_i2c_remove(struct i2c_client *client)
+{
+	struct lis331dlh_data *stat = i2c_get_clientdata(client);
+
+	lis331dlh_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis331dlh_suspend(struct device *dev)
+{
+	struct lis331dlh_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis331dlh_common_suspend(stat);
+}
+
+static int lis331dlh_resume(struct device *dev)
+{
+	struct lis331dlh_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis331dlh_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis331dlh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis331dlh_suspend, lis331dlh_resume)
+};
+
+#define LIS331DLH_PM_OPS	(&lis331dlh_pm_ops)
+#else /* CONFIG_PM */
+#define LIS331DLH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis331dlh_ids[] = {
+	{ LIS331DLH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis331dlh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis331dlh_id_table[] = {
+	{ .compatible = "st,lis331dlh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis331dlh_id_table);
+#endif
+
+static struct i2c_driver lis331dlh_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS331DLH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS331DLH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis331dlh_id_table,
+#endif
+	},
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0)
+	.remove = __devexit_p(lis331dlh_i2c_remove),
+#else
+	.remove = lis331dlh_i2c_remove,
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0) */
+	.probe    = lis331dlh_i2c_probe,
+	.id_table = lis331dlh_ids,
+};
+
+module_i2c_driver(lis331dlh_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis331dlh i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis331dlh/lis331dlh_spi.c b/drivers/input/misc/st/acc/lis331dlh/lis331dlh_spi.c
--- a/drivers/input/misc/st/acc/lis331dlh/lis331dlh_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331dlh/lis331dlh_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,203 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis331dlh_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis331dlh.h"
+
+#define SENSORS_SPI_READ	0x80
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define SPI_AUTO_INCREMENT	0x40
+#endif
+
+static int lis331dlh_spi_read(struct lis331dlh_data *stat, u8 reg_addr, int len,
+			      u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len);
+
+	return len;
+}
+
+static int lis331dlh_spi_write(struct lis331dlh_data *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	memcpy(&stat->tb.tx_buf[1], data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(to_spi_device(stat->dev), &msg);
+}
+
+static struct lis331dlh_transfer_function lis331dlh_tf_spi = {
+	.write = lis331dlh_spi_write,
+	.read = lis331dlh_spi_read,
+};
+
+static int lis331dlh_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis331dlh_data *stat;
+
+	stat = kzalloc(sizeof(struct lis331dlh_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis331dlh_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis331dlh_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis331dlh_spi_remove(struct spi_device *spi)
+{
+	struct lis331dlh_data *stat = spi_get_drvdata(spi);
+
+	lis331dlh_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis331dlh_suspend(struct device *dev)
+{
+	struct lis331dlh_data *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis331dlh_common_suspend(stat);
+}
+
+static int lis331dlh_resume(struct device *dev)
+{
+	struct lis331dlh_data *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis331dlh_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis331dlh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis331dlh_suspend, lis331dlh_resume)
+};
+
+#define LIS331DLH_PM_OPS	(&lis331dlh_pm_ops)
+#else /* CONFIG_PM */
+#define LIS331DLH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis331dlh_ids[] = {
+	{ LIS331DLH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis331dlh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis331dlh_id_table[] = {
+	{ .compatible = "st,lis331dlh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis331dlh_id_table);
+#endif
+
+static struct spi_driver lis331dlh_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS331DLH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS331DLH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis331dlh_id_table,
+#endif
+	},
+	.remove = lis331dlh_spi_remove,
+	.probe    = lis331dlh_spi_probe,
+	.id_table = lis331dlh_ids,
+};
+
+module_spi_driver(lis331dlh_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis331dlh spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis331dlh/Makefile b/drivers/input/misc/st/acc/lis331dlh/Makefile
--- a/drivers/input/misc/st/acc/lis331dlh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331dlh/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis331dlh driver
+#
+lis331dlh-core-y += lis331dlh_core.o
+obj-$(CONFIG_INPUT_LIS331DLH) += lis331dlh-core.o
+obj-$(CONFIG_INPUT_LIS331DLH_I2C) += lis331dlh_i2c.o
+obj-$(CONFIG_INPUT_LIS331DLH_SPI) += lis331dlh_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis331hh/Kconfig b/drivers/input/misc/st/acc/lis331hh/Kconfig
--- a/drivers/input/misc/st/acc/lis331hh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331hh/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS331HH
+	tristate "STMicroelectronics LIS331HH sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS331HH_I2C if (I2C)
+	select INPUT_LIS331HH_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS331HH sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis331hh.
+
+config INPUT_LIS331HH_I2C
+	tristate
+	depends on INPUT_LIS331HH
+	depends on I2C
+
+config INPUT_LIS331HH_SPI
+	tristate
+	depends on INPUT_LIS331HH
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis331hh/lis331hh_core.c b/drivers/input/misc/st/acc/lis331hh/lis331hh_core.c
--- a/drivers/input/misc/st/acc/lis331hh/lis331hh_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331hh/lis331hh_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1277 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lis331hh_core.c
+* Authors		: MSH - Motion Mems BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.7.2
+* Date			: 2012/10/07
+* Description		: LIS331HH 3D accelerometer sensor API
+*
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************
+
+ Revision 1.5.0 2010/09/05:
+	lis331hh_acc_device_power_off now calling CTRL_REG1 to set power off
+	manages 2 interrupts;
+	correction to update_g_range;
+	modified_get_acceleration_data function
+	modified update_odr function and lis331hh_acc_odr_table;
+	don't support ioclt;
+	supports sysfs;
+ Revision 1.6.0 2011/02/28
+	checks for availability of interrupts pins
+ Revision 1.7.0 2011/03/02
+	adds self test enable/disable
+ Revision 1.7.1 2012/10/07
+	corrects default permissions on sys fs files
+ Revision 1.7.2 2016/06/07
+	added spi support and default platform data
+******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lis331hh.h"
+
+#define G_MAX	10000
+
+#define SENSITIVITY_6G		3	/**	mg/LSB	*/
+#define SENSITIVITY_12G		6	/**	mg/LSB	*/
+#define SENSITIVITY_24G		12	/**	mg/LSB	*/
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_LIS331HH_ACC	0x32	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register */
+#define CTRL_REG1		0x20
+#define CTRL_REG2		0x21
+#define CTRL_REG3		0x22
+#define CTRL_REG4		0x23
+#define	CTRL_REG5		0x24
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold */
+#define	INT_DUR1		0x33	/*	interrupt 1 duration */
+
+#define	INT_CFG2		0x34	/*	interrupt 2 config	*/
+#define	INT_SRC2		0x35	/*	interrupt 2 source	*/
+#define	INT_THS2		0x36	/*	interrupt 2 threshold */
+#define	INT_DUR2		0x37	/*	interrupt 2 duration */
+/*	end CONTROL REGISTRES	*/
+
+#define LIS331HH_ACC_ENABLE_ALL_AXES	0x07
+#define LIS331HH_SELFTEST_EN		0x02
+#define LIS331HH_SELFTEST_DIS		0x00
+#define LIS331HH_SELFTEST_POS		0x00
+#define LIS331HH_SELFTEST_NEG		0x08
+
+/* Accelerometer output data rate  */
+#define LIS331HH_ACC_ODRHALF		0x40	/* 0.5Hz output data rate */
+#define LIS331HH_ACC_ODR1		0x60	/* 1Hz output data rate */
+#define LIS331HH_ACC_ODR2		0x80	/* 2Hz output data rate */
+#define LIS331HH_ACC_ODR5		0xA0	/* 5Hz output data rate */
+#define LIS331HH_ACC_ODR10		0xC0	/* 10Hz output data rate */
+#define LIS331HH_ACC_ODR50		0x00	/* 50Hz output data rate */
+#define LIS331HH_ACC_ODR100		0x08	/* 100Hz output data rate */
+#define LIS331HH_ACC_ODR400		0x10	/* 400Hz output data rate */
+#define LIS331HH_ACC_ODR1000		0x18	/* 1000Hz output data rate */
+
+#define FUZZ			0
+#define FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_REFERENCE		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+#define	RES_INT_CFG2		9
+#define	RES_INT_THS2		10
+#define	RES_INT_DUR2		11
+/* end RESUME STATE INDICES */
+
+static struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis331hh_odr_table[] = {
+	{ 1, LIS331HH_ACC_PM_NORMAL | LIS331HH_ACC_ODR1000 },
+	{ 3, LIS331HH_ACC_PM_NORMAL | LIS331HH_ACC_ODR400 },
+	{ 10, LIS331HH_ACC_PM_NORMAL | LIS331HH_ACC_ODR100 },
+	{ 20, LIS331HH_ACC_PM_NORMAL | LIS331HH_ACC_ODR50},
+	/* low power settings, max low pass filter cut-off freq */
+	{ 100, LIS331HH_ACC_ODR10 | LIS331HH_ACC_ODR1000 },
+	{ 200, LIS331HH_ACC_ODR5 | LIS331HH_ACC_ODR1000 },
+	{ 5000, LIS331HH_ACC_ODR2 | LIS331HH_ACC_ODR1000 },
+	{ 1000, LIS331HH_ACC_ODR1 | LIS331HH_ACC_ODR1000 },
+	{ 2000, LIS331HH_ACC_ODRHALF | LIS331HH_ACC_ODR1000 },
+};
+
+static struct lis331hh_platform_data default_lis331hh_pdata = {
+	.g_range = LIS331HH_ACC_G_6G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS331HH_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS331HH_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS331HH_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lis331hh_hw_init(struct lis331hh_data *acc)
+{
+	int err = -1;
+	u8 buf[4];
+
+	printk(KERN_INFO "%s: hw init start\n", LIS331HH_ACC_DEV_NAME);
+
+	err = acc->tf->read(acc, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			"available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+	if (buf[0] != WHOAMI_LIS331HH_ACC) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%x, Replies: 0x%x\n",
+			WHOAMI_LIS331HH_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_CTRL_REG1];
+	err = acc->tf->write(acc, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS1];
+	buf[1] = acc->resume_state[RES_INT_DUR1];
+	err = acc->tf->write(acc, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG1];
+	err = acc->tf->write(acc, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_THS2];
+	buf[1] = acc->resume_state[RES_INT_DUR2];
+	err = acc->tf->write(acc, INT_THS2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_INT_CFG2];
+	err = acc->tf->write(acc, INT_CFG2, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_CTRL_REG2];
+	buf[1] = acc->resume_state[RES_CTRL_REG3];
+	buf[2] = acc->resume_state[RES_CTRL_REG4];
+	buf[3] = acc->resume_state[RES_CTRL_REG5];
+	err = acc->tf->write(acc, CTRL_REG2, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	printk(KERN_INFO "%s: hw init done\n", LIS331HH_ACC_DEV_NAME);
+
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error: %d\n", err);
+
+	return err;
+}
+
+static void lis331hh_device_power_off(struct lis331hh_data *acc)
+{
+	int err;
+	u8 buf = LIS331HH_ACC_PM_OFF;
+
+	err = acc->tf->write(acc, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int lis331hh_device_power_on(struct lis331hh_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = lis331hh_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			lis331hh_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+	return 0;
+}
+
+static irqreturn_t lis331hh_isr1(int irq, void *dev)
+{
+	struct lis331hh_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+	printk(KERN_INFO "%s: isr1 queued\n", LIS331HH_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis331hh_isr2(int irq, void *dev)
+{
+	struct lis331hh_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+	printk(KERN_INFO "%s: isr2 queued\n", LIS331HH_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lis331hh_irq1_work_func(struct work_struct *work)
+{
+	struct lis331hh_data *acc =
+
+	container_of(work, struct lis331hh_data, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis331hh_get_int1_source(acc); */
+	printk(KERN_INFO "%s: IRQ1 triggered\n", LIS331HH_ACC_DEV_NAME);
+	enable_irq(acc->irq1);
+}
+
+static void lis331hh_irq2_work_func(struct work_struct *work)
+{
+	struct lis331hh_data *acc =
+
+	container_of(work, struct lis331hh_data, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis331hh_get_tap_source(acc); */
+	printk(KERN_INFO "%s: IRQ2 triggered\n", LIS331HH_ACC_DEV_NAME);
+	enable_irq(acc->irq2);
+}
+
+static int lis331hh_update_g_range(struct lis331hh_data *acc, u8 new_g_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+
+	switch (new_g_range) {
+	case LIS331HH_ACC_G_6G:
+		sensitivity = SENSITIVITY_6G;
+		break;
+	case LIS331HH_ACC_G_12G:
+		sensitivity = SENSITIVITY_12G;
+		break;
+	case LIS331HH_ACC_G_24G:
+		sensitivity = SENSITIVITY_24G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n",
+			new_g_range);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&acc->enabled)) {
+		/* Set configuration register 4, which contains g range setting
+		 *  NOTE: this is a straight overwrite because this driver does
+		 *  not use any of the other configuration bits in this
+		 *  register.  Should this become untrue, we will have to read
+		 *  out the value and only change the relevant bits --XX----
+		 *  (marked by X) */
+		err = acc->tf->read(acc, CTRL_REG4, 1, &init_val);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = init_val;
+		new_val = new_g_range;
+		updated_val = ((LIS331HH_ACC_FS_MASK & new_val) |
+			       ((~LIS331HH_ACC_FS_MASK) & init_val));
+		err = acc->tf->write(acc, CTRL_REG4, 1, &updated_val);
+		if (err < 0)
+			goto error;
+
+		acc->resume_state[RES_CTRL_REG4] = updated_val;
+		acc->sensitivity = sensitivity;
+	}
+
+	return err;
+error:
+	dev_err(acc->dev, "update g range failed 0x%x,0x%x: %d\n",
+		CTRL_REG4, updated_val, err);
+
+	return err;
+}
+
+static int lis331hh_update_odr(struct lis331hh_data *acc, int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis331hh_odr_table) - 1; i >= 0; i--) {
+		if (lis331hh_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+	config = lis331hh_odr_table[i].mask | LIS331HH_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		err = acc->tf->write(acc, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+		acc->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+
+error:
+	dev_err(acc->dev, "update odr failed 0x%x,0x%x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int lis331hh_register_write(struct lis331hh_data *acc, u8 *buf,
+				   u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return acc->tf->write(acc, reg_address, 1, buf);
+}
+
+static int lis331hh_register_read(struct lis331hh_data *acc, u8 *buf,
+				  u8 reg_address)
+{
+	return acc->tf->read(acc, reg_address, 1, buf);
+}
+
+/* This function must be called with acc->lock taken */
+static int lis331hh_register_update(struct lis331hh_data *acc, u8 *buf,
+				    u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	u8 init_val;
+	u8 updated_val;
+	int err = lis331hh_register_read(acc, buf, reg_address);
+
+	if (err >= 0) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = lis331hh_register_write(acc, buf, reg_address, updated_val);
+	}
+
+	return err;
+}
+
+static int lis331hh_selftest(struct lis331hh_data *acc, u8 enable)
+{
+	int err = -1;
+	u8 buf[2] = { 0x00, 0x00 };
+	char reg_address, mask, bit_values;
+
+	reg_address = CTRL_REG4;
+	mask = 0x0A;
+	if (enable > 0)
+		bit_values = LIS331HH_SELFTEST_EN | LIS331HH_SELFTEST_POS;
+	else
+		bit_values = LIS331HH_SELFTEST_DIS | LIS331HH_SELFTEST_POS;
+
+	if (atomic_read(&acc->enabled)) {
+		mutex_lock(&acc->lock);
+		err = lis331hh_register_update(acc, buf, reg_address, mask,
+					       bit_values);
+		acc->selftest_enabled = enable;
+		mutex_unlock(&acc->lock);
+		if (err < 0)
+			return err;
+
+		acc->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				(~mask & acc->resume_state[RES_CTRL_REG4]));
+	}
+
+	return err;
+}
+
+static int lis331hh_get_acceleration_data(struct lis331hh_data *acc, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x])
+		  : (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y])
+		  : (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
+		  : (hw_d[acc->pdata->axis_map_z]));
+
+#ifdef DEBUG
+		printk(KERN_INFO "%s read x=%d, y=%d, z=%d\n",
+		       LIS331HH_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+#endif
+
+	return err;
+}
+
+static void lis331hh_report_values(struct lis331hh_data *acc, int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static int lis331hh_enable(struct lis331hh_data *acc)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		err = lis331hh_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+		/* Android:
+		 * Udpate polling rate in case odr was changed while sensor disabled */
+		lis331hh_update_odr(acc, acc->pdata->poll_interval);
+		schedule_delayed_work(&acc->input_work,
+			msecs_to_jiffies(acc->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lis331hh_disable(struct lis331hh_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_delayed_work(&acc->input_work);
+		lis331hh_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	int rc = 0;
+	u8 data;
+
+	rc = acc->tf->read(acc, reg, 1, &data);
+	if (rc < 0)
+		return rc;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x = val;
+
+	return acc->tf->write(acc, reg, 1, &x);
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->poll_interval = interval_ms;
+	lis331hh_update_odr(acc, interval_ms);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->g_range ;
+	switch (val) {
+	case LIS331HH_ACC_G_6G:
+		range = 6;
+		break;
+	case LIS331HH_ACC_G_12G:
+		range = 12;
+		break;
+	case LIS331HH_ACC_G_24G:
+		range = 24;
+		break;
+	}
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->pdata->g_range = val;
+	lis331hh_update_g_range(acc, val);
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	
+	if (val)
+		lis331hh_enable(acc);
+	else
+		lis331hh_disable(acc);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->selftest_enabled;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	lis331hh_selftest(acc, val);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_intconfig2(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_get_intconfig2(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG2);
+}
+
+static ssize_t attr_set_duration2(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_get_duration2(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR2);
+}
+
+static ssize_t attr_set_thresh2(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t size)
+{
+	return write_reg(dev, buf, INT_THS2);
+}
+
+static ssize_t attr_get_thresh2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS2);
+}
+static ssize_t attr_get_source2(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC2);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	u8 reg;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	rc = acc->tf->write(acc, x, 1, (u8 *)&val);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 reg;
+
+	mutex_lock(&stat->lock);
+	reg = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	ret = stat->tf->read(stat, reg, 1, buf);
+
+	return ret;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	int ret;
+	u8 reg;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	ret = acc->tf->read(acc, &reg, 1, buf);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lis331hh_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(enable_selftest, 0664, attr_get_selftest, attr_set_selftest),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(int2_config, 0664, attr_get_intconfig2, attr_set_intconfig2),
+	__ATTR(int2_duration, 0664, attr_get_duration2, attr_set_duration2),
+	__ATTR(int2_threshold, 0664, attr_get_thresh2, attr_set_thresh2),
+	__ATTR(int2_source, 0444, attr_get_source2, NULL),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lis331hh_input_work_func(struct work_struct *work)
+{
+	struct lis331hh_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			    struct lis331hh_data, input_work);
+
+	mutex_lock(&acc->lock);
+	err = lis331hh_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_acceleration_data failed\n");
+	else
+		lis331hh_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work,
+			      msecs_to_jiffies(acc->pdata->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+#ifdef LIS331HH_EN_OPEN
+static int lis331hh_input_open(struct input_dev *input)
+{
+	struct lis331hh_data *acc = input_get_drvdata(input);
+
+	return lis331hh_enable(acc);
+}
+
+static void lis331hh_input_close(struct input_dev *dev)
+{
+	struct lis331hh_data *acc = input_get_drvdata(dev);
+
+	lis331hh_disable(acc);
+}
+#endif /* LIS331HH_EN_OPEN */
+
+static int lis331hh_validate_pdata(struct lis331hh_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 || acc->pdata->axis_map_y > 2 ||
+	    acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			acc->pdata->axis_map_x, acc->pdata->axis_map_y,
+			acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1 ||
+	    acc->pdata->negate_z > 1) {
+		dev_err(acc->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			acc->pdata->negate_x, acc->pdata->negate_y,
+			acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis331hh_input_init(struct lis331hh_data *acc)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&acc->input_work, lis331hh_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "input device allocation failed\n");
+		return err;
+	}
+
+#ifdef LIS331HH_EN_OPEN
+	acc->input_dev->open = lis331hh_input_open;
+	acc->input_dev->close = lis331hh_input_close;
+#else /* LIS331HH_EN_OPEN */
+	acc->input_dev->open = NULL;
+	acc->input_dev->close = NULL;
+#endif /* LIS331HH_EN_OPEN */
+	acc->input_dev->name = acc->name;
+	acc->input_dev->id.bustype = acc->bustype;
+	acc->input_dev->dev.parent = acc->dev;
+	input_set_drvdata(acc->input_dev, acc);
+
+	/* Set Misc event type */
+	__set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev,
+			"unable to register input device %s\n",
+			acc->input_dev->name);
+		input_free_device(acc->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lis331hh_input_cleanup(struct lis331hh_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 lis331hh_parse_dt(struct lis331hh_data *acc)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = acc->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "gpio_int1", &val))
+		acc->pdata->gpio_int1 = (u8)val;
+	if (!of_property_read_u32(np, "gpio_int2", &val))
+		acc->pdata->gpio_int2 = (u8)val;
+
+	return 0;
+}
+#endif
+
+int lis331hh_common_probe(struct lis331hh_data *acc)
+{
+	int err = -1;
+
+	pr_info("%s: probe start.\n", LIS331HH_ACC_DEV_NAME);
+
+	mutex_init(&acc->lock);
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kzalloc(sizeof(struct lis331hh_platform_data), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (acc->dev->platform_data == NULL) {
+		memcpy(acc->pdata, &default_lis331hh_pdata,
+		       sizeof(struct lis331hh_platform_data));
+		dev_info(acc->dev, "using default plaform_data\n");
+	} else {
+		memcpy(acc->pdata, acc->dev->platform_data,
+		       sizeof(struct lis331hh_platform_data));
+	}
+
+#ifdef CONFIG_OF
+	/* override default gpio_irq[1,2] if required */
+	lis331hh_parse_dt(acc);
+#endif
+
+	err = lis331hh_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		printk(KERN_INFO "%s: %s has set irq1 to irq: %d "
+		       "mapped on gpio:%d\n", LIS331HH_ACC_DEV_NAME, __func__,
+		        acc->irq1, acc->pdata->gpio_int1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		printk(KERN_INFO "%s: %s has set irq2 to irq: %d "
+		       "mapped on gpio:%d\n", LIS331HH_ACC_DEV_NAME, __func__,
+		       acc->irq2, acc->pdata->gpio_int2);
+	}
+
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+
+	acc->resume_state[RES_CTRL_REG1] = LIS331HH_ACC_ENABLE_ALL_AXES;
+
+	err = lis331hh_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = lis331hh_update_g_range(acc, acc->pdata->g_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_g_range failed\n");
+		goto err_power_off;
+	}
+
+	err = lis331hh_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = lis331hh_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+			"device %s register failed\n",  LIS331HH_ACC_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lis331hh_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&acc->irq1_work, lis331hh_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("lis331hh_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, lis331hh_isr1,
+				  IRQF_TRIGGER_RISING, "lis331hh_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&acc->irq2_work, lis331hh_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("lis331hh_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, lis331hh_isr2,
+				  IRQF_TRIGGER_RISING, "lis331hh_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+				goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(acc->dev, "%s: probed\n", LIS331HH_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if(acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	lis331hh_input_cleanup(acc);
+err_power_off:
+	lis331hh_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+	printk(KERN_ERR "%s: Driver Init failed\n", LIS331HH_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis331hh_common_probe);
+
+int lis331hh_common_remove(struct lis331hh_data *acc)
+{
+	if (acc->pdata->gpio_int1 >= 0) {
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	lis331hh_disable(acc);
+	lis331hh_input_cleanup(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+	kfree(acc->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis331hh_common_remove);
+
+#ifdef CONFIG_PM
+int lis331hh_common_resume(struct lis331hh_data *acc)
+{
+	if (acc->on_before_suspend)
+		return lis331hh_enable(acc);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis331hh_common_resume);
+
+int lis331hh_common_suspend(struct lis331hh_data *acc)
+{
+	acc->on_before_suspend = atomic_read(&acc->enabled);
+
+	return lis331hh_disable(acc);
+}
+EXPORT_SYMBOL(lis331hh_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis331hh accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno, Carmine Iascone, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis331hh/lis331hh.h b/drivers/input/misc/st/acc/lis331hh/lis331hh.h
--- a/drivers/input/misc/st/acc/lis331hh/lis331hh.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331hh/lis331hh.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,166 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lis331hh.h
+* Authors		: MSH - Motion Mems BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+* Version		: V 1.7.1
+* Date			: 2012/10/07
+* Description		: LIS331HH 3D accelerometer sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#ifndef __LIS331HH_H__
+#define __LIS331HH_H__
+
+/*
+#define	DEBUG
+*/
+
+/* Uncomment if want Enable/Disable sensor on Open/Close input device
+#define LIS331HH_EN_OPEN
+*/
+
+/* Device support autoincrement address on spi/i2c interface */
+#define HAS_IF_AUTO_INCREMENT
+
+#define	LIS331HH_ACC_DEV_NAME	"lis331hh"
+
+#define	LIS331HH_ACC_MIN_POLL_PERIOD_MS 1
+
+/* to set gpios numb connected to interrupt pins,
+* the unused ones have to be set to -EINVAL
+*/
+#define LIS331HH_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS331HH_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS331HH_ACC_FS_MASK	0x30
+#define LIS331HH_ACC_G_6G 	0x00
+#define LIS331HH_ACC_G_12G 	0x10
+#define LIS331HH_ACC_G_24G 	0x30
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS331HH_ACC_ENABLE	0x01
+#define LIS331HH_ACC_DISABLE	0x00
+#define LIS331HH_ACC_PM_NORMAL	0x20
+#define LIS331HH_ACC_PM_OFF	LIS331HH_ACC_DISABLE
+
+#define BUFF_RX_MAX_LENGTH	500
+#define BUFF_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		12
+
+#ifdef __KERNEL__
+
+struct lis331hh_data;
+
+struct lis331hh_platform_data {
+	int poll_interval;
+	int min_interval;
+
+	u8 g_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis331hh_transfer_buffer {
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis331hh_transfer_function {
+	int (*write)(struct lis331hh_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis331hh_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis331hh_data {
+	const char *name;
+	struct lis331hh_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	int selftest_enabled;
+
+	atomic_t enabled;
+	int on_before_suspend;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct lis331hh_transfer_function *tf;
+	struct lis331hh_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+/* Input events used by lis2dh driver */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+
+int lis331hh_common_probe(struct lis331hh_data *stat);
+int lis331hh_common_remove(struct lis331hh_data *stat);
+
+#ifdef CONFIG_PM
+int lis331hh_common_resume(struct lis331hh_data *stat);
+int lis331hh_common_suspend(struct lis331hh_data *stat);
+#endif /* CONFIG_PM */
+
+#endif /* __KERNEL__ */
+
+#endif  /* __LIS331HH_H__ */
diff -uNr a/drivers/input/misc/st/acc/lis331hh/lis331hh_i2c.c b/drivers/input/misc/st/acc/lis331hh/lis331hh_i2c.c
--- a/drivers/input/misc/st/acc/lis331hh/lis331hh_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331hh/lis331hh_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,209 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis331hh_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis331hh.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define	I2C_AUTO_INCREMENT	0x80
+#endif
+
+static int lis331hh_i2c_read(struct lis331hh_data *stat, u8 reg_addr,
+			     int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis331hh_i2c_write(struct lis331hh_data *stat, u8 reg_addr,
+			      int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct lis331hh_transfer_function lis331hh_tf_i2c = {
+	.write = lis331hh_i2c_write,
+	.read = lis331hh_i2c_read,
+};
+
+static int lis331hh_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	int err;
+	struct lis331hh_data *stat;
+
+	stat = kzalloc(sizeof(struct lis331hh_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis331hh_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis331hh_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis331hh_i2c_remove(struct i2c_client *client)
+{
+	struct lis331hh_data *stat = i2c_get_clientdata(client);
+
+	lis331hh_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis331hh_suspend(struct device *dev)
+{
+	struct lis331hh_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis331hh_common_suspend(stat);
+}
+
+static int lis331hh_resume(struct device *dev)
+{
+	struct lis331hh_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis331hh_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis331hh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis331hh_suspend, lis331hh_resume)
+};
+
+#define LIS331HH_PM_OPS	(&lis331hh_pm_ops)
+#else /* CONFIG_PM */
+#define LIS331HH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis331hh_ids[] = {
+	{ LIS331HH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis331hh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis331hh_id_table[] = {
+	{ .compatible = "st,lis331hh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis331hh_id_table);
+#endif
+
+static struct i2c_driver lis331hh_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS331HH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS331HH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis331hh_id_table,
+#endif
+	},
+	.remove = lis331hh_i2c_remove,
+	.probe = lis331hh_i2c_probe,
+	.id_table = lis331hh_ids,
+};
+
+module_i2c_driver(lis331hh_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis331hh i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis331hh/lis331hh_spi.c b/drivers/input/misc/st/acc/lis331hh/lis331hh_spi.c
--- a/drivers/input/misc/st/acc/lis331hh/lis331hh_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331hh/lis331hh_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,203 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis331hh_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis331hh.h"
+
+#define SENSORS_SPI_READ	0x80
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define SPI_AUTO_INCREMENT	0x40
+#endif
+
+static int lis331hh_spi_read(struct lis331hh_data *stat, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len);
+
+	return len;
+}
+
+static int lis331hh_spi_write(struct lis331hh_data *stat, u8 reg_addr, int len,
+			      u8 *data)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	memcpy(&stat->tb.tx_buf[1], data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(to_spi_device(stat->dev), &msg);
+}
+
+static struct lis331hh_transfer_function lis331hh_tf_spi = {
+	.write = lis331hh_spi_write,
+	.read = lis331hh_spi_read,
+};
+
+static int lis331hh_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis331hh_data *stat;
+
+	stat = kzalloc(sizeof(struct lis331hh_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis331hh_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis331hh_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis331hh_spi_remove(struct spi_device *spi)
+{
+	struct lis331hh_data *stat = spi_get_drvdata(spi);
+
+	lis331hh_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis331hh_suspend(struct device *dev)
+{
+	struct lis331hh_data *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis331hh_common_suspend(stat);
+}
+
+static int lis331hh_resume(struct device *dev)
+{
+	struct lis331hh_data *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis331hh_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis331hh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis331hh_suspend, lis331hh_resume)
+};
+
+#define LIS331HH_PM_OPS	(&lis331hh_pm_ops)
+#else /* CONFIG_PM */
+#define LIS331HH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis331hh_ids[] = {
+	{ LIS331HH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis331hh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis331hh_id_table[] = {
+	{ .compatible = "st,lis331hh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis331hh_id_table);
+#endif
+
+static struct spi_driver lis331hh_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS331HH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS331HH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis331hh_id_table,
+#endif
+	},
+	.remove = lis331hh_spi_remove,
+	.probe    = lis331hh_spi_probe,
+	.id_table = lis331hh_ids,
+};
+
+module_spi_driver(lis331hh_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis331hh spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis331hh/Makefile b/drivers/input/misc/st/acc/lis331hh/Makefile
--- a/drivers/input/misc/st/acc/lis331hh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis331hh/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis331hh driver
+#
+lis331hh-core-y += lis331hh_core.o
+obj-$(CONFIG_INPUT_LIS331HH) += lis331hh-core.o
+obj-$(CONFIG_INPUT_LIS331HH_I2C) += lis331hh_i2c.o
+obj-$(CONFIG_INPUT_LIS331HH_SPI) += lis331hh_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis3de/Kconfig b/drivers/input/misc/st/acc/lis3de/Kconfig
--- a/drivers/input/misc/st/acc/lis3de/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3de/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS3DE
+	tristate "STMicroelectronics LIS3DE sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS3DE_I2C if (I2C)
+	select INPUT_LIS3DE_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS3DE sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis3de.
+
+config INPUT_LIS3DE_I2C
+	tristate
+	depends on INPUT_LIS3DE
+	depends on I2C
+
+config INPUT_LIS3DE_SPI
+	tristate
+	depends on INPUT_LIS3DE
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis3de/lis3de_core.c b/drivers/input/misc/st/acc/lis3de/lis3de_core.c
--- a/drivers/input/misc/st/acc/lis3de/lis3de_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3de/lis3de_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1330 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : lis3de_core.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Mario Tesi (mario.tesi@st.com)
+ *		      : Both authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.3
+ * Date               : 2016/May/09
+ * Description        : LIS3DE accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ ******************************************************************************
+ Revision 1.0.1: 2012/Oct/12
+  first revision
+ Revision 1.0.2: 2012/Oct/12
+  better get_acceleration_data version. Modified _acc_remove function
+ Revision 1.0.3: 2016/May/09
+  added spi support
+ ******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lis3de.h"
+
+/*#define	DEBUG		1*/
+
+#define	G_MAX			16000000
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS3DE_ACC_ENABLE	0x01
+#define LIS3DE_ACC_DISABLE	0x00
+
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_LIS3DE_ACC	0x33	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define	TEMP_CFG_REG		0x1F	/*	temper sens control reg	*/
+/* ctrl 1: ODR3 ODR2 ODR ODR0 LPen Zenable Yenable Zenable */
+#define	CTRL_REG1		0x20	/*	control reg 1		*/
+#define	CTRL_REG2		0x21	/*	control reg 2		*/
+#define	CTRL_REG3		0x22	/*	control reg 3		*/
+#define	CTRL_REG4		0x23	/*	control reg 4		*/
+#define	CTRL_REG5		0x24	/*	control reg 5		*/
+#define	CTRL_REG6		0x25	/*	control reg 6		*/
+
+#define	FIFO_CTRL_REG		0x2E	/*	FiFo control reg	*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+
+#define	TT_CFG			0x38	/*	tap config		*/
+#define	TT_SRC			0x39	/*	tap source		*/
+#define	TT_THS			0x3A	/*	tap threshold		*/
+#define	TT_LIM			0x3B	/*	tap time limit		*/
+#define	TT_TLAT			0x3C	/*	tap time latency	*/
+#define	TT_TW			0x3D	/*	tap time window		*/
+/*	end CONTROL REGISTRES	*/
+
+#define ALL_ZEROES		0x00
+
+#define LIS3DE_ACC_PM_OFF	0x00
+#define LIS3DE_ACC_ENABLE_ALL_AXES	0x07
+
+#define LIS3DE_ACC_SENSITIVITY_2G	15600	/** ug/digit */
+#define LIS3DE_ACC_SENSITIVITY_4G	31200	/** ug/digit */
+#define LIS3DE_ACC_SENSITIVITY_8G	62500	/** ug/digit */
+#define LIS3DE_ACC_SENSITIVITY_16G	187500	/** ug/digit */
+
+#define PMODE_MASK		0x08
+#define ODR_MASK		0xF0
+
+#define LIS3DE_ACC_ODR1		0x10  /* 1Hz output data rate */
+#define LIS3DE_ACC_ODR10	0x20  /* 10Hz output data rate */
+#define LIS3DE_ACC_ODR25	0x30  /* 25Hz output data rate */
+#define LIS3DE_ACC_ODR50	0x40  /* 50Hz output data rate */
+#define LIS3DE_ACC_ODR100	0x50  /* 100Hz output data rate */
+#define LIS3DE_ACC_ODR200	0x60  /* 200Hz output data rate */
+#define LIS3DE_ACC_ODR400	0x70  /* 400Hz output data rate */
+#define LIS3DE_ACC_ODR1250	0x90  /* 1250Hz output data rate */
+
+#define	IA			0x40
+#define	ZH			0x20
+#define	ZL			0x10
+#define	YH			0x08
+#define	YL			0x04
+#define	XH			0x02
+#define	XL			0x01
+/* */
+/* CTRL REG BITS*/
+#define	CTRL_REG3_I1_AOI1	0x40
+#define	CTRL_REG4_BDU_ENABLE	0x80
+#define	CTRL_REG4_BDU_MASK	0x80
+#define	CTRL_REG6_I2_TAPEN	0x80
+#define	CTRL_REG6_HLACTIVE	0x02
+/* */
+#define NO_MASK			0xFF
+#define INT1_DURATION_MASK	0x7F
+#define	INT1_THRESHOLD_MASK	0x7F
+#define TAP_CFG_MASK		0x3F
+#define	TAP_THS_MASK		0x7F
+#define	TAP_TLIM_MASK		0x7F
+#define	TAP_TLAT_MASK		NO_MASK
+#define	TAP_TW_MASK		NO_MASK
+
+/* TAP_SOURCE_REG BIT */
+#define	DTAP			0x20
+#define	STAP			0x10
+#define	SIGNTAP			0x08
+#define	ZTAP			0x04
+#define	YTAP			0x02
+#define	XTAZ			0x01
+
+#define	FUZZ			0
+#define	FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+/* end RESUME STATE INDICES */
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis3de_odr_table[] = {
+		{    1, LIS3DE_ACC_ODR1250 },
+		{    3, LIS3DE_ACC_ODR400  },
+		{    5, LIS3DE_ACC_ODR200  },
+		{   10, LIS3DE_ACC_ODR100  },
+		{   20, LIS3DE_ACC_ODR50   },
+		{   40, LIS3DE_ACC_ODR25   },
+		{  100, LIS3DE_ACC_ODR10   },
+		{ 1000, LIS3DE_ACC_ODR1    },
+};
+
+static struct lis3de_platform_data default_lis3de_pdata = {
+	.fs_range = LIS3DE_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS3DE_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS3DE_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS3DE_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lis3de_hw_init(struct lis3de_status *stat)
+{
+	int err = -1;
+	u8 buf[7];
+
+	pr_info("%s: hw init start\n", LIS3DE_ACC_DEV_NAME);
+
+	err = stat->tf->read(stat, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(stat->dev,
+			 "Error reading WHO_AM_I: is device available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+
+	if (buf[0] != WHOAMI_LIS3DE_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n",
+			WHOAMI_LIS3DE_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TEMP_CFG_REG];
+	err = stat->tf->write(stat, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_THS];
+	buf[1] = stat->resume_state[RES_TT_LIM];
+	buf[2] = stat->resume_state[RES_TT_TLAT];
+	buf[3] = stat->resume_state[RES_TT_TW];
+	err = stat->tf->write(stat, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_CFG];
+	err = stat->tf->write(stat, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THS1];
+	buf[1] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	buf[3] = stat->resume_state[RES_CTRL_REG5];
+	buf[4] = stat->resume_state[RES_CTRL_REG6];
+	err = stat->tf->write(stat, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LIS3DE_ACC_DEV_NAME);
+
+	return 0;
+
+err_firstread:
+	stat->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev,
+		"hw init error 0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+
+	return err;
+}
+
+static void lis3de_device_power_off(struct lis3de_status *stat)
+{
+	int err;
+	u8 buf = LIS3DE_ACC_PM_OFF;
+
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->hw_initialized = 0;
+	}
+}
+
+static int lis3de_device_power_on(struct lis3de_status *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	if (!stat->hw_initialized) {
+		err = lis3de_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lis3de_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	return 0;
+}
+
+static irqreturn_t lis3de_isr1(int irq, void *dev)
+{
+	struct lis3de_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", LIS3DE_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis3de_isr2(int irq, void *dev)
+{
+	struct lis3de_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", LIS3DE_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lis3de_irq1_work_func(struct work_struct *work)
+{
+	struct lis3de_status *stat =
+	container_of(work, struct lis3de_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis3de_get_int1_source(stat); */
+	pr_debug("%s: IRQ1 triggered\n", LIS3DE_ACC_DEV_NAME);
+	enable_irq(stat->irq1);
+}
+
+static void lis3de_irq2_work_func(struct work_struct *work)
+{
+	struct lis3de_status *stat =
+	container_of(work, struct lis3de_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lis3de_get_tap_source(stat); */
+	pr_debug("%s: IRQ2 triggered\n", LIS3DE_ACC_DEV_NAME);
+	enable_irq(stat->irq2);
+}
+
+static int lis3de_update_fs_range(struct lis3de_status *stat,
+				  u8 new_fs_range)
+{
+	int err = -1;
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	unsigned int new_sensitivity = 0;
+
+	switch (new_fs_range) {
+	case LIS3DE_ACC_G_2G:
+		new_sensitivity = LIS3DE_ACC_SENSITIVITY_2G;
+		break;
+	case LIS3DE_ACC_G_4G:
+		new_sensitivity = LIS3DE_ACC_SENSITIVITY_4G;
+		break;
+	case LIS3DE_ACC_G_8G:
+		new_sensitivity = LIS3DE_ACC_SENSITIVITY_8G;
+		break;
+	case LIS3DE_ACC_G_16G:
+		new_sensitivity = LIS3DE_ACC_SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4,
+	* which contains fs range setting */
+	err = stat->tf->read(stat, CTRL_REG4, 1, &init_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG4] = init_val;
+	new_val = new_fs_range;
+	updated_val = ((LIS3DE_ACC_FS_MASK & new_val) |
+		       ((~LIS3DE_ACC_FS_MASK) & init_val));
+	err = stat->tf->write(stat, CTRL_REG4, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG4] = updated_val;
+	stat->sensitivity = new_sensitivity;
+
+	return err;
+error:
+	dev_err(stat->dev,
+		"update fs range failed 0x%02x,0x%02x: %d\n",
+		CTRL_REG4, updated_val, err);
+
+	return err;
+}
+
+static int lis3de_update_odr(struct lis3de_status *stat,
+			     int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis3de_odr_table) - 1; i >= 0; i--) {
+		if ((lis3de_odr_table[i].cutoff_ms <= poll_interval_ms) || (i == 0))
+			break;
+	}
+	config = lis3de_odr_table[i].mask | LIS3DE_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+
+		stat->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed 0x%02x,0x%02x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int lis3de_register_write(struct lis3de_status *stat,
+				 u8 *buf, u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return stat->tf->write(stat, reg_address, 1, buf);
+}
+
+static int lis3de_get_acceleration_data(struct lis3de_status *stat, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)((s8)acc_data[1])) * stat->sensitivity;
+	hw_d[1] = ((s32)((s8)acc_data[3])) * stat->sensitivity;
+	hw_d[2] = ((s32)((s8)acc_data[5])) * stat->sensitivity;
+
+	xyz[0] = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+#ifdef DEBUG
+
+	dev_info(stat->dev, "%s read x=%d, y=%d, z=%d\n",
+		 LIS3DE_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+
+#endif
+	return err;
+}
+
+static void lis3de_report_values(struct lis3de_status *stat, int *xyz)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(stat->input_dev);
+}
+
+static int lis3de_enable(struct lis3de_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = lis3de_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			return err;
+		}
+
+		schedule_delayed_work(&stat->input_work,
+			msecs_to_jiffies(stat->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lis3de_disable(struct lis3de_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work(&stat->input_work);
+		lis3de_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat, reg, 1, &data);
+	if (err < 0)
+		return err;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		     u8 mask, int resume_index)
+{
+	int err = -1;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+
+	err = lis3de_register_write(stat, x, reg, new_val);
+	if (err < 0)
+		return err;
+
+	stat->resume_state[resume_index] = new_val;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+			    stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	lis3de_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&stat->lock);
+
+	switch (stat->pdata->fs_range) {
+	case LIS3DE_ACC_G_2G:
+		range = 2;
+		break;
+	case LIS3DE_ACC_G_4G:
+		range = 4;
+		break;
+	case LIS3DE_ACC_G_8G:
+		range = 8;
+		break;
+	case LIS3DE_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LIS3DE_ACC_G_2G;
+		break;
+	case 4:
+		range = LIS3DE_ACC_G_4G;
+		break;
+	case 8:
+		range = LIS3DE_ACC_G_8G;
+		break;
+	case 16:
+		range = LIS3DE_ACC_G_16G;
+		break;
+	default:
+		dev_err(stat->dev,
+			"invalid range request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lis3de_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis3de_enable(stat);
+	else
+		lis3de_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1, INT1_THRESHOLD_MASK, RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG functions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	u8 reg;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	reg = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	rc = stat->tf->write(stat, reg, 1, (u8 *)&val);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 reg;
+
+	mutex_lock(&stat->lock);
+	reg = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	ret = stat->tf->read(stat, reg, 1, buf);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lis3de_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	stat->reg_addr = val;
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+	       attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lis3de_input_work_func(struct work_struct *work)
+{
+	struct lis3de_status *stat;
+	int xyz[3] = { 0 };
+	int err;
+
+	stat = container_of((struct delayed_work *)work,
+			    struct lis3de_status, input_work);
+
+	mutex_lock(&stat->lock);
+	err = lis3de_get_acceleration_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_acceleration_data failed\n");
+	else
+		lis3de_report_values(stat, xyz);
+
+	schedule_delayed_work(&stat->input_work, msecs_to_jiffies(
+			stat->pdata->poll_interval));
+	mutex_unlock(&stat->lock);
+}
+
+#ifdef LIS3DE_EN_OPEN
+static int lis3de_input_open(struct input_dev *input)
+{
+	struct lis3de_status *stat = input_get_drvdata(input);
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	return lis3de_enable(stat);
+}
+
+static void lis3de_input_close(struct input_dev *dev)
+{
+	struct lis3de_status *stat = input_get_drvdata(dev);
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+	lis3de_disable(stat);
+}
+#endif /* LIS3DE_EN_OPEN */
+
+static int lis3de_validate_pdata(struct lis3de_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)LIS3DE_ACC_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+			stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			stat->pdata->negate_x,
+			stat->pdata->negate_y,
+			stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis3de_input_init(struct lis3de_status *stat)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&stat->input_work, lis3de_input_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "input device allocation failed\n");
+		return err;
+	}
+
+#ifdef LIS3DE_EN_OPEN
+	stat->input_dev->open = lis3de_input_open;
+	stat->input_dev->close = lis3de_input_close;
+#else /* LIS3DE_EN_OPEN */
+	stat->input_dev->close = NULL;
+	stat->input_dev->open = NULL;
+#endif /* LIS3DE_EN_OPEN */
+	stat->input_dev->name = stat->name;
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	/* Set Misc event type */
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+	}
+
+	return err;
+}
+
+static void lis3de_input_cleanup(struct lis3de_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 lis3de_parse_dt(struct lis3de_status *stat)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = stat->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "gpio_int1", &val))
+		stat->pdata->gpio_int1 = (u8)val;
+	if (!of_property_read_u32(np, "gpio_int2", &val))
+		stat->pdata->gpio_int2 = (u8)val;
+
+	return 0;
+}
+#endif
+
+int lis3de_common_probe(struct lis3de_status *stat)
+{
+	int err = -1;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_lock(&stat->lock);
+
+	stat->pdata = kzalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n",
+			err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata, &default_lis3de_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+#ifdef CONFIG_OF
+	/* override default gpio_irq[1,2] if required */
+	lis3de_parse_dt(stat);
+#endif
+
+	err = lis3de_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		stat->irq1 = gpio_to_irq(stat->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, mapped on gpio:%d\n",
+			LIS3DE_ACC_DEV_NAME, __func__,
+			stat->irq1, stat->pdata->gpio_int1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d, mapped on gpio:%d\n",
+			LIS3DE_ACC_DEV_NAME, __func__,
+			stat->irq2, stat->pdata->gpio_int2);
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = (ALL_ZEROES |
+					     LIS3DE_ACC_ENABLE_ALL_AXES);
+	stat->resume_state[RES_CTRL_REG4] = (ALL_ZEROES | CTRL_REG4_BDU_ENABLE);
+
+	err = lis3de_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lis3de_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3de_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3de_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device %s sysfs register failed\n", LIS3DE_ACC_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lis3de_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&stat->irq1_work, lis3de_irq1_work_func);
+		stat->irq1_work_queue =
+			create_singlethread_workqueue("lis3de_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, lis3de_isr1,
+			IRQF_TRIGGER_RISING, "lis3de_irq1", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&stat->irq2_work, lis3de_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("lis3de_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, lis3de_isr2,
+			IRQF_TRIGGER_RISING, "lis3de_irq2", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", LIS3DE_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if (stat->pdata->gpio_int2 >= 0)
+		destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	if (stat->pdata->gpio_int1 >= 0)
+		destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	lis3de_input_cleanup(stat);
+err_power_off:
+	lis3de_device_power_off(stat);
+err_pdata_init:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	pr_err("%s: Driver Init failed\n", LIS3DE_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis3de_common_probe);
+
+int lis3de_common_remove(struct lis3de_status *stat)
+{
+	dev_info(stat->dev, "driver removing\n");
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lis3de_disable(stat);
+	lis3de_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3de_common_remove);
+
+#ifdef CONFIG_PM
+int lis3de_common_resume(struct lis3de_status *stat)
+{
+	if (stat->on_before_suspend)
+		return lis3de_enable(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3de_common_resume);
+
+int lis3de_common_suspend(struct lis3de_status *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	return lis3de_disable(stat);
+}
+EXPORT_SYMBOL(lis3de_common_suspend);
+
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis3de accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno, Denis Ciocca, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3de/lis3de.h b/drivers/input/misc/st/acc/lis3de/lis3de.h
--- a/drivers/input/misc/st/acc/lis3de/lis3de.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3de/lis3de.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,162 @@
+/******************** (C) COPYRIGHT 2015 STMicroelectronics ********************
+*
+* File Name	: lis3de.h
+* Authors	: AMS - Motion Mems Division - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Denis Ciocca (denis.ciocca@st.com)
+*		: Mario Tesi (mario.tesi@st.com)
+*		: Both authors are willing to be considered the contact
+*		: and update points for the driver.
+* Version	: V.1.0.2
+* Date		: 2013/Jun/17
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#ifndef	__LIS3DE_H__
+#define	__LIS3DE_H__
+
+/* Uncomment if want Enable/Disable sensor on Open/Close input device
+ * #define LIS3DE_EN_OPEN
+ */
+
+#define	LIS3DE_ACC_DEV_NAME		"lis3de"
+
+/************************************************/
+/* 	Output data: ug				*/
+/*	Sysfs enable: enable_device		*/
+/*	Sysfs odr: pollrate_ms			*/
+/*	Sysfs full scale: range			*/
+/************************************************/
+
+#define	LIS3DE_ACC_MIN_POLL_PERIOD_MS	1
+
+#ifdef __KERNEL__
+
+/* to set gpios numb connected to interrupt pins,
+* the unused ones have to be set to -EINVAL
+*/
+#define LIS3DE_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS3DE_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS3DE_ACC_FS_MASK	0x30
+#define LIS3DE_ACC_G_2G		0x00
+#define LIS3DE_ACC_G_4G		0x10
+#define LIS3DE_ACC_G_8G		0x20
+#define LIS3DE_ACC_G_16G	0x30
+
+#define BUFF_RX_MAX_LENGTH	500
+#define BUFF_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		17
+
+struct lis3de_status;
+
+struct lis3de_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis3de_transfer_buffer {
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis3de_transfer_function {
+	int (*write)(struct lis3de_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis3de_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis3de_status {
+	const char *name;
+	struct lis3de_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	struct device *dev;
+	u16 bustype;
+
+	unsigned int sensitivity;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct lis3de_transfer_function *tf;
+	struct lis3de_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+/* Input events used by lis2dh driver */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int lis3de_common_probe(struct lis3de_status *stat);
+int lis3de_common_remove(struct lis3de_status *stat);
+
+#ifdef CONFIG_PM
+int lis3de_common_resume(struct lis3de_status *stat);
+int lis3de_common_suspend(struct lis3de_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LIS3DE_H__ */
+
diff -uNr a/drivers/input/misc/st/acc/lis3de/lis3de_i2c.c b/drivers/input/misc/st/acc/lis3de/lis3de_i2c.c
--- a/drivers/input/misc/st/acc/lis3de/lis3de_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3de/lis3de_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,206 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3de_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis3de.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int lis3de_i2c_read(struct lis3de_status *stat, u8 reg_addr,
+			   int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis3de_i2c_write(struct lis3de_status *stat, u8 reg_addr,
+			    int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct lis3de_transfer_function lis3de_tf_i2c = {
+	.write = lis3de_i2c_write,
+	.read = lis3de_i2c_read,
+};
+
+static int lis3de_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct lis3de_status *stat;
+
+	stat = kmalloc(sizeof(struct lis3de_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis3de_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis3de_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis3de_i2c_remove(struct i2c_client *client)
+{
+	struct lis3de_status *stat = i2c_get_clientdata(client);
+
+	lis3de_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis3de_suspend(struct device *dev)
+{
+	struct lis3de_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis3de_common_suspend(stat);
+}
+
+static int lis3de_resume(struct device *dev)
+{
+	struct lis3de_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis3de_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis3de_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3de_suspend, lis3de_resume)
+};
+
+#define LIS3DE_PM_OPS	(&lis3de_pm_ops)
+#else /* CONFIG_PM */
+#define LIS3DE_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis3de_ids[] = {
+	{ LIS3DE_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis3de_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3de_id_table[] = {
+	{ .compatible = "st,lis3de", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3de_id_table);
+#endif
+
+static struct i2c_driver lis3de_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS3DE_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS3DE_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis3de_id_table,
+#endif
+	},
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0)
+	.remove = __devexit_p(lis3de_i2c_remove),
+#else
+	.remove = lis3de_i2c_remove,
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0) */
+	.probe    = lis3de_i2c_probe,
+	.id_table = lis3de_ids,
+};
+
+module_i2c_driver(lis3de_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis3de i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3de/lis3de_spi.c b/drivers/input/misc/st/acc/lis3de/lis3de_spi.c
--- a/drivers/input/misc/st/acc/lis3de/lis3de_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3de/lis3de_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,196 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3de_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis3de.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int lis3de_spi_read(struct lis3de_status *stat, u8 reg_addr, int len,
+			   u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len);
+
+	return len;
+}
+
+static int lis3de_spi_write(struct lis3de_status *stat, u8 reg_addr, int len,
+			    u8 *data)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+	memcpy(&stat->tb.tx_buf[1], data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(to_spi_device(stat->dev), &msg);
+}
+
+static struct lis3de_transfer_function lis3de_tf_spi = {
+	.write = lis3de_spi_write,
+	.read = lis3de_spi_read,
+};
+
+static int lis3de_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis3de_status *stat;
+
+	stat = kmalloc(sizeof(struct lis3de_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis3de_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis3de_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis3de_spi_remove(struct spi_device *spi)
+{
+	struct lis3de_status *stat = spi_get_drvdata(spi);
+
+	lis3de_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis3de_suspend(struct device *dev)
+{
+	struct lis3de_status *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis3de_common_suspend(stat);
+}
+
+static int lis3de_resume(struct device *dev)
+{
+	struct lis3de_status *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis3de_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis3de_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3de_suspend, lis3de_resume)
+};
+
+#define LIS3DE_PM_OPS	(&lis3de_pm_ops)
+#else /* CONFIG_PM */
+#define LIS3DE_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis3de_ids[] = {
+	{ LIS3DE_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis3de_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3de_id_table[] = {
+	{ .compatible = "st,lis3de", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3de_id_table);
+#endif
+
+static struct spi_driver lis3de_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS3DE_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS3DE_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis3de_id_table,
+#endif
+	},
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0)
+	.remove = __devexit_p(lis3de_spi_remove),
+#else
+	.remove = lis3de_spi_remove,
+#endif /* LINUX_VERSION_CODE <= KERNEL_VERSION(3,3,0) */
+	.probe    = lis3de_spi_probe,
+	.id_table = lis3de_ids,
+};
+
+module_spi_driver(lis3de_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis3de spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3de/Makefile b/drivers/input/misc/st/acc/lis3de/Makefile
--- a/drivers/input/misc/st/acc/lis3de/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3de/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis3de driver
+#
+lis3de-core-y += lis3de_core.o
+obj-$(CONFIG_INPUT_LIS3DE) += lis3de-core.o
+obj-$(CONFIG_INPUT_LIS3DE_I2C) += lis3de_i2c.o
+obj-$(CONFIG_INPUT_LIS3DE_SPI) += lis3de_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis3dh/Kconfig b/drivers/input/misc/st/acc/lis3dh/Kconfig
--- a/drivers/input/misc/st/acc/lis3dh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dh/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS3DH
+	tristate "STMicroelectronics LIS3DH sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS3DH_I2C if (I2C)
+	select INPUT_LIS3DH_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS3DH sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis3dh.
+
+config INPUT_LIS3DH_I2C
+	tristate
+	depends on INPUT_LIS3DH
+	depends on I2C
+
+config INPUT_LIS3DH_SPI
+	tristate
+	depends on INPUT_LIS3DH
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis3dh/lis3dh_core.c b/drivers/input/misc/st/acc/lis3dh/lis3dh_core.c
--- a/drivers/input/misc/st/acc/lis3dh/lis3dh_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dh/lis3dh_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1164 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : lis3dh_acc.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Mario Tesi <mario.tesi@st.com>
+ *		      : Both authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.14
+ * Date               : 2016/Apr/26
+ * Description        : LIS3DH accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ *******************************************************************************/
+/*******************************************************************************
+Version History.
+ Revision 1.0.6 15/11/2010
+  first revision
+  supports sysfs;
+  no more support for ioctl;
+ Revision 1.0.7 26/11/2010
+  checks for availability of interrupts pins
+  correction on FUZZ and FLAT values;
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7
+ Revision 1.0.9: 2011/May/23
+  update_odr func correction;
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lis3dh.h"
+
+#define	G_MAX			16000
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+#define SENSITIVITY_16G		12	/**	mg/LSB	*/
+
+/* Accelerometer Sensor Operating Mode */
+#define LIS3DH_ACC_ENABLE	0x01
+#define LIS3DH_ACC_DISABLE	0x00
+
+#define	HIGH_RESOLUTION		0x08
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_LIS3DH_ACC	0x33	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define	TEMP_CFG_REG		0x1F	/*	temper sens control reg	*/
+/* ctrl 1: ODR3 ODR2 ODR ODR0 LPen Zenable Yenable Zenable */
+#define	CTRL_REG1		0x20	/*	control reg 1		*/
+#define	CTRL_REG2		0x21	/*	control reg 2		*/
+#define	CTRL_REG3		0x22	/*	control reg 3		*/
+#define	CTRL_REG4		0x23	/*	control reg 4		*/
+#define	CTRL_REG5		0x24	/*	control reg 5		*/
+#define	CTRL_REG6		0x25	/*	control reg 6		*/
+
+#define CTRL_STATUS_REG		0x27
+#define ZYXDA_MASK		0x08
+
+#define	FIFO_CTRL_REG		0x2E	/*	FiFo control reg	*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+
+#define	TT_CFG			0x38	/*	tap config		*/
+#define	TT_SRC			0x39	/*	tap source		*/
+#define	TT_THS			0x3A	/*	tap threshold		*/
+#define	TT_LIM			0x3B	/*	tap time limit		*/
+#define	TT_TLAT			0x3C	/*	tap time latency	*/
+#define	TT_TW			0x3D	/*	tap time window		*/
+/*	end CONTROL REGISTRES	*/
+
+
+#define ENABLE_HIGH_RESOLUTION	1
+#define ALL_ZEROES		0x00
+
+#define LIS3DH_ACC_PM_OFF		0x00
+#define LIS3DH_ACC_ENABLE_ALL_AXES	0x07
+#define LIS3DH_ACC_EN_INT1_DRDY		0x10
+
+#define LIS3DH_ACC_ODR1		0x10  /* 1Hz output data rate */
+#define LIS3DH_ACC_ODR10	0x20  /* 10Hz output data rate */
+#define LIS3DH_ACC_ODR25	0x30  /* 25Hz output data rate */
+#define LIS3DH_ACC_ODR50	0x40  /* 50Hz output data rate */
+#define LIS3DH_ACC_ODR100	0x50  /* 100Hz output data rate */
+#define LIS3DH_ACC_ODR200	0x60  /* 200Hz output data rate */
+#define LIS3DH_ACC_ODR400	0x70  /* 400Hz output data rate */
+#define LIS3DH_ACC_ODR1250	0x90  /* 1250Hz output data rate */
+
+#define	IA			0x40
+#define	ZH			0x20
+#define	ZL			0x10
+#define	YH			0x08
+#define	YL			0x04
+#define	XH			0x02
+#define	XL			0x01
+/* */
+/* CTRL REG BITS*/
+#define	CTRL_REG3_I1_AOI1	0x40
+#define	CTRL_REG4_BDU_ENABLE	0x80
+#define	CTRL_REG4_BDU_MASK	0x80
+#define	CTRL_REG6_I2_TAPEN	0x80
+#define	CTRL_REG6_HLACTIVE	0x02
+/* */
+#define NO_MASK			0xFF
+#define INT1_DURATION_MASK	0x7F
+#define	INT1_THRESHOLD_MASK	0x7F
+#define TAP_CFG_MASK		0x3F
+#define	TAP_THS_MASK		0x7F
+#define	TAP_TLIM_MASK		0x7F
+#define	TAP_TLAT_MASK		NO_MASK
+#define	TAP_TW_MASK		NO_MASK
+
+
+/* TAP_SOURCE_REG BIT */
+#define	DTAP			0x20
+#define	STAP			0x10
+#define	SIGNTAP			0x08
+#define	ZTAP			0x04
+#define	YTAP			0x02
+#define	XTAZ			0x01
+
+#define	FUZZ			0
+#define	FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+
+/* end RESUME STATE INDICES */
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis3dh_acc_odr_table[] = {
+		{    1, LIS3DH_ACC_ODR1250 },
+		{    3, LIS3DH_ACC_ODR400  },
+		{    5, LIS3DH_ACC_ODR200  },
+		{   10, LIS3DH_ACC_ODR100  },
+		{   20, LIS3DH_ACC_ODR50   },
+		{   40, LIS3DH_ACC_ODR25   },
+		{  100, LIS3DH_ACC_ODR10   },
+		{ 1000, LIS3DH_ACC_ODR1    },
+};
+
+static int int1_gpio = LIS3DH_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LIS3DH_ACC_DEFAULT_INT2_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+module_param(int2_gpio, int, S_IRUGO);
+
+static struct lis3dh_acc_platform_data default_lis3dh_acc_pdata = {
+	.fs_range = LIS3DH_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LIS3DH_ACC_MIN_POLL_PERIOD_MS,
+};
+
+static int lis3dh_acc_hw_init(struct lis3dh_acc_status *stat)
+{
+	int err = -1;
+	u8 buf[5];
+
+	pr_info("%s: hw init start\n", LIS3DH_ACC_DEV_NAME);
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TEMP_CFG_REG];
+	err = stat->tf->write(stat, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_THS];
+	buf[1] = stat->resume_state[RES_TT_LIM];
+	buf[2] = stat->resume_state[RES_TT_TLAT];
+	buf[3] = stat->resume_state[RES_TT_TW];
+	err = stat->tf->write(stat, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_CFG];
+	err = stat->tf->write(stat, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THS1];
+	buf[1] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	buf[3] = stat->resume_state[RES_CTRL_REG5];
+	buf[4] = stat->resume_state[RES_CTRL_REG6];
+	err = stat->tf->write(stat, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LIS3DH_ACC_DEV_NAME);
+
+	return 0;
+
+	stat->hw_working = 0;
+
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error: %d\n", err);
+
+	return err;
+}
+
+static void lis3dh_acc_device_power_off(struct lis3dh_acc_status *stat)
+{
+	int err;
+	u8 buf = LIS3DH_ACC_PM_OFF;
+
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off) {
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized)
+		stat->hw_initialized = 0;
+}
+
+static int lis3dh_acc_device_power_on(struct lis3dh_acc_status *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"power_on failed: %d\n", err);
+
+			return err;
+		}
+	}
+
+	if (!stat->hw_initialized) {
+		err = lis3dh_acc_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lis3dh_acc_device_power_off(stat);
+
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lis3dh_acc_update_fs_range(struct lis3dh_acc_status *stat,
+				      u8 new_fs_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = LIS3DH_ACC_FS_MASK | HIGH_RESOLUTION;
+
+	switch (new_fs_range) {
+	case LIS3DH_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LIS3DH_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LIS3DH_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case LIS3DH_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4, which contains fs range setting */
+	err = stat->tf->read(stat, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+
+	init_val = buf[0];
+	stat->resume_state[RES_CTRL_REG4] = init_val;
+	new_val = new_fs_range | HIGH_RESOLUTION;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+	err = stat->tf->write(stat, CTRL_REG4, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG4] = updated_val;
+	stat->sensitivity = sensitivity;
+
+	return err;
+
+error:
+	dev_err(stat->dev,
+		"update fs range failed 0x%02x,0x%02x: %d\n",
+		buf[0], buf[1], err);
+
+	return err;
+}
+
+static int lis3dh_acc_update_odr(struct lis3dh_acc_status *stat,
+				 int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis3dh_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lis3dh_acc_odr_table[i].cutoff_ms <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+	config = lis3dh_acc_odr_table[i].mask | LIS3DH_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+	}
+	stat->resume_state[RES_CTRL_REG1] = config;
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed 0x%02x,0x%02x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int lis3dh_acc_register_write(struct lis3dh_acc_status *stat,
+				     u8 *buf, u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return stat->tf->write(stat, reg_address, 1, buf);
+}
+
+static int lis3dh_acc_get_acceleration_data(struct lis3dh_acc_status *stat,
+					    int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * stat->sensitivity;
+	hw_d[1] = hw_d[1] * stat->sensitivity;
+	hw_d[2] = hw_d[2] * stat->sensitivity;
+
+	xyz[0] = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+	return err;
+}
+
+/* Input events chenged to EV_MSC */
+static void lis3dh_acc_report_values(struct lis3dh_acc_status *stat,
+				     int *xyz, int64_t timestamp)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(stat->input_dev);
+}
+
+static int lis3dh_acc_enable(struct lis3dh_acc_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = lis3dh_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+
+			return err;
+		}
+		lis3dh_acc_update_odr(stat, stat->pdata->poll_interval);
+		enable_irq(stat->irq);
+	}
+
+	return 0;
+}
+
+static int lis3dh_acc_disable(struct lis3dh_acc_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		lis3dh_acc_device_power_off(stat);
+		disable_irq_nosync(stat->irq);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat, reg, 1, &data);
+	if (err < 0)
+		return err;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		     u8 mask, int resumeIndex)
+{
+	int err = -1;
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = lis3dh_acc_register_write(stat, x, reg, new_val);
+	if (err >= 0)
+		stat->resume_state[resumeIndex] = new_val;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	lis3dh_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range ;
+	switch (val) {
+	case LIS3DH_ACC_G_2G:
+		range = 2;
+		break;
+	case LIS3DH_ACC_G_4G:
+		range = 4;
+		break;
+	case LIS3DH_ACC_G_8G:
+		range = 8;
+		break;
+	case LIS3DH_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LIS3DH_ACC_G_2G;
+		break;
+	case 4:
+		range = LIS3DH_ACC_G_4G;
+		break;
+	case 8:
+		range = LIS3DH_ACC_G_8G;
+		break;
+	case 16:
+		range = LIS3DH_ACC_G_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lis3dh_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis3dh_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis3dh_acc_enable(stat);
+	else
+		lis3dh_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1, INT1_THRESHOLD_MASK, RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+							attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+#ifdef LIS3DH_EN_OPEN_CLOSE
+static int lis3dh_acc_input_open(struct input_dev *input)
+{
+	struct lis3dh_acc_status *stat = input_get_drvdata(input);
+
+	return lis3dh_acc_enable(stat);
+}
+
+static void lis3dh_acc_input_close(struct input_dev *dev)
+{
+	struct lis3dh_acc_status *stat = input_get_drvdata(dev);
+
+	lis3dh_acc_disable(stat);
+}
+#endif
+
+static int lis3dh_acc_validate_pdata(struct lis3dh_acc_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)LIS3DH_ACC_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					 stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 || stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y, stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", stat->pdata->negate_x,
+			stat->pdata->negate_y, stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lis3dh_acc_input_init(struct lis3dh_acc_status *stat)
+{
+	int err;
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		dev_err(stat->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	stat->input_dev->name = LIS3DH_ACC_DEV_NAME;
+#ifdef LIS3DH_EN_OPEN_CLOSE
+	stat->input_dev->open = lis3dh_acc_input_open;
+	stat->input_dev->close = lis3dh_acc_input_close;
+#endif
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+	}
+
+	return err;
+}
+
+static void lis3dh_acc_input_cleanup(struct lis3dh_acc_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+static irqreturn_t lis3dh_acc_save_timestamp(int irq, void *private)
+{
+	struct lis3dh_acc_status *stat = (struct lis3dh_acc_status *)private;
+
+	disable_irq_nosync(irq);
+	stat->timestamp = lis3dh_acc_get_time_ns();
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t lis3dh_acc_thread_fn(int irq, void *private)
+{
+	int err, xyz[3] = {};
+	struct lis3dh_acc_status *stat = (struct lis3dh_acc_status *)private;
+
+	mutex_lock(&stat->lock);
+
+	err = lis3dh_acc_get_acceleration_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_acceleration_data failed\n");
+	else
+		lis3dh_acc_report_values(stat, xyz, stat->timestamp);
+
+	mutex_unlock(&stat->lock);
+
+	enable_irq(irq);
+	return IRQ_HANDLED;
+}
+
+/*
+ * struct lis3dh_acc_status *stat is allocated/freed in tf probing
+ * so let it manage this stuff
+ */
+int lis3dh_acc_probe(struct lis3dh_acc_status *stat, int irq)
+{
+	int err = -1;
+	u8 wai = 0;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+
+	/* Check device ID and bus connection */
+	err = stat->tf->read(stat, WHO_AM_I, 1, &wai);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I:"
+			 " is device available/working?\n");
+
+		return err;
+	}
+
+	if (wai != WHOAMI_LIS3DH_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_LIS3DH_ACC, wai);
+
+		return -ENODEV;
+	}
+
+	mutex_lock(&stat->lock);
+	
+	stat->hw_working = 1;
+	stat->pdata = kmalloc(sizeof(struct lis3dh_acc_platform_data), GFP_KERNEL);
+	if (!stat->pdata) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata, &default_lis3dh_acc_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = lis3dh_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = (ALL_ZEROES |
+					     LIS3DH_ACC_ENABLE_ALL_AXES);
+	stat->resume_state[RES_CTRL_REG3] = LIS3DH_ACC_EN_INT1_DRDY;
+	stat->resume_state[RES_CTRL_REG4] = (ALL_ZEROES | CTRL_REG4_BDU_ENABLE);
+
+	err = lis3dh_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lis3dh_acc_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3dh_acc_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3dh_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device LIS3DH_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lis3dh_acc_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if (irq > 0) {
+		stat->irq = irq;
+
+		err = request_threaded_irq(irq, lis3dh_acc_save_timestamp,
+					   lis3dh_acc_thread_fn,
+					   IRQF_TRIGGER_HIGH, stat->name,
+					   stat);
+		if (err < 0)
+			goto err_remove_sysfs_int;
+
+		disable_irq_nosync(irq);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", LIS3DH_ACC_DEV_NAME);
+
+	return 0;
+
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	lis3dh_acc_input_cleanup(stat);
+err_power_off:
+	lis3dh_acc_device_power_off(stat);
+err_pdata_init:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	pr_err("%s: Driver Init failed\n", LIS3DH_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis3dh_acc_probe);
+
+int lis3dh_acc_remove(struct lis3dh_acc_status *stat)
+{
+	dev_info(stat->dev, "driver removing\n");
+
+	lis3dh_acc_disable(stat);
+	lis3dh_acc_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+	kfree(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3dh_acc_remove);
+
+#ifdef CONFIG_PM
+int lis3dh_acc_common_resume(struct lis3dh_acc_status *stat)
+{
+	if (stat->on_before_suspend)
+		return lis3dh_acc_enable(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3dh_acc_common_resume);
+
+int lis3dh_acc_common_suspend(struct lis3dh_acc_status *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	return lis3dh_acc_disable(stat);
+}
+EXPORT_SYMBOL(lis3dh_acc_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis3dh accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Mario tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3dh/lis3dh.h b/drivers/input/misc/st/acc/lis3dh/lis3dh.h
--- a/drivers/input/misc/st/acc/lis3dh/lis3dh.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dh/lis3dh.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,172 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3dh_acc.h
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Mario Tesi <mario.tesi@st.com>
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+  renamed field g_range to fs_range in lis3dh_acc_platform_data;
+  replaced defines SA0L and SA0H with LIS3DH_SAD0x
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+*******************************************************************************/
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+
+#ifndef	__LIS3DH_H__
+#define	__LIS3DH_H__
+
+/* Uncomment if want enable/disable on open/close input device */
+//#define LIS3DH_EN_OPEN_CLOSE
+
+#define	LIS3DH_ACC_DEV_NAME		"lis3dh_acc"
+
+#define	LIS3DH_ACC_MIN_POLL_PERIOD_MS	1
+
+#ifdef __KERNEL__
+
+#define LIS3DH_SAD0L			0x00
+#define LIS3DH_SAD0H			0x01
+
+#define LIS3DH_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS3DH_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LIS3DH_ACC_FS_MASK		0x30
+#define LIS3DH_ACC_G_2G			0x00
+#define LIS3DH_ACC_G_4G			0x10
+#define LIS3DH_ACC_G_8G			0x20
+#define LIS3DH_ACC_G_16G		0x30
+
+#define BUFF_RX_MAX_LENGTH		500
+#define BUFF_TX_MAX_LENGTH		500
+
+#define	RESUME_ENTRIES			17
+
+struct lis3dh_acc_status;
+
+struct lis3dh_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis3dh_acc_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis3dh_acc_transfer_function {
+	int (*write)(struct lis3dh_acc_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis3dh_acc_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis3dh_acc_status {
+	const char *name;
+	struct lis3dh_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	int use_smbus;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq;
+	int64_t timestamp;
+
+	struct lis3dh_acc_transfer_function *tf;
+	struct lis3dh_acc_transfer_buffer tb;
+};
+
+static inline s64 lis3dh_acc_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+/* Input events used by lis3dh driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+int lis3dh_acc_probe(struct lis3dh_acc_status *stat, int irq);
+int lis3dh_acc_remove(struct lis3dh_acc_status *stat);
+
+#ifdef CONFIG_PM
+int lis3dh_acc_common_resume(struct lis3dh_acc_status *stat);
+int lis3dh_acc_common_suspend(struct lis3dh_acc_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LIS3DH_H__ */
diff -uNr a/drivers/input/misc/st/acc/lis3dh/lis3dh_i2c.c b/drivers/input/misc/st/acc/lis3dh/lis3dh_i2c.c
--- a/drivers/input/misc/st/acc/lis3dh/lis3dh_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dh/lis3dh_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,193 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3dh_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis3dh.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int lis3dh_acc_i2c_read(struct lis3dh_acc_status *stat, u8 reg_addr,
+			       int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(stat->dev);
+	int tries = 0;
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis3dh_acc_i2c_write(struct lis3dh_acc_status *stat, u8 reg_addr,
+				int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static struct lis3dh_acc_transfer_function lis3dh_acc_tf_i2c = {
+	.write = lis3dh_acc_i2c_write,
+	.read = lis3dh_acc_i2c_read,
+};
+
+static int lis3dh_acc_i2c_probe(struct i2c_client *client,
+			        const struct i2c_device_id *id)
+{
+	int err;
+	struct lis3dh_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct lis3dh_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis3dh_acc_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis3dh_acc_probe(stat, client->irq);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+	return err;
+}
+
+static int lis3dh_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lis3dh_acc_status *stat = i2c_get_clientdata(client);
+
+	lis3dh_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis3dh_acc_suspend(struct device *dev)
+{
+	struct lis3dh_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis3dh_acc_common_suspend(stat);
+}
+
+static int lis3dh_acc_resume(struct device *dev)
+{
+	struct lis3dh_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis3dh_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis3dh_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3dh_acc_suspend, lis3dh_acc_resume)
+};
+
+#define LIS3DH_PM_OPS		(&lis3dh_acc_pm_ops)
+#else /* CONFIG_PM */
+#define LIS3DH_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis3dh_acc_ids[] = {
+	{ LIS3DH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis3dh_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3dh_acc_id_table[] = {
+	{ .compatible = "st,lis3dh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3dh_acc_id_table);
+#endif
+
+static struct i2c_driver lis3dh_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS3DH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS3DH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis3dh_acc_id_table,
+#endif
+	},
+	.remove = lis3dh_acc_i2c_remove,
+	.probe = lis3dh_acc_i2c_probe,
+	.id_table = lis3dh_acc_ids,
+};
+
+module_i2c_driver(lis3dh_acc_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis3dh i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3dh/lis3dh_spi.c b/drivers/input/misc/st/acc/lis3dh/lis3dh_spi.c
--- a/drivers/input/misc/st/acc/lis3dh/lis3dh_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dh/lis3dh_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,211 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3dh_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis3dh.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int lis3dh_acc_spi_read(struct lis3dh_acc_status *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(stat->dev);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, stat->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static int lis3dh_acc_spi_write(struct lis3dh_acc_status *stat, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(stat->dev);
+
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(spi, &msg);
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static struct lis3dh_acc_transfer_function lis3dh_acc_tf_spi = {
+	.write = lis3dh_acc_spi_write,
+	.read = lis3dh_acc_spi_read,
+};
+
+static int lis3dh_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis3dh_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct lis3dh_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis3dh_acc_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis3dh_acc_probe(stat, spi->irq);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis3dh_acc_spi_remove(struct spi_device *spi)
+{
+	struct lis3dh_acc_status *stat = spi_get_drvdata(spi);
+
+	lis3dh_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis3dh_acc_suspend(struct device *dev)
+{
+	struct lis3dh_acc_status *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis3dh_acc_common_suspend(stat);
+}
+
+static int lis3dh_acc_resume(struct device *dev)
+{
+	struct lis3dh_acc_status *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis3dh_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis3dh_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3dh_acc_suspend, lis3dh_acc_resume)
+};
+
+#define LIS3DH_PM_OPS		(&lis3dh_acc_pm_ops)
+#else /* CONFIG_PM */
+#define LIS3DH_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis3dh_acc_ids[] = {
+	{ LIS3DH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis3dh_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3dh_acc_id_table[] = {
+	{ .compatible = "st,lis3dh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3dh_acc_id_table);
+#endif
+
+static struct spi_driver lis3dh_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS3DH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS3DH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis3dh_acc_id_table,
+#endif
+	},
+	.remove = lis3dh_acc_spi_remove,
+	.probe = lis3dh_acc_spi_probe,
+	.id_table = lis3dh_acc_ids,
+};
+
+module_spi_driver(lis3dh_acc_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis3dh spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3dh/Makefile b/drivers/input/misc/st/acc/lis3dh/Makefile
--- a/drivers/input/misc/st/acc/lis3dh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dh/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis3dh driver
+#
+lis3dh-core-y += lis3dh_core.o
+obj-$(CONFIG_INPUT_LIS3DH) += lis3dh-core.o
+obj-$(CONFIG_INPUT_LIS3DH_I2C) += lis3dh_i2c.o
+obj-$(CONFIG_INPUT_LIS3DH_SPI) += lis3dh_spi.o
diff -uNr a/drivers/input/misc/st/acc/lis3dsh/Kconfig b/drivers/input/misc/st/acc/lis3dsh/Kconfig
--- a/drivers/input/misc/st/acc/lis3dsh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dsh/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LIS3DSH
+	tristate "STMicroelectronics LIS3DSH sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LIS3DSH_I2C if (I2C)
+	select INPUT_LIS3DSH_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LIS3DSH sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis3dsh.
+
+config INPUT_LIS3DSH_I2C
+	tristate
+	depends on INPUT_LIS3DSH
+	depends on I2C
+
+config INPUT_LIS3DSH_SPI
+	tristate
+	depends on INPUT_LIS3DSH
+	depends on SPI
diff -uNr a/drivers/input/misc/st/acc/lis3dsh/lis3dsh_core.c b/drivers/input/misc/st/acc/lis3dsh/lis3dsh_core.c
--- a/drivers/input/misc/st/acc/lis3dsh/lis3dsh_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dsh/lis3dsh_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1606 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name		: lis3dsh_core.c
+ * Authors		: MSH - Motion Mems BU - Application Team
+ *			: Matteo Dameno (matteo.dameno@st.com)
+ *			: Denis Ciocca (denis.ciocca@st.com)
+ *			: Mario Tesi (mario.tesi@st.com)
+ *			: Author is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V.1.2.3
+ * Date			: 2016/May/16
+ * Description		: LIS3DSH accelerometer driver
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+ *
+ ******************************************************************************
+Version History.
+	V 1.0.0		First Release
+	V 1.0.2		I2C address bugfix
+	V 1.2.0		Registers names compliant to correct datasheet
+	V.1.2.1		Removed enable_interrupt_output sysfs file, manage int1
+			and int2, implements int1 isr.
+	V.1.2.2		Modified state program loadiing defines, removed
+			state machine program.
+	V.1.2.3		Added support to spi interface.
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include "lis3dsh.h"
+
+//#define DEBUG
+
+/* set to 1 to enable SM program and parameters loading */
+/* set to 0 to leave unused */
+#define LOAD_SM1_PROGRAM	1
+#define LOAD_SP1_PARAMETERS	1
+#define LOAD_SM2_PROGRAM	1
+#define LOAD_SP2_PARAMETERS	1
+
+#define G_MAX			23920640	/* ug */
+
+#define SENSITIVITY_2G		60		/* ug/LSB	*/
+#define SENSITIVITY_4G		120		/* ug/LSB	*/
+#define SENSITIVITY_6G		180		/* ug/LSB	*/
+#define SENSITIVITY_8G		240		/* ug/LSB	*/
+#define SENSITIVITY_16G		730		/* ug/LSB	*/
+
+#define LIS3DSH_FS_MASK		0x38
+
+/* Output Data Rates ODR */
+#define LIS3DSH_ODR_MASK	0XF0
+#define LIS3DSH_PM_OFF		0x00		/* OFF */
+#define LIS3DSH_ODR3_125	0x10		/*    3.125 Hz */
+#define LIS3DSH_ODR6_25		0x20		/*    6.25  Hz */
+#define LIS3DSH_ODR12_5		0x30		/*   12.5   Hz */
+#define LIS3DSH_ODR25		0x40		/*   25     Hz */
+#define LIS3DSH_ODR50		0x50		/*   50     Hz */
+#define LIS3DSH_ODR100		0x60		/*  100     Hz */
+#define LIS3DSH_ODR400		0x70		/*  400     Hz */
+#define LIS3DSH_ODR800		0x80		/*  800     Hz */
+#define LIS3DSH_ODR1600		0x90		/* 1600     Hz */
+
+/* CTRLREG1 */
+#define LIS3DSH_HIST1_MASK	0xE0
+#define LIS3DSH_SM1INT_PIN_MASK	0x08
+#define LIS3DSH_SM1INT_PININT2	0x08
+#define LIS3DSH_SM1INT_PININT1	0x00
+#define LIS3DSH_SM1_EN_MASK	0x01
+#define LIS3DSH_SM1_EN_ON	0x01
+#define LIS3DSH_SM1_EN_OFF	0x00
+/* */
+
+/* CTRLREG2 */
+#define LIS3DSH_HIST2_MASK	0xE0
+#define LIS3DSH_SM2INT_PIN_MASK	0x08
+#define LIS3DSH_SM2INT_PININT2	0x08
+#define LIS3DSH_SM2INT_PININT1	0x00
+#define LIS3DSH_SM2_EN_MASK	0x01
+#define LIS3DSH_SM2_EN_ON	0x01
+#define LIS3DSH_SM2_EN_OFF	0x00
+/* */
+
+/* CTRLREG3 */
+#define LIS3DSH_INT_ACT_MASK	(0x01 << 6)
+#define LIS3DSH_INT_ACT_H	(0x01 << 6)
+#define LIS3DSH_INT_ACT_L	0x00
+
+#define LIS3DSH_INT2_EN_MASK	(0x01 << 4)
+#define LIS3DSH_INT2_EN_ON	(0x01 << 4)
+#define LIS3DSH_INT2_EN_OFF	0x00
+
+#define LIS3DSH_INT1_EN_MASK	(0x01 << 3)
+#define LIS3DSH_INT1_EN_ON	(0x01 << 3)
+#define LIS3DSH_INT1_EN_OFF	0x00
+/* */
+
+/* CTRLREG4 */
+#define LIS3DSH_BDU_EN		0x08
+#define LIS3DSH_ALL_AXES	0x07
+/* */
+
+/* STATUS REG BITS */
+#define LIS3DSH_STAT_INTSM1_BIT	(0x01 << 3)
+#define LIS3DSH_STAT_INTSM2_BIT	(0x01 << 2)
+
+#define OUT_AXISDATA_REG	LIS3DSH_OUTX_L
+#define WHOAMI_LIS3DSH_ACC	0x3F	/* Expected content for WAI */
+
+/*	CONTROL REGISTERS	*/
+#define LIS3DSH_WHO_AM_I	0x0F	/* WhoAmI register Address */
+
+#define LIS3DSH_OUTX_L		0x28	/* Output X LSByte */
+#define LIS3DSH_OUTX_H		0x29	/* Output X MSByte */
+#define LIS3DSH_OUTY_L		0x2A	/* Output Y LSByte */
+#define LIS3DSH_OUTY_H		0x2B	/* Output Y MSByte */
+#define LIS3DSH_OUTZ_L		0x2C	/* Output Z LSByte */
+#define LIS3DSH_OUTZ_H		0x2D	/* Output Z MSByte */
+#define LIS3DSH_LC_L		0x16	/* LSByte Long Counter Status */
+#define LIS3DSH_LC_H		0x17	/* MSByte Long Counter Status */
+
+#define LIS3DSH_INTERR_STAT	0x18	/* Interrupt Status */
+
+#define LIS3DSH_STATUS_REG	0x27	/* Status */
+
+#define LIS3DSH_CTRL_REG1	0x21	/* control reg 1 */
+#define LIS3DSH_CTRL_REG2	0x22	/* control reg 2 */
+#define LIS3DSH_CTRL_REG3	0x23	/* control reg 3 */
+#define LIS3DSH_CTRL_REG4	0x20	/* control reg 4 */
+#define LIS3DSH_CTRL_REG5	0x24	/* control reg 5 */
+#define LIS3DSH_CTRL_REG6	0x25	/* control reg 6 */
+
+#define LIS3DSH_OFF_X		0x10	/* Offset X Corr */
+#define LIS3DSH_OFF_Y		0x11	/* Offset Y Corr */
+#define LIS3DSH_OFF_Z		0x12	/* Offset Z Corr */
+
+#define LIS3DSH_CS_X		0x13	/* Const Shift X */
+#define LIS3DSH_CS_Y		0x14	/* Const Shift Y */
+#define LIS3DSH_CS_Z		0x15	/* Const Shift Z */
+
+#define LIS3DSH_VFC_1		0x1B	/* Vect Filter Coeff 1 */
+#define LIS3DSH_VFC_2		0x1C	/* Vect Filter Coeff 2 */
+#define LIS3DSH_VFC_3		0x1D	/* Vect Filter Coeff 3 */
+#define LIS3DSH_VFC_4		0x1E	/* Vect Filter Coeff 4 */
+
+	/* state program 1 */
+#define LIS3DSH_STATEPR1	0X40	/*	State Program 1 16 bytes */
+
+#define LIS3DSH_TIM4_1		0X50	/*	SPr1 Timer4		*/
+#define LIS3DSH_TIM3_1		0X51	/*	SPr1 Timer3		*/
+#define LIS3DSH_TIM2_1		0X52	/*	SPr1 Timer2	2bytes	*/
+#define LIS3DSH_TIM1_1		0X54	/*	SPr1 Timer1	2bytes	*/
+
+#define LIS3DSH_THRS2_1		0X56	/*	SPr1 Threshold1		*/
+#define LIS3DSH_THRS1_1		0X57	/*	SPr1 Threshold2		*/
+#define LIS3DSH_SA_1		0X59	/*	SPr1 Swap Axis Sign Msk	*/
+#define LIS3DSH_MA_1		0X5A	/*	SPr1 Axis Sign Msk	*/
+#define LIS3DSH_SETT_1		0X5B	/*	SPr1 			*/
+#define LIS3DSH_PPRP_1		0X5C	/*	SPr1 ProgPointer ResetPointer */
+#define LIS3DSH_TC_1		0X5D	/*	SPr1 		2bytes	*/
+#define LIS3DSH_OUTS_1		0X5F	/*	SPr1 			*/
+
+	/* state program 2 */
+#define LIS3DSH_STATEPR2	0X60	/*	State Program 2 16 bytes */
+
+#define LIS3DSH_TIM4_2		0X70	/*	SPr2 Timer4		*/
+#define LIS3DSH_TIM3_2		0X71	/*	SPr2 Timer3		*/
+#define LIS3DSH_TIM2_2		0X72	/*	SPr2 Timer2	2bytes	*/
+#define LIS3DSH_TIM1_2		0X74	/*	SPr2 Timer1	2bytes	*/
+
+#define LIS3DSH_THRS2_2		0X76	/*	SPr2 Threshold1		*/
+#define LIS3DSH_THRS1_2		0X77	/*	SPr2 Threshold2		*/
+#define LIS3DSH_DES_2		0X78	/*	SPr2 Decimation		*/
+#define LIS3DSH_SA_2		0X79	/*	SPr2 Swap Axis Sign Msk	*/
+#define LIS3DSH_MA_2		0X7A	/*	SPr2 Axis Sign Msk	*/
+#define LIS3DSH_SETT_2		0X7B	/*	SPr2 			*/
+#define LIS3DSH_PPRP_2		0X7C	/*	SPr2 ProgPointer ResetPointer */
+#define LIS3DSH_TC_2		0X7D	/*	SPr2 		2bytes	*/
+#define LIS3DSH_OUTS_2		0X7F	/*	SPr2 			*/
+/*	end CONTROL REGISTRES	*/
+
+
+/* RESUME STATE INDICES */
+#define RES_LIS3DSH_LC_L		0
+#define RES_LIS3DSH_LC_H		1
+
+#define RES_LIS3DSH_CTRL_REG4		2
+#define RES_LIS3DSH_CTRL_REG1		3
+#define RES_LIS3DSH_CTRL_REG2		4
+#define RES_LIS3DSH_CTRL_REG3		5
+#define RES_LIS3DSH_CTRL_REG5		6
+#define RES_LIS3DSH_CTRL_REG6		7
+
+#define RES_LIS3DSH_OFF_X		8
+#define RES_LIS3DSH_OFF_Y		9
+#define RES_LIS3DSH_OFF_Z		10
+
+#define RES_LIS3DSH_CS_X		11
+#define RES_LIS3DSH_CS_Y		12
+#define RES_LIS3DSH_CS_Z		13
+
+#define RES_LIS3DSH_VFC_1		14
+#define RES_LIS3DSH_VFC_2		15
+#define RES_LIS3DSH_VFC_3		16
+#define RES_LIS3DSH_VFC_4		17
+
+#define RES_LIS3DSH_THRS3		18
+
+#define RES_LIS3DSH_TIM4_1		20
+#define RES_LIS3DSH_TIM3_1		21
+#define RES_LIS3DSH_TIM2_1_L		22
+#define RES_LIS3DSH_TIM2_1_H		23
+#define RES_LIS3DSH_TIM1_1_L		24
+#define RES_LIS3DSH_TIM1_1_H		25
+
+#define RES_LIS3DSH_THRS2_1		26
+#define RES_LIS3DSH_THRS1_1		27
+#define RES_LIS3DSH_SA_1		28
+#define RES_LIS3DSH_MA_1		29
+#define RES_LIS3DSH_SETT_1		30
+
+#define RES_LIS3DSH_TIM4_2		31
+#define RES_LIS3DSH_TIM3_2		32
+#define RES_LIS3DSH_TIM2_2_L		33
+#define RES_LIS3DSH_TIM2_2_H		34
+#define RES_LIS3DSH_TIM1_2_L		35
+#define RES_LIS3DSH_TIM1_2_H		36
+
+#define RES_LIS3DSH_THRS2_2		37
+#define RES_LIS3DSH_THRS1_2		38
+#define RES_LIS3DSH_DES_2		39
+#define RES_LIS3DSH_SA_2		40
+#define RES_LIS3DSH_MA_2		41
+#define RES_LIS3DSH_SETT_2		42
+
+/* end RESUME STATE INDICES */
+
+/* STATE PROGRAMS ENABLE CONTROLS */
+#define LIS3DSH_SM1_DIS_SM2_DIS		0x00
+#define LIS3DSH_SM1_EN_SM2_DIS		0x01
+#define LIS3DSH_SM1_DIS_SM2_EN		0x02
+#define LIS3DSH_SM1_EN_SM2_EN		0x03
+
+/* INTERRUPTS ENABLE CONTROLS */
+#define LIS3DSH_INT1_DIS_INT2_DIS	0x00
+#define LIS3DSH_INT1_EN_INT2_DIS	0x01
+#define LIS3DSH_INT1_DIS_INT2_EN	0x02
+#define LIS3DSH_INT1_EN_INT2_EN		0x03
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lis3dsh_odr_table[] = {
+		{ 1, LIS3DSH_ODR1600 },
+		{ 3, LIS3DSH_ODR400 },
+		{ 10, LIS3DSH_ODR100 },
+		{ 20, LIS3DSH_ODR50 },
+		{ 40, LIS3DSH_ODR25 },
+		{ 80, LIS3DSH_ODR12_5 },
+		{ 160, LIS3DSH_ODR6_25 },
+		{ 320, LIS3DSH_ODR3_125 },
+};
+
+static struct lis3dsh_platform_data default_lis3dsh_pdata = {
+	.fs_range = LIS3DSH_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 10,
+	.min_interval = LIS3DSH_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LIS3DSH_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LIS3DSH_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int int1_gpio = LIS3DSH_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LIS3DSH_ACC_DEFAULT_INT2_GPIO;
+
+/* sets default init values to be written in registers at probe stage */
+static void lis3dsh_set_init_register_values(struct lis3dsh_status *acc)
+{
+	acc->resume_state[RES_LIS3DSH_LC_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_LC_H] = 0x00;
+
+	acc->resume_state[RES_LIS3DSH_CTRL_REG1] = (0x00 | LIS3DSH_SM1INT_PININT1);
+	acc->resume_state[RES_LIS3DSH_CTRL_REG2] = (0x00 | LIS3DSH_SM2INT_PININT1);
+	acc->resume_state[RES_LIS3DSH_CTRL_REG3] = LIS3DSH_INT_ACT_H;
+	if(acc->pdata->gpio_int1 >= 0)
+		acc->resume_state[RES_LIS3DSH_CTRL_REG3] =
+				acc->resume_state[RES_LIS3DSH_CTRL_REG3] | \
+					LIS3DSH_INT1_EN_ON;
+	if(acc->pdata->gpio_int2 >= 0)
+		acc->resume_state[RES_LIS3DSH_CTRL_REG3] =
+				acc->resume_state[RES_LIS3DSH_CTRL_REG3] | \
+					LIS3DSH_INT2_EN_ON;
+
+	acc->resume_state[RES_LIS3DSH_CTRL_REG4] = (LIS3DSH_BDU_EN |
+							LIS3DSH_ALL_AXES);
+	acc->resume_state[RES_LIS3DSH_CTRL_REG5] = 0x00;
+	acc->resume_state[RES_LIS3DSH_CTRL_REG6] = 0x10;
+
+	acc->resume_state[RES_LIS3DSH_THRS3] = 0x00;
+	acc->resume_state[RES_LIS3DSH_OFF_X] = 0x00;
+	acc->resume_state[RES_LIS3DSH_OFF_Y] = 0x00;
+	acc->resume_state[RES_LIS3DSH_OFF_Z] = 0x00;
+
+	acc->resume_state[RES_LIS3DSH_CS_X] = 0x00;
+	acc->resume_state[RES_LIS3DSH_CS_Y] = 0x00;
+	acc->resume_state[RES_LIS3DSH_CS_Z] = 0x00;
+
+	acc->resume_state[RES_LIS3DSH_VFC_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_VFC_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_VFC_3] = 0x00;
+	acc->resume_state[RES_LIS3DSH_VFC_4] = 0x00;
+}
+
+static void lis3dsh_set_init_statepr1_inst(struct lis3dsh_status *acc)
+{
+#if (LOAD_SM1_PROGRAM == 1)
+	/* Place here state machine 1 program */
+	acc->resume_stmach_program1[0] = 0x00;
+	acc->resume_stmach_program1[1] = 0x00;
+	acc->resume_stmach_program1[2] = 0X00;
+	acc->resume_stmach_program1[3] = 0X00;
+	acc->resume_stmach_program1[4] = 0x00;
+	acc->resume_stmach_program1[5] = 0x00;
+	acc->resume_stmach_program1[6] = 0x00;
+	acc->resume_stmach_program1[7] = 0x00;
+	acc->resume_stmach_program1[8] = 0x00;
+	acc->resume_stmach_program1[9] = 0x00;
+	acc->resume_stmach_program1[10] = 0x00;
+	acc->resume_stmach_program1[11] = 0x00;
+	acc->resume_stmach_program1[12] = 0x00;
+	acc->resume_stmach_program1[13] = 0x00;
+	acc->resume_stmach_program1[14] = 0x00;
+	acc->resume_stmach_program1[15] = 0x00;
+#else
+	acc->resume_stmach_program1[0] = 0x00;
+	acc->resume_stmach_program1[1] = 0x00;
+	acc->resume_stmach_program1[2] = 0X00;
+	acc->resume_stmach_program1[3] = 0X00;
+	acc->resume_stmach_program1[4] = 0x00;
+	acc->resume_stmach_program1[5] = 0x00;
+	acc->resume_stmach_program1[6] = 0x00;
+	acc->resume_stmach_program1[7] = 0x00;
+	acc->resume_stmach_program1[8] = 0x00;
+	acc->resume_stmach_program1[9] = 0x00;
+	acc->resume_stmach_program1[10] = 0x00;
+	acc->resume_stmach_program1[11] = 0x00;
+	acc->resume_stmach_program1[12] = 0x00;
+	acc->resume_stmach_program1[13] = 0x00;
+	acc->resume_stmach_program1[14] = 0x00;
+	acc->resume_stmach_program1[15] = 0x00;
+#endif /* LOAD_SM1_PROGRAM */
+}
+
+static void lis3dsh_set_init_statepr2_inst(struct lis3dsh_status *acc)
+{
+#if (LOAD_SM2_PROGRAM == 1)
+	/* Place here state machine 2 program */
+	acc->resume_stmach_program2[0] = 0x00;
+	acc->resume_stmach_program2[1] = 0x00;
+	acc->resume_stmach_program2[2] = 0X00;
+	acc->resume_stmach_program2[3] = 0X00;
+	acc->resume_stmach_program2[4] = 0x00;
+	acc->resume_stmach_program2[5] = 0x00;
+	acc->resume_stmach_program2[6] = 0x00;
+	acc->resume_stmach_program2[7] = 0x00;
+	acc->resume_stmach_program2[8] = 0x00;
+	acc->resume_stmach_program2[9] = 0x00;
+	acc->resume_stmach_program2[10] = 0x00;
+	acc->resume_stmach_program2[11] = 0x00;
+	acc->resume_stmach_program2[12] = 0x00;
+	acc->resume_stmach_program2[13] = 0x00;
+	acc->resume_stmach_program2[14] = 0x00;
+	acc->resume_stmach_program2[15] = 0x00;
+#else
+	acc->resume_stmach_program2[0] = 0x00;
+	acc->resume_stmach_program2[1] = 0x00;
+	acc->resume_stmach_program2[2] = 0X00;
+	acc->resume_stmach_program2[3] = 0X00;
+	acc->resume_stmach_program2[4] = 0x00;
+	acc->resume_stmach_program2[5] = 0x00;
+	acc->resume_stmach_program2[6] = 0x00;
+	acc->resume_stmach_program2[7] = 0x00;
+	acc->resume_stmach_program2[8] = 0x00;
+	acc->resume_stmach_program2[9] = 0x00;
+	acc->resume_stmach_program2[10] = 0x00;
+	acc->resume_stmach_program2[11] = 0x00;
+	acc->resume_stmach_program2[12] = 0x00;
+	acc->resume_stmach_program2[13] = 0x00;
+	acc->resume_stmach_program2[14] = 0x00;
+	acc->resume_stmach_program2[15] = 0x00;
+#endif /* LOAD_SM2_PROGRAM */
+}
+
+static void lis3dsh_set_init_statepr1_param(struct lis3dsh_status *acc)
+{
+#if (LOAD_SP1_PARAMETERS == 1)
+	/* Place here state machine 1 parameters */
+	acc->resume_state[RES_LIS3DSH_TIM4_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM3_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_1_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_1_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_1_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_1_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS2_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS1_1] = 0x00;
+	/* DES1 not available*/
+	acc->resume_state[RES_LIS3DSH_SA_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_MA_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_SETT_1] = 0x00;
+#else
+	acc->resume_state[RES_LIS3DSH_TIM4_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM3_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_1_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_1_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_1_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_1_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS2_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS1_1] = 0x00;
+	/* DES1 not available*/
+	acc->resume_state[RES_LIS3DSH_SA_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_MA_1] = 0x00;
+	acc->resume_state[RES_LIS3DSH_SETT_1] = 0x00;
+#endif
+}
+
+static void lis3dsh_set_init_statepr2_param(struct lis3dsh_status *acc)
+{
+#if (LOAD_SP2_PARAMETERS == 1)
+	/* Place here state machine 2 parameters */
+	acc->resume_state[RES_LIS3DSH_TIM4_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM3_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_2_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_2_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_2_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_2_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS2_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS1_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_DES_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_SA_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_MA_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_SETT_2] = 0x00;
+#else
+	acc->resume_state[RES_LIS3DSH_TIM4_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM3_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_2_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM2_2_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_2_L] = 0x00;
+	acc->resume_state[RES_LIS3DSH_TIM1_2_H] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS2_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_THRS1_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_DES_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_SA_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_MA_2] = 0x00;
+	acc->resume_state[RES_LIS3DSH_SETT_2] = 0x00;
+#endif
+}
+
+static int lis3dsh_i2c_update(struct lis3dsh_status *acc,
+			      u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+
+	err = acc->tf->read(acc, reg_address, 1, &init_val);
+	if (err >= 0) {
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = acc->tf->write(acc, reg_address, 1, &updated_val);
+	}
+
+	return err;
+}
+
+static int lis3dsh_hw_init(struct lis3dsh_status *acc)
+{
+	int i;
+	int err = -1;
+	u8 buf[17];
+
+	err = acc->tf->read(acc, LIS3DSH_WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+			 "available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+
+	if (buf[0] != WHOAMI_LIS3DSH_ACC) {
+		dev_err(acc->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_LIS3DSH_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_LC_L];
+	buf[1] = acc->resume_state[RES_LIS3DSH_LC_H];
+	err = acc->tf->write(acc, LIS3DSH_LC_L, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_TIM4_1];
+	buf[1] = acc->resume_state[RES_LIS3DSH_TIM3_1];
+	buf[2] = acc->resume_state[RES_LIS3DSH_TIM2_1_L];
+	buf[3] = acc->resume_state[RES_LIS3DSH_TIM2_1_H];
+	buf[4] = acc->resume_state[RES_LIS3DSH_TIM1_1_L];
+	buf[5] = acc->resume_state[RES_LIS3DSH_TIM1_1_H];
+	buf[6] = acc->resume_state[RES_LIS3DSH_THRS2_1];
+	buf[7] = acc->resume_state[RES_LIS3DSH_THRS1_1];
+	err = acc->tf->write(acc, LIS3DSH_TIM4_1, 8, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_SA_1];
+	buf[1] = acc->resume_state[RES_LIS3DSH_MA_1];
+	buf[2] = acc->resume_state[RES_LIS3DSH_SETT_1];
+	err = acc->tf->write(acc, LIS3DSH_SA_1, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_TIM4_2];
+	buf[1] = acc->resume_state[RES_LIS3DSH_TIM3_2];
+	buf[2] = acc->resume_state[RES_LIS3DSH_TIM2_2_L];
+	buf[3] = acc->resume_state[RES_LIS3DSH_TIM2_2_H];
+	buf[4] = acc->resume_state[RES_LIS3DSH_TIM1_2_L];
+	buf[5] = acc->resume_state[RES_LIS3DSH_TIM1_2_H];
+	buf[6] = acc->resume_state[RES_LIS3DSH_THRS2_2];
+	buf[7] = acc->resume_state[RES_LIS3DSH_THRS1_2];
+	buf[8] = acc->resume_state[RES_LIS3DSH_DES_2];
+	buf[9] = acc->resume_state[RES_LIS3DSH_SA_2];
+	buf[10] = acc->resume_state[RES_LIS3DSH_MA_2];
+	buf[11] = acc->resume_state[RES_LIS3DSH_SETT_2];
+	err = acc->tf->write(acc, LIS3DSH_TIM4_2, 12, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	/*	state program 1 */
+	for (i = 0; i <= LIS3DSH_STATE_PR_SIZE; i++) {
+		buf[i] = acc->resume_stmach_program1[i-1];
+		pr_debug("i=%d,sm pr1 buf[%d]=0x%02x\n", i, i, buf[i]);
+	};
+	err = acc->tf->write(acc, LIS3DSH_STATEPR1, LIS3DSH_STATE_PR_SIZE, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	/*	state program 2 */
+	for(i = 0; i <= LIS3DSH_STATE_PR_SIZE; i++) {
+		buf[i] = acc->resume_stmach_program2[i-1];
+		pr_debug("i=%d,sm pr2 buf[%d]=0x%02x\n", i, i, buf[i]);
+	};
+	err = acc->tf->write(acc, LIS3DSH_STATEPR2, LIS3DSH_STATE_PR_SIZE,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_CTRL_REG5];
+	buf[1] = acc->resume_state[RES_LIS3DSH_CTRL_REG6];
+	err = acc->tf->write(acc, LIS3DSH_CTRL_REG5, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_CTRL_REG1];
+	buf[1] = acc->resume_state[RES_LIS3DSH_CTRL_REG2];
+	buf[2] = acc->resume_state[RES_LIS3DSH_CTRL_REG3];
+	err = acc->tf->write(acc, LIS3DSH_CTRL_REG1, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LIS3DSH_CTRL_REG4];
+	err = acc->tf->write(acc, LIS3DSH_CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+		buf[1], err);
+	return err;
+}
+
+static void lis3dsh_device_power_off(struct lis3dsh_status *acc)
+{
+	int err;
+
+	err = lis3dsh_i2c_update(acc, LIS3DSH_CTRL_REG4,
+				 LIS3DSH_ODR_MASK, LIS3DSH_PM_OFF);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if (acc->pdata->gpio_int1)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int lis3dsh_device_power_on(struct lis3dsh_status *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = lis3dsh_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			lis3dsh_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if (acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if (acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	return 0;
+}
+
+static irqreturn_t lis3dsh_isr1(int irq, void *dev)
+{
+	struct lis3dsh_status *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis3dsh_isr2(int irq, void *dev)
+{
+	struct lis3dsh_status *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+
+	return IRQ_HANDLED;
+}
+
+static void lis3dsh_irq1_work_func(struct work_struct *work)
+{
+	struct lis3dsh_status *acc;
+
+	acc = container_of(work, struct lis3dsh_status, irq1_work);
+	pr_debug("%s: IRQ1 triggered\n", LIS3DSH_ACC_DEV_NAME);
+	/* TODO  add interrupt service procedure.
+		 ie:lis3dsh_get_int_source(acc); */
+	enable_irq(acc->irq1);
+}
+
+static void lis3dsh_irq2_work_func(struct work_struct *work)
+{
+	struct lis3dsh_status *acc;
+
+	acc = container_of(work, struct lis3dsh_status, irq2_work);
+	pr_debug("%s: IRQ2 triggered\n", LIS3DSH_ACC_DEV_NAME);
+	/* TODO  add interrupt service procedure.
+		 ie:lis3dsh_get_stat_source(acc); */
+	/* ; */
+	enable_irq(acc->irq2);
+}
+
+static int lis3dsh_register_masked_update(struct lis3dsh_status *acc,
+					  u8 reg_address, u8 mask,
+					  u8 new_bit_values, int resume_index)
+{
+	u8 init_val, updated_val;
+	int err;
+
+	err = acc->tf->read(acc, reg_address, 1, &init_val);
+	if (err < 0)
+		goto error;
+
+	acc->resume_state[resume_index] = init_val;
+	updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+	err = acc->tf->write(acc, reg_address, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	acc->resume_state[resume_index] = updated_val;
+
+	return err;
+
+error:
+		dev_err(acc->dev,
+			"register 0x%02x update failed error: %d\n",
+			updated_val, err);
+	return err;
+}
+
+static int lis3dsh_update_fs_range(struct lis3dsh_status *acc,
+				   u8 new_fs_range)
+{
+	int err = -1;
+	u16 sensitivity;
+
+	switch (new_fs_range) {
+	case LIS3DSH_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LIS3DSH_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LIS3DSH_ACC_G_6G:
+		sensitivity = SENSITIVITY_6G;
+		break;
+	case LIS3DSH_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case LIS3DSH_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&acc->enabled)) {
+		/* Updates configuration register 1,
+		* which contains g range setting */
+		err = lis3dsh_register_masked_update(acc, LIS3DSH_CTRL_REG5,
+		LIS3DSH_FS_MASK, new_fs_range, RES_LIS3DSH_CTRL_REG5);
+		if (err < 0) {
+			dev_err(acc->dev, "update g range failed\n");
+			return err;
+		} else
+			acc->sensitivity = sensitivity;
+	}
+
+	if (err < 0)
+		dev_err(acc->dev, "update g range not executed "
+			"because the device is off\n");
+	return err;
+}
+
+static int lis3dsh_update_odr(struct lis3dsh_status *acc,
+			      int poll_interval_ms)
+{
+	int err = 0;
+	int i;
+	u8 new_odr, old_odr;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis3dsh_odr_table) - 1; i >= 0; i--)
+		if (lis3dsh_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+
+	old_odr = acc->pdata->poll_interval;
+	new_odr = lis3dsh_odr_table[i].mask;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		err = lis3dsh_register_masked_update(acc, LIS3DSH_CTRL_REG4,
+						     LIS3DSH_ODR_MASK, new_odr,
+						     RES_LIS3DSH_CTRL_REG4);
+		if (err >= 0)
+			acc->pdata->poll_interval = lis3dsh_odr_table[i].cutoff_ms;
+		else
+			acc->pdata->poll_interval = old_odr;
+	} else {
+		/* Store new ODR for next activation */
+		acc->pdata->poll_interval = lis3dsh_odr_table[i].cutoff_ms;
+	}
+
+	return err;
+}
+
+
+#ifdef DEBUG
+static int lis3dsh_register_write(struct lis3dsh_status *acc, u8 *buf,
+				  u8 reg_address, u8 new_value)
+{
+	buf[0] = new_value;
+	
+	return acc->tf->write(acc, reg_address, 1, buf);
+}
+
+static int lis3dsh_register_read(struct lis3dsh_status *acc, u8 *buf,
+				 u8 reg_address)
+{
+	return acc->tf->read(acc, reg_address, 1, buf);
+}
+
+static int lis3dsh_register_update(struct lis3dsh_status *acc, u8 *buf,
+				   u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+
+	err = acc->tf->read(acc, reg_address, 1, &init_val);
+	if (!(err < 0)) {
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = acc->tf->write(acc, reg_address, 1, &updated_val);
+	}
+
+	return err;
+}
+#endif
+
+static int lis3dsh_get_acceleration_data(struct lis3dsh_status *acc,
+					 int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc, OUT_AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s16) ((acc_data[1] << 8) | acc_data[0]));
+	hw_d[1] = ((s16) ((acc_data[3] << 8) | acc_data[2]));
+	hw_d[2] = ((s16) ((acc_data[5] << 8) | acc_data[4]));
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x])
+		   : (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y])
+		   : (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
+		   : (hw_d[acc->pdata->axis_map_z]));
+
+	pr_debug("%s read x=%d, y=%d, z=%d\n", LIS3DSH_ACC_DEV_NAME,
+		 xyz[0], xyz[1], xyz[2]);
+
+	return err;
+}
+
+static void lis3dsh_report_values(struct lis3dsh_status *acc, int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static int lis3dsh_enable(struct lis3dsh_status *acc)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		dev_info(acc->dev, "Enabling Device %s\n",
+			acc->input_dev->name);
+		err = lis3dsh_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			return err;
+		}
+		/* Android:
+		 * Udpate polling rate in case odr was changed while sensor disabled */
+		lis3dsh_update_odr(acc, acc->pdata->poll_interval);
+		schedule_delayed_work(&acc->input_work,
+			msecs_to_jiffies(acc->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lis3dsh_disable(struct lis3dsh_status *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		dev_info(acc->dev, "Disabling Device %s\n",
+			acc->input_dev->name);
+		cancel_delayed_work(&acc->input_work);
+		lis3dsh_device_power_off(acc);
+	}
+
+	return 0;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int err;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	err = lis3dsh_update_odr(acc, interval_ms);
+	if (err < 0)
+		dev_err(acc->dev, "Failed to set odr\n");
+
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	u8 val;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	int range = 2;
+
+	mutex_lock(&acc->lock);
+	val = acc->pdata->fs_range ;
+	switch(val) {
+	case LIS3DSH_ACC_G_2G:
+		range = 2;
+		break;
+	case LIS3DSH_ACC_G_4G:
+		range = 4;
+		break;
+	case LIS3DSH_ACC_G_6G:
+		range = 6;
+		break;
+	case LIS3DSH_ACC_G_8G:
+		range = 8;
+		break;
+	case LIS3DSH_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr, const char *buf,
+			      size_t size)
+{
+	int err;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch(val) {
+		case 2:
+			range = LIS3DSH_ACC_G_2G;
+			break;
+		case 4:
+			range = LIS3DSH_ACC_G_4G;
+			break;
+		case 6:
+			range = LIS3DSH_ACC_G_6G;
+			break;
+		case 8:
+			range = LIS3DSH_ACC_G_8G;
+			break;
+		case 16:
+			range = LIS3DSH_ACC_G_16G;
+			break;
+		default:
+			return -1;
+	}
+
+	mutex_lock(&acc->lock);
+	err = lis3dsh_update_fs_range(acc, range);
+	if (err >= 0)
+		acc->pdata->fs_range = range;
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis3dsh_enable(acc);
+	else
+		lis3dsh_disable(acc);
+
+	return size;
+}
+
+static int lis3dsh_state_progrs_enable_control(struct lis3dsh_status *acc,
+					       u8 settings)
+{
+	u8 val1, val2;
+	int err = -1;
+
+	switch ( settings ) {
+	case LIS3DSH_SM1_DIS_SM2_DIS:
+		val1 = LIS3DSH_SM1_EN_OFF;
+		val2 = LIS3DSH_SM2_EN_OFF;
+		break;
+	case LIS3DSH_SM1_DIS_SM2_EN:
+		val1 = LIS3DSH_SM1_EN_OFF;
+		val2 = LIS3DSH_SM2_EN_ON;
+		break;
+	case LIS3DSH_SM1_EN_SM2_DIS:
+		val1 = LIS3DSH_SM1_EN_ON;
+		val2 = LIS3DSH_SM2_EN_OFF;
+		break;
+	case LIS3DSH_SM1_EN_SM2_EN:
+		val1 = LIS3DSH_SM1_EN_ON;
+		val2 = LIS3DSH_SM2_EN_ON;
+		break;
+	default :
+		pr_err("invalid state program setting : 0x%02x\n",settings);
+		return err;
+	}
+	err = lis3dsh_register_masked_update(acc, LIS3DSH_CTRL_REG1,
+					     LIS3DSH_SM1_EN_MASK, val1,
+					     RES_LIS3DSH_CTRL_REG1);
+	if (err < 0 )
+		return err;
+
+	err = lis3dsh_register_masked_update(acc, LIS3DSH_CTRL_REG2,
+					     LIS3DSH_SM2_EN_MASK, val2,
+					     RES_LIS3DSH_CTRL_REG2);
+	if (err < 0 )
+		return err;
+
+	acc->stateprogs_enable_setting = settings;
+
+	pr_debug("state program setting : 0x%02x\n",
+		 acc->stateprogs_enable_setting);
+
+	return err;
+}
+
+static ssize_t attr_set_enable_state_prog(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t size)
+{
+	int err = -1;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	long val=0;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	if (val < 0x00 || val > LIS3DSH_SM1_EN_SM2_EN) {
+		pr_warn("invalid state program setting, val: %ld\n",val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&acc->lock);
+	err = lis3dsh_state_progrs_enable_control(acc, val);
+	mutex_unlock(&acc->lock);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+static ssize_t attr_get_enable_state_prog(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	u8 val;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	val = acc->stateprogs_enable_setting;
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+#ifdef DEBUG
+/* PAY ATTENTION: These DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	u8 x[2];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	x[0] = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	x[1] = val;
+	rc = acc->tf->write(acc, &x[0], 1, &x[1]);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	int rc;
+	u8 reg, data;
+
+	mutex_lock(&acc->lock);
+	reg = acc->reg_addr;
+	mutex_unlock(&acc->lock);
+	rc = acc->tf->read(acc, reg, 1, &data);
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lis3dsh_status *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(poll_period_ms, 0664, attr_get_polling_rate,
+	       attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(enable_state_prog, 0664, attr_get_enable_state_prog,
+	       attr_set_enable_state_prog),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lis3dsh_input_work_func(struct work_struct *work)
+{
+	struct lis3dsh_status *acc;
+
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct delayed_work *)work,
+			   struct lis3dsh_status, input_work);
+
+	mutex_lock(&acc->lock);
+	err = lis3dsh_get_acceleration_data(acc, xyz);
+	if (err < 0)
+		pr_debug("get_acceleration_data failed\n");
+	else
+		lis3dsh_report_values(acc, xyz);
+
+	schedule_delayed_work(&acc->input_work, msecs_to_jiffies(
+			      acc->pdata->poll_interval));
+	mutex_unlock(&acc->lock);
+}
+
+#ifdef LIS3DSH_EN_ON_OPEN
+int lis3dsh_input_open(struct input_dev *input)
+{
+	struct lis3dsh_status *acc = input_get_drvdata(input);
+
+	return lis3dsh_enable(acc);
+}
+
+void lis3dsh_input_close(struct input_dev *dev)
+{
+	struct lis3dsh_status *acc = input_get_drvdata(dev);
+
+	lis3dsh_disable(acc);
+}
+#endif
+
+static int lis3dsh_validate_pdata(struct lis3dsh_status *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+					acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 ||
+	    acc->pdata->axis_map_y > 2 ||
+	     acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", acc->pdata->axis_map_x,
+			acc->pdata->axis_map_y, acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1
+	    || acc->pdata->negate_z > 1) {
+		dev_err(acc->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", acc->pdata->negate_x,
+			acc->pdata->negate_y, acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Report misc event type */
+static int lis3dsh_input_init(struct lis3dsh_status *acc)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&acc->input_work, lis3dsh_input_work_func);
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		dev_err(acc->dev, "input device allocation failed\n");
+
+		return -ENOMEM;
+	}
+
+	acc->input_dev->name = LIS3DSH_ACC_DEV_NAME;
+	acc->input_dev->id.bustype = acc->bustype;
+	acc->input_dev->dev.parent = acc->dev;
+#ifdef LIS3DSH_EN_ON_OPEN
+	acc->input_dev->open = lis3dsh_input_open;
+	acc->input_dev->close = lis3dsh_input_close;
+#endif
+	input_set_drvdata(acc->input_dev, acc);
+
+	__set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev, "unable to register input device %s\n",
+			acc->input_dev->name);
+		input_free_device(acc->input_dev);
+	}
+
+	return err;
+}
+
+static void lis3dsh_input_cleanup(struct lis3dsh_status *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+int lis3dsh_common_probe(struct lis3dsh_status *acc)
+{
+	int err = -1;
+
+	dev_info(acc->dev, "probe start.\n");
+	mutex_init(&acc->lock);
+	mutex_init(&acc->tb.buf_lock);
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kmalloc(sizeof(struct lis3dsh_platform_data), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (acc->dev->platform_data == NULL) {
+		default_lis3dsh_pdata.gpio_int1 = int1_gpio;
+		default_lis3dsh_pdata.gpio_int2 = int2_gpio;
+		memcpy(acc->pdata, &default_lis3dsh_pdata,
+							sizeof(*acc->pdata));
+		dev_info(acc->dev, "using default platform_data\n");
+	} else {
+		memcpy(acc->pdata, acc->dev->platform_data,
+		       sizeof(*acc->pdata));
+	}
+
+	err = lis3dsh_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d "
+			"mapped on gpio:%d\n",
+			LIS3DSH_ACC_DEV_NAME, __func__, acc->irq1,
+			acc->pdata->gpio_int1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d "
+			"mapped on gpio:%d\n",
+			LIS3DSH_ACC_DEV_NAME, __func__, acc->irq2,
+			acc->pdata->gpio_int2);
+	}
+
+	/* resume state init config */
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+	lis3dsh_set_init_register_values(acc);
+
+	/* init state program1 and params */
+	lis3dsh_set_init_statepr1_param(acc);
+	lis3dsh_set_init_statepr1_inst(acc);
+
+	/* init state program2  and params */
+	lis3dsh_set_init_statepr2_param(acc);
+	lis3dsh_set_init_statepr2_inst(acc);
+
+	err = lis3dsh_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&acc->enabled, 1);
+
+	err = lis3dsh_update_fs_range(acc, acc->pdata->fs_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3dsh_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3dsh_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(acc->dev);
+	if (err < 0) {
+		dev_err(acc->dev,
+		   	"device LIS3DSH_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lis3dsh_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+	if (acc->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&acc->irq1_work, lis3dsh_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("lis3dsh_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue1: %d\n",
+				err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, lis3dsh_isr1,
+				  IRQF_TRIGGER_RISING, "lis3dsh_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&acc->irq2_work, lis3dsh_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("lis3dsh_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev, "cannot create work queue2: %d\n",
+				err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, lis3dsh_isr2,
+				  IRQF_TRIGGER_RISING, "lis3dsh_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(acc->dev, "%s: probed\n", LIS3DSH_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if (acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if (acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	lis3dsh_input_cleanup(acc);
+err_power_off:
+	lis3dsh_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+	pr_err("%s: Driver Init failed\n", LIS3DSH_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lis3dsh_common_probe);
+
+int lis3dsh_common_remove(struct lis3dsh_status *acc)
+{
+	if (acc->pdata->gpio_int1 >= 0) {
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if (acc->pdata->gpio_int2 >= 0) {
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	if (atomic_cmpxchg(&acc->enabled, 1, 0))
+		cancel_delayed_work_sync(&acc->input_work);
+
+	lis3dsh_device_power_off(acc);
+	lis3dsh_input_cleanup(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+
+	kfree(acc->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3dsh_common_remove);
+
+#ifdef CONFIG_PM
+int lis3dsh_common_resume(struct lis3dsh_status *acc)
+{
+	if (acc->on_before_suspend)
+		return lis3dsh_enable(acc);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3dsh_common_resume);
+
+int lis3dsh_common_suspend(struct lis3dsh_status *acc)
+{
+	acc->on_before_suspend = atomic_read(&acc->enabled);
+
+	return lis3dsh_disable(acc);
+}
+EXPORT_SYMBOL(lis3dsh_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("lis3dsh accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno, Denis Ciocca, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/acc/lis3dsh/lis3dsh.h b/drivers/input/misc/st/acc/lis3dsh/lis3dsh.h
--- a/drivers/input/misc/st/acc/lis3dsh/lis3dsh.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dsh/lis3dsh.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,168 @@
+/*
+********************* (C) COPYRIGHT 2012 STMicroelectronics ********************
+*
+* File Name          : lis3dsh.h
+* Authors            : MH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+* Version            : V.1.2.2
+* Date               : 2012/Dec/15
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+
+********************************************************************************
+Version History.
+	V 1.0.0		First Release
+	V 1.0.2		I2C address bugfix
+	V 1.2.0		Registers names compliant to correct datasheet
+	V.1.2.1		Removed enable_interrupt_output sysfs file, manage int1
+			and int2, implements int1 isr.
+	V.1.2.2		Modified state program loadiing defines, removed
+			state machine program.
+********************************************************************************
+SYSFS interface
+- range: set full scale
+	-> accelerometer: 	2,4,6,8,16 				[g]
+- poll_period_ms: set 1/ODR
+	-> accelerometer:	LIS3DH_ACC_MIN_POLL_PERIOD_MS < t	[ms]
+- enable_device: enable/disable sensor					[1/0]
+
+
+INPUT subsystem: NOTE-> output data INCLUDE the sensitivity in accelerometer.
+- accelerometer:	abs_x, abs_y, abs_z		[ug]
+*******************************************************************************/
+
+#ifndef __LIS3DSH_H__
+#define __LIS3DSH_H__
+
+
+#define LIS3DSH_ACC_DEV_NAME		"lis3dsh_acc"
+
+
+/* Poll Interval */
+#define LIS3DSH_ACC_MIN_POLL_PERIOD_MS	1
+
+
+#ifdef __KERNEL__
+
+/* Interrupt */
+#define LIS3DSH_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LIS3DSH_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+
+/* Accelerometer Sensor Full Scale */
+#define LIS3DSH_ACC_G_2G		0x00
+#define LIS3DSH_ACC_G_4G		0x08
+#define LIS3DSH_ACC_G_6G		0x10
+#define LIS3DSH_ACC_G_8G		0x18
+#define LIS3DSH_ACC_G_16G		0x20
+
+#define LIS3DSH_RESUME_ENTRIES		43
+#define LIS3DSH_STATE_PR_SIZE		16
+
+#define BUFF_RX_MAX_LENGTH		500
+#define BUFF_TX_MAX_LENGTH		500
+
+/* Input Event Type */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+
+#define BUFF_RX_MAX_LENGTH		500
+#define BUFF_TX_MAX_LENGTH		500
+
+struct lis3dsh_status;
+
+struct lis3dsh_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+	u8 fs_range;
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	/* set gpio_int either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lis3dsh_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct lis3dsh_transfer_function {
+	int (*write)(struct lis3dsh_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lis3dsh_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lis3dsh_status {
+	const char *name;
+	struct lis3dsh_platform_data *pdata;
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	u16 bustype;
+	u16 sensitivity;
+	struct device *dev;
+	u8 stateprogs_enable_setting;
+	u8 resume_state[LIS3DSH_RESUME_ENTRIES];
+	u8 resume_stmach_program1[LIS3DSH_STATE_PR_SIZE];
+	u8 resume_stmach_program2[LIS3DSH_STATE_PR_SIZE];
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct lis3dsh_transfer_function *tf;
+	struct lis3dsh_transfer_buffer tb;
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+};
+
+#ifdef CONFIG_PM
+int lis3dsh_common_resume(struct lis3dsh_status *acc);
+int lis3dsh_common_suspend(struct lis3dsh_status *acc);
+#endif
+
+int lis3dsh_common_remove(struct lis3dsh_status *acc);
+int lis3dsh_common_probe(struct lis3dsh_status *acc);
+
+#endif /* __KERNEL__ */
+
+#endif /* __LIS3DSH_H__ */
diff -uNr a/drivers/input/misc/st/acc/lis3dsh/lis3dsh_i2c.c b/drivers/input/misc/st/acc/lis3dsh/lis3dsh_i2c.c
--- a/drivers/input/misc/st/acc/lis3dsh/lis3dsh_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dsh/lis3dsh_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,200 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3dsh_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lis3dsh.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int lis3dsh_i2c_read(struct lis3dsh_status *stat, u8 reg_addr,
+			    int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lis3dsh_i2c_write(struct lis3dsh_status *stat, u8 reg_addr,
+			     int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct lis3dsh_transfer_function lis3dsh_tf_i2c = {
+	.write = lis3dsh_i2c_write,
+	.read = lis3dsh_i2c_read,
+};
+
+static int lis3dsh_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lis3dsh_status *stat;
+
+	stat = kmalloc(sizeof(struct lis3dsh_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lis3dsh_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lis3dsh_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis3dsh_i2c_remove(struct i2c_client *client)
+{
+	struct lis3dsh_status *stat = i2c_get_clientdata(client);
+
+	lis3dsh_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis3dsh_suspend(struct device *dev)
+{
+	struct lis3dsh_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis3dsh_common_suspend(stat);
+}
+
+static int lis3dsh_resume(struct device *dev)
+{
+	struct lis3dsh_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lis3dsh_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis3dsh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3dsh_suspend, lis3dsh_resume)
+};
+
+#define LIS3DSH_PM_OPS	(&lis3dsh_pm_ops)
+#else /* CONFIG_PM */
+#define LIS3DSH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lis3dsh_ids[] = {
+	{ LIS3DSH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lis3dsh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3dsh_id_table[] = {
+	{ .compatible = "st,lis3dsh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3dsh_id_table);
+#endif
+
+static struct i2c_driver lis3dsh_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS3DSH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS3DSH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis3dsh_id_table,
+#endif
+	},
+	.remove = lis3dsh_i2c_remove,
+	.probe = lis3dsh_i2c_probe,
+	.id_table = lis3dsh_ids,
+};
+
+module_i2c_driver(lis3dsh_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis3dsh i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3dsh/lis3dsh_spi.c b/drivers/input/misc/st/acc/lis3dsh/lis3dsh_spi.c
--- a/drivers/input/misc/st/acc/lis3dsh/lis3dsh_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dsh/lis3dsh_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,207 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3dsh_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lis3dsh.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int lis3dsh_spi_read(struct lis3dsh_status *stat, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, stat->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static int lis3dsh_spi_write(struct lis3dsh_status *stat, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&stat->tb.buf_lock);
+	stat->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	mutex_unlock(&stat->tb.buf_lock);
+
+	return err;
+}
+
+static struct lis3dsh_transfer_function lis3dsh_tf_spi = {
+	.write = lis3dsh_spi_write,
+	.read = lis3dsh_spi_read,
+};
+
+static int lis3dsh_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis3dsh_status *stat;
+
+	stat = kmalloc(sizeof(struct lis3dsh_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lis3dsh_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lis3dsh_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lis3dsh_spi_remove(struct spi_device *spi)
+{
+	struct lis3dsh_status *stat = spi_get_drvdata(spi);
+
+	lis3dsh_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lis3dsh_suspend(struct device *dev)
+{
+	struct lis3dsh_status *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lis3dsh_common_suspend(stat);
+}
+
+static int lis3dsh_resume(struct device *dev)
+{
+	struct lis3dsh_status *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lis3dsh_common_resume(stat);
+}
+
+static const struct dev_pm_ops lis3dsh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3dsh_suspend, lis3dsh_resume)
+};
+
+#define LIS3DSH_PM_OPS	(&lis3dsh_pm_ops)
+#else /* CONFIG_PM */
+#define LIS3DSH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lis3dsh_ids[] = {
+	{ LIS3DSH_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis3dsh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3dsh_id_table[] = {
+	{ .compatible = "st,lis3dsh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3dsh_id_table);
+#endif
+
+static struct spi_driver lis3dsh_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS3DSH_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LIS3DSH_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lis3dsh_id_table,
+#endif
+	},
+	.remove = lis3dsh_spi_remove,
+	.probe = lis3dsh_spi_probe,
+	.id_table = lis3dsh_ids,
+};
+
+module_spi_driver(lis3dsh_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lis3dsh spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/lis3dsh/Makefile b/drivers/input/misc/st/acc/lis3dsh/Makefile
--- a/drivers/input/misc/st/acc/lis3dsh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/lis3dsh/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lis3dsh driver
+#
+lis3dsh-core-y += lis3dsh_core.o
+obj-$(CONFIG_INPUT_LIS3DSH) += lis3dsh-core.o
+obj-$(CONFIG_INPUT_LIS3DSH_I2C) += lis3dsh_i2c.o
+obj-$(CONFIG_INPUT_LIS3DSH_SPI) += lis3dsh_spi.o
diff -uNr a/drivers/input/misc/st/acc/Makefile b/drivers/input/misc/st/acc/Makefile
--- a/drivers/input/misc/st/acc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,19 @@
+#
+# Makefile for the input misc STM acc drivers.
+#
+
+obj-$(CONFIG_INPUT_AIS328DQ) += ais328dq/
+obj-$(CONFIG_INPUT_AIS3624DQ) += ais3624dq/
+obj-$(CONFIG_INPUT_LIS2DH) += lis2dh/
+obj-$(CONFIG_INPUT_LIS2DE) += lis2de/
+obj-$(CONFIG_INPUT_LIS2DS) += lis2ds/
+obj-$(CONFIG_INPUT_H3LIS100DL) += h3lis100dl/
+obj-$(CONFIG_INPUT_LIS3DSH) += lis3dsh/
+obj-$(CONFIG_INPUT_LIS2HH12) += lis2hh12/
+obj-$(CONFIG_INPUT_LIS3DE) += lis3de/
+obj-$(CONFIG_INPUT_LIS331DLH) += lis331dlh/
+obj-$(CONFIG_INPUT_LIS331HH) += lis331hh/
+obj-$(CONFIG_INPUT_H3LIS331DL) += h3lis331dl/
+obj-$(CONFIG_INPUT_LIS3DH) += lis3dh/
+obj-$(CONFIG_INPUT_N2DM) += n2dm/
+obj-$(CONFIG_INPUT_LIS2DW12) += lis2dw12/
diff -uNr a/drivers/input/misc/st/acc/n2dm/Kconfig b/drivers/input/misc/st/acc/n2dm/Kconfig
--- a/drivers/input/misc/st/acc/n2dm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/n2dm/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,14 @@
+config INPUT_N2DM
+	tristate "STMicroelectronics N2DM sensor"
+	depends on I2C && SYSFS
+	select INPUT_N2DM_I2C if (I2C)
+	help
+	   This driver support the STMicroelectronics N2DM sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called n2dm.
+
+config INPUT_N2DM_I2C
+	tristate
+	depends on INPUT_N2DM
+	depends on I2C
diff -uNr a/drivers/input/misc/st/acc/n2dm/Makefile b/drivers/input/misc/st/acc/n2dm/Makefile
--- a/drivers/input/misc/st/acc/n2dm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/n2dm/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for the input misc STM acc n2dm driver
+#
+n2dm-acc-y += n2dm_acc.o
+obj-$(CONFIG_INPUT_N2DM) += n2dm-acc.o
+obj-$(CONFIG_INPUT_N2DM_I2C) += n2dm_i2c.o
diff -uNr a/drivers/input/misc/st/acc/n2dm/n2dm_acc.c b/drivers/input/misc/st/acc/n2dm/n2dm_acc.c
--- a/drivers/input/misc/st/acc/n2dm/n2dm_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/n2dm/n2dm_acc.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1277 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : n2dm_acc.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Mario Tesi <mario.tesi@st.com>
+ *		      : Both authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.14
+ * Date               : 2016/Apr/26
+ * Description        : N2DM accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ *******************************************************************************/
+/*******************************************************************************
+Version History.
+ Revision 1.0.6 15/11/2010
+  first revision
+  supports sysfs;
+  no more support for ioctl;
+ Revision 1.0.7 26/11/2010
+  checks for availability of interrupts pins
+  correction on FUZZ and FLAT values;
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7
+ Revision 1.0.9: 2011/May/23
+  update_odr func correction;
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "n2dm.h"
+
+#define	G_MAX			16000
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+#define SENSITIVITY_16G		12	/**	mg/LSB	*/
+
+/* Accelerometer Sensor Operating Mode */
+#define N2DM_ACC_ENABLE		0x01
+#define N2DM_ACC_DISABLE	0x00
+
+#define	HIGH_RESOLUTION		0x08
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_N2DM_ACC		0x33	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		0x0F	/*	WhoAmI register		*/
+#define	TEMP_CFG_REG		0x1F	/*	temper sens control reg	*/
+/* ctrl 1: ODR3 ODR2 ODR ODR0 LPen Zenable Yenable Zenable */
+#define	CTRL_REG1		0x20	/*	control reg 1		*/
+#define	CTRL_REG2		0x21	/*	control reg 2		*/
+#define	CTRL_REG3		0x22	/*	control reg 3		*/
+#define	CTRL_REG4		0x23	/*	control reg 4		*/
+#define	CTRL_REG5		0x24	/*	control reg 5		*/
+#define	CTRL_REG6		0x25	/*	control reg 6		*/
+
+#define	FIFO_CTRL_REG		0x2E	/*	FiFo control reg	*/
+
+#define	INT_CFG1		0x30	/*	interrupt 1 config	*/
+#define	INT_SRC1		0x31	/*	interrupt 1 source	*/
+#define	INT_THS1		0x32	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		0x33	/*	interrupt 1 duration	*/
+
+
+#define	TT_CFG			0x38	/*	tap config		*/
+#define	TT_SRC			0x39	/*	tap source		*/
+#define	TT_THS			0x3A	/*	tap threshold		*/
+#define	TT_LIM			0x3B	/*	tap time limit		*/
+#define	TT_TLAT			0x3C	/*	tap time latency	*/
+#define	TT_TW			0x3D	/*	tap time window		*/
+/*	end CONTROL REGISTRES	*/
+
+
+#define ENABLE_HIGH_RESOLUTION	1
+#define ALL_ZEROES		0x00
+
+#define N2DM_ACC_PM_OFF		0x00
+#define N2DM_ACC_ENABLE_ALL_AXES	0x07
+
+#define PMODE_MASK		0x08
+#define ODR_MASK		0XF0
+
+#define N2DM_ACC_ODR1		0x10  /* 1Hz output data rate */
+#define N2DM_ACC_ODR10		0x20  /* 10Hz output data rate */
+#define N2DM_ACC_ODR25		0x30  /* 25Hz output data rate */
+#define N2DM_ACC_ODR50		0x40  /* 50Hz output data rate */
+#define N2DM_ACC_ODR100		0x50  /* 100Hz output data rate */
+#define N2DM_ACC_ODR200		0x60  /* 200Hz output data rate */
+#define N2DM_ACC_ODR400		0x70  /* 400Hz output data rate */
+#define N2DM_ACC_ODR1250	0x90  /* 1250Hz output data rate */
+
+#define	IA			0x40
+#define	ZH			0x20
+#define	ZL			0x10
+#define	YH			0x08
+#define	YL			0x04
+#define	XH			0x02
+#define	XL			0x01
+/* */
+/* CTRL REG BITS*/
+#define	CTRL_REG3_I1_AOI1	0x40
+#define	CTRL_REG4_BDU_ENABLE	0x80
+#define	CTRL_REG4_BDU_MASK	0x80
+#define	CTRL_REG6_I2_TAPEN	0x80
+#define	CTRL_REG6_HLACTIVE	0x02
+/* */
+#define NO_MASK			0xFF
+#define INT1_DURATION_MASK	0x7F
+#define	INT1_THRESHOLD_MASK	0x7F
+#define TAP_CFG_MASK		0x3F
+#define	TAP_THS_MASK		0x7F
+#define	TAP_TLIM_MASK		0x7F
+#define	TAP_TLAT_MASK		NO_MASK
+#define	TAP_TW_MASK		NO_MASK
+
+
+/* TAP_SOURCE_REG BIT */
+#define	DTAP			0x20
+#define	STAP			0x10
+#define	SIGNTAP			0x08
+#define	ZTAP			0x04
+#define	YTAP			0x02
+#define	XTAZ			0x01
+
+#define	FUZZ			0
+#define	FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+
+/* end RESUME STATE INDICES */
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} n2dm_acc_odr_table[] = {
+		{    1, N2DM_ACC_ODR1250 },
+		{    3, N2DM_ACC_ODR400  },
+		{    5, N2DM_ACC_ODR200  },
+		{   10, N2DM_ACC_ODR100  },
+		{   20, N2DM_ACC_ODR50   },
+		{   40, N2DM_ACC_ODR25   },
+		{  100, N2DM_ACC_ODR10   },
+		{ 1000, N2DM_ACC_ODR1    },
+};
+
+static int int1_gpio = N2DM_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = N2DM_ACC_DEFAULT_INT2_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+module_param(int2_gpio, int, S_IRUGO);
+
+static struct n2dm_acc_platform_data default_n2dm_acc_pdata = {
+	.fs_range = N2DM_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = N2DM_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = N2DM_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = N2DM_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int n2dm_acc_hw_init(struct n2dm_acc_status *stat)
+{
+	int err = -1;
+	u8 buf[6];
+
+	pr_info("%s: hw init start\n", N2DM_ACC_DEV_NAME);
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TEMP_CFG_REG];
+	err = stat->tf->write(stat, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_THS];
+	buf[1] = stat->resume_state[RES_TT_LIM];
+	buf[2] = stat->resume_state[RES_TT_TLAT];
+	buf[3] = stat->resume_state[RES_TT_TW];
+	err = stat->tf->write(stat, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_CFG];
+	err = stat->tf->write(stat, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THS1];
+	buf[1] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	buf[3] = stat->resume_state[RES_CTRL_REG5];
+	buf[4] = stat->resume_state[RES_CTRL_REG6];
+	err = stat->tf->write(stat, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", N2DM_ACC_DEV_NAME);
+
+	return 0;
+
+	stat->hw_working = 0;
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+		buf[1], err);
+
+	return err;
+}
+
+static void n2dm_acc_device_power_off(struct n2dm_acc_status *stat)
+{
+	int err;
+	u8 buf = N2DM_ACC_PM_OFF;
+
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->hw_initialized = 0;
+	}
+}
+
+static int n2dm_acc_device_power_on(struct n2dm_acc_status *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"power_on failed: %d\n", err);
+
+			return err;
+		}
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	if (!stat->hw_initialized) {
+		err = n2dm_acc_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			n2dm_acc_device_power_off(stat);
+
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	return 0;
+}
+
+static irqreturn_t n2dm_acc_isr1(int irq, void *dev)
+{
+	struct n2dm_acc_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", N2DM_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t n2dm_acc_isr2(int irq, void *dev)
+{
+	struct n2dm_acc_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", N2DM_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void n2dm_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct n2dm_acc_status *stat =
+	container_of(work, struct n2dm_acc_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:n2dm_acc_get_int1_source(stat); */
+	pr_debug("%s: IRQ1 triggered\n", N2DM_ACC_DEV_NAME);
+	enable_irq(stat->irq1);
+}
+
+static void n2dm_acc_irq2_work_func(struct work_struct *work)
+{
+	struct n2dm_acc_status *stat =
+	container_of(work, struct n2dm_acc_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:n2dm_acc_get_tap_source(stat); */
+	pr_debug("%s: IRQ2 triggered\n", N2DM_ACC_DEV_NAME);
+	enable_irq(stat->irq2);
+}
+
+static int n2dm_acc_update_fs_range(struct n2dm_acc_status *stat,
+				      u8 new_fs_range)
+{
+	int err = -1;
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = N2DM_ACC_FS_MASK | HIGH_RESOLUTION;
+
+	switch (new_fs_range) {
+	case N2DM_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case N2DM_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case N2DM_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case N2DM_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4, which contains fs range setting */
+	err = stat->tf->read(stat, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+
+	init_val = buf[0];
+	stat->resume_state[RES_CTRL_REG4] = init_val;
+	new_val = new_fs_range | HIGH_RESOLUTION;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+	err = stat->tf->write(stat, CTRL_REG4, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG4] = updated_val;
+	stat->sensitivity = sensitivity;
+
+	return err;
+
+error:
+	dev_err(stat->dev,
+		"update fs range failed 0x%02x,0x%02x: %d\n",
+		buf[0], buf[1], err);
+
+	return err;
+}
+
+static int n2dm_acc_update_odr(struct n2dm_acc_status *stat,
+				 int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(n2dm_acc_odr_table) - 1; i >= 0; i--) {
+		if ((n2dm_acc_odr_table[i].cutoff_ms <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+	config = n2dm_acc_odr_table[i].mask | N2DM_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat, CTRL_REG1, 1, &config);
+		if (err < 0)
+			goto error;
+
+		stat->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed 0x%02x,0x%02x: %d\n",
+		CTRL_REG1, config, err);
+
+	return err;
+}
+
+static int n2dm_acc_register_write(struct n2dm_acc_status *stat,
+				     u8 *buf, u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+
+	return stat->tf->write(stat, reg_address, 1, buf);
+}
+
+static int n2dm_acc_get_acceleration_data(struct n2dm_acc_status *stat,
+					    int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] = hw_d[0] * stat->sensitivity;
+	hw_d[1] = hw_d[1] * stat->sensitivity;
+	hw_d[2] = hw_d[2] * stat->sensitivity;
+
+	xyz[0] = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+	return err;
+}
+
+/* Input events chenged to EV_MSC */
+static void n2dm_acc_report_values(struct n2dm_acc_status *stat,
+				     int *xyz)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(stat->input_dev);
+}
+
+static int n2dm_acc_enable(struct n2dm_acc_status *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = n2dm_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+
+			return err;
+		}
+		n2dm_acc_update_odr(stat, stat->pdata->poll_interval);
+		schedule_delayed_work(&stat->input_work,
+				      msecs_to_jiffies(stat->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int n2dm_acc_disable(struct n2dm_acc_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&stat->input_work);
+		n2dm_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat, reg, 1, &data);
+	if (err < 0)
+		return err;
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		     u8 mask, int resumeIndex)
+{
+	int err = -1;
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = n2dm_acc_register_write(stat, x, reg, new_val);
+	if (err >= 0)
+		stat->resume_state[resumeIndex] = new_val;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	n2dm_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range ;
+	switch (val) {
+	case N2DM_ACC_G_2G:
+		range = 2;
+		break;
+	case N2DM_ACC_G_4G:
+		range = 4;
+		break;
+	case N2DM_ACC_G_8G:
+		range = 8;
+		break;
+	case N2DM_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = N2DM_ACC_G_2G;
+		break;
+	case 4:
+		range = N2DM_ACC_G_4G;
+		break;
+	case 8:
+		range = N2DM_ACC_G_8G;
+		break;
+	case 16:
+		range = N2DM_ACC_G_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = n2dm_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct n2dm_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		n2dm_acc_enable(stat);
+	else
+		n2dm_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1, INT1_THRESHOLD_MASK, RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+							attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void n2dm_acc_input_work_func(struct work_struct *work)
+{
+	struct n2dm_acc_status *stat;
+
+	int xyz[3] = { 0 };
+	int err;
+
+	stat = container_of((struct delayed_work *)work,
+			    struct n2dm_acc_status, input_work);
+
+	mutex_lock(&stat->lock);
+	err = n2dm_acc_get_acceleration_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_acceleration_data failed\n");
+	else
+		n2dm_acc_report_values(stat, xyz);
+
+	schedule_delayed_work(&stat->input_work, msecs_to_jiffies(
+			stat->pdata->poll_interval));
+	mutex_unlock(&stat->lock);
+}
+
+#ifdef N2DM_EN_OPEN_CLOSE
+static int n2dm_acc_input_open(struct input_dev *input)
+{
+	struct n2dm_acc_status *stat = input_get_drvdata(input);
+
+	return n2dm_acc_enable(stat);
+}
+
+static void n2dm_acc_input_close(struct input_dev *dev)
+{
+	struct n2dm_acc_status *stat = input_get_drvdata(dev);
+
+	n2dm_acc_disable(stat);
+}
+#endif
+
+static int n2dm_acc_validate_pdata(struct n2dm_acc_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)N2DM_ACC_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					 stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 || stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y, stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", stat->pdata->negate_x,
+			stat->pdata->negate_y, stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int n2dm_acc_input_init(struct n2dm_acc_status *stat)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&stat->input_work, n2dm_acc_input_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		dev_err(stat->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+#ifdef N2DM_EN_OPEN_CLOSE
+	stat->input_dev->open = n2dm_acc_input_open;
+	stat->input_dev->close = n2dm_acc_input_close;
+#endif
+	stat->input_dev->name = N2DM_ACC_DEV_NAME;
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit );
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+	}
+
+	return err;
+}
+
+static void n2dm_acc_input_cleanup(struct n2dm_acc_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+/*
+ * struct n2dm_acc_status *stat is allocated/freed in tf probing
+ * so let it manage this stuff
+ */
+int n2dm_acc_probe(struct n2dm_acc_status *stat)
+{
+	int err = -1;
+	u8 wai = 0;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+
+	/* Check device ID and bus connection */
+	err = stat->tf->read(stat, WHO_AM_I, 1, &wai);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I:"
+			 " is device available/working?\n");
+
+		return err;
+	}
+
+	if (wai != WHOAMI_N2DM_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_N2DM_ACC, wai);
+
+		return -ENODEV;
+	}
+
+	mutex_lock(&stat->lock);
+	
+	stat->hw_working = 1;
+	stat->pdata = kmalloc(sizeof(struct n2dm_acc_platform_data), GFP_KERNEL);
+	if (!stat->pdata) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_n2dm_acc_pdata.gpio_int1 = int1_gpio;
+		default_n2dm_acc_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_n2dm_acc_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = n2dm_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		stat->irq1 = gpio_to_irq(stat->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, "
+			"mapped on gpio:%d\n", N2DM_ACC_DEV_NAME,
+			__func__, stat->irq1, stat->pdata->gpio_int1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d, "
+			"mapped on gpio:%d\n", N2DM_ACC_DEV_NAME,
+			__func__, stat->irq2, stat->pdata->gpio_int2);
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = (ALL_ZEROES |
+					     N2DM_ACC_ENABLE_ALL_AXES);
+	stat->resume_state[RES_CTRL_REG4] = (ALL_ZEROES | CTRL_REG4_BDU_ENABLE);
+
+	err = n2dm_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = n2dm_acc_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = n2dm_acc_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = n2dm_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device N2DM_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	n2dm_acc_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&stat->irq1_work, n2dm_acc_irq1_work_func);
+		stat->irq1_work_queue =
+			create_singlethread_workqueue("n2dm_acc_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, n2dm_acc_isr1,
+			IRQF_TRIGGER_RISING, "n2dm_acc_irq1", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&stat->irq2_work, n2dm_acc_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("n2dm_acc_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+				"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, n2dm_acc_isr2,
+			IRQF_TRIGGER_RISING, "n2dm_acc_irq2", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", N2DM_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if (stat->pdata->gpio_int2 >= 0)
+		destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	if (stat->pdata->gpio_int1 >= 0)
+		destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	n2dm_acc_input_cleanup(stat);
+err_power_off:
+	n2dm_acc_device_power_off(stat);
+err_pdata_init:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	pr_err("%s: Driver Init failed\n", N2DM_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(n2dm_acc_probe);
+
+int n2dm_acc_remove(struct n2dm_acc_status *stat)
+{
+	dev_info(stat->dev, "driver removing\n");
+
+	if (stat->pdata->gpio_int1 >= 0) {
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	n2dm_acc_disable(stat);
+	n2dm_acc_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+	kfree(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(n2dm_acc_remove);
+
+#ifdef CONFIG_PM
+int n2dm_acc_common_resume(struct n2dm_acc_status *stat)
+{
+	if (stat->on_before_suspend)
+		return n2dm_acc_enable(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(n2dm_acc_common_resume);
+
+int n2dm_acc_common_suspend(struct n2dm_acc_status *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	return n2dm_acc_disable(stat);
+}
+EXPORT_SYMBOL(n2dm_acc_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("n2dm accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Mario tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/acc/n2dm/n2dm.h b/drivers/input/misc/st/acc/n2dm/n2dm.h
--- a/drivers/input/misc/st/acc/n2dm/n2dm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/n2dm/n2dm.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,160 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: n2dm_acc.h
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Mario Tesi <mario.tesi@st.com>
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.10: 2011/Aug/16
+
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+  renamed field g_range to fs_range in n2dm_acc_platform_data;
+  replaced defines SA0L and SA0H with N2DM_SAD0x
+ Revision 1.0.13: 2013/Feb/25
+  modified acc_remove function;
+ Revision 1.0.14: 2016/Apr/26
+  added new i2c and spi interface
+*******************************************************************************/
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+
+#ifndef	__N2DM_H__
+#define	__N2DM_H__
+
+/* Uncomment if want enable/disable on open/close input device */
+//#define N2DM_EN_OPEN_CLOSE
+
+#define	N2DM_ACC_DEV_NAME		"n2dm_acc"
+
+#define	N2DM_ACC_MIN_POLL_PERIOD_MS	1
+
+#ifdef __KERNEL__
+
+#define N2DM_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define N2DM_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	N2DM_ACC_FS_MASK		0x30
+#define N2DM_ACC_G_2G			0x00
+#define N2DM_ACC_G_4G			0x10
+#define N2DM_ACC_G_8G			0x20
+#define N2DM_ACC_G_16G		0x30
+
+#define BUFF_RX_MAX_LENGTH		500
+#define BUFF_TX_MAX_LENGTH		500
+
+#define	RESUME_ENTRIES			17
+
+struct n2dm_acc_status;
+
+struct n2dm_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct n2dm_acc_transfer_buffer {
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct n2dm_acc_transfer_function {
+	int (*write)(struct n2dm_acc_status *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct n2dm_acc_status *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct n2dm_acc_status {
+	const char *name;
+	struct n2dm_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	int on_before_suspend;
+	int use_smbus;
+	struct device *dev;
+	u16 bustype;
+	u8 sensitivity;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	struct n2dm_acc_transfer_function *tf;
+	struct n2dm_acc_transfer_buffer tb;
+};
+
+/* Input events used by n2dm driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+
+int n2dm_acc_probe(struct n2dm_acc_status *stat);
+int n2dm_acc_remove(struct n2dm_acc_status *stat);
+
+#ifdef CONFIG_PM
+int n2dm_acc_common_resume(struct n2dm_acc_status *stat);
+int n2dm_acc_common_suspend(struct n2dm_acc_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __N2DM_H__ */
diff -uNr a/drivers/input/misc/st/acc/n2dm/n2dm_i2c.c b/drivers/input/misc/st/acc/n2dm/n2dm_i2c.c
--- a/drivers/input/misc/st/acc/n2dm/n2dm_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/acc/n2dm/n2dm_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,180 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: n2dm_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "n2dm.h"
+
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int n2dm_acc_i2c_read(struct n2dm_acc_status *stat, u8 reg_addr,
+			       int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int n2dm_acc_i2c_write(struct n2dm_acc_status *stat, u8 reg_addr,
+				int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct n2dm_acc_transfer_function n2dm_acc_tf_i2c = {
+	.write = n2dm_acc_i2c_write,
+	.read = n2dm_acc_i2c_read,
+};
+
+static int n2dm_acc_i2c_probe(struct i2c_client *client,
+			        const struct i2c_device_id *id)
+{
+	int err;
+	struct n2dm_acc_status *stat;
+
+	stat = kmalloc(sizeof(struct n2dm_acc_status), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &n2dm_acc_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = n2dm_acc_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+	return err;
+}
+
+static int n2dm_acc_i2c_remove(struct i2c_client *client)
+{
+	struct n2dm_acc_status *stat = i2c_get_clientdata(client);
+
+	n2dm_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int n2dm_acc_suspend(struct device *dev)
+{
+	struct n2dm_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return n2dm_acc_common_suspend(stat);
+}
+
+static int n2dm_acc_resume(struct device *dev)
+{
+	struct n2dm_acc_status *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return n2dm_acc_common_resume(stat);
+}
+
+static const struct dev_pm_ops n2dm_acc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(n2dm_acc_suspend, n2dm_acc_resume)
+};
+
+#define N2DM_PM_OPS		(&n2dm_acc_pm_ops)
+#else /* CONFIG_PM */
+#define N2DM_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id n2dm_acc_ids[] = {
+	{ N2DM_ACC_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, n2dm_acc_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id n2dm_acc_id_table[] = {
+	{ .compatible = "st,n2dm", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, n2dm_acc_id_table);
+#endif
+
+static struct i2c_driver n2dm_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = N2DM_ACC_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = N2DM_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = n2dm_acc_id_table,
+#endif
+	},
+	.remove = n2dm_acc_i2c_remove,
+	.probe = n2dm_acc_i2c_probe,
+	.id_table = n2dm_acc_ids,
+};
+
+module_i2c_driver(n2dm_acc_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics n2dm i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/ecompass/Kconfig b/drivers/input/misc/st/ecompass/Kconfig
--- a/drivers/input/misc/st/ecompass/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,13 @@
+
+menuconfig INPUT_ECOMPASS
+	tristate "eCompass"
+
+if INPUT_ECOMPASS
+
+source "drivers/input/misc/st/ecompass/lsm303agr/Kconfig"
+source "drivers/input/misc/st/ecompass/lsm303ah/Kconfig"
+source "drivers/input/misc/st/ecompass/lsm303c/Kconfig"
+source "drivers/input/misc/st/ecompass/lsm303d/Kconfig"
+source "drivers/input/misc/st/ecompass/lsm303dlhc/Kconfig"
+
+endif # INPUT_ECOMPASS
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/Kconfig b/drivers/input/misc/st/ecompass/lsm303agr/Kconfig
--- a/drivers/input/misc/st/ecompass/lsm303agr/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,22 @@
+
+config INPUT_LSM303AGR
+         tristate "STM LSM303AGR sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LSM303AGR_I2C if (I2C)
+	 select INPUT_LSM303AGR_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics LSM303AGR sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm303agr.
+
+config INPUT_LSM303AGR_I2C
+         tristate
+         depends on INPUT_LSM303AGR
+         depends on I2C
+
+config INPUT_LSM303AGR_SPI
+         tristate
+         depends on INPUT_LSM303AGR
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc.c b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc.c
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,885 @@
+/*
+ * STMicroelectronics lsm303agr_acc.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303agr_core.h"
+
+#define LSM303AGR_ACC_DEV_NAME	"lsm303agr_acc"
+
+#define LSM303AGR_ACC_MIN_POLL_PERIOD_MS 1
+
+/* I2C slave address */
+#define LSM303AGR_ACC_I2C_SAD	0x29
+/* Accelerometer Sensor Full Scale */
+#define	LSM303AGR_ACC_FS_MSK	0x20
+#define LSM303AGR_ACC_G_2G	0x00
+#define LSM303AGR_ACC_G_8G	0x20
+
+#define AXISDATA_REG		0x28
+#define WHOAMI_LSM303AGR_ACC	0x33
+#define WHO_AM_I		0x0F
+#define CTRL_REG1		0x20
+#define CTRL_REG2		0x23
+
+#define LSM303AGR_ACC_PM_OFF		0x00
+#define LSM303AGR_ACC_ENABLE_ALL_AXIS	0x07
+#define LSM303AGR_ACC_AXIS_MSK		0x07
+#define LSM303AGR_ACC_ODR_MSK		0xf0
+#define LSM303AGR_ACC_LP_MSK		0X08
+#define LSM303AGR_ACC_HR_MSK		0X08
+
+/* device opmode */
+enum lsm303agr_acc_opmode {
+	LSM303AGR_ACC_OPMODE_NORMAL,
+	LSM303AGR_ACC_OPMODE_HR,
+	LSM303AGR_ACC_OPMODE_LP,
+};
+
+/* Device sensitivities [ug/digit] */
+#define LSM303AGR_ACC_SENSITIVITY_NORMAL_2G	3900
+#define LSM303AGR_ACC_SENSITIVITY_NORMAL_4G	7820
+#define LSM303AGR_ACC_SENSITIVITY_NORMAL_8G	15630
+#define LSM303AGR_ACC_SENSITIVITY_NORMAL_16G	46900
+#define LSM303AGR_ACC_SENSITIVITY_HR_2G		980
+#define LSM303AGR_ACC_SENSITIVITY_HR_4G		1950
+#define LSM303AGR_ACC_SENSITIVITY_HR_8G		3900
+#define LSM303AGR_ACC_SENSITIVITY_HR_16G	11720
+#define LSM303AGR_ACC_SENSITIVITY_LP_2G		15630
+#define LSM303AGR_ACC_SENSITIVITY_LP_4G		31260
+#define LSM303AGR_ACC_SENSITIVITY_LP_8G		62520
+#define LSM303AGR_ACC_SENSITIVITY_LP_16G	187580
+
+/* Device shift values */
+#define LSM303AGR_ACC_SHIFT_NORMAL_MODE	6
+#define LSM303AGR_ACC_SHIFT_HR_MODE	4
+#define LSM303AGR_ACC_SHIFT_LP_MODE	8
+
+const struct {
+	u16 shift;
+	u32 sensitivity[4];
+} lsm303agr_acc_opmode_table[] = {
+	{
+		/* normal mode */
+		LSM303AGR_ACC_SHIFT_NORMAL_MODE,
+		{
+			LSM303AGR_ACC_SENSITIVITY_NORMAL_2G,
+			LSM303AGR_ACC_SENSITIVITY_NORMAL_4G,
+			LSM303AGR_ACC_SENSITIVITY_NORMAL_8G,
+			LSM303AGR_ACC_SENSITIVITY_NORMAL_16G
+		}
+	},
+	{
+		/* hr mode */
+		LSM303AGR_ACC_SHIFT_HR_MODE,
+		{
+			LSM303AGR_ACC_SENSITIVITY_HR_2G,
+			LSM303AGR_ACC_SENSITIVITY_HR_4G,
+			LSM303AGR_ACC_SENSITIVITY_HR_8G,
+			LSM303AGR_ACC_SENSITIVITY_HR_16G
+		}
+	},
+	{
+		/* lp mode */
+		LSM303AGR_ACC_SHIFT_LP_MODE,
+		{
+			LSM303AGR_ACC_SENSITIVITY_LP_2G,
+			LSM303AGR_ACC_SENSITIVITY_LP_4G,
+			LSM303AGR_ACC_SENSITIVITY_LP_8G,
+			LSM303AGR_ACC_SENSITIVITY_LP_16G
+		}
+	}
+};
+
+#define LSM303AGR_ACC_ODR10	0x20  /* 10Hz output data rate */
+#define LSM303AGR_ACC_ODR50	0x40  /* 50Hz output data rate */
+#define LSM303AGR_ACC_ODR100	0x50  /* 100Hz output data rate */
+#define LSM303AGR_ACC_ODR200	0x60  /* 200Hz output data rate */
+
+/* read and write with mask a given register */
+static int lsm303agr_acc_write_data_with_mask(struct lsm303agr_common_data *cdata,
+					      u8 reg_addr, u8 mask, u8 *data)
+{
+	int err;
+	u8 new_data, old_data = 0;
+
+	err = cdata->tf->read(cdata->dev, reg_addr, 1, &old_data);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((*data) & mask));
+
+#ifdef LSM303AGR_ACC_DEBUG
+	dev_info(cdata->dev, "%s %02x o=%02x d=%02x n=%02x\n",
+		 LSM303AGR_ACC_DEV_NAME, reg_addr, old_data, *data, new_data);
+#endif
+
+	/* Save for caller usage the data that is about to be written */
+	*data = new_data;
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata->dev, reg_addr, 1, &new_data);
+}
+
+static int lsm303agr_acc_input_init(struct lsm303agr_sensor_data *sdata,
+				    const char* description)
+{
+	int err;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = description;
+	sdata->input_dev->id.bustype = sdata->cdata->bus_type;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit);
+	set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev,
+			"unable to register input device %s\n",
+			sdata->input_dev->name);
+		input_free_device(sdata->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lsm303agr_acc_odr_table[] = {
+	{    5, LSM303AGR_ACC_ODR200  }, /* ODR = 200Hz */
+	{   10, LSM303AGR_ACC_ODR100  }, /* ODR = 100Hz */
+	{   20, LSM303AGR_ACC_ODR50   }, /* ODR = 50Hz */
+	{  100, LSM303AGR_ACC_ODR10   }, /* ODR = 10Hz */
+};
+
+static int lsm303agr_acc_hw_init(struct lsm303agr_common_data *cdata)
+{
+	int err;
+	u8 buf, wai = 0;
+
+#ifdef LSM303AGR_ACC_DEBUG
+	pr_info("%s: hw init start\n", LSM303AGR_ACC_DEV_NAME);
+#endif
+
+	err = cdata->tf->read(cdata->dev, WHO_AM_I, 1, &wai);
+	if (err < 0) {
+		dev_warn(cdata->dev, "Error reading WHO_AM_I\n");
+		goto error;
+	}
+
+	if (wai != WHOAMI_LSM303AGR_ACC) {
+		dev_err(cdata->dev,
+			"device unknown (0x%02x-0x%02x)\n",
+			WHOAMI_LSM303AGR_ACC, wai);
+		err = -1; /* choose the right coded error */
+		goto error;
+	}
+
+	buf = cdata->sensors[LSM303AGR_ACC_SENSOR].c_odr;
+	err = lsm303agr_acc_write_data_with_mask(cdata, CTRL_REG1,
+						 LSM303AGR_ACC_ODR_MSK, &buf);
+	if (err < 0)
+		goto error;
+
+	cdata->hw_initialized = 1;
+
+#ifdef LSM303AGR_ACC_DEBUG
+	pr_info("%s: hw init done\n", LSM303AGR_ACC_DEV_NAME);
+#endif
+	return 0;
+
+error:
+	cdata->hw_initialized = 0;
+	dev_err(cdata->dev, "hw init error 0x%02x: %d\n", buf, err);
+
+	return err;
+}
+
+static void lsm303agr_acc_device_power_off(struct lsm303agr_common_data *cdata)
+{
+	int err;
+	u8 buf = LSM303AGR_ACC_PM_OFF;
+
+	err = lsm303agr_acc_write_data_with_mask(cdata, CTRL_REG1,
+						 LSM303AGR_ACC_ODR_MSK, &buf);
+	if (err < 0)
+		dev_err(cdata->dev, "soft power off failed: %d\n", err);
+
+	if (cdata->hw_initialized)
+		cdata->hw_initialized = 0;
+}
+
+static int lsm303agr_acc_device_power_on(struct lsm303agr_common_data *cdata)
+{
+	if (!cdata->hw_initialized) {
+		int err = lsm303agr_acc_hw_init(cdata);
+		if (err < 0) {
+			lsm303agr_acc_device_power_off(cdata);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lsm303agr_acc_update_fs_range(struct lsm303agr_common_data *cdata,
+					 u8 new_fs_range)
+{
+	int err;
+	u8 indx;
+	u16 opmode;
+	unsigned int new_sensitivity;
+	struct lsm303agr_sensor_data *sdata;
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	opmode = sdata->opmode;
+
+	switch (new_fs_range) {
+	case LSM303AGR_ACC_G_2G:
+		indx = 0;
+		break;
+	case LSM303AGR_ACC_G_8G:
+		indx = 2;
+		break;
+	default:
+		dev_err(cdata->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4 which contains fs range setting */
+	err = lsm303agr_acc_write_data_with_mask(cdata, CTRL_REG2,
+						 LSM303AGR_ACC_FS_MSK,
+						 &new_fs_range);
+	if (err < 0)
+		goto error;
+
+	new_sensitivity = lsm303agr_acc_opmode_table[opmode].sensitivity[indx];
+	sdata->sensitivity = new_sensitivity;
+
+#ifdef LSM303AGR_ACC_DEBUG
+	dev_info(cdata->dev, "%s shift=%d, sens=%d, opm=%d\n",
+		 LSM303AGR_ACC_DEV_NAME, sdata->shift, sdata->sensitivity,
+		 sdata->opmode);
+#endif
+
+	return err;
+error:
+	dev_err(cdata->dev, "update fs range failed %d\n", err);
+
+	return err;
+}
+
+static int lsm303agr_acc_update_odr(struct lsm303agr_common_data *cdata,
+							int poll_interval)
+{
+	u8 buf;
+	int i, err = -1;
+	struct lsm303agr_sensor_data *sdata;
+
+	/**
+	 * Following, looks for the longest possible odr
+	 * interval od -x /dev/input/event0 scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval
+	 */
+	for (i = ARRAY_SIZE(lsm303agr_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303agr_acc_odr_table[i].cutoff_ms <= poll_interval) ||
+		    (i == 0))
+			break;
+	}
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	/* also save requested odr */
+	buf = (sdata->c_odr = lsm303agr_acc_odr_table[i].mask) |
+	      LSM303AGR_ACC_ENABLE_ALL_AXIS;
+
+	/*
+	 * If device is currently enabled, we need to write new
+	 * configuration out to it
+	 */
+	if (atomic_read(&cdata->enabled)) {
+		err = lsm303agr_acc_write_data_with_mask(cdata, CTRL_REG1,
+							 LSM303AGR_ACC_ODR_MSK |
+							 LSM303AGR_ACC_AXIS_MSK,
+							 &buf);
+		if (err < 0)
+			goto error;
+	}
+
+#ifdef LSM303AGR_ACC_DEBUG
+	dev_info(cdata->dev, "update odr to 0x%02x,0x%02x: %d\n",
+			CTRL_REG1, buf, err);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update odr failed 0x%02x,0x%02x: %d\n",
+			CTRL_REG1, buf, err);
+
+	return err;
+}
+
+static int lsm303agr_acc_update_opmode(struct lsm303agr_common_data *cdata,
+				       unsigned short opmode)
+{
+	int err;
+	struct lsm303agr_sensor_data *sdata;
+	u8 lp = 0, hr = 0, indx = 0;
+
+	switch (opmode) {
+	case LSM303AGR_ACC_OPMODE_NORMAL:
+		break;
+	case LSM303AGR_ACC_OPMODE_HR:
+		hr = (1 << __ffs(LSM303AGR_ACC_LP_MSK));
+		break;
+	case LSM303AGR_ACC_OPMODE_LP:
+		lp = (1 << __ffs(LSM303AGR_ACC_HR_MSK));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Set LP bit in CTRL_REG1 */
+	err = lsm303agr_acc_write_data_with_mask(cdata, CTRL_REG1,
+						 LSM303AGR_ACC_LP_MSK, &lp);
+	if (err < 0)
+		goto error;
+
+	/* Set HR bit in CTRL_REG4 */
+	err = lsm303agr_acc_write_data_with_mask(cdata, CTRL_REG2,
+						 LSM303AGR_ACC_HR_MSK,
+						 &hr);
+	if (err < 0)
+		goto error;
+
+	/* Change platform data */
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	sdata->opmode = opmode;
+	sdata->shift = lsm303agr_acc_opmode_table[opmode].shift;
+
+	switch (sdata->fs_range) {
+	case LSM303AGR_ACC_G_2G:
+		indx = 0;
+		break;
+	case LSM303AGR_ACC_G_8G:
+		indx = 2;
+		break;
+	}
+	sdata->sensitivity = lsm303agr_acc_opmode_table[opmode].sensitivity[indx];
+
+#ifdef LSM303AGR_ACC_DEBUG
+	dev_info(cdata->dev, "%s shift=%d, sens=%d, opm=%d\n",
+		 LSM303AGR_ACC_DEV_NAME, sdata->shift, sdata->sensitivity,
+		 sdata->opmode);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update opmode failed: %d\n", err);
+
+	return err;
+}
+
+static int
+lsm303agr_acc_get_acceleration_data(struct lsm303agr_common_data *cdata, int *xyz)
+{
+	int err;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	u32 sensitivity, shift;
+
+	err = cdata->tf->read(cdata->dev, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	/* Get the current sensitivity and shift values */
+	sensitivity = cdata->sensors[LSM303AGR_ACC_SENSOR].sensitivity;
+	shift = cdata->sensors[LSM303AGR_ACC_SENSOR].shift;
+
+	/* Transform LSBs into ug */
+	xyz[0] = (s32)((s16)(acc_data[0] | (acc_data[1] << 8)) >> shift) * sensitivity;
+	xyz[1] = (s32)((s16)(acc_data[2] | (acc_data[3] << 8)) >> shift) * sensitivity;
+	xyz[2] = (s32)((s16)(acc_data[4] | (acc_data[5] << 8)) >> shift) * sensitivity;
+
+#ifdef LSM303AGR_ACC_DEBUG
+	dev_info(cdata->dev, "%s read x=%d, y=%d, z=%d\n",
+		 LSM303AGR_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+#endif
+
+	return err;
+}
+
+static void lsm303agr_acc_report_values(struct lsm303agr_common_data *cdata,
+					int *xyz, s64 timestamp)
+{
+	struct lsm303agr_sensor_data *sdata;
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(sdata->input_dev);
+}
+
+int lsm303agr_acc_enable(struct lsm303agr_common_data *cdata)
+{
+	if (!atomic_cmpxchg(&cdata->enabled, 0, 1)) {
+		int err;
+		struct lsm303agr_sensor_data *sdata;
+
+		mutex_lock(&cdata->lock);
+
+		sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+		err = lsm303agr_acc_device_power_on(cdata);
+		if (err < 0) {
+			atomic_set(&cdata->enabled, 0);
+			return err;
+		}
+		schedule_delayed_work(&sdata->input_work,
+				      msecs_to_jiffies(sdata->poll_interval));
+
+		mutex_unlock(&cdata->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303agr_acc_enable);
+
+int lsm303agr_acc_disable(struct lsm303agr_common_data *cdata)
+{
+	if (atomic_cmpxchg(&cdata->enabled, 1, 0)) {
+		struct lsm303agr_sensor_data *sdata;
+
+		sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+		cancel_delayed_work_sync(&sdata->input_work);
+
+		mutex_lock(&cdata->lock);
+		lsm303agr_acc_device_power_off(cdata);
+		mutex_unlock(&cdata->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303agr_acc_disable);
+
+static ssize_t attr_get_sched_num_acc(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	val = cdata->sensors[LSM303AGR_ACC_SENSOR].schedule_num;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_sched_num_acc(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	unsigned long sched_num;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &sched_num))
+		return -EINVAL;
+
+	mutex_lock(&cdata->lock);
+	cdata->sensors[LSM303AGR_ACC_SENSOR].schedule_num = sched_num;
+	mutex_unlock(&cdata->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_polling_rate_acc(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int val;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	val = cdata->sensors[LSM303AGR_ACC_SENSOR].poll_interval;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate_acc(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	unsigned long interval_ms;
+	struct lsm303agr_sensor_data *sdata;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+			    sdata->min_interval);
+
+	mutex_lock(&cdata->lock);
+	sdata->poll_interval = interval_ms;
+	lsm303agr_acc_update_odr(cdata, interval_ms);
+	mutex_unlock(&cdata->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range_acc(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct lsm303agr_sensor_data *sdata;
+	char range = 2;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+
+	mutex_lock(&cdata->lock);
+	switch (sdata->fs_range) {
+	case LSM303AGR_ACC_G_2G:
+		range = 2;
+		break;
+	case LSM303AGR_ACC_G_8G:
+		range = 8;
+		break;
+	}
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_acc(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	u8 range;
+	int err;
+	unsigned long val;
+	struct lsm303agr_sensor_data *sdata;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LSM303AGR_ACC_G_2G;
+		break;
+	case 8:
+		range = LSM303AGR_ACC_G_8G;
+		break;
+	default:
+		dev_err(cdata->dev,
+			"invalid range request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = lsm303agr_acc_update_fs_range(cdata, range);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	sdata->fs_range = range;
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_opmode_acc(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	char opmode;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	opmode = cdata->sensors[LSM303AGR_ACC_SENSOR].opmode;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d\n", opmode);
+}
+
+static ssize_t attr_set_opmode_acc(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 opmode;
+	unsigned long val;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid opmode */
+	switch (val) {
+	case LSM303AGR_ACC_OPMODE_NORMAL:
+	case LSM303AGR_ACC_OPMODE_HR:
+	case LSM303AGR_ACC_OPMODE_LP:
+		opmode = val;
+		break;
+	default:
+		dev_err(cdata->dev,
+			"invalid range request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = lsm303agr_acc_update_opmode(cdata, opmode);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "opmode set to: %u\n", opmode);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_acc(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+	int val = atomic_read(&cdata->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_acc(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303agr_acc_enable(cdata);
+	else
+		lsm303agr_acc_disable(cdata);
+
+	return size;
+}
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate_acc,
+	       attr_set_polling_rate_acc),
+	__ATTR(range, 0664, attr_get_range_acc, attr_set_range_acc),
+	__ATTR(opmode, 0664, attr_get_opmode_acc, attr_set_opmode_acc),
+	__ATTR(enable_device, 0664, attr_get_enable_acc, attr_set_enable_acc),
+	__ATTR(schedule_num, 0664, attr_get_sched_num_acc,
+	       attr_set_sched_num_acc),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lsm303agr_acc_input_work_func(struct work_struct *work)
+{
+	struct lsm303agr_common_data *cdata;
+	struct lsm303agr_sensor_data *sdata;
+	int err, xyz[3] = {};
+
+	sdata = container_of((struct delayed_work *)work,
+			     struct lsm303agr_sensor_data, input_work);
+	cdata = sdata->cdata;
+
+	mutex_lock(&cdata->lock);
+	sdata->schedule_num++;
+	err = lsm303agr_acc_get_acceleration_data(cdata, xyz);
+	if (err < 0)
+		dev_err(cdata->dev, "get_acceleration_data failed\n");
+	else
+		lsm303agr_acc_report_values(cdata, xyz, lsm303agr_get_time_ns());
+
+	schedule_delayed_work(&sdata->input_work, msecs_to_jiffies(
+			      sdata->poll_interval));
+	mutex_unlock(&cdata->lock);
+}
+
+static void lsm303agr_acc_input_cleanup(struct lsm303agr_common_data *cdata)
+{
+	struct lsm303agr_sensor_data *sdata;
+
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+int lsm303agr_acc_probe(struct lsm303agr_common_data *cdata)
+{
+	int err;
+	struct lsm303agr_sensor_data *sdata;
+
+	mutex_lock(&cdata->lock);
+	/* init sensor data structure */
+	sdata = &cdata->sensors[LSM303AGR_ACC_SENSOR];
+
+	sdata->cdata = cdata;
+	sdata->poll_interval = 100;
+	sdata->min_interval = LSM303AGR_ACC_MIN_POLL_PERIOD_MS;
+
+	err = lsm303agr_acc_device_power_on(cdata);
+	if (err < 0) {
+		dev_err(cdata->dev, "power on failed: %d\n", err);
+		goto  err_power_off;
+	}
+
+	atomic_set(&cdata->enabled, 1);
+
+	err = lsm303agr_acc_update_fs_range(cdata, LSM303AGR_ACC_G_2G);
+	if (err < 0) {
+		dev_err(cdata->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303agr_acc_update_odr(cdata, sdata->poll_interval);
+	if (err < 0) {
+		dev_err(cdata->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303agr_acc_update_opmode(cdata, LSM303AGR_ACC_OPMODE_NORMAL);
+	if (err < 0) {
+		dev_err(cdata->dev, "update_opmode failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303agr_acc_input_init(sdata, LSM303AGR_ACC_DEV_NAME);
+	if (err < 0) {
+		dev_err(cdata->dev, "input init failed\n");
+		goto err_power_off;
+	}
+	INIT_DELAYED_WORK(&sdata->input_work, lsm303agr_acc_input_work_func);
+
+
+	err = create_sysfs_interfaces(cdata->dev);
+	if (err < 0) {
+		dev_err(cdata->dev,
+		   "device LSM303AGR_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm303agr_acc_device_power_off(cdata);
+
+	/* As default, do not report information */
+	atomic_set(&cdata->enabled, 0);
+
+	dev_info(cdata->dev, "%s: probed\n", LSM303AGR_ACC_DEV_NAME);
+
+	mutex_unlock(&cdata->lock);
+
+	return 0;
+
+err_input_cleanup:
+	lsm303agr_acc_input_cleanup(cdata);
+err_power_off:
+	lsm303agr_acc_device_power_off(cdata);
+	mutex_unlock(&cdata->lock);
+	pr_err("%s: Driver Init failed\n", LSM303AGR_ACC_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm303agr_acc_probe);
+
+void lsm303agr_acc_remove(struct lsm303agr_common_data *cdata)
+{
+	lsm303agr_acc_disable(cdata);
+	lsm303agr_acc_input_cleanup(cdata);
+	remove_sysfs_interfaces(cdata->dev);
+}
+EXPORT_SYMBOL(lsm303agr_acc_remove);
+
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_i2c.c b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,194 @@
+/*
+ * STMicroelectronics lsm303agr_acc_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303agr_core.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_acc_i2c_read(struct device *dev, u8 reg_addr, int len,
+				  u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		reg_addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_acc_i2c_write(struct device *dev, u8 reg_addr, int len,
+				   u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		reg_addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+/* I2C IO routines */
+static const struct lsm303agr_transfer_function lsm303agr_acc_i2c_tf = {
+	.write = lsm303agr_acc_i2c_write,
+	.read = lsm303agr_acc_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303agr_acc_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lsm303agr_common_data *cdata = i2c_get_clientdata(client);
+
+	if (cdata->on_before_suspend)
+		return lsm303agr_acc_enable(cdata);
+	return 0;
+}
+
+static int lsm303agr_acc_i2c_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lsm303agr_common_data *cdata = i2c_get_clientdata(client);
+
+	cdata->on_before_suspend = atomic_read(&cdata->enabled);
+	return lsm303agr_acc_disable(cdata);
+}
+
+static const struct dev_pm_ops lsm303agr_acc_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303agr_acc_i2c_suspend,
+				lsm303agr_acc_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303agr_acc_i2c_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303agr_common_data *cdata;
+
+	dev_info(&client->dev, "probe start.\n");
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct lsm303agr_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensor_num = LSM303AGR_MAX_SENSORS_NUM;
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bus_type = BUS_I2C;
+	cdata->tf = &lsm303agr_acc_i2c_tf;
+
+	i2c_set_clientdata(client, cdata);
+
+	mutex_init(&cdata->lock);
+
+	err = lsm303agr_acc_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303agr_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303agr_common_data *cdata = i2c_get_clientdata(client);
+
+	dev_info(cdata->dev, "driver removing\n");
+
+	lsm303agr_acc_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303agr_acc_i2c_id[] = {
+	{ "lsm303agr_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303agr_acc_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303agr_acc_i2c_id_table[] = {
+	{.compatible = "st,lsm303agr_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303agr_acc_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm303agr_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303agr_acc",
+#ifdef CONFIG_PM
+		.pm = &lsm303agr_acc_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303agr_acc_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303agr_acc_i2c_probe,
+	.remove = lsm303agr_acc_i2c_remove,
+	.id_table = lsm303agr_acc_i2c_id,
+};
+
+module_i2c_driver(lsm303agr_acc_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303agr accelerometer i2c driver");
+MODULE_AUTHOR("Armando Visconti");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_spi.c b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_acc_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm303agr_acc_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/input.h>
+
+#include "lsm303agr_core.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_acc_spi_read(struct device *dev, u8 reg_addr, int len,
+				  u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		reg_addr |= SPI_AUTO_INCREMENT;
+
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_acc_spi_write(struct device *dev, u8 reg_addr, int len,
+				   u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303AGR_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		reg_addr |= SPI_AUTO_INCREMENT;
+
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static const struct lsm303agr_transfer_function lsm303agr_acc_spi_tf = {
+	.write = lsm303agr_acc_spi_write,
+	.read = lsm303agr_acc_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303agr_acc_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	cdata->on_before_suspend = atomic_read(&cdata->enabled);
+	return lsm303agr_acc_disable(cdata);
+}
+
+static int lsm303agr_acc_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	if (cdata->on_before_suspend)
+		return lsm303agr_acc_enable(cdata);
+	return 0;
+}
+
+static const struct dev_pm_ops lsm303agr_acc_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303agr_acc_spi_suspend,
+				lsm303agr_acc_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303agr_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm303agr_common_data *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->sensor_num = LSM303AGR_MAX_SENSORS_NUM;
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->bus_type = BUS_SPI;
+	cdata->tf = &lsm303agr_acc_spi_tf;
+	spi_set_drvdata(spi, cdata);
+
+	mutex_init(&cdata->lock);
+
+	err = lsm303agr_acc_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+		return err;
+	}
+
+	return 0;
+}
+
+static int lsm303agr_acc_spi_remove(struct spi_device *spi)
+{
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	lsm303agr_acc_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303agr_acc_spi_ids[] = {
+	{ "lsm303agr_acc", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm303agr_acc_spi_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303agr_acc_spi_id_table[] = {
+	{ .compatible = "st,lsm303agr_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303agr_acc_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm303agr_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303agr_acc",
+#ifdef CONFIG_PM
+		.pm = &lsm303agr_acc_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303agr_acc_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe    = lsm303agr_acc_spi_probe,
+	.remove   = lsm303agr_acc_spi_remove,
+	.id_table = lsm303agr_acc_spi_ids,
+};
+
+module_spi_driver(lsm303agr_acc_spi_driver);
+
+MODULE_DESCRIPTION("lsm303agr accelerometer spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_core.h b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_core.h
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_core.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,112 @@
+/*
+ * STMicroelectronics lsm303agr driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef	__LSM303AGR_H__
+#define	__LSM303AGR_H__
+
+#ifdef __KERNEL__
+
+#define LSM303AGR_MAX_SENSORS_NUM	1
+#define LSM303AGR_ACC_SENSOR		0 /* only this sensor */
+#define LSM303AGR_MAG_SENSOR		0 /* only this sensor */
+
+struct lsm303agr_common_data;
+
+/* specific bus I/O functions */
+struct lsm303agr_transfer_function {
+	int (*write) (struct device *dev, u8 reg_addr, int len, u8 *data);
+	int (*read) (struct device *dev, u8 reg_addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LSM303AGR_SPI) || \
+    defined(CONFIG_INPUT_LSM303AGR_SPI_MODULE)
+#define LSM303AGR_RX_MAX_LENGTH		500
+#define LSM303AGR_TX_MAX_LENGTH		500
+
+struct lsm303agr_transfer_buffer {
+	u8 rx_buf[LSM303AGR_RX_MAX_LENGTH];
+	u8 tx_buf[LSM303AGR_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LSM303AGR_SPI */
+
+/* Sensor data */
+struct lsm303agr_sensor_data {
+	struct lsm303agr_common_data *cdata;
+	const char* name;
+	s64 timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+	u32 poll_interval;
+	u32 min_interval;
+	u8 fs_range;
+	u32 sensitivity;
+	u16 shift;
+	u16 opmode;
+	struct input_dev *input_dev;
+	struct delayed_work input_work;
+	u32 schedule_num; /* Number of time work_input routine is called */
+};
+
+struct lsm303agr_common_data {
+	const char *name;
+	struct mutex lock;
+	struct device *dev;
+	int hw_initialized;
+	atomic_t enabled;
+	int on_before_suspend;
+	u8 sensor_num;
+	u16 bus_type;
+	struct lsm303agr_sensor_data sensors[LSM303AGR_MAX_SENSORS_NUM];
+	const struct lsm303agr_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM303AGR_SPI) || \
+    defined(CONFIG_INPUT_LSM303AGR_SPI_MODULE)
+	struct lsm303agr_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM303AGR_SPI */
+};
+
+/* Input events used by lsm303agr driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+static inline s64 lsm303agr_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+void lsm303agr_acc_remove(struct lsm303agr_common_data *cdata);
+int lsm303agr_acc_probe(struct lsm303agr_common_data *cdata);
+int lsm303agr_acc_enable(struct lsm303agr_common_data *cdata);
+int lsm303agr_acc_disable(struct lsm303agr_common_data *cdata);
+
+void lsm303agr_mag_remove(struct lsm303agr_common_data *cdata);
+int lsm303agr_mag_probe(struct lsm303agr_common_data *cdata);
+int lsm303agr_mag_enable(struct lsm303agr_common_data *cdata);
+int lsm303agr_mag_disable(struct lsm303agr_common_data *cdata);
+
+#endif /* __KERNEL__ */
+#endif	/* __LSM303AGR_H__ */
+
+
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag.c b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag.c
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,556 @@
+/*
+ * STMicroelectronics lsm303agr_mag.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303agr_core.h"
+
+#define LSM303AGR_MAG_DEV_NAME	"lsm303agr_mag"
+
+/* DEVICE REGISTERS */
+#define WHO_AM_I		0x4F
+#define CFG_REG_A		0x60
+#define AXISDATA_REG		0x68
+#define WHOAMI_LSM303AGR_MAG	0x40
+/* Device operating modes */
+#define MD_CONTINUOS_MODE	0x00
+#define MD_SINGLE_MODE		0x01
+#define MD_IDLE1_MODE		0x02
+#define MD_IDLE2_MODE		0x03
+#define LSM303AGR_MAG_MODE_MSK	0x03
+
+/* Device ODRs */
+#define LSM303AGR_MAG_ODR10_HZ		0x00
+#define LSM303AGR_MAG_ODR20_HZ		0x04
+#define LSM303AGR_MAG_ODR50_HZ		0x08
+#define LSM303AGR_MAG_ODR100_HZ		0x0C
+#define LSM303AGR_MAG_ODR_MSK		0x0C
+
+#define LSM303AGR_MAG_SENSITIVITY	1500	/* uGa/LSB */
+
+/* ODR table */
+struct {
+	u32 time_ms;
+	u32 reg_val;
+} lsm303agr_mag_odr_table[] = {
+	{   10, LSM303AGR_MAG_ODR100_HZ	}, /* ODR = 100Hz */
+	{   20, LSM303AGR_MAG_ODR50_HZ	}, /* ODR = 50Hz */
+	{   50, LSM303AGR_MAG_ODR20_HZ	}, /* ODR = 20Hz */
+	{  100, LSM303AGR_MAG_ODR10_HZ	}, /* ODR = 10Hz */
+};
+
+/* read and write with mask a given register */
+static int lsm303agr_mag_write_data_with_mask(struct lsm303agr_common_data *cdata,
+					      u8 reg_addr, u8 mask, u8 *data)
+{
+	int err;
+	u8 new_data, old_data = 0;
+
+	err = cdata->tf->read(cdata->dev, reg_addr, 1, &old_data);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((*data) & mask));
+
+#ifdef LSM303AGR_MAG_DEBUG
+	dev_info(cdata->dev, "%s %02x o=%02x d=%02x n=%02x\n",
+		 LSM303AGR_MAG_DEV_NAME, reg_addr, old_data, *data, new_data);
+#endif
+
+	/* Save for caller usage the data that is about to be written */
+	*data = new_data;
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata->dev, reg_addr, 1, &new_data);
+}
+
+int lsm303agr_mag_input_init(struct lsm303agr_sensor_data *sdata,
+			     const char* description)
+{
+	int err;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = description;
+	sdata->input_dev->id.bustype = sdata->cdata->bus_type;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev,
+			"unable to register input device %s\n",
+			sdata->input_dev->name);
+		input_free_device(sdata->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+/* Check if WHO_AM_I is correct */
+static int lsm303agr_mag_check_wai(struct lsm303agr_common_data *cdata)
+{
+	int err;
+	u8 wai;
+
+#ifdef LSM303AGR_MAG_DEBUG
+	pr_info("%s: check WAI start\n", LSM303AGR_MAG_DEV_NAME);
+#endif
+
+	err = cdata->tf->read(cdata->dev, WHO_AM_I, 1, &wai);
+	if (err < 0) {
+		dev_warn(cdata->dev,
+		"Error reading WHO_AM_I: is device available/working?\n");
+		goto error;
+	}
+
+	if (wai != WHOAMI_LSM303AGR_MAG) {
+		dev_err(cdata->dev,
+			"device unknown. Expected: 0x%02x," " Replies: 0x%02x\n",
+			WHOAMI_LSM303AGR_MAG, wai);
+		err = -1; /* choose the right coded error */
+		goto error;
+	}
+
+	cdata->hw_initialized = 1;
+#ifdef LSM303AGR_MAG_DEBUG
+	pr_info("%s: check WAI done\n", LSM303AGR_MAG_DEV_NAME);
+#endif
+	return 0;
+
+error:
+	cdata->hw_initialized = 0;
+	dev_err(cdata->dev,
+		"check WAI error 0x%02x,0x%02x: %d\n", WHO_AM_I, wai, err);
+
+	return err;
+}
+
+static int lsm303agr_mag_set_odr(struct lsm303agr_common_data *cdata, u8 odr)
+{
+	u8 odr_reg;
+	int err = -1, i;
+	struct lsm303agr_sensor_data *sdata;
+
+	/**
+	 * Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward
+	 * (longest interval), to support the poll_interval requested
+	 * by the system. It must be the longest interval lower
+	 * than the poll interval
+	 */
+	for (i = ARRAY_SIZE(lsm303agr_mag_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303agr_mag_odr_table[i].time_ms <= odr) || (i == 0))
+			break;
+	}
+
+	odr_reg = lsm303agr_mag_odr_table[i].reg_val;
+	sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+	sdata->poll_interval = sdata->c_odr = lsm303agr_mag_odr_table[i].time_ms;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&cdata->enabled)) {
+		err = lsm303agr_mag_write_data_with_mask(cdata, CFG_REG_A,
+							 LSM303AGR_MAG_ODR_MSK,
+							 &odr_reg);
+		if (err < 0)
+			goto error;
+#ifdef LSM303AGR_MAG_DEBUG
+		dev_info(cdata->dev, "update odr to 0x%02x,0x%02x: %d\n",
+			 CFG_REG_A, odr_reg, err);
+#endif
+	}
+
+	return lsm303agr_mag_odr_table[i].time_ms;
+
+error:
+	dev_err(cdata->dev, "set odr failed 0x%02x,0x%02x: %d\n",
+		CFG_REG_A, odr_reg, err);
+
+	return err;
+}
+
+static int lsm303agr_mag_set_device_mode(struct lsm303agr_common_data *cdata,
+					 u8 mode)
+{
+	int err;
+
+	err = lsm303agr_mag_write_data_with_mask(cdata, CFG_REG_A,
+						 LSM303AGR_MAG_MODE_MSK,
+						 &mode);
+	if (err < 0)
+		goto error;
+
+#ifdef LSM303AGR_MAG_DEBUG
+	dev_info(cdata->dev, "update mode to 0x%02x,0x%02x: %d\n",
+			CFG_REG_A, mode, err);
+#endif
+
+	return 0;
+
+error:
+	dev_err(cdata->dev,
+		"set continuos mode failed 0x%02x,0x%02x: %d\n",
+		CFG_REG_A, mode, err);
+
+	return err;
+}
+
+/* Set device in continuos mode */
+int lsm303agr_mag_enable(struct lsm303agr_common_data *cdata)
+{
+	struct lsm303agr_sensor_data *sdata;
+	int err;
+
+	mutex_lock(&cdata->lock);
+	/* Set the magnetometer in continuos mode */
+	err = lsm303agr_mag_set_device_mode(cdata, MD_CONTINUOS_MODE);
+	if (err < 0) {
+		dev_err(cdata->dev, "set_continuos failed: %d\n",
+			err);
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+
+	atomic_set(&cdata->enabled, 1);
+
+	sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+	if (lsm303agr_mag_set_odr(cdata, sdata->c_odr) < 0) {
+		mutex_unlock(&cdata->lock);
+		return -1;
+	}
+
+	/* Start scheduling input */
+	schedule_delayed_work(&sdata->input_work,
+			      msecs_to_jiffies(sdata->poll_interval));
+	mutex_unlock(&cdata->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303agr_mag_enable);
+
+/* Set device in idle mode */
+int lsm303agr_mag_disable(struct lsm303agr_common_data *cdata)
+{
+	if (atomic_cmpxchg(&cdata->enabled, 1, 0)) {
+		int err;
+		struct lsm303agr_sensor_data *sdata;
+
+		sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+		cancel_delayed_work_sync(&sdata->input_work);
+
+		mutex_lock(&cdata->lock);
+		/* Set the magnetometer in idle mode */
+		err = lsm303agr_mag_set_device_mode(cdata, MD_IDLE2_MODE);
+		if (err < 0) {
+			dev_err(cdata->dev, "set_idle failed: %d\n",
+				err);
+			mutex_unlock(&cdata->lock);
+			return err;
+		}
+		mutex_unlock(&cdata->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303agr_mag_disable);
+
+static void lsm303agr_mag_report_event(struct lsm303agr_common_data *cdata,
+					int *xyz, s64 timestamp)
+{
+	struct lsm303agr_sensor_data *sdata;
+
+	sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(sdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(sdata->input_dev);
+}
+
+static int lsm303agr_mag_get_data(struct lsm303agr_common_data *cdata,
+				  int *xyz)
+{
+	int err;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 mag_data[6];
+
+	err = cdata->tf->read(cdata->dev, AXISDATA_REG, 6, mag_data);
+	if (err < 0)
+		return err;
+
+	/* Transform LSBs into ug */
+	xyz[0] = (s32)((s16)(mag_data[0] | (mag_data[1] << 8)));
+	xyz[0] *= LSM303AGR_MAG_SENSITIVITY;
+	xyz[1] = (s32)((s16)(mag_data[2] | (mag_data[3] << 8)));
+	xyz[1] *= LSM303AGR_MAG_SENSITIVITY;
+	xyz[2] = (s32)((s16)(mag_data[4] | (mag_data[5] << 8)));
+	xyz[2] *= LSM303AGR_MAG_SENSITIVITY;
+
+#ifdef LSM303AGR_MAG_DEBUG
+	dev_info(cdata->dev, "%s read x=%d, y=%d, z=%d\n",
+		 LSM303AGR_MAG_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+#endif
+
+	return err;
+}
+
+static void lsm303agr_mag_input_work_func(struct work_struct *work)
+{
+	struct lsm303agr_common_data *cdata;
+	struct lsm303agr_sensor_data *sdata;
+	int err, xyz[3] = {};
+
+	sdata = container_of((struct delayed_work *)work,
+			     struct lsm303agr_sensor_data, input_work);
+	cdata = sdata->cdata;
+
+	mutex_lock(&cdata->lock);
+	sdata->schedule_num++;
+	err = lsm303agr_mag_get_data(cdata, xyz);
+	if (err < 0)
+		dev_err(cdata->dev, "get_mag_data failed\n");
+	else
+		lsm303agr_mag_report_event(cdata, xyz,
+					   lsm303agr_get_time_ns());
+
+	schedule_delayed_work(&sdata->input_work,
+			      msecs_to_jiffies(sdata->poll_interval));
+	mutex_unlock(&cdata->lock);
+}
+
+static void lsm303agr_mag_input_cleanup(struct lsm303agr_common_data *cdata)
+{
+	struct lsm303agr_sensor_data *sdata;
+
+	sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+/* SYSFS: set val to polling_ms ATTR */
+static ssize_t attr_get_polling_rate_mag(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	u32 val = 0;
+	struct lsm303agr_sensor_data *sdata;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+
+	/* read from platform data */
+	mutex_lock(&cdata->lock);
+	val = sdata->poll_interval;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate_mag(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	unsigned long val = 0;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (!val)
+		return -EINVAL;
+
+	mutex_lock(&cdata->lock);
+	/* set ODR */
+	val = lsm303agr_mag_set_odr(cdata, val);
+	if (val < 0) {
+		mutex_unlock(&cdata->lock);
+		return -1;
+	}
+
+	/* write to platform data */
+	cdata->sensors[LSM303AGR_MAG_SENSOR].poll_interval = val;
+
+	mutex_unlock(&cdata->lock);
+
+	return size;
+}
+
+/* SYSFS: set val to enable_device ATTR */
+static ssize_t attr_get_enable_mag(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+	int val = atomic_read(&cdata->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+/* SYSFS: get val from enable_device ATTR */
+static ssize_t attr_set_enable_mag(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm303agr_common_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303agr_mag_enable(cdata);
+	else
+		lsm303agr_mag_disable(cdata);
+
+	return size;
+}
+
+static struct device_attribute lsm303agr_mag_attributes[] = {
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate_mag,
+	       attr_set_polling_rate_mag),
+	__ATTR(enable_device, 0664, attr_get_enable_mag, attr_set_enable_mag),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lsm303agr_mag_attributes); i++)
+		if (device_create_file(dev, lsm303agr_mag_attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, lsm303agr_mag_attributes + i);
+
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(lsm303agr_mag_attributes); i++)
+		device_remove_file(dev, lsm303agr_mag_attributes + i);
+
+	return 0;
+}
+
+int lsm303agr_mag_probe(struct lsm303agr_common_data *cdata)
+{
+	int err;
+	struct lsm303agr_sensor_data *sdata;
+
+	mutex_lock(&cdata->lock);
+	/* init sensor data structure */
+	sdata = &cdata->sensors[LSM303AGR_MAG_SENSOR];
+	sdata->cdata = cdata;
+
+	/* Check WHO_AM_I */
+	err = lsm303agr_mag_check_wai(cdata);
+	if (err < 0) {
+		dev_err(cdata->dev, "check WAI failed\n");
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+
+	/* Set device ODR to 100ms (10Hz) */
+	err = lsm303agr_mag_set_odr(cdata, 100);
+	if (err < 0) {
+		dev_err(cdata->dev, "Set ODR On failed\n");
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+
+	/* Disable Magnetometer to save power */
+	mutex_unlock(&cdata->lock);
+	err = lsm303agr_mag_disable(cdata);
+	if (err < 0) {
+		dev_err(cdata->dev, "Power On failed\n");
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+
+	mutex_lock(&cdata->lock);
+	/* Init the input framework */
+	err = lsm303agr_mag_input_init(sdata, LSM303AGR_MAG_DEV_NAME);
+	if (err < 0) {
+		dev_err(cdata->dev, "input init failed\n");
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	INIT_DELAYED_WORK(&sdata->input_work, lsm303agr_mag_input_work_func);
+
+	/* Create SYSFS interface */
+	err = create_sysfs_interfaces(cdata->dev);
+	if (err < 0) {
+		dev_err(cdata->dev,
+		   "device LSM303AGR_MAG_DEV_NAME sysfs register failed\n");
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+
+	dev_info(cdata->dev, "%s: probed\n", LSM303AGR_MAG_DEV_NAME);
+	mutex_unlock(&cdata->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303agr_mag_probe);
+
+void lsm303agr_mag_remove(struct lsm303agr_common_data *cdata)
+{
+	lsm303agr_mag_disable(cdata);
+	lsm303agr_mag_input_cleanup(cdata);
+	remove_sysfs_interfaces(cdata->dev);
+}
+EXPORT_SYMBOL(lsm303agr_mag_remove);
+
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_i2c.c b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,197 @@
+/*
+ * STMicroelectronics lsm303agr_mag_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303agr_core.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_mag_i2c_read(struct device *dev, u8 reg_addr, int len,
+				  u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		reg_addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_mag_i2c_write(struct device *dev, u8 reg_addr, int len,
+				   u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		reg_addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+/* I2C IO routines */
+static const struct lsm303agr_transfer_function lsm303agr_mag_i2c_tf = {
+	.write = lsm303agr_mag_i2c_write,
+	.read = lsm303agr_mag_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303agr_mag_i2c_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lsm303agr_common_data *cdata = i2c_get_clientdata(client);
+
+	if (cdata->on_before_suspend)
+		return lsm303agr_mag_enable(cdata);
+	return 0;
+}
+
+static int lsm303agr_mag_i2c_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lsm303agr_common_data *cdata = i2c_get_clientdata(client);
+
+	cdata->on_before_suspend = atomic_read(&cdata->enabled);
+	return lsm303agr_mag_disable(cdata);
+}
+
+static const struct dev_pm_ops lsm303agr_mag_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303agr_mag_i2c_suspend,
+				lsm303agr_mag_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303agr_mag_i2c_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303agr_common_data *cdata;
+
+	dev_info(&client->dev, "probe start.\n");
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct lsm303agr_common_data), GFP_KERNEL);
+	if (cdata == NULL) {
+		dev_err(&client->dev,
+			"failed to allocate memory for module data\n");
+		mutex_unlock(&cdata->lock);
+
+		return -ENOMEM;
+	}
+
+	cdata->sensor_num = LSM303AGR_MAX_SENSORS_NUM;
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bus_type = BUS_I2C;
+	cdata->tf = &lsm303agr_mag_i2c_tf;
+
+	i2c_set_clientdata(client, cdata);
+
+	mutex_init(&cdata->lock);
+
+	err = lsm303agr_mag_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303agr_mag_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303agr_common_data *cdata = i2c_get_clientdata(client);
+
+	dev_info(cdata->dev, "driver removing\n");
+
+	lsm303agr_mag_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303agr_mag_i2c_id[] = {
+	{ "lsm303agr_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303agr_mag_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303agr_mag_i2c_id_table[] = {
+	{.compatible = "st,lsm303agr_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303agr_mag_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm303agr_mag_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303agr_mag",
+#ifdef CONFIG_PM
+		.pm = &lsm303agr_mag_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303agr_mag_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303agr_mag_i2c_probe,
+	.remove = lsm303agr_mag_i2c_remove,
+	.id_table = lsm303agr_mag_i2c_id,
+};
+
+module_i2c_driver(lsm303agr_mag_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303agr magnetometer i2c driver");
+MODULE_AUTHOR("Armando Visconti");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_spi.c b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/lsm303agr_mag_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,200 @@
+/*
+ * STMicroelectronics lsm303agr_mag_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/input.h>
+
+#include "lsm303agr_core.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_mag_spi_read(struct device *dev, u8 reg_addr, int len,
+				  u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		reg_addr |= SPI_AUTO_INCREMENT;
+
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303agr_mag_spi_write(struct device *dev, u8 reg_addr, int len,
+				   u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303AGR_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		reg_addr |= SPI_AUTO_INCREMENT;
+
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static const struct lsm303agr_transfer_function lsm303agr_mag_spi_tf = {
+	.write = lsm303agr_mag_spi_write,
+	.read = lsm303agr_mag_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303agr_mag_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	cdata->on_before_suspend = atomic_read(&cdata->enabled);
+	return lsm303agr_mag_disable(cdata);
+}
+
+static int lsm303agr_mag_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	if (cdata->on_before_suspend)
+		return lsm303agr_mag_enable(cdata);
+	return 0;
+}
+
+static const struct dev_pm_ops lsm303agr_mag_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303agr_mag_spi_suspend,
+				lsm303agr_mag_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303agr_mag_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm303agr_common_data *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->sensor_num = LSM303AGR_MAX_SENSORS_NUM;
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->bus_type = BUS_SPI;
+	cdata->tf = &lsm303agr_mag_spi_tf;
+	spi_set_drvdata(spi, cdata);
+
+	mutex_init(&cdata->lock);
+
+	err = lsm303agr_mag_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+static int lsm303agr_mag_spi_remove(struct spi_device *spi)
+{
+	struct lsm303agr_common_data *cdata = spi_get_drvdata(spi);
+
+	lsm303agr_mag_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303agr_mag_spi_ids[] = {
+	{ "lsm303agr_mag", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm303agr_mag_spi_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303agr_mag_spi_id_table[] = {
+	{ .compatible = "st,lsm303agr_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303agr_mag_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm303agr_mag_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303agr_mag",
+#ifdef CONFIG_PM
+		.pm = &lsm303agr_mag_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303agr_mag_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe    = lsm303agr_mag_spi_probe,
+	.remove   = lsm303agr_mag_spi_remove,
+	.id_table = lsm303agr_mag_spi_ids,
+};
+
+module_spi_driver(lsm303agr_mag_spi_driver);
+
+
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303agr/Makefile b/drivers/input/misc/st/ecompass/lsm303agr/Makefile
--- a/drivers/input/misc/st/ecompass/lsm303agr/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303agr/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,10 @@
+#
+# Makefile for the input misc lsm303agr driver.
+#
+
+# Each configuration option enables a list of files.
+
+lsm303agr-y += lsm303agr_acc.o lsm303agr_mag.o
+obj-$(CONFIG_INPUT_LSM303AGR) += lsm303agr.o
+obj-$(CONFIG_INPUT_LSM303AGR_I2C) += lsm303agr_acc_i2c.o lsm303agr_mag_i2c.o
+obj-$(CONFIG_INPUT_LSM303AGR_SPI) += lsm303agr_acc_spi.o lsm303agr_mag_spi.o
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/Kconfig b/drivers/input/misc/st/ecompass/lsm303ah/Kconfig
--- a/drivers/input/misc/st/ecompass/lsm303ah/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,18 @@
+config INPUT_LSM303AH
+         tristate "STM LSM303AH sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LSM303AH_I2C if (I2C)
+	 select INPUT_LSM303AH_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics LSM303AH sensor.
+
+config INPUT_LSM303AH_I2C
+         tristate
+         depends on INPUT_LSM303AH
+         depends on I2C
+
+config INPUT_LSM303AH_SPI
+         tristate
+         depends on INPUT_LSM303AH
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1250 @@
+/*
+ * STMicroelectronics lsm303ah_acc.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include "lsm303ah_core.h"
+
+#define LSM303AH_CTRL1_ADDR			0x20
+#define LSM303AH_CTRL2_ADDR			0x21
+#define LSM303AH_CTRL3_ADDR			0x22
+#define LSM303AH_CTRL4_INT1_PAD_ADDR		0x23
+#define LSM303AH_CTRL5_INT2_PAD_ADDR		0x24
+#define LSM303AH_STATUS_ADDR			0x27
+#define LSM303AH_OUTX_L_ADDR			0x28
+#define LSM303AH_TAP_THS_6D_ADDR		0x31
+#define LSM303AH_INT_DUR_ADDR			0x32
+#define LSM303AH_WAKE_UP_THS_ADDR		0x33
+#define LSM303AH_WAKE_UP_DUR_ADDR		0x34
+#define LSM303AH_FREE_FALL_ADDR			0x35
+#define LSM303AH_STATUS_DUP_ADDR		0x36
+#define LSM303AH_WAKE_UP_SRC_ADDR		0x37
+#define LSM303AH_TAP_SRC_ADDR			0x38
+#define LSM303AH_6D_SRC_ADDR			0x39
+#define LSM303AH_STEP_C_MINTHS_ADDR		0x3a
+#define LSM303AH_STEP_C_MINTHS_RST_NSTEP_MASK	0x80
+#define LSM303AH_STEP_C_OUT_L_ADDR		0x3b
+#define LSM303AH_STEP_C_OUT_SIZE		2
+
+#define LSM303AH_F_CK_GATE_ADDR			0x3d
+#define LSM303AH_F_CK_GATE_TILT_INT_MASK	0x80
+#define LSM303AH_F_CK_GATE_SIGN_M_DET_MASK	0x10
+#define LSM303AH_F_CK_GATE_RST_SIGN_M_MASK	0x08
+#define LSM303AH_F_CK_GATE_RST_PEDO_MASK	0x04
+#define LSM303AH_F_CK_GATE_STEP_D_MASK		0x02
+#define LSM303AH_F_CK_GATE_MASK			(LSM303AH_F_CK_GATE_TILT_INT_MASK | \
+						LSM303AH_F_CK_GATE_SIGN_M_DET_MASK | \
+						LSM303AH_F_CK_GATE_STEP_D_MASK)
+
+#define LSM303AH_F_CTRL_ADDR			0x3f
+#define LSM303AH_F_CTRL_TILT_MASK		0x10
+#define LSM303AH_F_CTRL_SIGN_MOT_MASK		0x02
+#define LSM303AH_F_CTRL_STEP_CNT_MASK		0x01
+#define LSM303AH_F_CTRL_EV_MASK			(LSM303AH_F_CTRL_TILT_MASK | \
+						LSM303AH_F_CTRL_SIGN_MOT_MASK | \
+						LSM303AH_F_CTRL_STEP_CNT_MASK)
+
+#define LSM303AH_INT_STATUS_ADDR		LSM303AH_STATUS_ADDR
+#define LSM303AH_WAKE_UP_IA_MASK		0x40
+#define LSM303AH_DOUBLE_TAP_MASK		0x10
+#define LSM303AH_SINGLE_TAP_MASK		0x08
+#define LSM303AH_6D_IA_MASK			0x04
+#define LSM303AH_FF_IA_MASK			0x02
+#define LSM303AH_DRDY_MASK			0x01
+#define LSM303AH_EVENT_MASK			(LSM303AH_WAKE_UP_IA_MASK | \
+						LSM303AH_DOUBLE_TAP_MASK | \
+						LSM303AH_SINGLE_TAP_MASK | \
+						LSM303AH_6D_IA_MASK | \
+						LSM303AH_FF_IA_MASK)
+
+#define LSM303AH_ODR_ADDR			LSM303AH_CTRL1_ADDR
+#define LSM303AH_ODR_MASK			0xf0
+#define LSM303AH_ODR_POWER_OFF_VAL		0x00
+#define LSM303AH_ODR_1HZ_LP_VAL			0x08
+#define LSM303AH_ODR_12HZ_LP_VAL		0x09
+#define LSM303AH_ODR_25HZ_LP_VAL		0x0a
+#define LSM303AH_ODR_50HZ_LP_VAL		0x0b
+#define LSM303AH_ODR_100HZ_LP_VAL		0x0c
+#define LSM303AH_ODR_200HZ_LP_VAL		0x0d
+#define LSM303AH_ODR_400HZ_LP_VAL		0x0e
+#define LSM303AH_ODR_800HZ_LP_VAL		0x0f
+#define LSM303AH_ODR_LP_LIST_NUM		9
+
+#define LSM303AH_ODR_12_5HZ_HR_VAL		0x01
+#define LSM303AH_ODR_25HZ_HR_VAL		0x02
+#define LSM303AH_ODR_50HZ_HR_VAL		0x03
+#define LSM303AH_ODR_100HZ_HR_VAL		0x04
+#define LSM303AH_ODR_200HZ_HR_VAL		0x05
+#define LSM303AH_ODR_400HZ_HR_VAL		0x06
+#define LSM303AH_ODR_800HZ_HR_VAL		0x07
+#define LSM303AH_ODR_HR_LIST_NUM		8
+
+#define LSM303AH_FS_ADDR			LSM303AH_CTRL1_ADDR
+#define LSM303AH_FS_MASK			0x0c
+#define LSM303AH_FS_2G_VAL			0x00
+#define LSM303AH_FS_4G_VAL			0x02
+#define LSM303AH_FS_8G_VAL			0x03
+#define LSM303AH_FS_16G_VAL			0x01
+
+/*
+ * Sensitivity sets in LP mode [ug]
+ */
+#define LSM303AH_FS_2G_GAIN_LP			3906
+#define LSM303AH_FS_4G_GAIN_LP			7813
+#define LSM303AH_FS_8G_GAIN_LP			15625
+#define LSM303AH_FS_16G_GAIN_LP			31250
+
+/*
+ * Sensitivity sets in HR mode [ug]
+ */
+#define LSM303AH_FS_2G_GAIN_HR			244
+#define LSM303AH_FS_4G_GAIN_HR			488
+#define LSM303AH_FS_8G_GAIN_HR			976
+#define LSM303AH_FS_16G_GAIN_HR			1952
+
+#define LSM303AH_FS_LIST_NUM			4
+enum {
+	LSM303AH_LP_MODE = 0,
+	LSM303AH_HR_MODE,
+	LSM303AH_MODE_COUNT,
+};
+#define LSM303AH_PMODE_DEFAULT			LSM303AH_LP_MODE
+
+#define LSM303AH_INT1_S_TAP_MASK		0x40
+#define LSM303AH_INT1_WAKEUP_MASK		0x20
+#define LSM303AH_INT1_FREE_FALL_MASK		0x10
+#define LSM303AH_INT1_TAP_MASK			0x08
+#define LSM303AH_INT1_6D_MASK			0x04
+#define LSM303AH_INT1_FTH_MASK			0x02
+#define LSM303AH_INT1_DRDY_MASK			0x01
+#define LSM303AH_INT1_EVENTS_MASK		0x7f
+
+#define LSM303AH_INT2_ON_INT1_MASK		0x20
+#define LSM303AH_INT2_TILT_MASK			0x04
+#define LSM303AH_INT2_SIG_MOT_DET_MASK		0x02
+#define LSM303AH_INT2_STEP_DET_MASK		0x01
+#define LSM303AH_INT2_EVENTS_MASK		0x1c
+
+#define LSM303AH_INT_DUR_SHOCK_MASK		0x03
+#define LSM303AH_INT_DUR_QUIET_MASK		0x0c
+#define LSM303AH_INT_DUR_LAT_MASK		0xf0
+#define LSM303AH_INT_DUR_MASK			(LSM303AH_INT_DUR_SHOCK_MASK | \
+						LSM303AH_INT_DUR_QUIET_MASK | \
+						LSM303AH_INT_DUR_LAT_MASK)
+#define LSM303AH_INT_DUR_STAP_DEFAULT		0x06
+#define LSM303AH_INT_DUR_DTAP_DEFAULT		0x7f
+#define LSM303AH_WAKE_UP_THS_S_D_TAP_MASK	0x80
+#define LSM303AH_WAKE_UP_THS_SLEEP_MASK		0x40
+#define LSM303AH_WAKE_UP_THS_WU_MASK		0x3f
+#define LSM303AH_WAKE_UP_THS_WU_DEFAULT		0x02
+#define LSM303AH_FREE_FALL_THS_MASK		0x07
+#define LSM303AH_FREE_FALL_DUR_MASK		0xF8
+#define LSM303AH_FREE_FALL_THS_DEFAULT		0x01
+#define LSM303AH_FREE_FALL_DUR_DEFAULT		0x01
+#define LSM303AH_BDU_ADDR			LSM303AH_CTRL1_ADDR
+#define LSM303AH_BDU_MASK			0x01
+#define LSM303AH_SOFT_RESET_ADDR		LSM303AH_CTRL2_ADDR
+#define LSM303AH_SOFT_RESET_MASK		0x40
+#define LSM303AH_LIR_ADDR			LSM303AH_CTRL3_ADDR
+#define LSM303AH_LIR_MASK			0x04
+#define LSM303AH_TAP_AXIS_ADDR			LSM303AH_CTRL3_ADDR
+#define LSM303AH_TAP_AXIS_MASK			0x38
+#define LSM303AH_TAP_AXIS_ANABLE_ALL		0x07
+
+#define LSM303AH_TAP_THS_ADDR			LSM303AH_TAP_THS_6D_ADDR
+#define LSM303AH_TAP_THS_MASK			0x1f
+#define LSM303AH_TAP_THS_DEFAULT		0x09
+
+#define LSM303AH_INT2_ON_INT1_ADDR		LSM303AH_CTRL5_INT2_PAD_ADDR
+#define LSM303AH_INT2_ON_INT1_MASK		0x20
+
+#define LSM303AH_ACCEL_ODR			1
+#define LSM303AH_ACCEL_FS			2
+#define LSM303AH_FF_ODR				25
+#define LSM303AH_STEP_D_ODR			25
+#define LSM303AH_TILT_ODR			25
+#define LSM303AH_SIGN_M_ODR			25
+#define LSM303AH_TAP_ODR			400
+#define LSM303AH_WAKEUP_ODR			25
+#define LSM303AH_ACTIVITY_ODR			12
+#define LSM303AH_MIN_EVENT_ODR			25
+
+#define LSM303AH_BYTE_FOR_SAMPLE		6
+#define SET_BIT(a, b)				{a |= (1 << b);}
+#define RESET_BIT(a, b)				{a &= ~(1 << b);}
+#define CHECK_BIT(a, b)				(a & (1 << b))
+
+#define LSM303AH_NAME				"lsm303ah_acc"
+
+#define GET_PDATA(cdata)	((priv_data_t *)(cdata->priv_data))
+
+static const struct lsm303ah_sensors_table {
+	const char *name;
+	const char *description;
+	const u32 min_odr_hz;
+} lsm303ah_sensors_table[LSM303AH_SENSORS_NUMB] = {
+	[LSM303AH_ACCEL] = {
+		.name = "accel",
+		.description = "ST LSM303AH Accelerometer Sensor",
+		.min_odr_hz = LSM303AH_ACCEL_ODR,
+	},
+	[LSM303AH_STEP_C] = {
+		.name = "step_c",
+		.description = "ST LSM303AH Step Counter Sensor",
+		.min_odr_hz = LSM303AH_STEP_D_ODR,
+	},
+	[LSM303AH_FF] = {
+		.name = "free_fall",
+		.description = "ST LSM303AH Free Fall Sensor",
+		.min_odr_hz = LSM303AH_FF_ODR,
+	},
+	[LSM303AH_TAP] = {
+		.name = "tap",
+		.description = "ST LSM303AH Tap Sensor",
+		.min_odr_hz = LSM303AH_TAP_ODR,
+	},
+	[LSM303AH_DOUBLE_TAP] = {
+		.name = "double_tap",
+		.description = "ST LSM303AH Double Tap Sensor",
+		.min_odr_hz = LSM303AH_TAP_ODR,
+	},
+	[LSM303AH_STEP_D] = {
+		.name = "step_d",
+		.description = "ST LSM303AH Step Detector Sensor",
+		.min_odr_hz = LSM303AH_STEP_D_ODR,
+	},
+	[LSM303AH_TILT] = {
+		.name = "tilt",
+		.description = "ST LSM303AH Tilt Sensor",
+		.min_odr_hz = LSM303AH_TILT_ODR,
+	},
+	[LSM303AH_SIGN_M] = {
+		.name = "sign_m",
+		.description = "ST LSM303AH Significant Motion Sensor",
+		.min_odr_hz = LSM303AH_SIGN_M_ODR,
+	},
+	[LSM303AH_WAKEUP] = {
+		.name = "wake_up",
+		.description = "ST LSM303AH Free Fall Sensor",
+		.min_odr_hz = LSM303AH_WAKEUP_ODR,
+	},
+	[LSM303AH_ACTIVITY] = {
+		.name = "act",
+		.description = "ST LSM303AH Activity Sensor",
+		.min_odr_hz = LSM303AH_ACTIVITY_ODR,
+	},
+};
+
+static const struct lsm303ah_odr_reg {
+	u32 hz;
+	u8 value;
+} lsm303ah_odr_table[LSM303AH_MODE_COUNT][LSM303AH_ODR_LP_LIST_NUM] = {
+	[LSM303AH_LP_MODE] = {
+		{ .hz = 0,	.value = LSM303AH_ODR_POWER_OFF_VAL, },
+		{ .hz = 1,	.value = LSM303AH_ODR_1HZ_LP_VAL, },
+		{ .hz = 12,	.value = LSM303AH_ODR_12HZ_LP_VAL, },
+		{ .hz = 25,	.value = LSM303AH_ODR_25HZ_LP_VAL, },
+		{ .hz = 50,	.value = LSM303AH_ODR_50HZ_LP_VAL, },
+		{ .hz = 100,	.value = LSM303AH_ODR_100HZ_LP_VAL, },
+		{ .hz = 200,	.value = LSM303AH_ODR_200HZ_LP_VAL, },
+		{ .hz = 400,	.value = LSM303AH_ODR_400HZ_LP_VAL, },
+		{ .hz = 800,	.value = LSM303AH_ODR_800HZ_LP_VAL, },
+	},
+	[LSM303AH_HR_MODE] = {
+		{ .hz = 0,	.value = LSM303AH_ODR_POWER_OFF_VAL, },
+		{ .hz = 12,	.value = LSM303AH_ODR_12_5HZ_HR_VAL },
+		{ .hz = 25,	.value = LSM303AH_ODR_25HZ_HR_VAL },
+		{ .hz = 50,	.value = LSM303AH_ODR_50HZ_HR_VAL },
+		{ .hz = 100,	.value = LSM303AH_ODR_100HZ_HR_VAL },
+		{ .hz = 200,	.value = LSM303AH_ODR_200HZ_HR_VAL },
+		{ .hz = 400,	.value = LSM303AH_ODR_400HZ_HR_VAL },
+		{ .hz = 800,	.value = LSM303AH_ODR_800HZ_HR_VAL },
+	}
+};
+
+struct lsm303ah_fs_reg {
+	unsigned int gain[LSM303AH_MODE_COUNT];
+	u8 value;
+	int urv;
+};
+
+static struct lsm303ah_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lsm303ah_fs_reg fs_avl[LSM303AH_FS_LIST_NUM];
+} lsm303ah_fs_table = {
+	.addr = LSM303AH_FS_ADDR,
+	.mask = LSM303AH_FS_MASK,
+	.fs_avl[0] = { .gain = {LSM303AH_FS_2G_GAIN_LP, LSM303AH_FS_2G_GAIN_HR,},
+			.value = LSM303AH_FS_2G_VAL,
+			.urv = 2, },
+	.fs_avl[1] = { .gain = {LSM303AH_FS_4G_GAIN_LP, LSM303AH_FS_4G_GAIN_HR,},
+			.value = LSM303AH_FS_4G_VAL,
+			.urv = 4, },
+	.fs_avl[2] = { .gain = {LSM303AH_FS_8G_GAIN_LP, LSM303AH_FS_8G_GAIN_LP,},
+			.value = LSM303AH_FS_8G_VAL,
+			.urv = 8, },
+	.fs_avl[3] = { .gain = {LSM303AH_FS_16G_GAIN_LP, LSM303AH_FS_16G_GAIN_HR,},
+			.value = LSM303AH_FS_16G_VAL,
+			.urv = 16, },
+};
+
+static struct workqueue_struct *lsm303ah_acc_wkq = 0;
+
+static int lsm303ah_acc_get_poll_data(struct st_sensor_data *sdata, u8 *data)
+{
+	int err = 0;
+	u8 reg_addr;
+
+	switch(sdata->sindex) {
+		case LSM303AH_ACCEL:
+			reg_addr = LSM303AH_OUTX_L_ADDR;
+
+			break;
+		default:
+			dev_err(sdata->cdata->dev, "invalid polling mode for "
+						"sensor %s\n", sdata->name);
+			return -1;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata, reg_addr,
+					LSM303AH_BYTE_FOR_SAMPLE,
+					data);
+
+	return err;
+}
+
+static int lsm303ah_report_step_c_data(struct st_common_data *cdata)
+{
+	int err;
+	s32 steps;
+	u8 data[2];
+
+	err = cdata->tf->read(cdata, LSM303AH_STEP_C_OUT_L_ADDR,
+						LSM303AH_STEP_C_OUT_SIZE, data);
+	if (err < 0)
+		return err;
+
+	steps = (s32)((u16)(data[1] << 8) | data[0]);
+	st_sensor_report_single_event(&cdata->sensors[LSM303AH_STEP_C], steps);
+
+	return 0;
+}
+
+static inline s32 lsm303ah_acc_data_align(u8 ms, u8 ls, u8 power_mode)
+{
+	if (power_mode == LSM303AH_LP_MODE)
+		return (s32)(((s16)(ls | ms << 8)) >> 6);
+	else
+		return (s32)(((s16)(ls | ms << 8)) >> 2);
+}
+
+static void lsm303ah_acc_poll_wk(struct work_struct *input_work)
+{
+	struct st_sensor_data *sdata;
+	int xyz[3] = { 0 };
+	u8 pmode;
+	u8 data[6];
+	int err;
+
+	sdata = container_of((struct work_struct *)input_work,
+			     struct st_sensor_data, input_work);
+
+	hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+
+	pmode = GET_PDATA(sdata->cdata)->power_mode;
+	err = lsm303ah_acc_get_poll_data(sdata, data);
+	if (err < 0)
+		dev_err(sdata->cdata->dev, "get %s data failed %d\n",
+			sdata->name, err);
+	else {
+		xyz[0] = lsm303ah_acc_data_align(data[1], data[0], pmode);
+		xyz[1] = lsm303ah_acc_data_align(data[3], data[2], pmode);
+		xyz[2] = lsm303ah_acc_data_align(data[5], data[4], pmode);
+
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+		st_sensor_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+}
+
+u8 lsm303ah_event_irq1_value(struct st_common_data *cdata)
+{
+	u8 value = 0x0;
+	priv_data_t *priv = GET_PDATA(cdata);
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_FF))
+		value |= LSM303AH_INT1_FREE_FALL_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_DOUBLE_TAP))
+		value |= LSM303AH_INT1_TAP_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_TAP))
+		value |= LSM303AH_INT1_S_TAP_MASK | LSM303AH_INT1_TAP_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_WAKEUP))
+		value |= LSM303AH_INT1_WAKEUP_MASK;
+	
+	return value;
+}
+
+u8 lsm303ah_event_irq2_value(struct st_common_data *cdata)
+{
+	u8 value = 0x0;
+	priv_data_t *priv = GET_PDATA(cdata);
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_TILT))
+		value |= LSM303AH_INT2_TILT_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_SIGN_M))
+		value |= LSM303AH_INT2_SIG_MOT_DET_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_STEP_C) ||
+			CHECK_BIT(priv->enabled_sensor, LSM303AH_STEP_D))
+		value |= LSM303AH_INT2_STEP_DET_MASK;
+	
+	return value;
+}
+
+int lsm303ah_acc_set_enable_function(struct st_common_data *cdata, bool state,
+				 u8 func_bit_mask)
+{
+	int err = 0;
+	
+	err = st_sensor_write_data(cdata, LSM303AH_F_CTRL_ADDR,
+						func_bit_mask, state);
+	if (err < 0)
+		return err;
+	
+	return 0;
+}
+
+int lsm303ah_update_drdy_irq(struct st_sensor_data *sdata)
+{
+	u8 reg_addr, reg_val, reg_mask;
+	
+	switch (sdata->sindex) {
+		case LSM303AH_FF:
+		case LSM303AH_TAP:
+		case LSM303AH_DOUBLE_TAP:
+		case LSM303AH_WAKEUP:
+		case LSM303AH_ACTIVITY:
+			reg_val = lsm303ah_event_irq1_value(sdata->cdata);
+			reg_addr = LSM303AH_CTRL4_INT1_PAD_ADDR;
+			reg_mask = LSM303AH_INT1_EVENTS_MASK;
+			
+			break;
+			
+		case LSM303AH_SIGN_M:
+		case LSM303AH_TILT:
+		case LSM303AH_STEP_D:
+		case LSM303AH_STEP_C:
+			reg_val = lsm303ah_event_irq2_value(sdata->cdata);
+			reg_addr = LSM303AH_CTRL5_INT2_PAD_ADDR;
+			reg_mask = LSM303AH_INT2_EVENTS_MASK;
+			
+			break;
+			
+		case LSM303AH_ACCEL:
+			return 0;
+			
+			break;
+			
+		default:
+			return -EINVAL;
+	}
+	
+	return st_sensor_write_data(sdata->cdata, reg_addr, reg_mask, reg_val);
+}
+
+int lsm303ah_set_fs(struct st_sensor_data *sdata, unsigned int fs)
+{
+	int err, i;
+	u8 pmode = GET_PDATA(sdata->cdata)->power_mode;
+
+	for (i = 0; i < LSM303AH_FS_LIST_NUM; i++) {
+		if (lsm303ah_fs_table.fs_avl[i].urv == fs)
+			break;
+	}
+
+	if (i == LSM303AH_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = st_sensor_write_data(sdata->cdata, lsm303ah_fs_table.addr,
+					lsm303ah_fs_table.mask,
+					lsm303ah_fs_table.fs_avl[i].value);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = lsm303ah_fs_table.fs_avl[i].gain[pmode];
+
+	return 0;
+}
+
+void lsm303ah_event_management(struct st_common_data *cdata, u8 int_reg_val,
+								u8 ck_gate_val)
+{
+	priv_data_t *priv = GET_PDATA(cdata);
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_TAP) &&
+				(int_reg_val & LSM303AH_SINGLE_TAP_MASK)) {
+		cdata->sensors[LSM303AH_TAP].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_TAP], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_DOUBLE_TAP) &&
+				(int_reg_val & LSM303AH_DOUBLE_TAP_MASK)) {
+		cdata->sensors[LSM303AH_DOUBLE_TAP].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_DOUBLE_TAP], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_FF) &&
+				(int_reg_val & LSM303AH_FF_IA_MASK)) {
+		cdata->sensors[LSM303AH_FF].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_FF], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_WAKEUP) &&
+				(int_reg_val & LSM303AH_WAKE_UP_IA_MASK)) {
+		cdata->sensors[LSM303AH_WAKEUP].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_WAKEUP], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_STEP_D) &&
+				(ck_gate_val & LSM303AH_F_CK_GATE_STEP_D_MASK)) {
+		cdata->sensors[LSM303AH_STEP_D].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_STEP_D], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_TILT) &&
+				(ck_gate_val & LSM303AH_F_CK_GATE_TILT_INT_MASK)) {
+		cdata->sensors[LSM303AH_TILT].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_TILT], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_SIGN_M) &&
+			(ck_gate_val & LSM303AH_F_CK_GATE_SIGN_M_DET_MASK)) {
+		cdata->sensors[LSM303AH_SIGN_M].timestamp = priv->timestamp;
+		st_sensor_report_single_event(&cdata->sensors[LSM303AH_SIGN_M], 1);
+	}
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_STEP_C) &&
+			(ck_gate_val & LSM303AH_F_CK_GATE_STEP_D_MASK)) {
+		cdata->sensors[LSM303AH_STEP_C].timestamp = priv->timestamp;
+		lsm303ah_report_step_c_data(cdata);
+	}
+}
+
+void lsm303ah_irq_management(struct work_struct *irq_work)
+{
+	priv_data_t *priv;
+	u8 status[4], func[2];
+	struct st_common_data *cdata;
+
+	priv = container_of((struct work_struct *)irq_work, priv_data_t,
+								irq_work);
+
+	cdata = priv->cdata;
+	cdata->tf->read(cdata, LSM303AH_STATUS_DUP_ADDR, 4, status);
+	cdata->tf->read(cdata, LSM303AH_F_CK_GATE_ADDR, 2, func);
+
+	if ((status[0] & LSM303AH_EVENT_MASK) ||
+	    (func[0] & LSM303AH_F_CK_GATE_MASK))
+		/*
+		 * Detected an event! Decode and report it.
+		 */
+		lsm303ah_event_management(cdata, status[0], func[0]);
+
+	enable_irq(cdata->irq);
+
+	return;
+}
+
+int lsm303ah_acc_write_odr(struct st_sensor_data *sdata) {
+	int err, i;
+	u32 max_odr = 0;
+	priv_data_t *priv = GET_PDATA(sdata->cdata);
+	u8 pmode = priv->power_mode;
+
+	for (i = 0; i < LSM303AH_SENSORS_NUMB; i++)
+		if (CHECK_BIT(priv->enabled_sensor, i)) {
+			if (sdata->cdata->sensors[i].c_odr > max_odr)
+				max_odr = sdata->cdata->sensors[i].c_odr;
+		}
+
+	if (max_odr != priv->common_odr) {
+		for (i = 0; i < LSM303AH_ODR_LP_LIST_NUM; i++) {
+			if (lsm303ah_odr_table[pmode][i].hz >= max_odr)
+				break;
+		}
+		if (i == LSM303AH_ODR_LP_LIST_NUM)
+			return -EINVAL;
+
+		err = st_sensor_write_data(sdata->cdata,
+					LSM303AH_ODR_ADDR,
+					LSM303AH_ODR_MASK,
+					lsm303ah_odr_table[pmode][i].value);
+		if (err < 0)
+			return err;
+
+		priv->common_odr = max_odr;
+	}
+
+	return 0;
+}
+
+int lsm303ah_configure_tap_event(struct st_sensor_data *sdata, bool single_tap)
+{
+	u8 err = 0;
+
+	if (single_tap) {
+		err = st_sensor_write_data(sdata->cdata,
+					LSM303AH_INT_DUR_ADDR,
+					LSM303AH_INT_DUR_MASK,
+					LSM303AH_INT_DUR_STAP_DEFAULT);
+		if (err < 0)
+			return err;
+
+		err = st_sensor_write_data(sdata->cdata,
+					LSM303AH_WAKE_UP_THS_ADDR,
+					LSM303AH_WAKE_UP_THS_S_D_TAP_MASK,
+					LSM303AH_DIS_BIT);
+		if (err < 0)
+			return err;
+	} else {
+		err = st_sensor_write_data(sdata->cdata,
+					LSM303AH_INT_DUR_ADDR,
+					LSM303AH_INT_DUR_MASK,
+					LSM303AH_INT_DUR_DTAP_DEFAULT);
+		if (err < 0)
+			return err;
+
+		err = st_sensor_write_data(sdata->cdata,
+					LSM303AH_WAKE_UP_THS_ADDR,
+					LSM303AH_WAKE_UP_THS_S_D_TAP_MASK,
+					LSM303AH_EN_BIT);
+		if (err < 0)
+			return err;
+	}
+
+	return err;
+}
+
+int lsm303ah_update_event_functions(struct st_common_data *cdata)
+{
+	u8 reg_val = 0;
+	priv_data_t *priv = GET_PDATA(cdata);
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_SIGN_M))
+		reg_val |= LSM303AH_F_CTRL_SIGN_MOT_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_TILT))
+		reg_val |= LSM303AH_F_CTRL_TILT_MASK;
+
+	if (CHECK_BIT(priv->enabled_sensor, LSM303AH_STEP_D) ||
+			CHECK_BIT(priv->enabled_sensor, LSM303AH_STEP_C))
+		reg_val |= LSM303AH_F_CTRL_STEP_CNT_MASK;
+
+	return st_sensor_write_data(cdata, LSM303AH_F_CTRL_ADDR,
+						LSM303AH_F_CTRL_EV_MASK,
+						LSM303AH_F_CTRL_EV_MASK);
+}
+
+int lsm303ah_set_enable(struct st_sensor_data *sdata, bool state)
+{
+	int err = 0;
+	priv_data_t *priv = GET_PDATA(sdata->cdata);
+
+	if (sdata->enabled == state)
+		return 0;
+
+	if (state) {
+		SET_BIT(priv->enabled_sensor, sdata->sindex);
+	} else {
+		RESET_BIT(priv->enabled_sensor, sdata->sindex);
+	}
+
+	switch (sdata->sindex) {
+	case LSM303AH_TAP:
+		if (state && CHECK_BIT(priv->enabled_sensor,
+				LSM303AH_DOUBLE_TAP)) {
+			err = -EINVAL;
+
+			goto enable_sensor_error;
+		}
+
+		break;
+
+	case LSM303AH_DOUBLE_TAP:
+		if (state && CHECK_BIT(priv->enabled_sensor,
+				LSM303AH_TAP)) {
+			err = -EINVAL;
+
+			goto enable_sensor_error;
+		}
+
+		break;
+
+	case LSM303AH_FF:
+	case LSM303AH_WAKEUP:
+	case LSM303AH_ACTIVITY:
+		break;
+
+	case LSM303AH_TILT:
+	case LSM303AH_SIGN_M:
+	case LSM303AH_STEP_D:
+	case LSM303AH_STEP_C:
+		err = lsm303ah_update_event_functions(sdata->cdata);
+		if (err < 0)
+			goto enable_sensor_error;
+
+		break;
+
+	case LSM303AH_ACCEL:
+		hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm303ah_update_drdy_irq(sdata);
+	if (err < 0)
+		goto enable_sensor_error;
+
+	err = lsm303ah_acc_write_odr(sdata);
+	if (err < 0)
+		goto enable_sensor_error;
+
+	sdata->enabled = state;
+
+	return 0;
+
+enable_sensor_error:
+	if (state) {
+		RESET_BIT(priv->enabled_sensor, sdata->sindex);
+	} else {
+		SET_BIT(priv->enabled_sensor, sdata->sindex);
+	}
+
+	return err;
+}
+
+int lsm303ah_acc_enable_sensors(struct st_sensor_data *sdata)
+{
+	return lsm303ah_set_enable(sdata, true);
+}
+
+int lsm303ah_acc_disable_sensors(struct st_sensor_data *sdata)
+{
+	return lsm303ah_set_enable(sdata, false);
+}
+
+ssize_t lsm303ah_acc_get_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LSM303AH_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lsm303ah_fs_table.fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+ssize_t lsm303ah_acc_get_cur_scale(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+	u8 pmode = GET_PDATA(sdata->cdata)->power_mode;
+
+	for (i = 0; i < LSM303AH_FS_LIST_NUM; i++)
+		if (sdata->c_gain ==
+			lsm303ah_fs_table.fs_avl[i].gain[pmode])
+			break;
+
+	return sprintf(buf, "%d\n", lsm303ah_fs_table.fs_avl[i].urv);
+}
+
+ssize_t lsm303ah_acc_set_cur_scale(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int urv, err;
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	err = lsm303ah_set_fs(sdata, urv);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+static ssize_t lsm303ah_acc_get_resolution_mode(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+	u8 pmode = GET_PDATA(sdata->cdata)->power_mode;
+
+	return sprintf(buf, "%s\n", (pmode == LSM303AH_LP_MODE) ? "low" : "high");
+}
+
+static ssize_t lsm303ah_acc_set_resolution_mode(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int err, i;
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+	u8 *pmode = &(GET_PDATA(sdata->cdata)->power_mode);
+
+	for (i = 0; i < LSM303AH_FS_LIST_NUM; i++) {
+		if (sdata->c_gain ==
+			lsm303ah_fs_table.fs_avl[i].gain[*pmode])
+			break;
+	}
+
+	if (!strncmp(buf, "low", count - 1))
+		*pmode = LSM303AH_LP_MODE;
+	else if (!strncmp(buf, "high", count - 1))
+		*pmode = LSM303AH_HR_MODE;
+	else
+		return -EINVAL;
+
+	err = lsm303ah_acc_write_odr(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = lsm303ah_fs_table.fs_avl[i].gain[*pmode];
+
+	return count;
+}
+
+ssize_t lsm303ah_reset_step_counter(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int err;
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_STEP_C_MINTHS_ADDR,
+					LSM303AH_STEP_C_MINTHS_RST_NSTEP_MASK,
+					LSM303AH_EN_BIT);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+int lsm303ah_init_sensors(struct st_common_data *cdata)
+{
+	int err, i;
+	struct st_sensor_data *sdata;
+	
+	for (i = 0; i < LSM303AH_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		
+		err = lsm303ah_acc_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+		
+		if (sdata->sindex == LSM303AH_ACCEL) {
+			err = lsm303ah_set_fs(sdata, LSM303AH_ACCEL_FS);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	hrtimer_init(&cdata->sensors[LSM303AH_ACCEL].hr_timer, CLOCK_MONOTONIC,
+						HRTIMER_MODE_REL);
+	cdata->sensors[LSM303AH_ACCEL].hr_timer.function =
+						&st_sensor_poll_function;
+
+	/*
+	 * Soft reset the device on power on.
+	 */
+	err = st_sensor_write_data(cdata, LSM303AH_SOFT_RESET_ADDR,
+						LSM303AH_SOFT_RESET_MASK,
+						LSM303AH_EN_BIT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Enable latched interrupt mode.
+	 */
+	err = st_sensor_write_data(cdata, LSM303AH_LIR_ADDR,
+						LSM303AH_LIR_MASK,
+						LSM303AH_EN_BIT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Enable block data update feature.
+	 */
+	err = st_sensor_write_data(cdata, LSM303AH_BDU_ADDR,
+						LSM303AH_BDU_MASK,
+						LSM303AH_EN_BIT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Route interrupt from INT2 to INT1 pin.
+	 */
+	err = st_sensor_write_data(cdata, LSM303AH_INT2_ON_INT1_ADDR,
+						LSM303AH_INT2_ON_INT1_MASK,
+						LSM303AH_EN_BIT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default free fall event threshold.
+	 */
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_FREE_FALL_ADDR,
+						LSM303AH_FREE_FALL_THS_MASK,
+						LSM303AH_FREE_FALL_THS_DEFAULT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default free fall event duration.
+	 */
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_FREE_FALL_ADDR,
+						LSM303AH_FREE_FALL_DUR_MASK,
+						LSM303AH_FREE_FALL_DUR_DEFAULT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure Tap event recognition on all direction (X, Y and Z axes).
+	 */
+
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_TAP_AXIS_ADDR,
+						LSM303AH_TAP_AXIS_MASK,
+						LSM303AH_TAP_AXIS_ANABLE_ALL);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default threshold for Tap event recognition.
+	 */
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_TAP_THS_ADDR,
+						LSM303AH_TAP_THS_MASK,
+						LSM303AH_TAP_THS_DEFAULT);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Configure default threshold for Wake Up event recognition.
+	 */
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_WAKE_UP_THS_ADDR,
+						LSM303AH_WAKE_UP_THS_WU_MASK,
+						LSM303AH_WAKE_UP_THS_WU_DEFAULT);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static irqreturn_t lsm303ah_save_tstamp(int irq, void *private)
+{
+	struct st_common_data *cdata = private;
+
+	GET_PDATA(cdata)->timestamp = st_sensor_get_time_ns();
+	queue_work(lsm303ah_acc_wkq, &(GET_PDATA(cdata)->irq_work));
+	disable_irq_nosync(irq);
+
+	return IRQ_HANDLED;
+}
+
+int lsm303ah_allocate_workqueue(struct st_common_data *cdata)
+{
+	int err;
+
+	if (!lsm303ah_acc_wkq)
+		lsm303ah_acc_wkq = create_workqueue(cdata->name);
+
+	if (!lsm303ah_acc_wkq)
+		return -EINVAL;
+
+	INIT_WORK(&(GET_PDATA(cdata)->irq_work), lsm303ah_irq_management);
+
+	err = request_threaded_irq(cdata->irq, lsm303ah_save_tstamp, NULL,
+				   IRQF_TRIGGER_HIGH, cdata->name, cdata);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+ADD_DEVICE_ENABLE_ATTR;
+ADD_DEVICE_POLLING_ATTR;
+
+static DEVICE_ATTR(resolution, S_IWUSR | S_IRUGO,
+				lsm303ah_acc_get_resolution_mode,
+				lsm303ah_acc_set_resolution_mode);
+
+static DEVICE_ATTR(scale_avail, S_IRUGO,
+				lsm303ah_acc_get_scale_avail,
+				NULL);
+
+static DEVICE_ATTR(scale, S_IWUSR | S_IRUGO,
+				lsm303ah_acc_get_cur_scale,
+				lsm303ah_acc_set_cur_scale);
+
+static DEVICE_ATTR(reset_steps, S_IWUSR,
+				NULL,
+				lsm303ah_reset_step_counter);
+
+static struct attribute *lsm303ah_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_resolution.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_step_c_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_reset_steps.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_step_ff_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_tap_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_double_tap_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_step_d_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_tilt_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_sign_m_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_wakeup_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm303ah_act_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lsm303ah_attribute_groups[] = {
+	[LSM303AH_ACCEL] = {
+		.attrs = lsm303ah_accel_attribute,
+		.name = "accel",
+	},
+	[LSM303AH_STEP_C] = {
+		.attrs = lsm303ah_step_c_attribute,
+		.name = "step_c",
+	},
+	[LSM303AH_FF] = {
+		.attrs = lsm303ah_step_ff_attribute,
+		.name = "free_fall",
+	},
+	[LSM303AH_TAP] = {
+		.name = "tap",
+		.attrs = lsm303ah_tap_attribute,
+	},
+	[LSM303AH_DOUBLE_TAP] = {
+		.name = "double_tap",
+		.attrs = lsm303ah_double_tap_attribute,
+	},
+	[LSM303AH_STEP_D] = {
+		.name = "step_d",
+		.attrs = lsm303ah_step_d_attribute,
+	},
+	[LSM303AH_TILT] = {
+		.name = "tilt",
+		.attrs = lsm303ah_tilt_attribute,
+	},
+	[LSM303AH_SIGN_M] = {
+		.name = "sign_m",
+		.attrs = lsm303ah_sign_m_attribute,
+	},
+	[LSM303AH_WAKEUP] = {
+		.name = "wake_up",
+		.attrs = lsm303ah_wakeup_attribute,
+	},
+	[LSM303AH_ACTIVITY] = {
+		.name = "act",
+		.attrs = lsm303ah_act_attribute,
+	},
+};
+
+int lsm303ah_sensors_data_init(struct st_common_data *cdata)
+{
+	int32_t i;
+	bool is_3_axis;
+	struct st_sensor_data *sdata;
+
+	GET_PDATA(cdata)->common_odr = 0;
+	GET_PDATA(cdata)->enabled_sensor = 0;
+	GET_PDATA(cdata)->power_mode = LSM303AH_PMODE_DEFAULT;
+	GET_PDATA(cdata)->cdata = cdata;
+	cdata->sensors_count = LSM303AH_SENSORS_NUMB;
+
+	for (i = 0; i < LSM303AH_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lsm303ah_sensors_table[i].name;
+		sdata->c_odr = lsm303ah_sensors_table[i].min_odr_hz;
+		sdata->write_odr = lsm303ah_acc_write_odr;
+		sdata->enable = lsm303ah_acc_enable_sensors;
+		sdata->disable = lsm303ah_acc_disable_sensors;
+
+		switch(i) {
+			case LSM303AH_ACCEL:
+				sdata->ktime = ktime_set(0, MS_TO_NS(1000 /
+								sdata->c_odr));
+				is_3_axis = true;
+
+				break;
+
+			default:
+				is_3_axis = false;
+
+				break;
+		}
+
+		st_sensor_input_init(sdata, kasprintf(GFP_KERNEL, "%s_%s",
+						cdata->name, sdata->name),
+						is_3_axis);
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+						&lsm303ah_attribute_groups[i]))
+			goto error_lsm303ah_sensors_data_init;
+	}
+
+	return 0;
+
+error_lsm303ah_sensors_data_init:
+	dev_err(cdata->dev, "failed to create sysfs group for sensor %s",
+							sdata->name);
+	for (; i >= 0; i--) {
+		sysfs_remove_group(&sdata->input_dev->dev.kobj,
+						&lsm303ah_attribute_groups[i]);
+		input_unregister_device(cdata->sensors[i].input_dev);
+	}
+
+	return -EINVAL;
+}
+
+int lsm303ah_acc_probe(struct st_common_data *cdata)
+{
+	int err;
+
+	err = st_sensor_common_probe(cdata, cdata->irq);
+	if (err < 0)
+		return err;
+
+	err = lsm303ah_sensors_data_init(cdata);
+	if (err < 0)
+		return err;
+
+	err = lsm303ah_init_sensors(cdata);
+	if (err < 0)
+		return err;
+
+	INIT_WORK(&cdata->sensors[LSM303AH_ACCEL].input_work, lsm303ah_acc_poll_wk);
+
+	if (cdata->irq > 0) {
+		err = lsm303ah_allocate_workqueue(cdata);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lsm303ah_acc_probe);
+
+int lsm303ah_acc_remove(struct st_common_data *cdata)
+{
+	u8 i;
+
+	for (i = 0; i < cdata->sensors_count; i++) {
+		lsm303ah_acc_disable_sensors(&cdata->sensors[i]);
+		st_sensor_input_cleanup(&cdata->sensors[i]);
+	}
+	st_sensor_common_remove(cdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303ah_acc_remove);
+
+int lsm303ah_acc_enable(struct st_common_data *cdata)
+{
+	int i, err;
+
+	for (i = 0; i < cdata->sensors_count; i++) {
+		err = lsm303ah_acc_enable_sensors(&cdata->sensors[i]);
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lsm303ah_acc_enable);
+
+int lsm303ah_acc_disable(struct st_common_data *cdata)
+{
+	int i, err;
+
+	for (i = 0; i < cdata->sensors_count; i++) {
+		err = lsm303ah_acc_disable_sensors(&cdata->sensors[i]);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303ah_acc_disable);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm303ah_acc driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_i2c.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,195 @@
+/*
+ * STMicroelectronics lsm303ah_acc_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303ah_core.h"
+
+#define LSM303AH_WHO_AM_I_ADDR			0x0f
+#define LSM303AH_WHO_AM_I_DEF			0x43
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_acc_i2c_read(struct st_common_data *cdata,
+				 u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_acc_i2c_write(struct st_common_data *cdata,
+				  u8 addr, int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct st_sensor_transfer_function lsm303ah_acc_i2c_tf = {
+	.write = lsm303ah_acc_i2c_write,
+	.read = lsm303ah_acc_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303ah_acc_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+	return lsm303ah_acc_enable(cdata);
+}
+
+static int lsm303ah_acc_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+	return lsm303ah_acc_disable(cdata);
+}
+
+static const struct dev_pm_ops lsm303ah_acc_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303ah_acc_i2c_suspend, lsm303ah_acc_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303ah_acc_i2c_id_table[] = {
+	{ .compatible = "st,lsm303ah_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303ah_acc_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303ah_acc_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct st_common_data *cdata;
+
+#ifdef LSM303AH_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct st_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensors = (struct st_sensor_data *) kmalloc(
+						sizeof(struct st_sensor_data) *
+						LSM303AH_SENSORS_NUMB,
+						GFP_KERNEL);
+	if (!cdata->sensors)
+		return -ENOMEM;
+
+	cdata->priv_data = (priv_data_t *) kmalloc(sizeof(priv_data_t),
+						   GFP_KERNEL);
+	if (!cdata->priv_data)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->irq = client->irq;
+	cdata->bus_type = BUS_I2C;
+	cdata->tf = &lsm303ah_acc_i2c_tf;
+	cdata->wai_addr = LSM303AH_WHO_AM_I_ADDR;
+	cdata->wai_val = LSM303AH_WHO_AM_I_DEF;
+
+	mutex_init(&cdata->lock);
+
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm303ah_acc_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303ah_acc_i2c_remove(struct i2c_client *client)
+{
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+#ifdef LSM303AH_DEBUG
+	dev_info(cdata->dev, "driver removing\n");
+#endif
+
+	lsm303ah_acc_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303ah_acc_i2c_id[] = {
+	{ "lsm303ah_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303ah_acc_i2c_id);
+
+static struct i2c_driver lsm303ah_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303ah_acc_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303ah_acc_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303ah_acc_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303ah_acc_i2c_probe,
+	.remove = lsm303ah_acc_i2c_remove,
+	.id_table = lsm303ah_acc_i2c_id,
+};
+
+module_i2c_driver(lsm303ah_acc_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303ah_acc i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_spi.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_acc_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,218 @@
+/*
+ * STMicroelectronics lsm303ah_acc_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303ah_core.h"
+
+#define LSM303AH_WHO_AM_I_ADDR			0x0f
+#define LSM303AH_WHO_AM_I_DEF			0x43
+
+#define SENSORS_SPI_READ	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_acc_spi_read(struct st_common_data *cdata,
+				 u8 addr, int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(cdata->dev);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	cdata->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_acc_spi_write(struct st_common_data *cdata,
+				  u8 addr, int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(cdata->dev);
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303AH_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	cdata->tb.tx_buf[0] = addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct st_sensor_transfer_function lsm303ah_acc_spi_tf = {
+	.write = lsm303ah_acc_spi_write,
+	.read = lsm303ah_acc_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303ah_acc_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+	return lsm303ah_acc_enable(cdata);
+}
+
+static int lsm303ah_acc_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+	return lsm303ah_acc_disable(cdata);
+}
+
+static const struct dev_pm_ops lsm303ah_acc_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303ah_acc_spi_suspend,
+				lsm303ah_acc_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303ah_acc_spi_id_table[] = {
+	{ .compatible = "st,lsm303ah_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303ah_acc_spi_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303ah_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct st_common_data *cdata;
+
+#ifdef LSM303AH_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct st_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensors = (struct st_sensor_data *) kmalloc(
+						sizeof(struct st_sensor_data) *
+						LSM303AH_SENSORS_NUMB,
+						GFP_KERNEL);
+	if (!cdata->sensors)
+		return -ENOMEM;
+
+	cdata->priv_data = (priv_data_t *) kmalloc(sizeof(priv_data_t),
+						   GFP_KERNEL);
+	if (!cdata->priv_data)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->irq = spi->irq;
+	cdata->bus_type = BUS_SPI;
+	cdata->tf = &lsm303ah_acc_spi_tf;
+	cdata->wai_addr = LSM303AH_WHO_AM_I_ADDR;
+	cdata->wai_val = LSM303AH_WHO_AM_I_DEF;
+
+	mutex_init(&cdata->lock);
+
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm303ah_acc_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303ah_acc_spi_remove(struct spi_device *spi)
+{
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+#ifdef LSM303AH_DEBUG
+	dev_info(cdata->dev, "driver removing\n");
+#endif
+
+	lsm303ah_acc_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303ah_acc_spi_id[] = {
+	{ "lsm303ah_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm303ah_acc_spi_id);
+
+static struct spi_driver lsm303ah_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303ah_acc_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm303ah_acc_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303ah_acc_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303ah_acc_spi_probe,
+	.remove = lsm303ah_acc_spi_remove,
+	.id_table = lsm303ah_acc_spi_id,
+};
+
+module_spi_driver(lsm303ah_acc_spi_driver);
+
+MODULE_DESCRIPTION("lsm303ah_acc spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,294 @@
+/*
+ * STMicroelectronics lsm303ah_core.c driver
+ *
+ * Copyright 2015 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm303ah_core.h"
+
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+
+int st_sensor_write_data(struct st_common_data *cdata, u8 reg_addr,
+			 u8 mask, u8 data)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data);
+}
+EXPORT_SYMBOL(st_sensor_write_data);
+
+int st_sensor_input_init(struct st_sensor_data *sdata, const char* description,
+							bool is_3_axis)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = description;
+	sdata->input_dev->id.bustype = sdata->cdata->bus_type;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if (is_3_axis) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+								sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(st_sensor_input_init);
+
+void st_sensor_input_cleanup(struct st_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+EXPORT_SYMBOL(st_sensor_input_cleanup);
+
+void st_sensor_report_3axes_event(struct st_sensor_data *sdata, s32 *xyz,
+								s64 timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+							timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+							timestamp & 0xffffffff);
+	input_sync(input);
+}
+EXPORT_SYMBOL(st_sensor_report_3axes_event);
+
+void st_sensor_report_single_event(struct st_sensor_data *sdata, s32 data)
+{
+	struct input_dev  *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+						sdata->timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+						sdata->timestamp & 0xffffffff);
+	input_sync(input);
+}
+EXPORT_SYMBOL(st_sensor_report_single_event);
+
+enum hrtimer_restart st_sensor_poll_function(struct hrtimer *timer)
+{
+	struct st_sensor_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct st_sensor_data,
+							hr_timer);
+
+	sdata->timestamp = st_sensor_get_time_ns();
+	queue_work(sdata->cdata->workqueue, &sdata->input_work);
+
+	return HRTIMER_NORESTART;
+}
+EXPORT_SYMBOL(st_sensor_poll_function);
+
+ssize_t st_sensor_get_enable(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+EXPORT_SYMBOL(st_sensor_get_enable);
+
+ssize_t st_sensor_set_enable(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int err;
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = sdata->enable(sdata);
+	else
+		err = sdata->disable(sdata);
+
+	return (err < 0) ? err : count;
+}
+EXPORT_SYMBOL(st_sensor_set_enable);
+
+ssize_t st_sensor_get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", 1000 / sdata->c_odr);
+}
+EXPORT_SYMBOL(st_sensor_get_polling_rate);
+
+ssize_t st_sensor_set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct st_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	sdata->c_odr = 1000 / polling_rate;
+	sdata->ktime = ktime_set(0, MS_TO_NS(polling_rate));
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	err = sdata->write_odr(sdata);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+EXPORT_SYMBOL(st_sensor_set_polling_rate);
+
+#if defined(CONFIG_OF)
+static u32 st_sensor_parse_dt(struct st_common_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+							(val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	return 0;
+}
+#endif
+
+int st_sensor_common_probe(struct st_common_data *cdata, int irq)
+{
+	/* TODO: add errors management */
+	int32_t err;
+	u8 wai = 0;
+
+	err = cdata->tf->read(cdata, cdata->wai_addr, 1, &wai);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register 0x%x.\n",
+								cdata->wai_addr);
+		return err;
+	}
+	if (wai != cdata->wai_val) {
+		dev_err(cdata->dev, "Who-Am-I value not valid. (expected 0x%x, \
+			readed 0x%x))\n", cdata->wai_val, wai);
+		return -ENODEV;
+	}
+
+	if (irq > 0) {
+#if defined(CONFIG_OF)
+		err = st_sensor_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lsm303ah_platform_data *)
+					cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) || (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else
+			cdata->drdy_int_pin = 1;
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+							cdata->drdy_int_pin);
+	}
+
+	cdata->workqueue = create_workqueue(cdata->name);
+
+	if (irq > 0)
+		cdata->irq = irq;
+
+	return 0;
+}
+EXPORT_SYMBOL(st_sensor_common_probe);
+
+void st_sensor_common_remove(struct st_common_data *cdata)
+{
+}
+EXPORT_SYMBOL(st_sensor_common_remove);
+
+#if defined(CONFIG_PM)
+int st_sensor_common_suspend(struct st_common_data *cdata)
+{
+	return 0;
+}
+EXPORT_SYMBOL(st_sensor_common_suspend);
+
+int st_sensor_common_resume(struct st_common_data *cdata)
+{
+	return 0;
+}
+EXPORT_SYMBOL(st_sensor_common_resume);
+#endif /* CONFIG_PM */
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.h b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.h
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_core.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,195 @@
+/*
+ * STMicroelectronics lsm303ah_core.h driver
+ *
+ * Copyright 2015 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef DRIVERS_INPUT_MISC_LSM303AH_CORE_H_
+#define DRIVERS_INPUT_MISC_LSM303AH_CORE_H_
+
+#define LSM303AH_OUT_XYZ_SIZE		8
+
+#define HZ_TO_NSEC(hz)			(1000 * 1000 * 1000 / ((u32)(hz)))
+#define HZ_TO_MSEC(hz)			(1000 / ((u32)x))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+#define DEF_ZERO			(0x00)
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+#define LSM303AH_EN_BIT			0x01
+#define LSM303AH_DIS_BIT		0x00
+
+#define LSM303AH_RX_MAX_LENGTH		(500)
+#define LSM303AH_TX_MAX_LENGTH		(500)
+
+#define ADD_DEVICE_ENABLE_ATTR		static \
+					DEVICE_ATTR(enable, \
+						S_IWUSR | S_IRUGO, \
+						st_sensor_get_enable, \
+						st_sensor_set_enable);
+
+#define ADD_DEVICE_POLLING_ATTR		static \
+						DEVICE_ATTR(polling_rate, \
+						S_IWUSR | S_IRUGO, \
+						st_sensor_get_polling_rate, \
+						st_sensor_set_polling_rate);
+#define LSM303AH_CONCAT(a, b)		(a b)
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+#define LSM303AH_DEV_NAME			"lsm303ah"
+#define LSM303AH_ACC_INPUT_DEV_NAME		"lsm303ah_acc"
+#define LSM303AH_I2C_ADDR			0x1e
+
+struct lsm303ah_platform_data {
+	u8 drdy_int_pin;
+};
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lsm303ah_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM303AH_RX_MAX_LENGTH];
+	u8 tx_buf[LSM303AH_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct st_common_data;
+
+struct st_sensor_transfer_function {
+	int (*write) (struct st_common_data *cdata, u8 addr, int len, u8 *data);
+	int (*read) (struct st_common_data *cdata, u8 addr, int len, u8 *data);
+};
+
+enum {
+	LSM303AH_ACCEL = 0,
+	LSM303AH_STEP_C,
+	LSM303AH_FF,
+	LSM303AH_TAP,
+	LSM303AH_DOUBLE_TAP,
+	LSM303AH_STEP_D,
+	LSM303AH_TILT,
+	LSM303AH_SIGN_M,
+	LSM303AH_WAKEUP,
+	LSM303AH_ACTIVITY,
+	LSM303AH_SENSORS_NUMB,
+};
+
+typedef struct {
+	u8 power_mode;
+	u8 enabled_sensor;
+	u32 common_odr;
+	s64 timestamp;
+	struct work_struct irq_work;
+	struct st_common_data *cdata; /* link back to common data */
+} priv_data_t;
+
+struct st_sensor_data {
+	struct st_common_data *cdata;
+	const char* name;
+	s64 timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+
+	struct input_dev *input_dev;
+	struct hrtimer hr_timer;
+	struct work_struct input_work;
+	ktime_t ktime;
+	int (*enable)(struct st_sensor_data *sdata);
+	int (*disable)(struct st_sensor_data *sdata);
+	int (*write_odr)(struct st_sensor_data *sdata);
+};
+
+struct st_common_data {
+	const char *name;
+	u16 bus_type;
+	u8 drdy_int_pin;
+	u8 wai_addr;
+	u8 wai_val;
+	int irq;
+	uint32_t sensors_count;
+
+	void *priv_data;
+
+	struct mutex lock;
+	struct workqueue_struct *workqueue;
+	struct device *dev;
+	struct st_sensor_data *sensors;
+	const struct st_sensor_transfer_function *tf;
+	struct lsm303ah_transfer_buffer tb;
+};
+
+static inline s64 st_sensor_get_time_ns(void) {
+	struct timespec ts;
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+enum hrtimer_restart st_sensor_poll_function(struct hrtimer *timer);
+int st_sensor_common_probe(struct st_common_data *cdata, int irq);
+void st_sensor_common_remove(struct st_common_data *cdata);
+int st_sensor_common_resume(struct st_common_data *cdata);
+int st_sensor_common_suspend(struct st_common_data *cdata);
+int st_sensor_input_init(struct st_sensor_data *sdata, const char* description,
+								bool is_3_axis);
+int st_sensor_write_data(struct st_common_data *cdata, u8 reg_addr,
+							u8 mask, u8 data);
+void st_sensor_input_cleanup(struct st_sensor_data *sdata);
+void st_sensor_report_3axes_event(struct st_sensor_data *sdata, s32 *xyz,
+								s64 timestamp);
+void st_sensor_report_single_event(struct st_sensor_data *sdata, s32 data);
+
+ssize_t st_sensor_get_enable(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf);
+ssize_t st_sensor_set_enable(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count);
+ssize_t st_sensor_get_polling_rate(struct device *dev,
+				   struct device_attribute *attr, char *buf);
+ssize_t st_sensor_set_polling_rate(struct device *dev,
+				   struct device_attribute *attr, const char *buf,
+				   size_t count);
+
+int lsm303ah_acc_enable(struct st_common_data *cdata);
+int lsm303ah_acc_disable(struct st_common_data *cdata);
+int lsm303ah_acc_probe(struct st_common_data *cdata);
+int lsm303ah_acc_remove(struct st_common_data *cdata);
+
+int lsm303ah_mag_enable(struct st_common_data *cdata);
+int lsm303ah_mag_disable(struct st_common_data *cdata);
+int lsm303ah_mag_probe(struct st_common_data *cdata);
+int lsm303ah_mag_remove(struct st_common_data *cdata);
+
+#endif /* DRIVERS_INPUT_MISC_LSM303AH_CORE_H_ */
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,279 @@
+/*
+ * STMicroelectronics lsm303ah_mag.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include "lsm303ah_core.h"
+
+
+/* DEVICE REGISTERS */
+#define LSM303AH_MAG_WHO_AM_I_ADDR		(0x4F)
+#define LSM303AH_MAG_WHO_AM_I_VAL		(0x40)
+#define LSM303AH_MAG_CFG_REG_A			(0x60)
+#define LSM303AH_MAG_CFG_REG_B			(0x61)
+#define LSM303AH_MAG_CFG_REG_B_OFF_CANC_MASK	(0x02)
+#define LSM303AH_MAG_CFG_REG_C			(0x62)
+#define LSM303AH_MAG_CFG_REG_C_BDU_MASK		(0x10)
+#define LSM303AH_MAG_OUT_L_ADDR			(0x68)
+
+/* Device operating modes */
+#define LSM303AH_MAG_MD_CONTINUOS_MODE		0x00
+#define LSM303AH_MAG_MD_SINGLE_MODE		0x01
+#define LSM303AH_MAG_MD_IDLE_MODE		0x03
+#define LSM303AH_MAG_MODE_MASK			0x03
+
+/* Device ODRs */
+#define LSM303AH_MAG_ODR_10HZ			0x00
+#define LSM303AH_MAG_ODR_20HZ			0x01
+#define LSM303AH_MAG_ODR_50HZ			0x02
+#define LSM303AH_MAG_ODR_100HZ			0x03
+#define LSM303AH_MAG_ODR_MASK			0x0C
+#define LSM303AH_MAG_BYTE_FOR_SAMPLE		6
+#define LSM303AH_MAG_ODR_LIST_NUM		4
+#define LSM303AH_MAG_DEV_DESCRIPTION		"ST LSM303AH Magnetometer Sensor"
+#define LSM303AH_MAG_DEV_NAME			"magn"
+#define LSM303AH_MAGN_NAME			"lsm303ah_magn"
+#define LSM303AH_MAG_SCALE			1500
+
+struct lsm303ah_odr_reg {
+	u32 hz;
+	u8 value;
+} lsm303ah_mag_odr_table_t[] = {
+	[0] = { .hz = 10, 	.value = LSM303AH_MAG_ODR_10HZ },
+	[1] = { .hz = 20, 	.value = LSM303AH_MAG_ODR_20HZ },
+	[2] = { .hz = 50, 	.value = LSM303AH_MAG_ODR_50HZ },
+	[3] = { .hz = 100, 	.value = LSM303AH_MAG_ODR_100HZ },
+};
+
+static void lsm303ah_mag_poll_wk(struct work_struct *input_work)
+{
+	struct st_sensor_data *sdata;
+	int xyz[3] = { 0 };
+	u8 data[6];
+	int err;
+
+	sdata = container_of((struct work_struct *)input_work,
+			     struct st_sensor_data, input_work);
+
+	hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+
+	err = sdata->cdata->tf->read(sdata->cdata, LSM303AH_MAG_OUT_L_ADDR,
+						LSM303AH_MAG_BYTE_FOR_SAMPLE,
+						data);
+	if (err < 0)
+		dev_err(sdata->cdata->dev, "get %s data failed %d\n",
+			sdata->name, err);
+	else {
+		xyz[0] = (s32)((s16)(data[0] | data[1] << 8));
+		xyz[1] = (s32)((s16)(data[2] | data[3] << 8));
+		xyz[2] = (s32)((s16)(data[4] | data[5] << 8));
+
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+		st_sensor_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+}
+
+int lsm303ah_mag_write_odr(struct st_sensor_data *sdata) {
+	int i;
+
+	for (i = 0; i < LSM303AH_MAG_ODR_LIST_NUM; i++) {
+		if (lsm303ah_mag_odr_table_t[i].hz >= sdata->c_odr)
+				break;
+	}
+	if (i == LSM303AH_MAG_ODR_LIST_NUM)
+		return -EINVAL;
+
+	return st_sensor_write_data(sdata->cdata,
+				LSM303AH_MAG_CFG_REG_A,
+				LSM303AH_MAG_ODR_MASK,
+				lsm303ah_mag_odr_table_t[i].value);
+}
+
+int lsm303ah_mag_enable_sensors(struct st_sensor_data *sdata)
+{
+	int err;
+
+	if (sdata->enabled)
+		return 0;
+
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_MAG_CFG_REG_A,
+						LSM303AH_MAG_MODE_MASK,
+						LSM303AH_MAG_MD_CONTINUOS_MODE);
+	if (err < 0)
+		return err;
+
+	hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+	sdata->enabled = true;
+
+	return 0;
+}
+
+int lsm303ah_mag_disable_sensor(struct st_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	err = st_sensor_write_data(sdata->cdata, LSM303AH_MAG_CFG_REG_A,
+						LSM303AH_MAG_MODE_MASK,
+						LSM303AH_MAG_MD_IDLE_MODE);
+	if (err < 0)
+		return err;
+
+	cancel_work_sync(&sdata->input_work);
+	hrtimer_cancel(&sdata->hr_timer);
+	sdata->enabled = false;
+
+	return 0;
+}
+
+ssize_t lsm303ah_mag_get_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "50\n");
+}
+
+int lsm303ah_mag_init_sensor(struct st_common_data *cdata)
+{
+	int err;
+	struct st_sensor_data *sdata = cdata->sensors;
+
+	INIT_WORK(&cdata->sensors->input_work, lsm303ah_mag_poll_wk);
+	hrtimer_init(&cdata->sensors->hr_timer, CLOCK_MONOTONIC,
+					HRTIMER_MODE_REL);
+
+	err = lsm303ah_mag_disable_sensor(sdata);
+	if (err < 0)
+		return err;
+
+	cdata->sensors->hr_timer.function = &st_sensor_poll_function;
+
+	/*
+	* Enable offset cancellation
+	*/
+	err = st_sensor_write_data(cdata, LSM303AH_MAG_CFG_REG_B,
+					LSM303AH_MAG_CFG_REG_B_OFF_CANC_MASK,
+					LSM303AH_EN_BIT);
+	if (err < 0)
+		return err;
+
+
+	/*
+	 * Enable block data update feature.
+	 */
+	return st_sensor_write_data(cdata, LSM303AH_MAG_CFG_REG_C,
+					LSM303AH_MAG_CFG_REG_C_BDU_MASK,
+					LSM303AH_EN_BIT);
+}
+
+ADD_DEVICE_ENABLE_ATTR;
+ADD_DEVICE_POLLING_ATTR;
+
+static DEVICE_ATTR(scale_avail, S_IRUGO,
+				lsm303ah_mag_get_scale_avail,
+				NULL);
+
+static struct attribute *lsm303ah_mag_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_scale_avail.attr,
+	NULL,
+};
+
+static const struct attribute_group lsm303ah_mag_attribute_groups = {
+	.attrs = lsm303ah_mag_attribute,
+	.name = LSM303AH_MAG_DEV_NAME,
+};
+
+int lsm303ah_mag_data_init(struct st_common_data *cdata)
+{
+	struct st_sensor_data *sdata = cdata->sensors;
+
+	sdata->enabled = false;
+	sdata->cdata = cdata;
+	sdata->sindex = 0;
+	sdata->c_gain = LSM303AH_MAG_SCALE;
+	sdata->name = LSM303AH_MAG_DEV_NAME;
+	sdata->c_odr = lsm303ah_mag_odr_table_t[0].hz;
+	sdata->ktime = ktime_set(0, HZ_TO_NSEC(sdata->c_odr));
+
+	st_sensor_input_init(sdata, LSM303AH_MAG_DEV_DESCRIPTION, true);
+
+	if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+					&lsm303ah_mag_attribute_groups)) {
+		dev_err(cdata->dev, "failed to create sysfs group for sensor %s",
+					sdata->name);
+		return -EINVAL;
+	}
+
+	sdata->write_odr = lsm303ah_mag_write_odr;
+	sdata->enable = lsm303ah_mag_enable_sensors;
+	sdata->disable = lsm303ah_mag_disable_sensor;
+
+	return 0;
+}
+
+int lsm303ah_mag_probe(struct st_common_data *cdata)
+{
+	int err;
+
+	err = st_sensor_common_probe(cdata, 0);
+	if (err < 0)
+		return err;
+
+	err = lsm303ah_mag_data_init(cdata);
+	if (err < 0)
+		return err;
+
+	err = lsm303ah_mag_init_sensor(cdata);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303ah_mag_probe);
+
+int lsm303ah_mag_remove(struct st_common_data *cdata)
+{
+	lsm303ah_mag_disable_sensor(cdata->sensors);
+	st_sensor_input_cleanup(cdata->sensors);
+
+	st_sensor_common_remove(cdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303ah_mag_remove);
+
+int lsm303ah_mag_enable(struct st_common_data *cdata)
+{
+	return lsm303ah_mag_enable_sensors(cdata->sensors);
+}
+EXPORT_SYMBOL(lsm303ah_mag_enable);
+
+int lsm303ah_mag_disable(struct st_common_data *cdata)
+{
+	return lsm303ah_mag_disable_sensor(cdata->sensors);
+}
+EXPORT_SYMBOL(lsm303ah_mag_disable);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm303ah_mag i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_i2c.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,193 @@
+/*
+ * STMicroelectronics lsm303ah_mag_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303ah_core.h"
+
+#define LSM303AH_MAG_WHO_AM_I_ADDR		(0x4F)
+#define LSM303AH_MAG_WHO_AM_I_VAL		(0x40)
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_mag_i2c_read(struct st_common_data *cdata,
+				 u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_mag_i2c_write(struct st_common_data *cdata,
+				  u8 addr, int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct st_sensor_transfer_function lsm303ah_mag_i2c_tf = {
+	.write = lsm303ah_mag_i2c_write,
+	.read = lsm303ah_mag_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303ah_mag_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+	return lsm303ah_mag_enable(cdata);
+}
+
+static int lsm303ah_mag_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+	return lsm303ah_mag_disable(cdata);
+}
+
+static const struct dev_pm_ops lsm303ah_mag_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303ah_mag_i2c_suspend, lsm303ah_mag_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303ah_mag_i2c_id_table[] = {
+	{ .compatible = "st,lsm303ah_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303ah_mag_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303ah_mag_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct st_common_data *cdata;
+
+#ifdef LSM303AH_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct st_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensors = (struct st_sensor_data *) kmalloc(
+						sizeof(struct st_sensor_data),
+						GFP_KERNEL);
+	if (!cdata->sensors)
+		return -ENOMEM;
+
+	cdata->priv_data = (priv_data_t *) kmalloc(sizeof(priv_data_t),
+						   GFP_KERNEL);
+	if (!cdata->priv_data)
+		return -ENOMEM;
+
+	cdata->irq = client->irq;
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bus_type = BUS_I2C;
+	cdata->tf = &lsm303ah_mag_i2c_tf;
+	cdata->wai_addr = LSM303AH_MAG_WHO_AM_I_ADDR;
+	cdata->wai_val = LSM303AH_MAG_WHO_AM_I_VAL;
+
+	mutex_init(&cdata->lock);
+
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm303ah_mag_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303ah_mag_i2c_remove(struct i2c_client *client)
+{
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+#ifdef LSM303AH_DEBUG
+	dev_info(cdata->dev, "driver removing\n");
+#endif
+
+	lsm303ah_mag_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303ah_mag_i2c_id[] = {
+	{ "lsm303ah_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303ah_mag_i2c_id);
+
+static struct i2c_driver lsm303ah_mag_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303ah_mag_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303ah_mag_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303ah_mag_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303ah_mag_i2c_probe,
+	.remove = lsm303ah_mag_i2c_remove,
+	.id_table = lsm303ah_mag_i2c_id,
+};
+
+module_i2c_driver(lsm303ah_mag_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303ah_mag i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_spi.c b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/lsm303ah_mag_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,216 @@
+/*
+ * STMicroelectronics lsm303ah_mag_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303ah_core.h"
+
+#define LSM303AH_MAG_WHO_AM_I_ADDR		(0x4F)
+#define LSM303AH_MAG_WHO_AM_I_VAL		(0x40)
+
+#define SENSORS_SPI_READ	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_mag_spi_read(struct st_common_data *cdata,
+				 u8 addr, int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(cdata->dev);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	cdata->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303ah_mag_spi_write(struct st_common_data *cdata,
+				  u8 addr, int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(cdata->dev);
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303AH_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	cdata->tb.tx_buf[0] = addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct st_sensor_transfer_function lsm303ah_mag_spi_tf = {
+	.write = lsm303ah_mag_spi_write,
+	.read = lsm303ah_mag_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303ah_mag_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+	return lsm303ah_mag_enable(cdata);
+}
+
+static int lsm303ah_mag_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+	return lsm303ah_mag_disable(cdata);
+}
+
+static const struct dev_pm_ops lsm303ah_mag_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303ah_mag_spi_suspend,
+				lsm303ah_mag_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303ah_mag_spi_id_table[] = {
+	{ .compatible = "st,lsm303ah_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303ah_mag_spi_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303ah_mag_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct st_common_data *cdata;
+
+#ifdef LSM303AH_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct st_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensors = (struct st_sensor_data *) kmalloc(
+						sizeof(struct st_sensor_data),
+						GFP_KERNEL);
+	if (!cdata->sensors)
+		return -ENOMEM;
+
+	cdata->priv_data = (priv_data_t *) kmalloc(sizeof(priv_data_t),
+						   GFP_KERNEL);
+	if (!cdata->priv_data)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->irq = spi->irq;
+	cdata->bus_type = BUS_SPI;
+	cdata->tf = &lsm303ah_mag_spi_tf;
+	cdata->wai_addr = LSM303AH_MAG_WHO_AM_I_ADDR;
+	cdata->wai_val = LSM303AH_MAG_WHO_AM_I_VAL;
+
+	mutex_init(&cdata->lock);
+
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm303ah_mag_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303ah_mag_spi_remove(struct spi_device *spi)
+{
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+#ifdef LSM303AH_DEBUG
+	dev_info(cdata->dev, "driver removing\n");
+#endif
+
+	lsm303ah_mag_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303ah_mag_spi_id[] = {
+	{ "lsm303ah_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm303ah_mag_spi_id);
+
+static struct spi_driver lsm303ah_mag_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303ah_mag_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm303ah_mag_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303ah_mag_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303ah_mag_spi_probe,
+	.remove = lsm303ah_mag_spi_remove,
+	.id_table = lsm303ah_mag_spi_id,
+};
+
+module_spi_driver(lsm303ah_mag_spi_driver);
+
+MODULE_DESCRIPTION("lsm303ah_mag spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303ah/Makefile b/drivers/input/misc/st/ecompass/lsm303ah/Makefile
--- a/drivers/input/misc/st/ecompass/lsm303ah/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303ah/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_INPUT_LSM303AH) += lsm303ah_acc.o lsm303ah_mag.o lsm303ah_core.o
+obj-$(CONFIG_INPUT_LSM303AH_I2C) += lsm303ah_acc_i2c.o lsm303ah_mag_i2c.o
+obj-$(CONFIG_INPUT_LSM303AH_SPI) += lsm303ah_acc_spi.o lsm303ah_mag_spi.o
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/Kconfig b/drivers/input/misc/st/ecompass/lsm303c/Kconfig
--- a/drivers/input/misc/st/ecompass/lsm303c/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,22 @@
+
+config INPUT_LSM303C
+         tristate "STM LSM303C sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LSM303C_I2C if (I2C)
+	 select INPUT_LSM303C_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics LSM303C sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm303c.
+
+config INPUT_LSM303C_I2C
+         tristate
+         depends on INPUT_LSM303C
+         depends on I2C
+
+config INPUT_LSM303C_SPI
+         tristate
+         depends on INPUT_LSM303C
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc.c b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc.c
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1235 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : lsm303c_acc.c
+ * Authors            : AMS - Motion Mems Division - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Denis Ciocca (denis.ciocca@st.com)
+ *		      : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+ *		      : Authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.3
+ * Date               : 2016/May/18
+ * Description        : LSM303C accelerometer driver
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ ******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lsm303c.h"
+
+#define MS_TO_NS(x)		(x * 1000000L)
+
+#define SENSITIVITY_2G		 61	/**	ug/LSB	*/
+#define SENSITIVITY_4G		122	/**	ug/LSB	*/
+#define SENSITIVITY_8G		244	/**	ug/LSB	*/
+
+/* Accelerometer Sensor Operating Mode */
+#define LSM303C_ACC_ENABLE	(0x01)
+#define LSM303C_ACC_DISABLE	(0x00)
+
+#define AXISDATA_REG		(0x28)
+#define WHOAMI_LSM303C_ACC	(0x41)	/*	Expctd content for WAI	*/
+#define ALL_ZEROES		(0x00)
+#define LSM303C_ACC_PM_OFF	(0x00)
+#define ACC_ENABLE_ALL_AXES	(0x07)
+
+/*	CONTROL REGISTERS	*/
+#define TEMP_L			(0x0B)
+#define TEMP_H			(0x0C)
+#define WHO_AM_I		(0x0F)	/*	WhoAmI register		*/
+#define ACT_THS			(0x1E)	/*	Activity Threshold	*/
+#define ACT_DUR			(0x1F)	/*	Activity Duration	*/
+/* ctrl 1: HR ODR2 ODR1 ODR0 BDU Zenable Yenable Xenable */
+#define CTRL1			(0x20)	/*	control reg 1		*/
+#define CTRL2			(0x21)	/*	control reg 2		*/
+#define CTRL3			(0x22)	/*	control reg 3		*/
+#define CTRL4			(0x23)	/*	control reg 4		*/
+#define CTRL5			(0x24)	/*	control reg 5		*/
+#define CTRL6			(0x25)	/*	control reg 6		*/
+#define CTRL7			(0x26)	/*	control reg 7		*/
+
+#define FIFO_CTRL		(0x2E)	/*	fifo control reg	*/
+
+#define INT_CFG1		(0x30)	/*	interrupt 1 config	*/
+#define INT_SRC1		(0x31)	/*	interrupt 1 source	*/
+#define INT_THSX1		(0x32)	/*	interrupt 1 threshold x	*/
+#define INT_THSY1		(0x33)	/*	interrupt 1 threshold y	*/
+#define INT_THSZ1		(0x34)	/*	interrupt 1 threshold z	*/
+#define INT_DUR1		(0x35)	/*	interrupt 1 duration	*/
+
+#define INT_CFG2		(0x36)	/*	interrupt 2 config	*/
+#define INT_SRC2		(0x37)	/*	interrupt 2 source	*/
+#define INT_THS2		(0x38)	/*	interrupt 2 threshold	*/
+#define INT_DUR2		(0x39)	/*	interrupt 2 duration	*/
+
+#define REF_XL			(0x3A)	/*	reference_l_x		*/
+#define REF_XH			(0x3B)	/*	reference_h_x		*/
+#define REF_YL			(0x3C)	/*	reference_l_y		*/
+#define REF_YH			(0x3D)	/*	reference_h_y		*/
+#define REF_ZL			(0x3E)	/*	reference_l_z		*/
+#define REF_ZH			(0x3F)	/*	reference_h_z		*/
+/*	end CONTROL REGISTRES	*/
+
+#define ACC_ODR10		(0x10)	/*   10Hz output data rate */
+#define ACC_ODR50		(0x20)	/*   50Hz output data rate */
+#define ACC_ODR100		(0x30)	/*  100Hz output data rate */
+#define ACC_ODR200		(0x40)	/*  200Hz output data rate */
+#define ACC_ODR400		(0x50)	/*  400Hz output data rate */
+#define ACC_ODR800		(0x60)	/*  800Hz output data rate */
+#define ACC_ODR_MASK		(0X70)
+
+/* Registers configuration Mask and settings */
+/* CTRL1 */
+#define CTRL1_HR_DISABLE	(0x00)
+#define CTRL1_HR_ENABLE		(0x80)
+#define CTRL1_HR_MASK		(0x80)
+#define CTRL1_BDU_ENABLE	(0x08)
+#define CTRL1_BDU_MASK		(0x08)
+
+/* CTRL2 */
+#define CTRL2_IG1_INT1		(0x08)
+
+/* CTRL3 */
+#define CTRL3_IG1_INT1		(0x08)
+#define CTRL3_DRDY_INT1
+
+/* CTRL4 */
+#define CTRL4_IF_ADD_INC_EN	(0x04)
+#define CTRL4_BW_SCALE_ODR_AUT	(0x00)
+#define CTRL4_BW_SCALE_ODR_SEL	(0x08)
+#define CTRL4_ANTALIAS_BW_400	(0x00)
+#define CTRL4_ANTALIAS_BW_200	(0x40)
+#define CTRL4_ANTALIAS_BW_100	(0x80)
+#define CTRL4_ANTALIAS_BW_50	(0xC0)
+#define CTRL4_ANTALIAS_BW_MASK	(0xC0)
+
+/* CTRL5 */
+#define CTRL5_HLACTIVE_L	(0x02)
+#define CTRL5_HLACTIVE_H	(0x00)
+
+/* CTRL6 */
+#define CTRL6_IG2_INT2		(0x10)
+#define CTRL6_DRDY_INT2		(0x01)
+
+/* CTRL7 */
+#define CTRL7_LIR2		(0x08)
+#define CTRL7_LIR1		(0x04)
+/* */
+
+#define NO_MASK			(0xFF)
+
+#define INT1_DURATION_MASK	(0x7F)
+#define INT1_THRESHOLD_MASK	(0x7F)
+
+/* RESUME STATE INDICES */
+#define RES_CTRL1		0
+#define RES_CTRL2		1
+#define RES_CTRL3		2
+#define RES_CTRL4		3
+#define RES_CTRL5		4
+#define RES_CTRL6		5
+#define RES_CTRL7		6
+
+#define RES_INT_CFG1		7
+#define RES_INT_THSX1		8
+#define RES_INT_THSY1		9
+#define RES_INT_THSZ1		10
+#define RES_INT_DUR1		11
+
+#define RES_INT_CFG2		12
+#define RES_INT_THS2		13
+#define RES_INT_DUR2		14
+
+#define RES_TEMP_CFG_REG	15
+#define RES_REFERENCE_REG	16
+#define RES_FIFO_CTRL	17
+
+/* end RESUME STATE INDICES */
+
+#define OUTPUT_ALWAYS_ANTI_ALIASED 1
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lsm303c_acc_odr_table[] = {
+	{    2, ACC_ODR800 },
+	{    3, ACC_ODR400  },
+	{    5, ACC_ODR200  },
+	{   10, ACC_ODR100  },
+#if (!OUTPUT_ALWAYS_ANTI_ALIASED)
+	{   20, ACC_ODR50   },
+	{  100, ACC_ODR10   },
+#endif
+};
+
+static int int1_gpio = LSM303C_ACC_DEFAULT_INT1_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+
+static struct lsm303c_acc_platform_data default_lsm303c_acc_pdata = {
+	.fs_range = LSM303C_ACC_FS_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LSM303C_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LSM303C_ACC_DEFAULT_INT1_GPIO,
+};
+
+/* sets default init values to be written in registers at probe stage */
+static void lsm303c_acc_set_init_register_values(
+						struct lsm303c_acc_dev *dev)
+{
+	memset(dev->resume_state, 0, ARRAY_SIZE(dev->resume_state));
+
+	dev->resume_state[RES_CTRL1] = (ALL_ZEROES |
+					CTRL1_HR_DISABLE |
+					CTRL1_BDU_ENABLE |
+					ACC_ENABLE_ALL_AXES);
+
+	if (dev->pdata->gpio_int1 >= 0)
+		dev->resume_state[RES_CTRL3] =
+			(dev->resume_state[RES_CTRL3] | CTRL3_IG1_INT1);
+
+	dev->resume_state[RES_CTRL4] = (ALL_ZEROES | CTRL4_IF_ADD_INC_EN);
+
+	dev->resume_state[RES_CTRL5] = (ALL_ZEROES | CTRL5_HLACTIVE_H);
+
+	dev->resume_state[RES_CTRL7] = (ALL_ZEROES | CTRL7_LIR2 | CTRL7_LIR1);
+
+}
+
+static int lsm303c_acc_hw_init(struct lsm303c_acc_dev *dev)
+{
+	int err = -1;
+	u8 buf[7];
+
+#ifdef LSM303C_DEBUG
+	pr_info("%s: hw init start\n", LSM303C_ACC_DEV_NAME);
+#endif
+	err = dev->tf->read(dev->dev, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(dev->dev,
+		"Error reading WHO_AM_I: is device available/working?\n");
+		goto err_firstread;
+	} else
+		dev->hw_working = 1;
+
+	if (buf[0] != WHOAMI_LSM303C_ACC) {
+		dev_err(dev->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n",
+			WHOAMI_LSM303C_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = dev->resume_state[RES_CTRL4];
+	err = dev->tf->write(dev->dev, CTRL4, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_FIFO_CTRL];
+	err = dev->tf->write(dev->dev, FIFO_CTRL, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_INT_THSX1];
+	buf[1] = dev->resume_state[RES_INT_THSY1];
+	buf[2] = dev->resume_state[RES_INT_THSZ1];
+	buf[3] = dev->resume_state[RES_INT_DUR1];
+	err = dev->tf->write(dev->dev, INT_THSX1, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+	
+	buf[0] = dev->resume_state[RES_INT_CFG1];
+	err = dev->tf->write(dev->dev, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+
+	buf[0] = dev->resume_state[RES_CTRL2];
+	buf[1] = dev->resume_state[RES_CTRL3];
+	err = dev->tf->write(dev->dev, CTRL2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_CTRL5];
+	buf[1] = dev->resume_state[RES_CTRL6];
+	buf[2] = dev->resume_state[RES_CTRL7];
+	err = dev->tf->write(dev->dev, CTRL5, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_CTRL1];
+	err = dev->tf->write(dev->dev, CTRL1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	dev->hw_initialized = 1;
+#ifdef LSM303C_DEBUG
+	pr_info("%s: hw init done\n", LSM303C_ACC_DEV_NAME);
+#endif
+	return 0;
+
+err_firstread:
+	dev->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	dev->hw_initialized = 0;
+	dev_err(dev->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+			buf[1], err);
+	return err;
+}
+
+static void lsm303c_acc_device_power_off(struct lsm303c_acc_dev *dev)
+{
+	int err;
+	u8 data = LSM303C_ACC_PM_OFF;
+
+	err = dev->tf->write(dev->dev, CTRL1, 1, &data);
+	if (err < 0)
+		dev_err(dev->dev, "soft power off failed: %d\n", err);
+
+	if (dev->pdata->power_off) {
+		if (dev->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(dev->irq1);
+
+		dev->pdata->power_off();
+		dev->hw_initialized = 0;
+	}
+	if (dev->hw_initialized) {
+		if (dev->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(dev->irq1);
+
+		dev->hw_initialized = 0;
+	}
+
+}
+
+static int lsm303c_acc_device_power_on(struct lsm303c_acc_dev *dev)
+{
+	int err = -1;
+
+	if (dev->pdata->power_on) {
+		err = dev->pdata->power_on();
+		if (err < 0) {
+			dev_err(dev->dev,
+					"power_on failed: %d\n", err);
+			return err;
+		}
+		if (dev->pdata->gpio_int1 >= 0)
+			enable_irq(dev->irq1);
+	}
+
+	if (!dev->hw_initialized) {
+		err = lsm303c_acc_hw_init(dev);
+		if (dev->hw_working == 1 && err < 0) {
+			lsm303c_acc_device_power_off(dev);
+			return err;
+		}
+	}
+
+	if (dev->hw_initialized) {
+		if (dev->pdata->gpio_int1 >= 0)
+			enable_irq(dev->irq1);
+	}
+	return 0;
+}
+
+
+static int lsm303c_acc_update_fs_range(struct lsm303c_acc_dev *dev,
+				       u8 new_fs_range)
+{
+	int err = -1;
+
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = LSM303C_ACC_FS_MASK;
+
+	switch (new_fs_range) {
+	case LSM303C_ACC_FS_2G:
+
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LSM303C_ACC_FS_4G:
+
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LSM303C_ACC_FS_8G:
+
+		sensitivity = SENSITIVITY_8G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid fs range requested: %u\n",
+				new_fs_range);
+		return -EINVAL;
+	}
+
+
+	/* Updates configuration register 4,
+	* which contains fs range setting */
+	err = dev->tf->read(dev->dev, CTRL4, 1, buf);
+	if (err < 0)
+		goto error;
+	init_val = buf[0];
+	dev->resume_state[RES_CTRL4] = init_val;
+	new_val = new_fs_range;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, CTRL4, 1, buf);
+	if (err < 0)
+		goto error;
+	dev->resume_state[RES_CTRL4] = updated_val;
+	dev->sensitivity = sensitivity;
+
+	return err;
+error:
+	dev_err(dev->dev,
+			"update fs range failed 0x%02x,0x%02x: %d\n",
+			buf[0], buf[1], err);
+
+	return err;
+}
+
+static int lsm303c_acc_update_odr(struct lsm303c_acc_dev *dev,
+				  int poll_interval_ms)
+{
+	int err;
+	int i;
+	u8 config[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = ACC_ODR_MASK;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lsm303c_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303c_acc_odr_table[i].cutoff_ms <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+	new_val = lsm303c_acc_odr_table[i].mask;
+
+	/* Updates configuration register 1,
+	* which contains odr range setting if enabled,
+	* otherwise updates RES_CTRL1 for when it will */
+	if (atomic_read(&dev->enabled)) {
+		err = dev->tf->read(dev->dev, CTRL1, 1, config);
+		if (err < 0)
+			goto error;
+		init_val = config[0];
+		dev->resume_state[RES_CTRL1] = init_val;
+		updated_val = ((mask & new_val) | ((~mask) & init_val));
+
+		config[0] = updated_val;
+		err = dev->tf->write(dev->dev, CTRL1, 1, config);
+		if (err < 0)
+			goto error;
+		dev->resume_state[RES_CTRL1] = updated_val;
+		return err;
+	} else {
+		init_val = dev->resume_state[RES_CTRL1];
+		updated_val = ((mask & new_val) | ((~mask) & init_val));
+		dev->resume_state[RES_CTRL1] = updated_val;
+		return 0;
+	}
+
+error:
+	dev_err(dev->dev,
+			"update odr failed 0x%02x,0x%02x: %d\n",
+			config[0], config[1], err);
+
+	return err;
+}
+
+
+
+static int lsm303c_acc_register_write(struct lsm303c_acc_dev *dev,
+				      u8 *buf, u8 reg_address, u8 new_value)
+{
+	int err;
+
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->write(dev->dev, reg_address, 1, &new_value);
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+
+
+static int lsm303c_acc_get_data(struct lsm303c_acc_dev *dev, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s32 hw_d[3];
+
+	err = dev->tf->read(dev->dev, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s16) ((acc_data[1] << 8) | acc_data[0]));
+	hw_d[1] = ((s16) ((acc_data[3] << 8) | acc_data[2]));
+	hw_d[2] = ((s16) ((acc_data[5] << 8) | acc_data[4]));
+
+	hw_d[0] = hw_d[0] * dev->sensitivity;
+	hw_d[1] = hw_d[1] * dev->sensitivity;
+	hw_d[2] = hw_d[2] * dev->sensitivity;
+
+
+	xyz[0] = ((dev->pdata->negate_x) ? (-hw_d[dev->pdata->axis_map_x])
+		   : (hw_d[dev->pdata->axis_map_x]));
+	xyz[1] = ((dev->pdata->negate_y) ? (-hw_d[dev->pdata->axis_map_y])
+		   : (hw_d[dev->pdata->axis_map_y]));
+	xyz[2] = ((dev->pdata->negate_z) ? (-hw_d[dev->pdata->axis_map_z])
+		   : (hw_d[dev->pdata->axis_map_z]));
+
+#ifdef LSM303C_DEBUG
+
+	dev_dbg(dev->dev, "%s read x=%d, y=%d, z=%d\n",
+			LSM303C_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+
+#endif
+	return err;
+}
+
+static void lsm303c_acc_report_values(struct lsm303c_acc_dev *dev,
+					int *xyz)
+{
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(dev->input_dev);
+}
+
+static void lsm303c_acc_report_triple(struct lsm303c_acc_dev *dev)
+{
+	int err;
+	int xyz[3];
+
+	err = lsm303c_acc_get_data(dev, xyz);
+	if (err < 0)
+		dev_err(dev->dev, "get_data failed\n");
+	else
+		lsm303c_acc_report_values(dev, xyz);
+}
+
+static irqreturn_t lsm303c_acc_isr1(int irq, void *data)
+{
+	struct lsm303c_acc_dev *dev = data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq1_work_queue, &dev->irq1_work);
+	pr_debug("%s: isr1 queued\n", LSM303C_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm303c_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct lsm303c_acc_dev *dev =
+	container_of(work, struct lsm303c_acc_dev, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303c_acc_get_int1_source(dev); */
+	/* ; */
+	pr_debug("%s: IRQ1 served\n", LSM303C_ACC_DEV_NAME);
+/* exit: */
+	enable_irq(dev->irq1);
+}
+
+int lsm303c_acc_enable(struct lsm303c_acc_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&dev->lock);
+		err = lsm303c_acc_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		dev->polling_ktime = ktime_set(
+				dev->pdata->poll_interval / 1000,
+				MS_TO_NS(dev->pdata->poll_interval % 1000));
+		hrtimer_start(&dev->hr_timer_poll,
+			      dev->polling_ktime, HRTIMER_MODE_REL);
+		mutex_unlock(&dev->lock);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lsm303c_acc_enable);
+
+int lsm303c_acc_disable(struct lsm303c_acc_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled, 1, 0)) {
+		cancel_work_sync(&dev->input_poll_work);
+
+		mutex_lock(&dev->lock);
+		lsm303c_acc_device_power_off(dev);
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303c_acc_disable);
+
+static ssize_t read_single_reg(struct device *device, char *buf, u8 reg)
+{
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	u8 data;
+	int err;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, reg, 1, &data);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static int write_reg(struct device *device, const char *buf, u8 reg,
+						u8 mask, int resume_index)
+{
+	int err = -1;
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val = ((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = lsm303c_acc_register_write(dev, x, reg, new_val);
+	if (err < 0)
+		return err;
+	dev->resume_state[resume_index] = new_val;
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *device,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	mutex_lock(&dev->lock);
+	val = dev->pdata->poll_interval;
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *device,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int err;
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+						dev->pdata->min_interval);
+	mutex_lock(&dev->lock);
+	dev->pdata->poll_interval = interval_ms;
+	err = lsm303c_acc_update_odr(dev, interval_ms);
+	if (err >= 0) {
+		dev->pdata->poll_interval = interval_ms;
+		dev->polling_ktime = ktime_set(
+				dev->pdata->poll_interval / 1000,
+				MS_TO_NS(dev->pdata->poll_interval % 1000));
+	}
+	mutex_unlock(&dev->lock);
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	char range = 2;
+	mutex_lock(&dev->lock);
+	val = dev->pdata->fs_range;
+	switch (val) {
+	case LSM303C_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM303C_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM303C_ACC_FS_8G:
+		range = 8;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM303C_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM303C_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM303C_ACC_FS_8G;
+		break;
+	default:
+		dev_err(dev->dev,
+				"invalid range request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&dev->lock);
+	err = lsm303c_acc_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	int val = atomic_read(&dev->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303c_acc_enable(dev);
+	else
+		lsm303c_acc_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *device,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(device, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *device,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(device, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *device,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(device, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *device,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(device, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_threshx1(struct device *device,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(device, buf, INT_THSX1,
+					INT1_THRESHOLD_MASK, RES_INT_THSX1);
+}
+
+static ssize_t attr_get_threshx1(struct device *device,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(device, buf, INT_THSX1);
+}
+
+static ssize_t attr_set_threshy1(struct device *device,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(device, buf, INT_THSY1,
+					INT1_THRESHOLD_MASK, RES_INT_THSY1);
+}
+
+static ssize_t attr_get_threshy1(struct device *device,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(device, buf, INT_THSY1);
+}
+
+static ssize_t attr_set_threshz1(struct device *device,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(device, buf, INT_THSZ1,
+					INT1_THRESHOLD_MASK, RES_INT_THSZ1);
+}
+
+static ssize_t attr_get_threshz1(struct device *device,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(device, buf, INT_THSZ1);
+}
+
+static ssize_t attr_get_source1(struct device *device,
+		struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(device, buf, INT_SRC1);
+}
+
+
+#ifdef LSM303C_DEBUG
+/* PAY ATTENTION: These LSM303C_DEBUG functions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *device, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	rc = dev->tf->write(dev->dev, dev->reg_addr, 1, &(u8)val);
+	mutex_unlock(&dev->lock);
+
+	/*TODO: error need to be managed */
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *device, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	int rc;
+	u8 data;
+
+	mutex_lock(&dev->lock);
+	rc = dev->tf->read(dev->dev, dev->reg_addr, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	/*TODO: error need to be managed */
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *device, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm303c_acc_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	dev->reg_addr = val;
+	mutex_unlock(&dev->lock);
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0666, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0666, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_thresholdx, 0664, attr_get_threshx1, attr_set_threshx1),
+	__ATTR(int1_thresholdy, 0664, attr_get_threshy1, attr_set_threshy1),
+	__ATTR(int1_thresholdz, 0664, attr_get_threshz1, attr_set_threshz1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+#ifdef LSM303C_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *device)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(device, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(device, attributes + i);
+	dev_err(device, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *device)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(device, attributes + i);
+	return 0;
+}
+
+static void lsm303c_acc_input_poll_work_func(struct work_struct *work)
+{
+	struct lsm303c_acc_dev *dev;
+
+	dev = container_of((struct work_struct *) work,
+			   struct lsm303c_acc_dev, input_poll_work);
+
+	mutex_lock(&dev->lock);
+	lsm303c_acc_report_triple(dev);
+	mutex_unlock(&dev->lock);
+
+	if (atomic_read(&dev->enabled))
+		hrtimer_start(&dev->hr_timer_poll,
+					dev->polling_ktime, HRTIMER_MODE_REL);
+}
+
+enum hrtimer_restart lsm303c_acc_hr_timer_poll_function(struct hrtimer *timer)
+{
+	struct lsm303c_acc_dev *dev;
+
+	dev = container_of((struct hrtimer *)timer,
+			   struct lsm303c_acc_dev, hr_timer_poll);
+
+	queue_work(dev->hr_timer_poll_work_queue, &dev->input_poll_work);
+	return HRTIMER_NORESTART;
+}
+
+static int lsm303c_acc_validate_pdata(struct lsm303c_acc_dev *dev)
+{
+	/* checks for correctness of minimal polling period */
+	dev->pdata->min_interval =
+		max((unsigned int)LSM303C_ACC_MIN_POLL_PERIOD_MS,
+						dev->pdata->min_interval);
+
+	dev->pdata->poll_interval = max(dev->pdata->poll_interval,
+			dev->pdata->min_interval);
+
+	if (dev->pdata->axis_map_x > 2 ||
+		dev->pdata->axis_map_y > 2 ||
+		 dev->pdata->axis_map_z > 2) {
+		dev_err(dev->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+						dev->pdata->axis_map_x,
+						dev->pdata->axis_map_y,
+						dev->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (dev->pdata->negate_x > 1 || dev->pdata->negate_y > 1
+			|| dev->pdata->negate_z > 1) {
+		dev_err(dev->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+						dev->pdata->negate_x,
+						dev->pdata->negate_y,
+						dev->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (dev->pdata->poll_interval < dev->pdata->min_interval) {
+		dev_err(dev->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lsm303c_acc_input_init(struct lsm303c_acc_dev *dev)
+{
+	int err;
+
+	INIT_WORK(&dev->input_poll_work, lsm303c_acc_input_poll_work_func);
+	dev->input_dev = input_allocate_device();
+	if (!dev->input_dev) {
+		err = -ENOMEM;
+		dev_err(dev->dev, "input device allocation failed\n");
+		goto err0;
+	}
+
+	dev->input_dev->name = LSM303C_ACC_DEV_NAME;
+	dev->input_dev->id.bustype = dev->bus_type;
+	dev->input_dev->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev, dev);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev->mscbit);
+
+	err = input_register_device(dev->input_dev);
+	if (err) {
+		dev_err(dev->dev,
+				"unable to register input device %s\n",
+				dev->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(dev->input_dev);
+err0:
+	return err;
+}
+
+static void lsm303c_acc_input_cleanup(struct lsm303c_acc_dev *dev)
+{
+	input_unregister_device(dev->input_dev);
+	input_free_device(dev->input_dev);
+}
+
+int lsm303c_acc_probe(struct lsm303c_acc_dev *dev)
+{
+	int err = -1;
+
+	mutex_lock(&dev->lock);
+
+	dev->pdata = kmalloc(sizeof(*dev->pdata), GFP_KERNEL);
+	if (dev->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(dev->dev,
+				"failed to allocate memory for pdata: %d\n",
+				err);
+		goto err_mutexunlock;
+	}
+
+	if (dev->dev->platform_data == NULL) {
+		default_lsm303c_acc_pdata.gpio_int1 = int1_gpio;
+
+		memcpy(dev->pdata, &default_lsm303c_acc_pdata,
+		       sizeof(*dev->pdata));
+		dev_info(dev->dev, "using default plaform_data\n");
+	} else {
+		memcpy(dev->pdata, dev->dev->platform_data,
+		       sizeof(*dev->pdata));
+	}
+	dev->hr_timer_poll_work_queue = 0;
+
+	err = lsm303c_acc_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (dev->pdata->init) {
+		err = dev->pdata->init();
+		if (err < 0) {
+			dev_err(dev->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (dev->pdata->gpio_int1 >= 0) {
+		dev->irq1 = gpio_to_irq(dev->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, mapped on gpio:%d\n",
+			LSM303C_ACC_DEV_NAME, __func__, dev->irq1,
+							dev->pdata->gpio_int1);
+	}
+
+	lsm303c_acc_set_init_register_values(dev);
+
+	err = lsm303c_acc_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&dev->enabled, 1);
+
+	err = lsm303c_acc_update_fs_range(dev, dev->pdata->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303c_acc_update_odr(dev, dev->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	dev->hr_timer_poll_work_queue =
+			create_workqueue("lsm303c_acc_hr_timer_poll_wq");
+	hrtimer_init(&dev->hr_timer_poll, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer_poll.function = &lsm303c_acc_hr_timer_poll_function;
+
+	err = lsm303c_acc_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "input init failed\n");
+		goto err_remove_hr_work_queue;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev,
+		   "device LSM303C_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm303c_acc_device_power_off(dev);
+
+	/* As default, do not report information */
+	atomic_set(&dev->enabled, 0);
+
+	if (dev->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&dev->irq1_work, lsm303c_acc_irq1_work_func);
+		dev->irq1_work_queue =
+			create_singlethread_workqueue("lsm303c_acc_wq1");
+		if (!dev->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(dev->irq1, lsm303c_acc_isr1,
+			IRQF_TRIGGER_RISING, "lsm303c_acc_irq1", dev);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(dev->irq1);
+	}
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err_destoyworkqueue1:
+	if (dev->pdata->gpio_int1 >= 0)
+		destroy_workqueue(dev->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(dev->dev);
+err_input_cleanup:
+	lsm303c_acc_input_cleanup(dev);
+err_remove_hr_work_queue:
+	if (dev->hr_timer_poll_work_queue)
+		destroy_workqueue(dev->hr_timer_poll_work_queue);
+err_power_off:
+	lsm303c_acc_device_power_off(dev);
+err_pdata_init:
+	if (dev->pdata->exit)
+		dev->pdata->exit();
+exit_kfree_pdata:
+	kfree(dev->pdata);
+err_mutexunlock:
+	mutex_unlock(&dev->lock);
+/* err_freedata: */
+
+	return err;
+}
+EXPORT_SYMBOL(lsm303c_acc_probe);
+
+int lsm303c_acc_remove(struct lsm303c_acc_dev *dev)
+{
+	if (dev->pdata->gpio_int1 >= 0) {
+		free_irq(dev->irq1, dev);
+		gpio_free(dev->pdata->gpio_int1);
+		destroy_workqueue(dev->irq1_work_queue);
+	}
+
+	lsm303c_acc_disable(dev);
+	lsm303c_acc_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (dev->hr_timer_poll_work_queue)
+		destroy_workqueue(dev->hr_timer_poll_work_queue);
+
+	if (dev->pdata->exit)
+		dev->pdata->exit();
+	kfree(dev->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303c_acc_remove);
+
+MODULE_DESCRIPTION("lsm303c accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_i2c.c b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,177 @@
+/*
+ * STMicroelectronics lsm303c_acc_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303c.h"
+
+/* XXX: caller must hold dev->lock */
+static int lsm303c_acc_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm303c_acc_i2c_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm303c_transfer_function lsm303c_acc_i2c_tf = {
+	.write = lsm303c_acc_i2c_write,
+	.read = lsm303c_acc_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303c_acc_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303c_acc_dev *dev = i2c_get_clientdata(client);
+
+	return lsm303c_acc_enable(dev);
+}
+
+static int lsm303c_acc_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303c_acc_dev *dev = i2c_get_clientdata(client);
+
+	return lsm303c_acc_disable(dev);
+}
+
+static const struct dev_pm_ops lsm303c_acc_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303c_acc_i2c_suspend,
+				lsm303c_acc_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303c_acc_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303c_acc_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm303c_acc_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm303c_acc_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm303c_acc_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303c_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303c_acc_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303c_acc_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303c_acc_i2c_id[] = {
+	{ "lsm303c_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303c_acc_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303c_acc_i2c_id_table[] = {
+	{ .compatible = "st,lsm303c_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303c_acc_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm303c_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303c_acc_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303c_acc_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303c_acc_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303c_acc_i2c_probe,
+	.remove = lsm303c_acc_i2c_remove,
+	.id_table = lsm303c_acc_i2c_id,
+};
+
+module_i2c_driver(lsm303c_acc_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303c acc i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_spi.c b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_acc_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,192 @@
+/*
+ * STMicroelectronics lsm303c_acc_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm303c.h"
+
+#define SENSORS_SPI_READ	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303c_acc_spi_read(struct device *device, u8 addr,
+				int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_acc_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303c_acc_spi_write(struct device *device, u8 addr,
+				 int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_acc_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303C_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm303c_transfer_function lsm303c_acc_spi_tf = {
+	.write = lsm303c_acc_spi_write,
+	.read = lsm303c_acc_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303c_acc_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_acc_dev *dev = spi_get_drvdata(spi);
+
+	return lsm303c_acc_enable(dev);
+}
+
+static int lsm303c_acc_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_acc_dev *dev = spi_get_drvdata(spi);
+
+	return lsm303c_acc_disable(dev);
+}
+
+static const struct dev_pm_ops lsm303c_acc_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303c_acc_spi_suspend,
+				lsm303c_acc_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303c_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm303c_acc_dev *dev;
+
+#ifdef lsm303c_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm303c_acc_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm303c_acc_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm303c_acc_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303c_acc_spi_remove(struct spi_device *spi)
+{
+	struct lsm303c_acc_dev *dev = spi_get_drvdata(spi);
+
+#ifdef lsm303c_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303c_acc_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303c_acc_spi_id[] = {
+	{ "lsm303c_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm303c_acc_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303c_acc_spi_id_table[] = {
+	{ .compatible = "st,lsm303c_acc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303c_acc_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm303c_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303c_acc_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm303c_acc_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303c_acc_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303c_acc_spi_probe,
+	.remove = lsm303c_acc_spi_remove,
+	.id_table = lsm303c_acc_spi_id,
+};
+
+module_spi_driver(lsm303c_acc_spi_driver);
+
+MODULE_DESCRIPTION("lsm303c acc spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c.h b/drivers/input/misc/st/ecompass/lsm303c/lsm303c.h
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,217 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lsm303c.h
+* Authors	: AMS - Motion Mems Division - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Denis Ciocca (denis.ciocca@st.com)
+*		: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+* Version	: V.1.0.3
+* Date		: 2013/Dec/18
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/******************************************************************************/
+
+#ifndef	__LSM303C_H__
+#define	__LSM303C_H__
+
+
+#define LSM303C_ACC_DEV_NAME			"lsm303c_acc"
+#define	LSM303C_MAG_DEV_NAME			"lsm303c_mag"
+
+
+/* to set gpios numb connected to interrupt pins,
+ * the unused ones have to be set to -EINVAL
+ */
+#define LSM303C_ACC_DEFAULT_INT1_GPIO		(-EINVAL)
+
+#define LSM303C_MAG_DEFAULT_INT1_GPIO		(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define LSM303C_ACC_FS_MASK			(0x30)
+#define LSM303C_ACC_FS_2G			(0x00)
+#define LSM303C_ACC_FS_4G			(0x20)
+#define LSM303C_ACC_FS_8G			(0x30)
+
+/* Magnetometer Sensor Full Scale */
+#define LSM303C_MAG_FS_MASK			(0x60)
+#define LSM303C_MAG_FS_4G			(0x00)	/* Full scale 4 G */
+#define LSM303C_MAG_FS_8G			(0x20)	/* Full scale 8 G */
+#define LSM303C_MAG_FS_10G			(0x40)	/* Full scale 10 G */
+#define LSM303C_MAG_FS_16G			(0x60)	/* Full scale 16 G */
+
+#define LSM303C_ACC_MIN_POLL_PERIOD_MS		2
+#define LSM303C_MAG_MIN_POLL_PERIOD_MS		13
+
+
+struct lsm303c_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LSM303C_SPI) || \
+    defined(CONFIG_INPUT_LSM303C_SPI_MODULE)
+#define LSM303C_RX_MAX_LENGTH		500
+#define LSM303C_TX_MAX_LENGTH		500
+
+struct lsm303c_transfer_buffer {
+	u8 rx_buf[LSM303C_RX_MAX_LENGTH];
+	u8 tx_buf[LSM303C_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+
+#define LSM303C_ACC_RESUME_ENTRIES		18
+
+struct lsm303c_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1] to choose gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+};
+
+struct lsm303c_acc_dev {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	struct lsm303c_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct work_struct input_poll_work;
+	struct hrtimer hr_timer_poll;
+	ktime_t polling_ktime;
+	struct workqueue_struct *hr_timer_poll_work_queue;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	u8 sensitivity;
+
+	u8 resume_state[LSM303C_ACC_RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef LSM303C_DEBUG
+	u8 reg_addr;
+#endif
+
+	struct lsm303c_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM303C_SPI) || \
+    defined(CONFIG_INPUT_LSM303C_SPI_MODULE)
+	struct lsm303c_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM303C_SPI */
+};
+
+struct lsm303c_mag_platform_data {
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm303c_mag_dev {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	struct i2c_client *client;
+	struct lsm303c_mag_platform_data *pdata_mag;
+
+	struct mutex lock;
+	struct work_struct input_work_mag;
+
+	struct hrtimer hr_timer_mag;
+	ktime_t ktime_mag;
+	struct workqueue_struct *mag_workqueue;
+
+	struct input_dev *input_dev_mag;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+
+	atomic_t enabled_mag;
+
+	int on_before_suspend;
+	int use_smbus;
+
+	u32 sensitivity_mag;
+
+	u8 xy_mode;
+	u8 z_mode;
+
+	struct lsm303c_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM303C_SPI) || \
+    defined(CONFIG_INPUT_LSM303C_SPI_MODULE)
+	struct lsm303c_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM303C_SPI */
+};
+
+int lsm303c_acc_probe(struct lsm303c_acc_dev *dev);
+int lsm303c_acc_remove(struct lsm303c_acc_dev *dev);
+int lsm303c_acc_enable(struct lsm303c_acc_dev *dev);
+int lsm303c_acc_disable(struct lsm303c_acc_dev *dev);
+
+int lsm303c_mag_probe(struct lsm303c_mag_dev *dev);
+int lsm303c_mag_remove(struct lsm303c_mag_dev *dev);
+int lsm303c_mag_enable(struct lsm303c_mag_dev *dev);
+int lsm303c_mag_disable(struct lsm303c_mag_dev *dev);
+
+#endif	/* __LSM303C_H__ */
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag.c b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag.c
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,1143 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm303c_mag.c
+* Authors            : MSH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+*		     : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*		     : Authors are willing to be considered the contact
+*		     : and update points for the driver.
+* Version            : V.1.0.3
+* Date               : 2016/May/18
+* Description        : LSM303C magnetometer driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+*******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include "lsm303c.h"
+
+
+#define MS_TO_NS(x)		(x*1000000L)
+
+/* Address registers */
+#define REG_WHOAMI_ADDR		(0x0F)	/** Who am i address register */
+#define REG_CNTRL1_ADDR		(0x20)	/** CNTRL1 address register */
+#define REG_CNTRL2_ADDR		(0x21)	/** CNTRL2 address register */
+#define REG_CNTRL3_ADDR		(0x22)	/** CNTRL3 address register */
+#define REG_CNTRL4_ADDR		(0x23)	/** CNTRL4 address register */
+#define REG_CNTRL5_ADDR		(0x24)	/** CNTRL5 address register */
+
+#define REG_MAG_DATA_ADDR	(0x28)	/** Mag. data low address register */
+
+/* Sensitivity */
+#define SENSITIVITY_MAG_4G	146156	/**	ngauss/LSB	*/
+#define SENSITIVITY_MAG_8G	292312	/**	ngauss/LSB	*/
+#define SENSITIVITY_MAG_10G	365364	/**	ngauss/LSB	*/
+#define SENSITIVITY_MAG_16G	584454	/**	ngauss/LSB	*/
+
+/* ODR */
+#define ODR_MAG_MASK		(0X1C)	/* Mask for odr change on mag */
+#define LSM303C_MAG_ODR0_625	(0x00)	/* 0.625Hz output data rate */
+#define LSM303C_MAG_ODR1_25	(0x04)	/* 1.25Hz output data rate */
+#define LSM303C_MAG_ODR2_5	(0x08)	/* 2.5Hz output data rate */
+#define LSM303C_MAG_ODR5	(0x0C)	/* 5Hz output data rate */
+#define LSM303C_MAG_ODR10	(0x10)	/* 10Hz output data rate */
+#define LSM303C_MAG_ODR20	(0x14)	/* 20Hz output data rate */
+#define LSM303C_MAG_ODR40	(0x18)	/* 40Hz output data rate */
+#define LSM303C_MAG_ODR80	(0x1C)	/* 80Hz output data rate */
+
+/* Magnetic sensor mode */
+#define MSMS_MASK		(0x03)	/* Mask magnetic sensor mode */
+#define POWEROFF_MAG		(0x02)	/* Power Down */
+#define CONTINUOS_CONVERSION	(0x00)	/* Continuos Conversion */
+
+/* X and Y axis operative mode selection */
+#define X_Y_PERFORMANCE_MASK		(0x60)
+#define X_Y_LOW_PERFORMANCE		(0x00)
+#define X_Y_MEDIUM_PERFORMANCE		(0x20)
+#define X_Y_HIGH_PERFORMANCE		(0x40)
+#define X_Y_ULTRA_HIGH_PERFORMANCE	(0x60)
+
+/* Z axis operative mode selection */
+#define Z_PERFORMANCE_MASK		(0x0c)
+#define Z_LOW_PERFORMANCE		(0x00)
+#define Z_MEDIUM_PERFORMANCE		(0x04)
+#define Z_HIGH_PERFORMANCE		(0x08)
+#define Z_ULTRA_HIGH_PERFORMANCE	(0x0c)
+
+/* Default values loaded in probe function */
+#define WHOIAM_VALUE		(0x3d)	/** Who Am I default value */
+#define REG_DEF_CNTRL1		(0x60)	/** CNTRL1 default value */
+#define REG_DEF_CNTRL2		(0x00)	/** CNTRL2 default value */
+#define REG_DEF_CNTRL3		(0x03)	/** CNTRL3 default value */
+#define REG_DEF_CNTRL4		(0x00)	/** CNTRL4 default value */
+#define REG_DEF_CNTRL5		(0x40)	/** CNTRL5 default value */
+
+#define REG_DEF_ALL_ZEROS	(0x00)
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm303c_mag_odr_table[] = {
+	{  12, LSM303C_MAG_ODR80  },
+	{  25, LSM303C_MAG_ODR40   },
+	{  50, LSM303C_MAG_ODR20   },
+	{  100, LSM303C_MAG_ODR10 },
+	{ 200, LSM303C_MAG_ODR5 },
+	{ 400, LSM303C_MAG_ODR2_5},
+	{ 800, LSM303C_MAG_ODR1_25},
+	{ 1600, LSM303C_MAG_ODR0_625},
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	u8 address;
+	u8 mask;
+};
+
+struct interrupt_value {
+	int value;
+	u8 address;
+};
+
+static const struct lsm303c_mag_platform_data default_lsm303c_mag_pdata = {
+	.poll_interval = 100,
+	.min_interval = LSM303C_MAG_MIN_POLL_PERIOD_MS,
+	.fs_range = LSM303C_MAG_FS_4G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+};
+
+struct reg_rw {
+	u8 address;
+	u8 default_value;
+	u8 resume_value;
+};
+
+struct reg_r {
+	u8 address;
+	u8 value;
+};
+
+static struct status_registers {
+	struct reg_r who_am_i;
+	struct reg_rw cntrl1;
+	struct reg_rw cntrl2;
+	struct reg_rw cntrl3;
+	struct reg_rw cntrl4;
+	struct reg_rw cntrl5;
+} status_registers = {
+	.who_am_i.address = REG_WHOAMI_ADDR,
+	.who_am_i.value = WHOIAM_VALUE,
+	.cntrl1.address = REG_CNTRL1_ADDR,
+	.cntrl1.default_value = REG_DEF_CNTRL1,
+	.cntrl2.address = REG_CNTRL2_ADDR,
+	.cntrl2.default_value = REG_DEF_CNTRL2,
+	.cntrl3.address = REG_CNTRL3_ADDR,
+	.cntrl3.default_value = REG_DEF_CNTRL3,
+	.cntrl4.address = REG_CNTRL4_ADDR,
+	.cntrl4.default_value = REG_DEF_CNTRL4,
+	.cntrl5.address = REG_CNTRL5_ADDR,
+	.cntrl5.default_value = REG_DEF_CNTRL5,
+};
+
+static int lsm303c_hw_init(struct lsm303c_mag_dev *dev)
+{
+	int err = -1;
+	u8 buf[5];
+
+#ifdef LSM303C_DEBUG
+	pr_info("%s: hw init start\n", LSM303C_MAG_DEV_NAME);
+#endif
+	err = dev->tf->read(dev->dev, status_registers.who_am_i.address, 1,
+			    buf);
+	if (err < 0) {
+		dev_warn(dev->dev,
+		"Error reading WHO_AM_I: is device available/working?\n");
+		goto err_firstread;
+	} else
+		dev->hw_working = 1;
+
+	if (buf[0] != status_registers.who_am_i.value) {
+		dev_err(dev->dev,
+		"device unknown. Expected: 0x%02x, Replies: 0x%02x\n",
+				status_registers.who_am_i.value, buf[0]);
+		err = -1;
+		goto err_unknown_device;
+	}
+
+	status_registers.cntrl1.resume_value =
+					status_registers.cntrl1.default_value;
+	status_registers.cntrl2.resume_value =
+					status_registers.cntrl2.default_value;
+	status_registers.cntrl3.resume_value =
+					status_registers.cntrl3.default_value;
+	status_registers.cntrl4.resume_value =
+					status_registers.cntrl4.default_value;
+	status_registers.cntrl5.resume_value =
+					status_registers.cntrl5.default_value;
+
+	buf[0] = status_registers.cntrl1.default_value;
+	buf[1] = status_registers.cntrl2.default_value;
+	buf[2] = status_registers.cntrl3.default_value;
+	buf[3] = status_registers.cntrl4.default_value;
+	buf[4] = status_registers.cntrl5.default_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 5,
+			     buf);
+	if (err < 0) {
+		dev_warn(dev->dev,
+		"Error initializing CLTR_REG registers\n");
+		goto err_reginit;
+	}
+
+	dev->xy_mode = X_Y_ULTRA_HIGH_PERFORMANCE;
+	dev->z_mode = Z_ULTRA_HIGH_PERFORMANCE;
+	dev->hw_initialized = 1;
+
+#ifdef LSM303C_DEBUG
+	pr_info("%s: hw init done\n", LSM303C_MAG_DEV_NAME);
+#endif
+
+	return 0;
+
+err_reginit:
+err_unknown_device:
+err_firstread:
+	dev->hw_working = 0;
+	dev->hw_initialized = 0;
+	return err;
+}
+
+static int lsm303c_mag_device_power_off(struct lsm303c_mag_dev *dev)
+{
+	int err;
+	u8 buf[1];
+
+	buf[0] = ((MSMS_MASK & POWEROFF_MAG) |
+		  (~MSMS_MASK & status_registers.cntrl3.resume_value));
+
+	err = dev->tf->write(dev->dev, status_registers.cntrl3.address, 1,
+			     buf);
+	if (err < 0)
+		dev_err(dev->dev,
+			"magnetometer soft power off failed: %d\n", err);
+
+	if (dev->pdata_mag->power_off)
+		dev->pdata_mag->power_off();
+
+	atomic_set(&dev->enabled_mag, 0);
+
+	return 0;
+}
+
+static int lsm303c_mag_device_power_on(struct lsm303c_mag_dev *dev)
+{
+	int err = -1;
+	u8 buf[1];
+
+	if (dev->pdata_mag->power_on) {
+		err = dev->pdata_mag->power_on();
+		if (err < 0) {
+			dev_err(dev->dev,
+				"magnetometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.cntrl1.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 1,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = ((MSMS_MASK & CONTINUOS_CONVERSION) |
+		  (~MSMS_MASK & status_registers.cntrl3.resume_value));
+	err = dev->tf->write(dev->dev, status_registers.cntrl3.address, 1,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_mag, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&dev->enabled_mag, 0);
+	dev_err(dev->dev, "magnetometer hw power on error 0x%02x: %d\n",
+		buf[0], err);
+	return err;
+}
+
+static int lsm303c_mag_update_fs_range(struct lsm303c_mag_dev *dev,
+				       u8 new_fs_range)
+{
+	int err = -1;
+	u32 sensitivity;
+	u8 updated_val;
+	u8 buf[1];
+
+	switch (new_fs_range) {
+	case LSM303C_MAG_FS_4G:
+		sensitivity = SENSITIVITY_MAG_4G;
+		break;
+	case LSM303C_MAG_FS_8G:
+		sensitivity = SENSITIVITY_MAG_8G;
+		break;
+	case LSM303C_MAG_FS_10G:
+		sensitivity = SENSITIVITY_MAG_10G;
+		break;
+	case LSM303C_MAG_FS_16G:
+		sensitivity = SENSITIVITY_MAG_16G;
+		break;
+	default:
+		dev_err(dev->dev,
+			"invalid magnetometer fs range requested: %u\n",
+								new_fs_range);
+		return -EINVAL;
+	}
+
+	err = dev->tf->read(dev->dev, status_registers.cntrl2.address, 1, buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl2.resume_value = buf[0];
+	updated_val = (LSM303C_MAG_FS_MASK & new_fs_range);
+
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.cntrl2.address, 1,
+			     buf);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl2.resume_value = updated_val;
+	dev->sensitivity_mag = sensitivity;
+
+	return err;
+
+error:
+	dev_err(dev->dev,
+		"update magnetometer fs range failed 0x%02x: %d\n",
+		buf[0], err);
+	return err;
+}
+
+static int lsm303c_mag_update_odr(struct lsm303c_mag_dev *dev,
+				  unsigned int poll_interval_ms)
+{
+	int err = 0;
+	u8 config[1];
+	int i;
+
+	for (i = ARRAY_SIZE(lsm303c_mag_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303c_mag_odr_table[i].cutoff_us <= poll_interval_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	config[0] = ((ODR_MAG_MASK & lsm303c_mag_odr_table[i].value) |
+		     (~ODR_MAG_MASK & status_registers.cntrl1.resume_value));
+
+	if (atomic_read(&dev->enabled_mag)) {
+		err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 1,
+				     config);
+		if (err < 0)
+			goto error;
+	}
+	status_registers.cntrl1.resume_value = config[0];
+	dev->ktime_mag = ktime_set(0, MS_TO_NS(poll_interval_ms));
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update magnetometer odr failed 0x%02x: %d\n",
+		config[0], err);
+
+	return err;
+}
+
+static int lsm303c_mag_update_operative_mode(struct lsm303c_mag_dev *dev,
+					     int axis, u8 value)
+{
+	int err = -1;
+	u8 raddr, mask, waddr, data;
+
+	if (axis == 0) {
+		raddr = REG_CNTRL1_ADDR;
+		mask = X_Y_PERFORMANCE_MASK;
+		waddr = REG_CNTRL1_ADDR;
+	} else {
+		raddr = REG_CNTRL4_ADDR;
+		mask = Z_PERFORMANCE_MASK;
+		waddr = REG_CNTRL4_ADDR;
+	}
+
+	mutex_lock(&dev->lock);
+
+	err = dev->tf->read(dev->dev, raddr, 1, &data);
+	if (err < 0)
+		goto error;
+
+	data = ((mask & value) | (~mask & data));
+	err = dev->tf->write(dev->dev, waddr, 1, &data);
+	if (err < 0)
+		goto error;
+	if (axis == 0)
+		dev->xy_mode = value;
+	else
+		dev->z_mode = value;
+
+	mutex_unlock(&dev->lock);
+
+	return err;
+
+error:
+	mutex_unlock(&dev->lock);
+
+	dev_err(dev->dev, "update operative mode failed 0x%02x: %d\n",
+		data, err);
+
+	return err;
+}
+
+static int lsm303c_validate_polling(unsigned int *min_interval,
+					unsigned int *poll_interval,
+					unsigned int min, u8 *axis_map_x,
+					u8 *axis_map_y, u8 *axis_map_z)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+
+	if (*axis_map_x > 2 || *axis_map_y > 2 || *axis_map_z > 2) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lsm303c_validate_negate(u8 *negate_x, u8 *negate_y, u8 *negate_z)
+{
+	if (*negate_x > 1 || *negate_y > 1 || *negate_z > 1) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int lsm303c_mag_validate_pdata(struct lsm303c_mag_dev *dev)
+{
+	int res = -1;
+
+	res = lsm303c_validate_polling(&dev->pdata_mag->min_interval,
+				&dev->pdata_mag->poll_interval,
+				(unsigned int)LSM303C_MAG_MIN_POLL_PERIOD_MS,
+				&dev->pdata_mag->axis_map_x,
+				&dev->pdata_mag->axis_map_y,
+				&dev->pdata_mag->axis_map_z);
+	if (res < 0)
+		return -EINVAL;
+
+	res = lsm303c_validate_negate(&dev->pdata_mag->negate_x,
+				&dev->pdata_mag->negate_y,
+				&dev->pdata_mag->negate_z);
+	if (res < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+int lsm303c_mag_enable(struct lsm303c_mag_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled_mag, 0, 1)) {
+		int err;
+
+		mutex_lock(&dev->lock);
+
+		err = lsm303c_mag_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled_mag, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag,
+			      HRTIMER_MODE_REL);
+
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303c_mag_enable);
+
+int lsm303c_mag_disable(struct lsm303c_mag_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_mag, 1, 0)) {
+		cancel_work_sync(&dev->input_work_mag);
+		hrtimer_cancel(&dev->hr_timer_mag);
+
+		mutex_lock(&dev->lock);
+		lsm303c_mag_device_power_off(dev);
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303c_mag_disable);
+
+static void lsm303c_mag_input_cleanup(struct lsm303c_mag_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static ssize_t attr_get_polling_rate_mag(struct device *device,
+						struct device_attribute *attr,
+		char *buf)
+{
+	unsigned int val;
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_mag->poll_interval;
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate_mag(struct device *device,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int err;
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+			    dev->pdata_mag->min_interval);
+
+	mutex_lock(&dev->lock);
+	dev->pdata_mag->poll_interval = (unsigned int)interval_ms;
+	err = lsm303c_mag_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return (!err) ? size : err;
+}
+
+static ssize_t attr_get_enable_mag(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+	int val = (int)atomic_read(&dev->enabled_mag);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_mag(struct device *device,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303c_mag_enable(dev);
+	else
+		lsm303c_mag_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_range_mag(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	u8 val;
+	int range = 2;
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_mag->fs_range;
+	switch (val) {
+	case LSM303C_MAG_FS_4G:
+		range = 4;
+		break;
+	case LSM303C_MAG_FS_8G:
+		range = 8;
+		break;
+	case LSM303C_MAG_FS_10G:
+		range = 10;
+		break;
+	case LSM303C_MAG_FS_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_mag(struct device *device,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 4:
+		range = LSM303C_MAG_FS_4G;
+		break;
+	case 8:
+		range = LSM303C_MAG_FS_8G;
+		break;
+	case 10:
+		range = LSM303C_MAG_FS_10G;
+		break;
+	case 16:
+		range = LSM303C_MAG_FS_16G;
+		break;
+	default:
+		dev_err(dev->dev,
+			"magnetometer invalid range request: %lu, discarded\n",
+									val);
+		return -EINVAL;
+	}
+	mutex_lock(&dev->lock);
+	err = lsm303c_mag_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_mag->fs_range = range;
+	mutex_unlock(&dev->lock);
+	dev_info(dev->dev,
+				"magnetometer range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_xy_mode(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	u8 val;
+	char mode[13];
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->xy_mode;
+	switch (val) {
+	case X_Y_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "high");
+		break;
+	case X_Y_LOW_PERFORMANCE:
+		strcpy(&(mode[0]), "low");
+		break;
+	case X_Y_MEDIUM_PERFORMANCE:
+		strcpy(&(mode[0]), "medium");
+		break;
+	case X_Y_ULTRA_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "ultra_high");
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%s\n", mode);
+}
+
+static ssize_t attr_set_xy_mode(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+	u8 mode;
+	int err;
+
+	err = strncmp(buf, "high", 4);
+	if (err == 0) {
+		mode = X_Y_HIGH_PERFORMANCE;
+		goto valid;
+	}
+	err = strncmp(buf, "low", 3);
+	if (err == 0) {
+		mode = X_Y_LOW_PERFORMANCE;
+		goto valid;
+	}
+	err = strncmp(buf, "medium", 6);
+	if (err == 0) {
+		mode = X_Y_MEDIUM_PERFORMANCE;
+		goto valid;
+	}
+	err = strncmp(buf, "ultra_high", 10);
+	if (err == 0) {
+		mode = X_Y_ULTRA_HIGH_PERFORMANCE;
+		goto valid;
+	}
+	goto error;
+
+valid:
+	err = lsm303c_mag_update_operative_mode(dev, 0, mode);
+	if (err < 0)
+		goto error;
+
+	dev_info(dev->dev, "magnetometer x_y op. mode set to: %s", buf);
+	return size;
+
+error:
+	dev_err(dev->dev,
+		"magnetometer invalid value request: %s, discarded\n", buf);
+
+	return -EINVAL;
+}
+
+static ssize_t attr_get_z_mode(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	u8 val;
+	char mode[13];
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->z_mode;
+	switch (val) {
+	case Z_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "high");
+		break;
+	case Z_LOW_PERFORMANCE:
+		strcpy(&(mode[0]), "low");
+		break;
+	case Z_MEDIUM_PERFORMANCE:
+		strcpy(&(mode[0]), "medium");
+		break;
+	case Z_ULTRA_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "ultra_high");
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%s\n", mode);
+}
+
+static ssize_t attr_set_z_mode(struct device *device,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct lsm303c_mag_dev *dev = dev_get_drvdata(device);
+	u8 mode;
+	int err;
+
+	err = strncmp(buf, "high", 4);
+	if (err == 0) {
+		mode = Z_HIGH_PERFORMANCE;
+		goto valid;
+	}
+	err = strncmp(buf, "low", 3);
+	if (err == 0) {
+		mode = Z_LOW_PERFORMANCE;
+		goto valid;
+	}
+	err = strncmp(buf, "medium", 6);
+	if (err == 0) {
+		mode = Z_MEDIUM_PERFORMANCE;
+		goto valid;
+	}
+	err = strncmp(buf, "ultra_high", 10);
+	if (err == 0) {
+		mode = Z_ULTRA_HIGH_PERFORMANCE;
+		goto valid;
+	}
+	goto error;
+
+valid:
+	err = lsm303c_mag_update_operative_mode(dev, 1, mode);
+	if (err < 0)
+		goto error;
+
+	dev_info(dev->dev,
+			"magnetometer z op. mode set to: %s", buf);
+	return size;
+
+error:
+	dev_err(dev->dev,
+		"magnetometer invalid value request: %s, discarded\n", buf);
+
+	return -EINVAL;
+}
+
+#ifdef DEBUG
+static int write_bit_on_register(struct lsm303c_mag_dev *dev, u8 address,
+				 u8 *resume_value, u8 mask, int value)
+{
+	int err;
+	u8 updated_val;
+	u8 buf[1];
+	u8 val = 0x00;
+
+	mutex_lock(&dev->lock);
+
+	err = dev->tf->read(dev->dev, address, 1, buf);
+	if (err < 0) {
+		mutex_lock(&dev->lock);
+		return -1;
+	}
+
+	if (resume_value != NULL)
+		*resume_value = buf[0];
+
+	if (mask == 0)
+		updated_val = (u8)value;
+	else {
+		if (value > 0)
+			val = 0xFF;
+
+		updated_val = (mask & val) | ((~mask) & buf[0]);
+	}
+
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, address, 1, buf);
+	if (err < 0) {
+		mutex_lock(&dev->lock);
+		return -1;
+	}
+
+	if (resume_value != NULL)
+		*resume_value = updated_val;
+
+	return err;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate_mag,
+						attr_set_polling_rate_mag),
+	__ATTR(full_scale, 0666, attr_get_range_mag, attr_set_range_mag),
+	__ATTR(enable_device, 0666, attr_get_enable_mag, attr_set_enable_mag),
+	__ATTR(x_y_opearative_mode, 0666, attr_get_xy_mode, attr_set_xy_mode),
+	__ATTR(z_opearative_mode, 0666, attr_get_z_mode, attr_set_z_mode),
+#ifdef DEBUG
+	//__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	//__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static int lsm303c_mag_get_data(struct lsm303c_mag_dev *dev, int *xyz)
+{
+	int err = -1;
+	u8 mag_data[6];
+	s32 hw_d[3] = { 0 };
+
+	err = dev->tf->read(dev->dev, REG_MAG_DATA_ADDR, 6, mag_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)((s16)((mag_data[1] << 8) | (mag_data[0]))));
+	hw_d[1] = ((s32)((s16)((mag_data[3] << 8) | (mag_data[2]))));
+	hw_d[2] = ((s32)((s16)((mag_data[5] << 8) | (mag_data[4]))));
+
+#ifdef DEBUG
+	pr_debug("%s read x=0x%02x 0x%02x (regH regL), x=%d (dec) [LSB]\n",
+		LSM303C_MAG_DEV_NAME, mag_data[1], mag_data[0], hw_d[0]);
+	pr_debug("%s read y=0x%02x 0x%02x (regH regL), y=%d (dec) [LSB]\n",
+		LSM303C_MAG_DEV_NAME, mag_data[3], mag_data[2], hw_d[1]);
+	pr_debug("%s read z=0x%02x 0x%02x (regH regL), z=%d (dec) [LSB]\n",
+		LSM303C_MAG_DEV_NAME, mag_data[5], mag_data[4], hw_d[2]);
+#endif
+/*
+	hw_d[0] = hw_d[0] * dev->sensitivity_mag;
+	hw_d[1] = hw_d[1] * dev->sensitivity_mag;
+	hw_d[2] = hw_d[2] * dev->sensitivity_mag;
+*/
+	xyz[0] = ((dev->pdata_mag->negate_x) ?
+				(-hw_d[dev->pdata_mag->axis_map_x])
+					: (hw_d[dev->pdata_mag->axis_map_x]));
+	xyz[1] = ((dev->pdata_mag->negate_y) ?
+				(-hw_d[dev->pdata_mag->axis_map_y])
+					: (hw_d[dev->pdata_mag->axis_map_y]));
+	xyz[2] = ((dev->pdata_mag->negate_z) ?
+				(-hw_d[dev->pdata_mag->axis_map_z])
+					: (hw_d[dev->pdata_mag->axis_map_z]));
+
+	return err;
+}
+
+static void lsm303c_mag_report_values(struct lsm303c_mag_dev *dev, int *xyz)
+{
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(dev->input_dev_mag);
+}
+
+static int lsm303c_mag_input_init(struct lsm303c_mag_dev *dev)
+{
+	int err;
+
+	dev->input_dev_mag = input_allocate_device();
+	if (!dev->input_dev_mag) {
+		err = -ENOMEM;
+		dev_err(dev->dev,
+			"magnetometer input device allocation failed\n");
+		goto err0;
+	}
+
+	dev->input_dev_mag->name = LSM303C_MAG_DEV_NAME;
+	dev->input_dev_mag->id.bustype = dev->bus_type;
+	dev->input_dev_mag->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_mag, dev);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev_mag->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev_mag->mscbit);
+
+	err = input_register_device(dev->input_dev_mag);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register magnetometer input device %s\n",
+				dev->input_dev_mag->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(dev->input_dev_mag);
+err0:
+	return err;
+}
+
+static void lsm303c_input_cleanup(struct lsm303c_mag_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static void poll_function_work_mag(struct work_struct *input_work_mag)
+{
+	struct lsm303c_mag_dev *dev;
+	int xyz[3] = { 0 };
+	int err;
+
+	dev = container_of((struct work_struct *)input_work_mag,
+			   struct lsm303c_mag_dev, input_work_mag);
+
+	mutex_lock(&dev->lock);
+
+	if (atomic_read(&dev->enabled_mag)) {
+		err = lsm303c_mag_get_data(dev, xyz);
+		if (err < 0)
+			dev_err(dev->dev,
+					"get_magnetometer_data failed\n");
+		else
+			lsm303c_mag_report_values(dev, xyz);
+	}
+
+	mutex_unlock(&dev->lock);
+	hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag, HRTIMER_MODE_REL);
+}
+
+static enum hrtimer_restart poll_function_read_mag(struct hrtimer *timer)
+{
+	struct lsm303c_mag_dev *dev;
+
+
+	dev = container_of((struct hrtimer *)timer,
+			   struct lsm303c_mag_dev, hr_timer_mag);
+
+	queue_work(dev->mag_workqueue, &dev->input_work_mag);
+	return HRTIMER_NORESTART;
+}
+
+int lsm303c_mag_probe(struct lsm303c_mag_dev *dev)
+{
+	int err = -1;
+
+	mutex_lock(&dev->lock);
+
+	dev->pdata_mag = kmalloc(sizeof(*dev->pdata_mag), GFP_KERNEL);
+	if (dev->pdata_mag == NULL) {
+		err = -ENOMEM;
+		dev_err(dev->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (dev->dev->platform_data == NULL) {
+		memcpy(dev->pdata_mag, &default_lsm303c_mag_pdata,
+						sizeof(*dev->pdata_mag));
+		dev_info(dev->dev,
+			"using default plaform_data for magnetometer\n");
+	} else {
+		memcpy(dev->pdata_mag, dev->dev->platform_data,
+						sizeof(*dev->pdata_mag));
+	}
+
+	err = lsm303c_mag_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev,
+			"failed to validate platform data for magnetometer\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (dev->pdata_mag->init) {
+		err = dev->pdata_mag->init();
+		if (err < 0) {
+			dev_err(dev->dev,
+				"magnetometer init failed: %d\n", err);
+			goto err_pdata_mag_init;
+		}
+	}
+
+	err = lsm303c_hw_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm303c_mag_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev,
+			"magnetometer power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm303c_mag_update_fs_range(dev, dev->pdata_mag->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev,
+			"update_fs_range on magnetometer failed\n");
+		goto  err_power_off_mag;
+	}
+
+	err = lsm303c_mag_update_odr(dev, dev->pdata_mag->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr on magnetometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303c_mag_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev,
+			"device LSM303C_MAG_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm303c_mag_device_power_off(dev);
+
+	dev->mag_workqueue = create_workqueue("lsm303c_workqueue");
+	if (!dev->mag_workqueue)
+		goto err_input_cleanup;
+
+	hrtimer_init(&dev->hr_timer_mag, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer_mag.function = &poll_function_read_mag;
+	INIT_WORK(&dev->input_work_mag, poll_function_work_mag);
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err_input_cleanup:
+	lsm303c_input_cleanup(dev);
+err_power_off:
+err_power_off_mag:
+	lsm303c_mag_device_power_off(dev);
+err_hw_init:
+err_pdata_init:
+err_pdata_mag_init:
+	if (dev->pdata_mag->exit)
+		dev->pdata_mag->exit();
+exit_kfree_pdata:
+	kfree(dev->pdata_mag);
+err_mutexunlock:
+	mutex_unlock(&dev->lock);
+	if (dev->mag_workqueue)
+		destroy_workqueue(dev->mag_workqueue);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm303c_mag_probe);
+
+int lsm303c_mag_remove(struct lsm303c_mag_dev *dev)
+{
+	lsm303c_mag_disable(dev);
+	lsm303c_mag_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (dev->pdata_mag->exit)
+		dev->pdata_mag->exit();
+
+	if (dev->mag_workqueue)
+		destroy_workqueue(dev->mag_workqueue);
+
+	kfree(dev->pdata_mag);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303c_mag_remove);
+
+MODULE_DESCRIPTION("lsm303c magnetometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_i2c.c b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_i2c.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,185 @@
+/*
+ * STMicroelectronics lsm303c_mag_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+//#include <linux/umagess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303c.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm303c_mag_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm303c_mag_i2c_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm303c_transfer_function lsm303c_mag_i2c_tf = {
+	.write = lsm303c_mag_i2c_write,
+	.read = lsm303c_mag_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303c_mag_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303c_mag_dev *dev = i2c_get_clientdata(client);
+
+	return lsm303c_mag_enable(dev);
+}
+
+static int lsm303c_mag_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303c_mag_dev *dev = i2c_get_clientdata(client);
+
+	return lsm303c_mag_disable(dev);
+}
+
+static const struct dev_pm_ops lsm303c_mag_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303c_mag_i2c_suspend,
+				lsm303c_mag_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303c_mag_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303c_mag_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm303c_mag_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm303c_mag_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm303c_mag_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303c_mag_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303c_mag_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303c_mag_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303c_mag_i2c_id[] = {
+	{ "lsm303c_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303c_mag_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303c_mag_i2c_id_table[] = {
+	{ .compatible = "st,lsm303c_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303c_mag_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm303c_mag_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303c_mag_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303c_mag_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303c_mag_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303c_mag_i2c_probe,
+	.remove = lsm303c_mag_i2c_remove,
+	.id_table = lsm303c_mag_i2c_id,
+};
+
+module_i2c_driver(lsm303c_mag_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303c mag i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_spi.c b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/lsm303c_mag_spi.c	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm303c_mag_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm303c.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303c_mag_spi_read(struct device *device, u8 addr,
+				int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_mag_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm303c_mag_spi_write(struct device *device, u8 addr,
+				 int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_mag_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303C_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm303c_transfer_function lsm303c_mag_spi_tf = {
+	.write = lsm303c_mag_spi_write,
+	.read = lsm303c_mag_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303c_mag_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_mag_dev *dev = spi_get_drvdata(spi);
+
+	return lsm303c_mag_enable(dev);
+}
+
+static int lsm303c_mag_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303c_mag_dev *dev = spi_get_drvdata(spi);
+
+	return lsm303c_mag_disable(dev);
+}
+
+static const struct dev_pm_ops lsm303c_mag_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303c_mag_spi_suspend,
+				lsm303c_mag_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm303c_mag_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm303c_mag_dev *dev;
+
+#ifdef lsm303c_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm303c_mag_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm303c_mag_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm303c_mag_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303c_mag_spi_remove(struct spi_device *spi)
+{
+	struct lsm303c_mag_dev *dev = spi_get_drvdata(spi);
+
+#ifdef lsm303c_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303c_mag_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303c_mag_spi_id[] = {
+	{ "lsm303c_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm303c_mag_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303c_mag_spi_id_table[] = {
+	{ .compatible = "st,lsm303c_mag" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303c_mag_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm303c_mag_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303c_mag_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm303c_mag_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303c_mag_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303c_mag_spi_probe,
+	.remove = lsm303c_mag_spi_remove,
+	.id_table = lsm303c_mag_spi_id,
+};
+
+module_spi_driver(lsm303c_mag_spi_driver);
+
+MODULE_DESCRIPTION("lsm303c mag spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303c/Makefile b/drivers/input/misc/st/ecompass/lsm303c/Makefile
--- a/drivers/input/misc/st/ecompass/lsm303c/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303c/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,9 @@
+#
+# Makefile for the input misc lsm303c driver.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_INPUT_LSM303C) += lsm303c_acc.o lsm303c_mag.o
+obj-$(CONFIG_INPUT_LSM303C_I2C) += lsm303c_acc_i2c.o lsm303c_mag_i2c.o
+obj-$(CONFIG_INPUT_LSM303C_SPI) += lsm303c_acc_spi.o lsm303c_mag_spi.o
diff -uNr a/drivers/input/misc/st/ecompass/lsm303d/Kconfig b/drivers/input/misc/st/ecompass/lsm303d/Kconfig
--- a/drivers/input/misc/st/ecompass/lsm303d/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303d/Kconfig	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,22 @@
+
+config INPUT_LSM303D
+         tristate "STM LSM303D sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LSM303D_I2C if (I2C)
+	 select INPUT_LSM303D_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics LSM303D sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm303d.
+
+config INPUT_LSM303D_I2C
+         tristate
+         depends on INPUT_LSM303D
+         depends on I2C
+
+config INPUT_LSM303D_SPI
+         tristate
+         depends on INPUT_LSM303D
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303d/lsm303d_core.c b/drivers/input/misc/st/ecompass/lsm303d/lsm303d_core.c
--- a/drivers/input/misc/st/ecompass/lsm303d/lsm303d_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303d/lsm303d_core.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,3398 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics *******************
+*
+* File Name          : lsm303d.c
+* Authors            : AMS - MSH Div - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+* 		     : Giuseppe Barba (giuseppe.barba@st.com)
+*		     : Both authors are willing to be considered the contact
+*		     : and update points for the driver.
+* Version            : V.1.0.7
+* Date               : 2014/Aug/04
+* Description        : LSM303D accelerometer & magnetometer driver
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************/
+/******************************************************************************
+Version History.
+
+Revision 1-0-0 2012/05/04
+ first revision
+Revision 1-0-1 2012/05/07
+ New sysfs architecture
+ Support antialiasing filter
+Revision 1-0-2 2012/10/15
+ I2C address bugfix
+Revision 1-0-3 2013/01/21
+ Move CTLREG7 resume write from acc_power_on to magn_power_on
+Revision 1-0-4 2013/05/09
+ Added rotation matrix
+Revision 1-0-5 2013/10/23
+ Corrects Mag Enable bug, Corrects missing BDU enable
+Revision 1-0-7 2014/08/04
+ Add Device Tree support
+******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#if defined(CONFIG_OF)
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm303d.h"
+
+
+#define MS_TO_NS(x)		(x*1000000L)
+
+#define	ACC_G_MAX_POS		1495040	/** max positive value acc [ug] */
+#define	ACC_G_MAX_NEG		1495770	/** max negative value acc [ug] */
+#define	MAG_G_MAX_POS		983520	/** max positive value mag [ugauss] */
+#define	MAG_G_MAX_NEG		983040	/** max negative value mag [ugauss] */
+
+#define FUZZ			0
+#define FLAT			0
+
+/* Address registers */
+#define REG_WHOAMI_ADDR		(0x0F)	/** Who am i address register */
+#define REG_CNTRL0_ADDR		(0x1F)	/** CNTRL0 address register */
+#define REG_CNTRL1_ADDR		(0x20)	/** CNTRL1 address register */
+#define REG_CNTRL2_ADDR		(0x21)	/** CNTRL2 address register */
+#define REG_CNTRL3_ADDR		(0x22)	/** CNTRL3 address register */
+#define REG_CNTRL4_ADDR		(0x23)	/** CNTRL4 address register */
+#define REG_CNTRL5_ADDR		(0x24)	/** CNTRL5 address register */
+#define REG_CNTRL6_ADDR		(0x25)	/** CNTRL6 address register */
+#define REG_CNTRL7_ADDR		(0x26)	/** CNTRL7 address register */
+
+#define REG_ACC_DATA_ADDR	(0x28)	/** Acc. data low address register */
+#define REG_MAG_DATA_ADDR	(0x08)	/** Mag. data low address register */
+#define REG_TEMP_DATA_ADDR	(0x05)	/** Temp. data low address register */
+
+#define REG_GEN_MAG_ADDR	(0x12)	/** INT_CTRL_REG_M address register */
+#define INT_SRC_REG_M_ADDR	(0x13)	/** INT_SRC_REG_M address register */
+#define REG_GEN_MAG_THR_ADDR	(0x14)	/** INT_THS_L_M address register */
+#define MIG_THRESHOLD_ADDR_H	(0x15)	/** INT_THS_H_M address register */
+#define REG_GEN1_AXIS_ADDR	(0x30)	/** INT_GEN1_REG address register */
+#define INT_GEN1_SRC_ADDR	(0x31)	/** INT_GEN1_SRC address register */
+#define REG_GEN1_THR_ADDR	(0x32)	/** INT_GEN1_THS address register */
+#define REG_GEN1_DUR_ADDR	(0x33)	/** INT_GEN1_DUR address register */
+#define REG_GEN2_AXIS_ADDR	(0x34)	/** INT_GEN2_REG address register */
+#define INT_GEN2_SRC_ADDR	(0x35)	/** INT_GEN2_SRC address register */
+#define REG_GEN2_THR_ADDR	(0x36)	/** INT_GEN2_THS address register */
+#define REG_GEN2_DUR_ADDR	(0x37)	/** INT_GEN2_DUR address register */
+
+/* Sensitivity */
+#define SENSITIVITY_ACC_2G	61	/**	ug/LSB	*/
+#define SENSITIVITY_ACC_4G	122	/**	ug/LSB	*/
+#define SENSITIVITY_ACC_8G	244	/**	ug/LSB	*/
+#define SENSITIVITY_ACC_16G	732	/**	ug/LSB	*/
+
+#define SENSITIVITY_MAG_2G	80	/**	ugauss/LSB	*/
+#define SENSITIVITY_MAG_4G	160	/**	ugauss/LSB	*/
+#define SENSITIVITY_MAG_8G	320	/**	ugauss/LSB	*/
+#define SENSITIVITY_MAG_12G	479	/**	ugauss/LSB	*/
+
+/* ODR */
+#define ODR_ACC_MASK		(0XF0)	/* Mask for odr change on acc */
+#define LSM303D_ACC_ODR_OFF	(0x00)  /* Power down */
+#define LSM303D_ACC_ODR3_125	(0x10)  /* 3.25Hz output data rate */
+#define LSM303D_ACC_ODR6_25	(0x20)  /* 6.25Hz output data rate */
+#define LSM303D_ACC_ODR12_5	(0x30)  /* 12.5Hz output data rate */
+#define LSM303D_ACC_ODR25	(0x40)  /* 25Hz output data rate */
+#define LSM303D_ACC_ODR50	(0x50)  /* 50Hz output data rate */
+#define LSM303D_ACC_ODR100	(0x60)  /* 100Hz output data rate */
+#define LSM303D_ACC_ODR200	(0x70)  /* 200Hz output data rate */
+#define LSM303D_ACC_ODR400	(0x80)  /* 400Hz output data rate */
+#define LSM303D_ACC_ODR800	(0x90)  /* 800Hz output data rate */
+#define LSM303D_ACC_ODR1600	(0xA0)  /* 1600Hz output data rate */
+
+#define ODR_MAG_MASK		(0X1C)	/* Mask for odr change on mag */
+#define LSM303D_MAG_ODR3_125	(0x00)  /* 3.25Hz output data rate */
+#define LSM303D_MAG_ODR6_25	(0x04)  /* 6.25Hz output data rate */
+#define LSM303D_MAG_ODR12_5	(0x08)  /* 12.5Hz output data rate */
+#define LSM303D_MAG_ODR25	(0x0C)  /* 25Hz output data rate */
+#define LSM303D_MAG_ODR50	(0x10)  /* 50Hz output data rate */
+#define LSM303D_MAG_ODR100	(0x14)  /* 100Hz output data rate */
+
+/* Magnetic sensor mode */
+#define MSMS_MASK		(0x03)	/* Mask magnetic sensor mode */
+#define POWEROFF_MAG		(0x02)	/* Power Down */
+#define CONTINUOS_CONVERSION	(0x00)	/* Continuos Conversion */
+
+/* Default values loaded in probe function */
+#define WHOIAM_VALUE		(0x49)	/** Who Am I default value */
+#define REG_DEF_CNTRL0		(0x00)	/** CNTRL0 default value */
+#define REG_DEF_CNTRL1		(0x0F)	/** CNTRL1 default value */
+#define REG_DEF_CNTRL2		(0x00)	/** CNTRL2 default value */
+#define REG_DEF_CNTRL3		(0x00)	/** CNTRL3 default value */
+#define REG_DEF_CNTRL4		(0x00)	/** CNTRL4 default value */
+#define REG_DEF_CNTRL5		(0x14)	/** CNTRL5 default value */
+#define REG_DEF_CNTRL6		(0x20)	/** CNTRL6 default value */
+#define REG_DEF_CNTRL7		(0x02)	/** CNTRL7 default value */
+
+#define REG_DEF_INT_CNTRL_MAG	(0x00)	/** INT_CTRL_REG_M default value */
+#define REG_DEF_INT_GEN1	(0x00)	/** INT_GEN1_REG default value */
+#define REG_DEF_INT_GEN2	(0x00)	/** INT_GEN2_REG default value */
+#define REG_DEF_IIG1_DURATION	(0x00)	/** INT_GEN1_DUR default value */
+#define REG_DEF_IIG2_DURATION	(0x00)	/** INT_GEN2_DUR default value */
+#define REG_DEF_IIG1_THRESHOLD	(0x00)	/** INT_GEN1_THS default value */
+#define REG_DEF_IIG2_THRESHOLD	(0x00)	/** INT_GEN2_THS default value */
+#define REG_DEF_MIG_THRESHOLD_L	(0x00)	/** INT_THS_L_M default value */
+#define REG_DEF_MIG_THRESHOLD_H	(0x00)	/** INT_THS_H_M default value */
+
+#define REG_DEF_ALL_ZEROS	(0x00)
+
+/* Accelerometer Filter */
+#define LSM303D_ACC_FILTER_MASK	(0xC0)	/* Mask for filter band change on acc */
+#define FILTER_773		773	/* Anti-Aliasing 773 Hz */
+#define FILTER_362		362	/* Anti-Aliasing 362 Hz */
+#define FILTER_194		194	/* Anti-Aliasing 194 Hz */
+#define FILTER_50		50	/* Anti-Aliasing 50 Hz */
+
+/* Temperature */
+#define TEMP_MASK		(0x80)	/* Mask for temperature change */
+#define TEMP_ON			(0x80)	/* Enable temperature */
+#define TEMP_OFF		(0x00)	/* Disable temperature */
+#define TEMP_SENSITIVITY	8	/* Sensitivity temperature */
+#define OFFSET_TEMP		25	/* Offset temperature */
+#define NDTEMP			1000	/* Not Available temperature */
+
+/* Interrupt */
+#define GEN1_PIN1_MASK		(0x20)
+#define GEN1_PIN2_MASK		(0x40)
+#define GEN2_PIN1_MASK		(0x10)
+#define GEN2_PIN2_MASK		(0x20)
+#define GEN_MAG_PIN1_MASK	(0x08)
+#define GEN_MAG_PIN2_MASK	(0x10)
+#define GEN_MAG_EN_MASK		(0x01)
+#define MAX_DUR_TH		127
+#define MAX_TH_MAG		131071
+#define GEN_X_HIGH_MASK		(0x02)
+#define GEN_X_LOW_MASK		(0x01)
+#define GEN_Y_HIGH_MASK		(0x08)
+#define GEN_Y_LOW_MASK		(0x04)
+#define GEN_Z_HIGH_MASK		(0x20)
+#define GEN_Z_LOW_MASK		(0x10)
+#define GEN_X_MAG_MASK		(0x80)
+#define GEN_Y_MAG_MASK		(0x40)
+#define GEN_Z_MAG_MASK		(0x20)
+
+#define GEN1_AND_OR_MASK	(0x80)
+#define GEN2_AND_OR_MASK	(0x83)
+
+#define INT_PIN_CONF_MASK	(0x10)
+#define INT_POLARITY_MASK	(0x80)
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+
+static struct kobject *acc_kobj;
+static struct kobject *mag_kobj;
+
+static struct workqueue_struct *lsm303d_workqueue;
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm303d_acc_odr_table[] = {
+		{   1, LSM303D_ACC_ODR800  },
+		{   2, LSM303D_ACC_ODR400  },
+		{   5, LSM303D_ACC_ODR200  },
+		{  10, LSM303D_ACC_ODR100  },
+		{  20, LSM303D_ACC_ODR50   },
+		{  40, LSM303D_ACC_ODR25   },
+		{  80, LSM303D_ACC_ODR12_5 },
+		{ 160, LSM303D_ACC_ODR6_25 },
+		{ 320, LSM303D_ACC_ODR3_125},
+};
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm303d_mag_odr_table[] = {
+		{  10, LSM303D_MAG_ODR100  },
+		{  20, LSM303D_MAG_ODR50   },
+		{  40, LSM303D_MAG_ODR25   },
+		{  80, LSM303D_MAG_ODR12_5 },
+		{ 160, LSM303D_MAG_ODR6_25 },
+		{ 320, LSM303D_MAG_ODR3_125},
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	u8 address;
+	u8 mask;
+};
+
+struct interrupt_value {
+	int value;
+	u8 address;
+};
+
+struct lsm303d_interrupt {
+	struct interrupt_enable gen1_pin1;
+	struct interrupt_enable gen1_pin2;
+	struct interrupt_enable gen2_pin1;
+	struct interrupt_enable gen2_pin2;
+	struct interrupt_value gen1_threshold;
+	struct interrupt_value gen2_threshold;
+	struct interrupt_value gen1_duration;
+	struct interrupt_value gen2_duration;
+	struct interrupt_enable gen_mag_pin1;
+	struct interrupt_enable gen_mag_pin2;
+	struct interrupt_enable gen_mag;
+	struct interrupt_value gen_mag_threshold;
+	struct interrupt_enable gen1_axis[6];
+	struct interrupt_enable gen2_axis[6];
+	struct interrupt_enable gen_mag_axis[3];
+	struct interrupt_enable gen1_and_or;
+	struct interrupt_enable gen2_and_or;
+	struct interrupt_enable interrupt_pin_conf;
+	struct interrupt_enable interrupt_polarity;
+};
+
+static const struct lsm303d_acc_platform_data default_lsm303d_acc_pdata = {
+	.fs_range = LSM303D_ACC_FS_2G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+	.poll_interval = 100,
+	.min_interval = LSM303D_ACC_MIN_POLL_PERIOD_MS,
+	.aa_filter_bandwidth = ANTI_ALIASING_773,
+	.gpio_int1 = DEFAULT_INT1_GPIO,
+	.gpio_int2 = DEFAULT_INT2_GPIO,
+};
+
+static const struct lsm303d_mag_platform_data default_lsm303d_mag_pdata = {
+	.poll_interval = 100,
+	.min_interval = LSM303D_MAG_MIN_POLL_PERIOD_MS,
+	.fs_range = LSM303D_MAG_FS_2G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+};
+
+struct reg_rw {
+	u8 address;
+	u8 default_value;
+	u8 resume_value;
+};
+
+struct reg_r {
+	u8 address;
+	u8 value;
+};
+
+static struct status_registers {
+	struct reg_r who_am_i;
+	struct reg_rw cntrl0;
+	struct reg_rw cntrl1;
+	struct reg_rw cntrl2;
+	struct reg_rw cntrl3;
+	struct reg_rw cntrl4;
+	struct reg_rw cntrl5;
+	struct reg_rw cntrl6;
+	struct reg_rw cntrl7;
+	struct reg_rw int_ctrl_reg_m;
+	struct reg_rw int_mag_threshold_low;
+	struct reg_rw int_mag_threshold_high;
+	struct reg_rw int_gen1_reg;
+	struct reg_rw int_gen2_reg;
+	struct reg_rw int_gen1_duration;
+	struct reg_rw int_gen2_duration;
+	struct reg_rw int_gen1_threshold;
+	struct reg_rw int_gen2_threshold;
+	struct reg_r int_src_reg_m;
+	struct reg_r int_gen1_src;
+	struct reg_r int_gen2_src;
+	struct reg_r int_gen_mag_src;
+} status_registers = {
+	.who_am_i.address=REG_WHOAMI_ADDR, .who_am_i.value=WHOIAM_VALUE,
+	.cntrl0.address=REG_CNTRL0_ADDR, .cntrl0.default_value=REG_DEF_CNTRL0,
+	.cntrl1.address=REG_CNTRL1_ADDR, .cntrl1.default_value=REG_DEF_CNTRL1,
+	.cntrl2.address=REG_CNTRL2_ADDR, .cntrl2.default_value=REG_DEF_CNTRL2,
+	.cntrl3.address=REG_CNTRL3_ADDR, .cntrl3.default_value=REG_DEF_CNTRL3,
+	.cntrl4.address=REG_CNTRL4_ADDR, .cntrl4.default_value=REG_DEF_CNTRL4,
+	.cntrl5.address=REG_CNTRL5_ADDR, .cntrl5.default_value=REG_DEF_CNTRL5,
+	.cntrl6.address=REG_CNTRL6_ADDR, .cntrl6.default_value=REG_DEF_CNTRL6,
+	.cntrl7.address=REG_CNTRL7_ADDR, .cntrl7.default_value=REG_DEF_CNTRL7,
+	.int_ctrl_reg_m.address=REG_GEN_MAG_ADDR, 
+		.int_ctrl_reg_m.default_value=REG_DEF_INT_CNTRL_MAG,
+	.int_mag_threshold_low.address=REG_GEN_MAG_THR_ADDR,
+		.int_mag_threshold_low.default_value=REG_DEF_MIG_THRESHOLD_L,
+	.int_mag_threshold_low.address=MIG_THRESHOLD_ADDR_H,
+		.int_mag_threshold_low.default_value=REG_DEF_MIG_THRESHOLD_H,
+	.int_gen1_reg.address=REG_GEN1_AXIS_ADDR, 
+		.int_gen1_reg.default_value=REG_DEF_INT_GEN1,
+	.int_gen2_reg.address=REG_GEN2_AXIS_ADDR, 
+		.int_gen2_reg.default_value=REG_DEF_INT_GEN2,
+	.int_gen1_duration.address=REG_GEN1_DUR_ADDR,
+		.int_gen1_duration.default_value=REG_DEF_IIG1_DURATION,
+	.int_gen2_duration.address=REG_GEN2_DUR_ADDR,
+		.int_gen2_duration.default_value=REG_DEF_IIG2_DURATION,
+	.int_gen1_threshold.address=REG_GEN1_THR_ADDR,
+		.int_gen1_threshold.default_value=REG_DEF_IIG1_THRESHOLD,
+	.int_gen2_threshold.address=REG_GEN2_THR_ADDR,
+		.int_gen2_threshold.default_value=REG_DEF_IIG2_THRESHOLD,
+	.int_src_reg_m.address = INT_SRC_REG_M_ADDR,
+				.int_src_reg_m.value = REG_DEF_ALL_ZEROS,
+	.int_gen1_src.address = INT_GEN1_SRC_ADDR,
+				.int_gen1_src.value = REG_DEF_ALL_ZEROS,
+	.int_gen2_src.address = INT_GEN2_SRC_ADDR,
+				.int_gen2_src.value = REG_DEF_ALL_ZEROS,
+	.int_gen_mag_src.address = INT_SRC_REG_M_ADDR,
+				.int_gen_mag_src.value = REG_DEF_ALL_ZEROS,
+};
+
+static int lsm303d_write_data_with_mask(struct lsm303d_dev *dev,
+					u8 addr, u8 mask, u8 data)
+{
+	int err;
+	u8 old_data, new_data;
+
+	err = dev->tf->read(dev->dev, addr, 1, &old_data);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & ~mask) | (data & mask));
+	if (old_data == new_data)
+		return new_data;
+
+	err = dev->tf->write(dev->dev, addr, 1, &new_data);
+	if (err < 0)
+		return err;
+
+	return new_data;
+}
+
+static int lsm303d_hw_init(struct lsm303d_status *stat)
+{
+	int i, err = -1;
+	u8 buf[1];
+	struct lsm303d_dev *dev = stat->dev;
+
+	err = dev->tf->read(dev->dev, status_registers.who_am_i.address,
+			    1, buf);
+	if (err < 0) {
+		dev_warn(stat->dev->dev, "Error reading WHO_AM_I: is device"
+		" available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+
+	if (buf[0] != status_registers.who_am_i.value) {
+		dev_err(stat->dev->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", status_registers.who_am_i.value,
+			buf[0]);
+		err = -1;
+		goto err_unknown_device;
+	}
+
+	status_registers.cntrl1.resume_value = 
+					status_registers.cntrl1.default_value;
+	status_registers.cntrl2.resume_value = 
+					status_registers.cntrl2.default_value;
+	status_registers.cntrl3.resume_value = 
+					status_registers.cntrl3.default_value;
+	status_registers.cntrl4.resume_value = 
+					status_registers.cntrl4.default_value;
+	status_registers.cntrl5.resume_value = 
+					status_registers.cntrl5.default_value;
+	status_registers.cntrl6.resume_value = 
+					status_registers.cntrl6.default_value;
+	status_registers.cntrl7.resume_value = 
+					status_registers.cntrl7.default_value;
+
+	status_registers.int_ctrl_reg_m.resume_value = 
+			status_registers.int_ctrl_reg_m.default_value;
+	status_registers.int_mag_threshold_low.resume_value = 
+			status_registers.int_mag_threshold_low.default_value;
+	status_registers.int_mag_threshold_high.resume_value = 
+			status_registers.int_mag_threshold_high.default_value;
+	status_registers.int_gen1_reg.resume_value = 
+			status_registers.int_gen1_reg.default_value;
+	status_registers.int_gen2_reg.resume_value = 
+			status_registers.int_gen2_reg.default_value;
+	status_registers.int_gen1_duration.resume_value = 
+			status_registers.int_gen1_duration.default_value;
+	status_registers.int_gen2_duration.resume_value = 
+			status_registers.int_gen2_duration.default_value;
+	status_registers.int_gen1_threshold.resume_value = 
+			status_registers.int_gen1_threshold.default_value;
+	status_registers.int_gen2_threshold.resume_value = 
+			status_registers.int_gen2_threshold.default_value;
+
+
+	stat->temp_value_dec = NDTEMP;
+
+	if((stat->pdata_acc->gpio_int1 >= 0) || 
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+
+		stat->interrupt = kmalloc(sizeof(*stat->interrupt), 
+								GFP_KERNEL);
+
+		if(stat->interrupt == NULL)
+			goto error_interrupt;
+
+		stat->interrupt->gen1_pin1.address = REG_CNTRL3_ADDR;
+		stat->interrupt->gen1_pin2.address = REG_CNTRL4_ADDR;
+		stat->interrupt->gen2_pin1.address = REG_CNTRL3_ADDR;
+		stat->interrupt->gen2_pin2.address = REG_CNTRL4_ADDR;
+		stat->interrupt->gen_mag_pin1.address = REG_CNTRL3_ADDR;
+		stat->interrupt->gen_mag_pin2.address = REG_CNTRL4_ADDR;
+		stat->interrupt->gen_mag.address = REG_GEN_MAG_ADDR;
+		stat->interrupt->gen1_duration.address = REG_GEN1_DUR_ADDR;
+		stat->interrupt->gen2_duration.address = REG_GEN2_DUR_ADDR;
+		stat->interrupt->gen1_threshold.address = REG_GEN1_THR_ADDR;
+		stat->interrupt->gen2_threshold.address = REG_GEN2_THR_ADDR;
+		stat->interrupt->gen_mag_threshold.address = 
+							REG_GEN_MAG_THR_ADDR;
+
+		stat->interrupt->gen1_pin1.mask = GEN1_PIN1_MASK;
+		stat->interrupt->gen1_pin2.mask = GEN1_PIN2_MASK;
+		stat->interrupt->gen2_pin1.mask = GEN2_PIN1_MASK;
+		stat->interrupt->gen2_pin2.mask = GEN2_PIN2_MASK;
+		stat->interrupt->gen_mag_pin1.mask = GEN_MAG_PIN1_MASK;
+		stat->interrupt->gen_mag_pin2.mask = GEN_MAG_PIN2_MASK;
+		stat->interrupt->gen_mag.mask = GEN_MAG_EN_MASK;
+
+		atomic_set(&stat->interrupt->gen1_pin1.enable, 0);
+		atomic_set(&stat->interrupt->gen1_pin2.enable, 0);
+		atomic_set(&stat->interrupt->gen2_pin1.enable, 0);
+		atomic_set(&stat->interrupt->gen2_pin2.enable, 0);
+		atomic_set(&stat->interrupt->gen_mag_pin1.enable, 0);
+		atomic_set(&stat->interrupt->gen_mag_pin2.enable, 0);
+		atomic_set(&stat->interrupt->gen_mag.enable, 0);
+
+		stat->interrupt->gen1_threshold.value = 0;
+		stat->interrupt->gen2_threshold.value = 0;
+		stat->interrupt->gen1_duration.value = 0;
+		stat->interrupt->gen2_duration.value = 0;
+		stat->interrupt->gen_mag_threshold.value = 0;
+
+		for(i=0; i<6; i++) {
+			stat->interrupt->gen1_axis[i].address = 
+							REG_GEN1_AXIS_ADDR;
+			stat->interrupt->gen2_axis[i].address = 
+							REG_GEN2_AXIS_ADDR;
+
+			atomic_set(&stat->interrupt->gen1_axis[i].enable, 0);
+			atomic_set(&stat->interrupt->gen2_axis[i].enable, 0);
+		}
+		for(i=0; i<3; i++) {
+			stat->interrupt->gen_mag_axis[i].address = 
+							REG_GEN_MAG_ADDR;
+			atomic_set(&stat->interrupt->gen_mag_axis[i].enable, 0);
+		}
+
+		stat->interrupt->gen1_axis[0].mask = GEN_X_LOW_MASK;
+		stat->interrupt->gen1_axis[1].mask = GEN_Y_LOW_MASK;
+		stat->interrupt->gen1_axis[2].mask = GEN_Z_LOW_MASK;
+		stat->interrupt->gen1_axis[3].mask = GEN_X_HIGH_MASK;
+		stat->interrupt->gen1_axis[4].mask = GEN_Y_HIGH_MASK;
+		stat->interrupt->gen1_axis[5].mask = GEN_Z_HIGH_MASK;
+
+		stat->interrupt->gen2_axis[0].mask = GEN_X_LOW_MASK;
+		stat->interrupt->gen2_axis[1].mask = GEN_Y_LOW_MASK;
+		stat->interrupt->gen2_axis[2].mask = GEN_Z_LOW_MASK;
+		stat->interrupt->gen2_axis[3].mask = GEN_X_HIGH_MASK;
+		stat->interrupt->gen2_axis[4].mask = GEN_Y_HIGH_MASK;
+		stat->interrupt->gen2_axis[5].mask = GEN_Z_HIGH_MASK;
+
+		stat->interrupt->gen_mag_axis[0].mask = GEN_X_MAG_MASK;
+		stat->interrupt->gen_mag_axis[1].mask = GEN_Y_MAG_MASK;
+		stat->interrupt->gen_mag_axis[2].mask = GEN_Z_MAG_MASK;
+
+		stat->interrupt->gen1_and_or.address = REG_GEN1_AXIS_ADDR;
+		stat->interrupt->gen1_and_or.mask = GEN1_AND_OR_MASK;
+		atomic_set(&stat->interrupt->gen1_and_or.enable, 0);
+		stat->interrupt->gen2_and_or.address = REG_GEN1_DUR_ADDR;
+		stat->interrupt->gen2_and_or.mask = GEN2_AND_OR_MASK;
+		atomic_set(&stat->interrupt->gen2_and_or.enable, 0);
+
+		stat->interrupt->interrupt_pin_conf.address = REG_GEN_MAG_ADDR;
+		stat->interrupt->interrupt_pin_conf.mask = INT_PIN_CONF_MASK;
+		atomic_set(&stat->interrupt->interrupt_pin_conf.enable, 0);
+
+		stat->interrupt->interrupt_polarity.address = REG_GEN_MAG_ADDR;
+		stat->interrupt->interrupt_polarity.mask = INT_POLARITY_MASK;
+		atomic_set(&stat->interrupt->interrupt_polarity.enable, 0);
+	}
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LSM303D_DEV_NAME);
+
+	return 0;
+
+error_interrupt:
+err_unknown_device:
+err_firstread:
+	stat->hw_working = 0;
+	stat->hw_initialized = 0;
+	return err;
+}
+
+static irqreturn_t lsm303d_isr1(int irq, void *dev)
+{
+	struct lsm303d_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", LSM303D_DEV_NAME);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lsm303d_isr2(int irq, void *dev)
+{
+	struct lsm303d_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", LSM303D_DEV_NAME);
+	return IRQ_HANDLED;
+}
+
+static void lsm303d_interrupt_catch(struct lsm303d_status *stat, int pin) 
+{
+	u8 buf[1];
+	struct lsm303d_dev *dev = stat->dev;
+
+	mutex_lock(&stat->lock);
+	if (atomic_read(&stat->interrupt->gen1_pin1.enable) == 1) {
+		if (dev->tf->read(dev->dev,
+				  status_registers.int_gen1_src.address,
+				  1, buf) < 0) {
+			mutex_unlock(&stat->lock);
+			return;
+		}
+		status_registers.int_gen1_src.value = buf[0];
+
+		if(((int)status_registers.int_gen1_src.value) > 64)
+			pr_info("interrupt send by accelerometer interrupt "
+							"generator 1\n");
+	}
+	if (atomic_read(&stat->interrupt->gen_mag_pin1.enable) == 1) {
+		if (dev->tf->read(dev->dev,
+				  status_registers.int_gen_mag_src.address,
+				  1, buf) < 0) {
+			mutex_unlock(&stat->lock);
+			return;
+		}
+		status_registers.int_gen_mag_src.value = buf[0];
+
+		if(((int)status_registers.int_gen_mag_src.value) > 1)
+			pr_info("interrupt send by magnetometer interrupt "
+								"generator\n");
+	}
+	mutex_unlock(&stat->lock);
+}
+
+static void lsm303d_irq1_work_func(struct work_struct *work)
+{
+
+	struct lsm303d_status *stat =
+	container_of(work, struct lsm303d_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303d_get_int1_source(stat); */
+	
+	lsm303d_interrupt_catch(stat,1);
+	pr_info("%s: IRQ1 triggered\n", LSM303D_DEV_NAME);
+
+	enable_irq(stat->irq1);
+}
+
+static void lsm303d_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm303d_status *stat =
+	container_of(work, struct lsm303d_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303d_get_int2_source(stat); */
+	
+	lsm303d_interrupt_catch(stat,2);
+	pr_info("%s: IRQ2 triggered\n", LSM303D_DEV_NAME);
+
+	enable_irq(stat->irq2);
+}
+
+static int lsm303d_acc_device_power_off(struct lsm303d_status *stat)
+{
+	int err;
+	u8 data;
+	struct lsm303d_dev *dev = stat->dev;
+
+	data = (ODR_ACC_MASK & LSM303D_ACC_ODR_OFF) |
+	       (~ODR_ACC_MASK & status_registers.cntrl1.resume_value);
+	err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 1,
+			     &data);
+	if (err < 0)
+		dev_err(stat->dev->dev,
+			"acc soft power off failed: %d\n", err);
+
+	if (stat->pdata_acc->power_off)
+		stat->pdata_acc->power_off();
+	
+	atomic_set(&stat->enabled_acc, 0);
+
+	return 0;
+}
+
+static int lsm303d_mag_device_power_off(struct lsm303d_status *stat)
+{
+	int err;
+	u8 data;
+	struct lsm303d_dev *dev = stat->dev;
+
+	data = (MSMS_MASK & POWEROFF_MAG) |
+	       (~MSMS_MASK & status_registers.cntrl7.resume_value);
+	err = dev->tf->write(dev->dev, status_registers.cntrl7.address, 1,
+			     &data);
+	if (err < 0)
+		dev_err(stat->dev->dev,
+			"magn soft power off failed: %d\n", err);
+
+	if (stat->pdata_mag->power_off)
+		stat->pdata_mag->power_off();
+
+	atomic_set(&stat->enabled_mag, 0);
+
+	return 0;
+}
+
+static int lsm303d_acc_device_power_on(struct lsm303d_status *stat)
+{
+	int err;
+	u8 buf[4];
+	struct lsm303d_dev *dev = stat->dev;
+
+	if (stat->pdata_acc->power_on) {
+		err = stat->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(stat->dev->dev,
+				"accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.cntrl0.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl0.address, 1,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+			     
+	buf[0] = status_registers.cntrl1.resume_value;
+	buf[1] = status_registers.cntrl2.resume_value;
+	buf[2] = status_registers.cntrl3.resume_value;
+	buf[3] = status_registers.cntrl4.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 4,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen1_reg.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_gen1_reg.address, 1,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen1_threshold.resume_value;
+	buf[1] = status_registers.int_gen1_duration.resume_value;
+	err = dev->tf->write(dev->dev,
+			status_registers.int_gen1_threshold.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen2_reg.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_gen2_reg.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen2_threshold.resume_value;
+	buf[1] = status_registers.int_gen2_duration.resume_value;
+	err = dev->tf->write(dev->dev,
+			     status_registers.int_gen2_threshold.address,
+			     2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&stat->enabled_acc, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&stat->enabled_acc, 0);
+	dev_err(stat->dev->dev, "acc hw power on error: %d\n", err);
+	return err;
+}
+
+static int lsm303d_mag_device_power_on(struct lsm303d_status *stat)
+{
+	int err;
+	u8 buf[6];
+	struct lsm303d_dev *dev = stat->dev;
+
+	if (stat->pdata_mag->power_on) {
+		err = stat->pdata_mag->power_on();
+		if (err < 0) {
+			dev_err(stat->dev->dev,
+				"magnetometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+	
+	buf[0] = status_registers.cntrl0.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl0.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.cntrl3.resume_value;
+	buf[1] = status_registers.cntrl4.resume_value;
+	buf[2] = status_registers.cntrl5.resume_value;
+	buf[3] = status_registers.cntrl6.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl3.address,
+			     4, buf);
+	if (err < 0)
+		goto err_resume_state;	
+
+	buf[0] = status_registers.int_ctrl_reg_m.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_ctrl_reg_m.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_mag_threshold_low.resume_value;
+	buf[1] = status_registers.int_mag_threshold_high.resume_value;
+	err = dev->tf->write(dev->dev,
+			     status_registers.int_mag_threshold_low.address,
+			     2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = (MSMS_MASK & CONTINUOS_CONVERSION) |
+		 (~MSMS_MASK & status_registers.cntrl7.resume_value);
+	err = dev->tf->write(dev->dev, status_registers.cntrl7.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&stat->enabled_mag, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&stat->enabled_mag, 0);
+	dev_err(stat->dev->dev, "magnetometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm303d_acc_update_filter(struct lsm303d_status *stat,
+				     u8 new_bandwidth)
+{
+	int val;
+	struct lsm303d_dev *dev = stat->dev;
+
+	switch (new_bandwidth) {
+	case ANTI_ALIASING_50:
+	case ANTI_ALIASING_194:
+	case ANTI_ALIASING_362:
+	case ANTI_ALIASING_773:
+		break;
+	default:
+		dev_err(stat->dev->dev, "invalid accelerometer "
+			"update bandwidth requested: %u\n", new_bandwidth);
+		return -EINVAL;
+	}
+
+	val = lsm303d_write_data_with_mask(dev, status_registers.cntrl2.address,
+					   LSM303D_ACC_FILTER_MASK,
+					   new_bandwidth);
+	if (val < 0)
+		goto error;
+	status_registers.cntrl2.resume_value = (u8)val;
+
+	return 0;
+	
+error:
+	dev_err(stat->dev->dev, "update acc fs range failed: %d\n", val);
+	return val;
+}
+
+static int lsm303d_acc_update_fs_range(struct lsm303d_status *stat,
+				       u8 new_fs_range)
+{
+	int val;
+	u16 sensitivity;
+	struct lsm303d_dev *dev = stat->dev;
+
+	switch (new_fs_range) {
+	case LSM303D_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case LSM303D_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case LSM303D_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	case LSM303D_ACC_FS_16G:
+		sensitivity = SENSITIVITY_ACC_16G;
+		break;
+	default:
+		dev_err(stat->dev->dev, "invalid accelerometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	val = lsm303d_write_data_with_mask(dev,
+					   status_registers.cntrl2.address,
+					   LSM303D_ACC_FS_MASK,
+					   new_fs_range);
+	if (val < 0)
+		goto error;
+
+	status_registers.cntrl2.resume_value = (u8)val;
+	stat->sensitivity_acc = sensitivity;
+
+	return 0;
+	
+error:
+	dev_err(stat->dev->dev, "update acc fs range failed: %d\n", val);
+	return val;
+}
+
+static int lsm303d_mag_update_fs_range(struct lsm303d_status *stat,
+				       u8 new_fs_range)
+{
+	int val;
+	u16 sensitivity;
+	struct lsm303d_dev *dev = stat->dev;
+
+	switch (new_fs_range) {
+	case LSM303D_MAG_FS_2G:
+		sensitivity = SENSITIVITY_MAG_2G;
+		break;
+	case LSM303D_MAG_FS_4G:
+		sensitivity = SENSITIVITY_MAG_4G;
+		break;
+	case LSM303D_MAG_FS_8G:
+		sensitivity = SENSITIVITY_MAG_8G;
+		break;
+	case LSM303D_MAG_FS_12G:
+		sensitivity = SENSITIVITY_MAG_12G;
+		break;
+	default:
+		dev_err(stat->dev->dev, "invalid magnetometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	val = lsm303d_write_data_with_mask(dev,
+					   status_registers.cntrl6.address,
+					   LSM303D_MAG_FS_MASK,
+					   new_fs_range);
+	if (val < 0)
+		goto error;
+
+	status_registers.cntrl6.resume_value = (u8)val;
+	stat->sensitivity_mag = sensitivity;
+
+	return 0;
+	
+error:
+	dev_err(stat->dev->dev, "update magn fs range failed: %d\n", val);
+	return val;
+}
+
+static int lsm303d_acc_update_odr(struct lsm303d_status *stat,
+				  unsigned int poll_interval_ms)
+{
+	int err = -1;
+
+	if (atomic_read(&stat->enabled_acc)) {
+		int i;
+		u8 data;
+		struct lsm303d_dev *dev = stat->dev;
+
+		for (i = ARRAY_SIZE(lsm303d_acc_odr_table) - 1; i >= 0; i--) {
+			if ((lsm303d_acc_odr_table[i].cutoff_us <=
+			     poll_interval_ms) || (i == 0))
+				break;
+		}
+
+		data = ((ODR_ACC_MASK & lsm303d_acc_odr_table[i].value) |
+			(~ODR_ACC_MASK & status_registers.cntrl1.resume_value));
+
+		err = dev->tf->write(dev->dev, status_registers.cntrl1.address,
+				     1, &data);
+		if (err < 0)
+			goto error;
+
+		status_registers.cntrl1.resume_value = data;
+		stat->ktime_acc = ktime_set(0, MS_TO_NS(poll_interval_ms));
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev->dev, "update acc odr failed: %d\n", err);
+
+	return err;
+}
+
+static int lsm303d_mag_update_odr(struct lsm303d_status *stat,
+				  unsigned int poll_interval_ms)
+{
+	int err = -1;
+
+	if (atomic_read(&stat->enabled_mag)) {
+		int i;
+		u8 data;
+		struct lsm303d_dev *dev = stat->dev;
+
+		for (i = ARRAY_SIZE(lsm303d_mag_odr_table) - 1; i >= 0; i--) {
+			if ((lsm303d_mag_odr_table[i].cutoff_us <=
+			     poll_interval_ms) || (i == 0))
+				break;
+		}
+
+		data = ((ODR_MAG_MASK & lsm303d_mag_odr_table[i].value) | 
+			(~ODR_MAG_MASK & status_registers.cntrl5.resume_value));
+
+		err = dev->tf->write(dev->dev, status_registers.cntrl5.address,
+				     1, &data);
+		if (err < 0)
+			goto error;
+		status_registers.cntrl5.resume_value = data;
+		stat->ktime_mag = ktime_set(0, MS_TO_NS(poll_interval_ms));
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev->dev, "update magn odr failed: %d\n", err);
+
+	return err;
+}
+
+static void lsm303d_validate_polling(unsigned int *min_interval,
+				     unsigned int *poll_interval,
+				     unsigned int min)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int lsm303d_acc_validate_pdata(struct lsm303d_status *stat)
+{
+	int res = -EINVAL;
+
+	lsm303d_validate_polling(&stat->pdata_acc->min_interval,
+				&stat->pdata_acc->poll_interval,
+				(unsigned int)LSM303D_ACC_MIN_POLL_PERIOD_MS);
+
+	switch (stat->pdata_acc->aa_filter_bandwidth) {
+		case ANTI_ALIASING_50:
+			res = 1;
+			break;
+		case ANTI_ALIASING_194:
+			res = 1;
+			break;
+		case ANTI_ALIASING_362:
+			res = 1;
+			break;
+		case ANTI_ALIASING_773:
+			res = 1;
+			break;
+		default:
+			dev_err(stat->dev->dev, "invalid accelerometer "
+				"bandwidth selected: %u\n", 
+				stat->pdata_acc->aa_filter_bandwidth);
+	}
+
+	return res;
+}
+
+static int lsm303d_mag_validate_pdata(struct lsm303d_status *stat)
+{
+	lsm303d_validate_polling(&stat->pdata_mag->min_interval,
+				&stat->pdata_mag->poll_interval,
+				(unsigned int)LSM303D_MAG_MIN_POLL_PERIOD_MS);
+
+	return 0;
+}
+
+static int lsm303d_acc_enable(struct lsm303d_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled_acc, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = lsm303d_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_acc, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+		hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc,
+			      HRTIMER_MODE_REL);
+
+		if (!atomic_read(&stat->enabled_mag)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				enable_irq(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				enable_irq(stat->irq2);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+
+static int lsm303d_acc_disable(struct lsm303d_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_acc, 1, 0)) {
+		cancel_work_sync(&stat->input_work_acc);
+		hrtimer_cancel(&stat->hr_timer_acc);
+
+		mutex_lock(&stat->lock);
+		lsm303d_acc_device_power_off(stat);
+		if(!atomic_read(&stat->enabled_mag)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				disable_irq_nosync(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				disable_irq_nosync(stat->irq2);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+
+static int lsm303d_mag_enable(struct lsm303d_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled_mag, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = lsm303d_mag_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_mag, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+
+		if (!atomic_read(&stat->enabled_temp))
+			hrtimer_start(&stat->hr_timer_mag, stat->ktime_mag,
+				      HRTIMER_MODE_REL);
+		if (!atomic_read(&stat->enabled_acc)) {
+			if (stat->pdata_acc->gpio_int1 >= 0)
+				enable_irq(stat->irq1);
+			if (stat->pdata_acc->gpio_int2 >= 0)
+				enable_irq(stat->irq2);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+
+static int lsm303d_mag_disable(struct lsm303d_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_mag, 1, 0)) {
+		if(!atomic_read(&stat->enabled_temp)) {
+			cancel_work_sync(&stat->input_work_mag);
+			hrtimer_cancel(&stat->hr_timer_mag);
+		}
+		mutex_lock(&stat->lock);
+		lsm303d_mag_device_power_off(stat);
+		if(!atomic_read(&stat->enabled_acc)) {
+			if(stat->pdata_acc->gpio_int1 >= 0)
+				disable_irq(stat->irq1);
+			if(stat->pdata_acc->gpio_int2 >= 0)
+				disable_irq(stat->irq2);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+
+static int lsm303d_temperature_enable(struct lsm303d_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled_temp, 0, 1)) {
+		int val;
+		struct lsm303d_dev *dev = stat->dev;
+
+		mutex_lock(&stat->lock);
+		val = lsm303d_write_data_with_mask(dev,
+				status_registers.cntrl5.address,
+				TEMP_MASK, TEMP_ON);
+		if (val < 0) {
+			mutex_unlock(&stat->lock);
+			return val;
+		}
+		mutex_unlock(&stat->lock);
+
+		status_registers.cntrl5.resume_value = (u8)val;
+		if (!atomic_read(&stat->enabled_mag))
+			hrtimer_start(&stat->hr_timer_mag, stat->ktime_mag,
+				      HRTIMER_MODE_REL);
+	}
+	return 0;
+}
+
+static int lsm303d_temperature_disable(struct lsm303d_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_mag, 1, 0)) {
+		int val;
+		struct lsm303d_dev *dev = stat->dev;
+
+		mutex_lock(&stat->lock);
+		val = lsm303d_write_data_with_mask(dev,
+				status_registers.cntrl5.address,
+				TEMP_MASK, TEMP_OFF);
+		if (val < 0) {
+			mutex_unlock(&stat->lock);
+			return val;
+		}
+		mutex_unlock(&stat->lock);
+
+		status_registers.cntrl5.resume_value = (u8)val;
+
+		if(!atomic_read(&stat->enabled_mag)) {
+			cancel_work_sync(&stat->input_work_mag);
+			hrtimer_cancel(&stat->hr_timer_mag);
+		}
+		stat->temp_value_dec = NDTEMP;
+	}
+	return 0;
+}
+
+int lsm303d_enable(struct lsm303d_dev *dev)
+{
+	int err;
+
+	err = lsm303d_acc_enable(&dev->st);
+	if (err < 0)
+		return err;
+
+	err = lsm303d_mag_enable(&dev->st);
+	if (err < 0)
+		return err;
+
+	err = lsm303d_temperature_enable(&dev->st);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303d_enable);
+
+int lsm303d_disable(struct lsm303d_dev *dev)
+{
+	int err;
+
+	err = lsm303d_acc_disable(&dev->st);
+	if (err < 0)
+		return err;
+
+	err = lsm303d_mag_disable(&dev->st);
+	if (err < 0)
+		return err;
+
+	err = lsm303d_temperature_disable(&dev->st);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303d_disable);
+
+static void lsm303d_acc_input_cleanup(struct lsm303d_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+}
+
+static void lsm303d_mag_input_cleanup(struct lsm303d_status *stat)
+{
+	input_unregister_device(stat->input_dev_mag);
+	input_free_device(stat->input_dev_mag);
+}
+
+static ssize_t attr_get_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_get_polling_rate_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata_mag->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+						stat->pdata_acc->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata_acc->poll_interval = (unsigned int)interval_ms;
+	lsm303d_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_set_polling_rate_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+						stat->pdata_mag->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata_mag->poll_interval = (unsigned int)interval_ms;
+	lsm303d_mag_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_get_enable_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	int val = (int)atomic_read(&stat->enabled_acc);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_get_enable_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	int val = (int)atomic_read(&stat->enabled_mag);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303d_acc_enable(stat);
+	else
+		lsm303d_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_enable_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303d_mag_enable(stat);
+	else
+		lsm303d_mag_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_get_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	u8 val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	int range = 2;
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->fs_range ;
+	switch (val) {
+	case LSM303D_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM303D_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM303D_ACC_FS_8G:
+		range = 8;
+		break;
+	case LSM303D_ACC_FS_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_get_range_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	u8 val;
+	int range = 2;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	mutex_lock(&stat->lock);
+	val = stat->pdata_mag->fs_range ;
+	switch (val) {
+	case LSM303D_MAG_FS_2G:
+		range = 2;
+		break;
+	case LSM303D_MAG_FS_4G:
+		range = 4;
+		break;
+	case LSM303D_MAG_FS_8G:
+		range = 8;
+		break;
+	case LSM303D_MAG_FS_12G:
+		range = 12;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM303D_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM303D_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM303D_ACC_FS_8G;
+		break;
+	case 16:
+		range = LSM303D_ACC_FS_16G;
+		break;
+	default:
+		dev_err(stat->dev->dev, "accelerometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303d_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata_acc->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev->dev, "accelerometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_set_range_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM303D_MAG_FS_2G;
+		break;
+	case 4:
+		range = LSM303D_MAG_FS_4G;
+		break;
+	case 8:
+		range = LSM303D_MAG_FS_8G;
+		break;
+	case 12:
+		range = LSM303D_MAG_FS_12G;
+		break;
+	default:
+		dev_err(stat->dev->dev, "magnetometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303d_mag_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata_mag->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev->dev, "magnetometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	u8 val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	int frequency=FILTER_773;
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->aa_filter_bandwidth;
+	switch (val) {
+	case ANTI_ALIASING_50:
+		frequency = FILTER_50;
+		break;
+	case ANTI_ALIASING_194:
+		frequency = FILTER_194;
+		break;
+	case ANTI_ALIASING_362:
+		frequency = FILTER_362;
+		break;
+	case ANTI_ALIASING_773:
+		frequency = FILTER_773;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", frequency);
+}
+
+static ssize_t attr_set_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	unsigned long val;
+	u8 frequency;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case FILTER_50:
+		frequency = ANTI_ALIASING_50;
+		break;
+	case FILTER_194:
+		frequency = ANTI_ALIASING_194;
+		break;
+	case FILTER_362:
+		frequency = ANTI_ALIASING_362;
+		break;
+	case FILTER_773:
+		frequency = ANTI_ALIASING_773;
+		break;
+	default:
+		dev_err(stat->dev->dev, "accelerometer invalid filter "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303d_acc_update_filter(stat, frequency);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata_acc->aa_filter_bandwidth = frequency;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev->dev, "accelerometer anti-aliasing filter "
+					"set to: %lu Hz\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_temp_enable(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	int val = (int)atomic_read(&stat->enabled_temp);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_temp_enable(struct device *device,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val > 0) {
+		lsm303d_temperature_enable(stat);
+	} else {
+		lsm303d_temperature_disable(stat);
+	}
+
+	return size;
+}
+
+static ssize_t attr_get_temp(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int dec;
+	unsigned int flo;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	dec = stat->temp_value_dec;
+	flo = stat->temp_value_flo;
+
+	if(dec==NDTEMP)
+		return sprintf(buf, "n.d.\n");
+	
+	return sprintf(buf, "%d.%u\n", dec, flo);
+}
+
+static struct kobj_attribute poll_attr_acc =
+__ATTR(pollrate_ms, 0664, attr_get_polling_rate_acc, attr_set_polling_rate_acc);
+static struct kobj_attribute enable_attr_acc =
+__ATTR(enable_device, 0664, attr_get_enable_acc, attr_set_enable_acc);
+static struct kobj_attribute fs_attr_acc = 
+__ATTR(full_scale, 0664, attr_get_range_acc, attr_set_range_acc);
+static struct kobj_attribute aa_filter_attr  =
+__ATTR(anti_aliasing_frequency, 0664, attr_get_aa_filter, attr_set_aa_filter);
+static struct kobj_attribute poll_attr_mag =
+__ATTR(pollrate_ms, 0664, attr_get_polling_rate_mag, attr_set_polling_rate_mag);
+static struct kobj_attribute enable_attr_mag =
+__ATTR(enable_device, 0664, attr_get_enable_mag, attr_set_enable_mag);
+static struct kobj_attribute fs_attr_mag =
+__ATTR(full_scale, 0664, attr_get_range_mag, attr_set_range_mag);
+
+static int write_bit_on_register(struct lsm303d_status *stat, u8 address, 
+				 u8 *resume_value, u8 mask, int value)
+{
+	int err;
+	struct lsm303d_dev *dev = stat->dev;
+	u8 data, val = 0;
+
+	mutex_lock(&stat->lock);
+	err = dev->tf->read(dev->dev, address, 1, &data);
+	if (err < 0)
+		goto unlock;
+
+	if (resume_value)
+		*resume_value = data;
+
+	if (mask == 0) {
+		data = (u8)value;
+	} else {
+		if(value > 0)
+			val = 0xff;
+		data = (mask & val) | (~mask & data);
+	}
+
+	err = dev->tf->write(dev->dev, address, 1, &data);
+	if (err < 0)
+		goto unlock;
+
+	if (resume_value)
+		*resume_value = data;
+
+unlock:
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int write_gen_int(struct lsm303d_status *stat, 
+					struct interrupt_enable *ie, int val) 
+{
+	int err;
+
+	if(val>0)
+		val = 1;
+	else
+		val = 0;
+
+	err = write_bit_on_register(stat, ie->address, NULL, ie->mask, val);
+	if(err < 0)
+		return -1;
+
+	atomic_set(&ie->enable, val);
+	return err;
+}
+
+static int write_duration_threshold_int(struct lsm303d_status *stat, 
+					struct interrupt_value *ie, int val) 
+{
+	int err;
+
+	if(val<0)
+		return -1;
+
+	if(val>MAX_DUR_TH)
+		return -1;
+
+	err = write_bit_on_register(stat, ie->address, NULL, 0, val);
+	if(err<0)
+		return -1;
+
+	ie->value = val;
+
+	return err;
+}
+
+static int write_threshold_mag_int(struct lsm303d_status *stat, 
+					struct interrupt_value *ie, int val) 
+{
+	int err;
+	u8 high;
+	u8 low;
+
+	if(val<0)
+		return -1;
+
+	if(val>MAX_TH_MAG)
+		return -1;
+
+	low = (u8)(0xff & val);
+
+	err = write_bit_on_register(stat, ie->address, NULL, 0, low);
+	if(err<0)
+		return -1;
+
+	high = (u8)(0xff & (val >> 8));
+
+	err = write_bit_on_register(stat, (ie->address)+1, NULL, 0, high);
+	if(err<0)
+		return -1;
+
+	ie->value = val;
+
+	return err;
+}
+
+static ssize_t attr_get_gen1_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen1_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen1_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen1_pin1, (int)val);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen1_pin2, (int)val);
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen2_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen2_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen2_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen2_pin1, (int)val);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(stat, 
+					&stat->interrupt->gen2_pin2, (int)val);
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen1_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = stat->interrupt->gen1_duration.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen1_duration, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen2_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = stat->interrupt->gen2_duration.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen2_duration, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen1_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = stat->interrupt->gen1_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen1_threshold, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen2_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = stat->interrupt->gen2_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(stat, 
+				&stat->interrupt->gen2_threshold, (int)val);
+	
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen_mag_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&stat->interrupt->gen_mag_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(stat, 
+				&stat->interrupt->gen_mag_pin1, (int)val);
+		if(err >= 0) {
+		if((atomic_read(&stat->interrupt->gen_mag_pin2.enable))==0)
+			write_gen_int(stat, 
+					&stat->interrupt->gen_mag, (int)val);
+		}
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(stat, 
+				&stat->interrupt->gen_mag_pin2, (int)val);
+		if(err >= 0) {
+		if((atomic_read(&stat->interrupt->gen_mag_pin1.enable))==0)
+			write_gen_int(stat, 
+					&stat->interrupt->gen_mag, (int)val);
+		}
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = stat->interrupt->gen_mag_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_threshold_mag_int(stat, 
+				&stat->interrupt->gen_mag_threshold, (int)val);
+	
+	return size;
+}
+
+static int get_axis(struct lsm303d_status *stat, 
+					int generator, const char *name) {
+
+	int val;
+	int axis;
+
+	if(strcmp(name, "x_high_enable") == 0) {
+		axis = 3;
+	}
+	if(strcmp(name, "x_low_enable") == 0) {
+		axis = 0;
+	}
+	if(strcmp(name, "y_high_enable") == 0) {
+		axis = 4;
+	}
+	if(strcmp(name, "y_low_enable") == 0) {
+		axis = 1;
+	}
+	if(strcmp(name, "z_high_enable") == 0) {
+		axis = 5;
+	}
+	if(strcmp(name, "z_low_enable") == 0) {
+		axis = 2;
+	}
+
+	if(generator == 1)
+		val = atomic_read(&stat->interrupt->gen1_axis[axis].enable);
+	else
+		val = atomic_read(&stat->interrupt->gen2_axis[axis].enable);
+
+	return val;
+}
+
+static int set_axis(struct lsm303d_status *stat, int generator, 
+					const char *name, unsigned long value) 
+{
+	int err = -1;
+	int axis;
+
+	if(strcmp(name, "x_high_enable") == 0) {
+		axis = 3;
+	}
+	if((strcmp(name, "x_low_enable") == 0) || 
+					(strcmp(name, "x_enable") == 0)) {
+		axis = 0;
+	}
+	if(strcmp(name, "y_high_enable") == 0) {
+		axis = 4;
+	}
+	if((strcmp(name, "y_low_enable") == 0) || 
+					(strcmp(name, "y_enable") == 0)) {
+		axis = 1;
+	}
+	if(strcmp(name, "z_high_enable") == 0) {
+		axis = 5;
+	}
+	if((strcmp(name, "z_low_enable") == 0) || 
+					(strcmp(name, "z_enable") == 0)) {
+		axis = 2;
+	}
+
+	if(generator == 1)
+		err = write_gen_int(stat, 
+			&(stat->interrupt->gen1_axis[axis]), (int)value);
+	if(generator == 2)
+		err = write_gen_int(stat, 
+			&(stat->interrupt->gen2_axis[axis]), (int)value);
+	if(generator == 3)
+		err = write_gen_int(stat, 
+			&(stat->interrupt->gen_mag_axis[axis]), (int)value);
+
+	if(err < 0)
+		return -1;
+
+	return err;
+}
+
+static ssize_t attr_get_gen1_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = get_axis(stat,1,attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(stat, 1, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = get_axis(stat,2,attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(stat, 2, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = get_axis(stat, 3, attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(stat, 3, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen1_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = atomic_read(&stat->interrupt->gen1_and_or.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, &(stat->interrupt->gen1_and_or), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = atomic_read(&stat->interrupt->gen2_and_or.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, &(stat->interrupt->gen2_and_or), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_set_pin_conf(struct device *device,
+						struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, 
+			&(stat->interrupt->interrupt_pin_conf), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_pin_conf(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = atomic_read(&stat->interrupt->interrupt_pin_conf.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_interrupt_polarity(struct device *device,
+						struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(stat, 
+			&(stat->interrupt->interrupt_polarity), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_interrupt_polarity(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+
+	val = atomic_read(&stat->interrupt->interrupt_polarity.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static struct kobj_attribute gen1_interrupt_pin1_enable =
+__ATTR(pin1_enable, 0664, attr_get_gen1_status, attr_set_gen1_status);
+static struct kobj_attribute gen1_interrupt_pin2_enable =
+__ATTR(pin2_enable, 0664, attr_get_gen1_status, attr_set_gen1_status);
+
+static struct kobj_attribute gen2_interrupt_pin1_enable =
+__ATTR(pin1_enable, 0664, attr_get_gen2_status, attr_set_gen2_status);
+static struct kobj_attribute gen2_interrupt_pin2_enable =
+__ATTR(pin2_enable, 0664, attr_get_gen2_status, attr_set_gen2_status);
+
+static struct kobj_attribute gen1_duration =
+__ATTR(duration, 0664, attr_get_gen1_duration, attr_set_gen1_duration);
+static struct kobj_attribute gen2_duration =
+__ATTR(duration, 0664, attr_get_gen2_duration, attr_set_gen2_duration);
+
+static struct kobj_attribute gen1_threshold =
+__ATTR(threshold, 0664, attr_get_gen1_threshold, attr_set_gen1_threshold);
+static struct kobj_attribute gen2_threshold =
+__ATTR(threshold, 0664, attr_get_gen2_threshold, attr_set_gen2_threshold);
+
+static struct kobj_attribute mag_gen_interrupt_pin1 =
+__ATTR(pin1_enable, 0664, attr_get_gen_mag_status, attr_set_gen_mag_status);
+static struct kobj_attribute mag_gen_interrupt_pin2 =
+__ATTR(pin2_enable, 0664, attr_get_gen_mag_status, attr_set_gen_mag_status);
+
+static struct kobj_attribute mag_gen_threshold =
+__ATTR(threshold, 0664, attr_get_gen_mag_threshold, attr_set_gen_mag_threshold);
+
+static struct kobj_attribute gen1_x_high =
+__ATTR(x_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_x_low =
+__ATTR(x_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_x_high =
+__ATTR(x_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_x_low =
+__ATTR(x_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen1_y_high =
+__ATTR(y_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_y_low =
+__ATTR(y_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_y_high =
+__ATTR(y_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_y_low =
+__ATTR(y_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen1_z_high =
+__ATTR(z_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_z_low =
+__ATTR(z_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_z_high =
+__ATTR(z_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_z_low =
+__ATTR(z_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen_mag_x =
+__ATTR(x_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+static struct kobj_attribute gen_mag_y =
+__ATTR(y_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+static struct kobj_attribute gen_mag_z =
+__ATTR(z_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+
+static struct kobj_attribute gen1_and_or =
+__ATTR(and(1)_or(0)_combination, 0664, attr_get_gen1_and_or, 
+							attr_set_gen1_and_or);
+static struct kobj_attribute gen2_and_or =
+__ATTR(and(1)_or(0)_combination, 0664, attr_get_gen2_and_or, 
+							attr_set_gen2_and_or);
+
+
+static struct attribute *attributes_acc_interrupt1[] = {
+	&gen1_interrupt_pin1_enable.attr,
+	&gen1_interrupt_pin2_enable.attr,
+	&gen1_duration.attr,
+	&gen1_threshold.attr,
+	&gen1_x_high.attr,
+	&gen1_x_low.attr,
+	&gen1_y_high.attr,
+	&gen1_y_low.attr,
+	&gen1_z_high.attr,
+	&gen1_z_low.attr,
+	&gen1_and_or.attr,
+	NULL,
+};
+
+static struct attribute *attributes_acc_interrupt2[] = {
+	&gen2_interrupt_pin1_enable.attr,
+	&gen2_interrupt_pin2_enable.attr,
+	&gen2_duration.attr,
+	&gen2_threshold.attr,
+	&gen2_x_high.attr,
+	&gen2_x_low.attr,
+	&gen2_y_high.attr,
+	&gen2_y_low.attr,
+	&gen2_z_high.attr,
+	&gen2_z_low.attr,
+	&gen2_and_or.attr,
+	NULL,
+};
+
+static struct attribute *attributes_mag_interrupt[] = {
+	&mag_gen_interrupt_pin1.attr,
+	&mag_gen_interrupt_pin2.attr,
+	&mag_gen_threshold.attr,
+	&gen_mag_x.attr,
+	&gen_mag_y.attr,
+	&gen_mag_z.attr,
+	NULL,
+};
+
+static struct attribute *attributes_acc[] = {
+	&poll_attr_acc.attr,
+	&enable_attr_acc.attr,
+	&fs_attr_acc.attr,
+	&aa_filter_attr.attr,
+	NULL,
+};
+
+static struct attribute *attributes_mag[] = {
+	&poll_attr_mag.attr,
+	&enable_attr_mag.attr,
+	&fs_attr_mag.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_mag = {
+	.attrs = attributes_mag,
+};
+
+static struct attribute_group attr_group_int1_acc = {
+	.attrs = attributes_acc_interrupt1,
+	.name = "interrupt_generator1",
+};
+
+static struct attribute_group attr_group_int2_acc = {
+	.attrs = attributes_acc_interrupt2,
+	.name = "interrupt_generator2",
+};
+
+static struct attribute_group attr_group_int_mag = {
+	.attrs = attributes_mag_interrupt,
+	.name = "interrupt_generator",
+};
+
+static struct device_attribute attributes_com[] = {
+	__ATTR(enable_temperature, 0664, attr_get_temp_enable,
+	       attr_set_temp_enable),
+	__ATTR(read_temperature, 0444, attr_get_temp, NULL),
+};
+
+static struct device_attribute attributes_interrupt_com[] = {
+	__ATTR(interrupt_pin_configuration, 0664, attr_get_pin_conf, 
+						attr_set_pin_conf),
+	__ATTR(interrupt_polarity, 0664, attr_get_interrupt_polarity, 
+						attr_set_interrupt_polarity),
+};
+
+static int create_sysfs_interfaces(struct lsm303d_dev *dev)
+{
+	int err;
+	int i,n;
+	struct lsm303d_status *stat = &dev->st;
+
+	acc_kobj = kobject_create_and_add("accelerometer", &dev->dev->kobj);
+	if(!acc_kobj)
+		return -ENOMEM;
+
+	mag_kobj = kobject_create_and_add("magnetometer", &dev->dev->kobj);
+	if(!mag_kobj)
+		return -ENOMEM;
+
+	err = sysfs_create_group(acc_kobj, &attr_group_acc);
+	if (err)
+		kobject_put(acc_kobj);
+
+	err = sysfs_create_group(mag_kobj, &attr_group_mag);
+	if (err)
+		kobject_put(mag_kobj);
+
+	if((stat->pdata_acc->gpio_int1 >= 0)||
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+		err = sysfs_create_group(acc_kobj, &attr_group_int1_acc);
+		if (err)
+			kobject_put(acc_kobj);
+
+		err = sysfs_create_group(acc_kobj, &attr_group_int2_acc);
+		if (err)
+			kobject_put(acc_kobj);
+
+		err = sysfs_create_group(mag_kobj, &attr_group_int_mag);
+		if (err)
+			kobject_put(mag_kobj);
+
+		for (n = 0; n < ARRAY_SIZE(attributes_interrupt_com); n++)
+		if (device_create_file(dev->dev, attributes_interrupt_com + n))
+			goto error1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(attributes_com); i++)
+		if (device_create_file(dev->dev, attributes_com + i))
+			goto error;
+
+	
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev->dev, attributes_com + i);
+
+error1:
+	for ( ; n >= 0; n--)
+		device_remove_file(dev->dev, attributes_interrupt_com + n);
+
+	dev_err(dev->dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static void remove_sysfs_interfaces(struct device *device)
+{
+	int i;
+	struct lsm303d_dev *dev = dev_get_drvdata(device);
+	struct lsm303d_status *stat = &dev->st;
+	kobject_put(acc_kobj);
+	kobject_put(mag_kobj);
+	for (i = 0; i < ARRAY_SIZE(attributes_com); i++)
+		device_remove_file(device, attributes_com + i);
+	if((stat->pdata_acc->gpio_int1 >= 0)||
+					(stat->pdata_acc->gpio_int2 >= 0)) {
+		for (i = 0; i < ARRAY_SIZE(attributes_interrupt_com); i++)
+			device_remove_file(device, attributes_interrupt_com + i);
+	}
+}
+
+static int lsm303d_acc_get_data(struct lsm303d_status *stat, int *xyz)
+{
+	int i, err;
+	u8 acc_data[6];
+	s32 hw_d[3] = {};
+	struct lsm303d_dev *dev = stat->dev;
+
+	err = dev->tf->read(dev->dev, REG_ACC_DATA_ADDR, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)((s16)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((s32)((s16)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((s32)((s16)((acc_data[5] << 8) | (acc_data[4]))));
+
+#ifdef LSM303D_DEBUG
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_ACC_DEV_NAME, acc_data[1], acc_data[0], hw_d[0]);
+	pr_debug("%s read y=%X %X(regH regL), y=%d(dec) [ug]\n",
+		LSM303D_ACC_DEV_NAME, acc_data[3], acc_data[2], hw_d[1]);
+	pr_debug("%s read z=%X %X(regH regL), z=%d(dec) [ug]\n",
+		LSM303D_ACC_DEV_NAME, acc_data[5], acc_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_acc;
+	hw_d[1] = hw_d[1] * stat->sensitivity_acc;
+	hw_d[2] = hw_d[2] * stat->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_acc->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_acc->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_acc->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm303d_mag_get_data(struct lsm303d_status *stat, int *xyz)
+{
+	int i, err;
+	u8 mag_data[6];
+	s32 hw_d[3] = {};
+	struct lsm303d_dev *dev = stat->dev;
+
+	err = dev->tf->read(dev->dev, REG_MAG_DATA_ADDR, 6, mag_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)( (s16)((mag_data[1] << 8) | (mag_data[0]))));
+	hw_d[1] = ((s32)( (s16)((mag_data[3] << 8) | (mag_data[2]))));
+	hw_d[2] = ((s32)( (s16)((mag_data[5] << 8) | (mag_data[4]))));
+
+#ifdef LSM303D_DEBUG
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_MAG_DEV_NAME, mag_data[1], mag_data[0], hw_d[0]);
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_MAG_DEV_NAME, mag_data[3], mag_data[2], hw_d[1]);
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM303D_MAG_DEV_NAME, mag_data[5], mag_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_mag;
+	hw_d[1] = hw_d[1] * stat->sensitivity_mag;
+	hw_d[2] = hw_d[2] * stat->sensitivity_mag;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_acc->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_acc->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_acc->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm303d_temp_get_data(struct lsm303d_status *stat, int *dec, int *flo)
+{
+	int err;
+	u8 temp_data[2];
+	s16 hw_d = 0;
+	struct lsm303d_dev *dev = stat->dev;
+
+	err = dev->tf->read(dev->dev, REG_TEMP_DATA_ADDR, 2, temp_data);
+	if (err < 0)
+		return err;
+
+	hw_d = (s16)((temp_data[1] << 8) | (temp_data[0]));
+
+#ifdef LSM303D_DEBUG
+	pr_debug("%s read T=%X %X(regH regL), T=%d(dec) [C]\n",
+		LSM303D_DEV_NAME, temp_data[1], temp_data[0], hw_d);
+#endif
+
+	*dec = (int)(hw_d/TEMP_SENSITIVITY) + OFFSET_TEMP;
+	*flo = (((unsigned int)hw_d)%TEMP_SENSITIVITY);
+
+	return err;
+}
+
+static void lsm303d_acc_report_values(struct lsm303d_status *stat, int *xyz)
+{
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(stat->input_dev_acc);
+}
+
+static void lsm303d_mag_report_values(struct lsm303d_status *stat, int *xyz)
+{
+	input_event(stat->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(stat->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(stat->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(stat->input_dev_mag);
+}
+
+static int lsm303d_acc_input_init(struct lsm303d_status *stat)
+{
+	int err;
+
+	stat->input_dev_acc = input_allocate_device();
+	if (!stat->input_dev_acc) {
+		err = -ENOMEM;
+		dev_err(stat->dev->dev, "accelerometer "
+					"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev_acc->name = LSM303D_ACC_DEV_NAME;
+	stat->input_dev_acc->id.bustype = stat->dev->bus_type;
+	stat->input_dev_acc->dev.parent = stat->dev->dev;
+
+	input_set_drvdata(stat->input_dev_acc, stat);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev_acc->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev_acc->mscbit);
+
+	err = input_register_device(stat->input_dev_acc);
+	if (err) {
+		dev_err(stat->dev->dev,
+			"unable to register accelerometer input device %s\n",
+				stat->input_dev_acc->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev_acc);
+err0:
+	return err;
+}
+
+static int lsm303d_mag_input_init(struct lsm303d_status *stat)
+{
+	int err;
+
+	stat->input_dev_mag = input_allocate_device();
+	if (!stat->input_dev_mag) {
+		err = -ENOMEM;
+		dev_err(stat->dev->dev, "magnetometer "
+					"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev_mag->name = LSM303D_MAG_DEV_NAME;
+	stat->input_dev_mag->id.bustype = stat->dev->bus_type;
+	stat->input_dev_mag->dev.parent = stat->dev->dev;
+
+	input_set_drvdata(stat->input_dev_mag, stat);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev_mag->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev_mag->mscbit);
+
+	err = input_register_device(stat->input_dev_mag);
+	if (err) {
+		dev_err(stat->dev->dev,
+			"unable to register magnetometer input device %s\n",
+				stat->input_dev_mag->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev_mag);
+err0:
+	return err;
+}
+
+static void lsm303d_input_cleanup(struct lsm303d_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+
+	input_unregister_device(stat->input_dev_mag);
+	input_free_device(stat->input_dev_mag);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct lsm303d_status *stat;
+	int xyz[3] = { 0 };
+	int err;
+
+	stat = container_of((struct work_struct *)input_work_acc,
+			struct lsm303d_status, input_work_acc);
+
+	mutex_lock(&stat->lock);
+	err = lsm303d_acc_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev->dev, "get_accelerometer_data failed\n");
+	else
+		lsm303d_acc_report_values(stat, xyz);
+
+	mutex_unlock(&stat->lock);
+	hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+}
+
+static void poll_function_work_mag(struct work_struct *input_work_mag)
+{
+	struct lsm303d_status *stat;
+	int xyz[3] = { 0 };
+	int err;
+	int dec;
+	int flo;
+
+	stat = container_of((struct work_struct *)input_work_mag,
+			struct lsm303d_status, input_work_mag);
+
+	mutex_lock(&stat->lock);
+
+	if (atomic_read(&stat->enabled_temp)) {
+		err = lsm303d_temp_get_data(stat, &dec, &flo);
+		if (err < 0)
+			dev_err(stat->dev->dev, "get_temperature_data"
+								" failed\n");
+		else {
+			stat->temp_value_dec = dec;
+			stat->temp_value_flo = flo;
+		}
+	}
+
+	if(atomic_read(&stat->enabled_mag)) {
+		err = lsm303d_mag_get_data(stat, xyz);
+		if (err < 0)
+			dev_err(stat->dev->dev, "get_magnetometer_data"
+								" failed\n");
+		else
+			lsm303d_mag_report_values(stat, xyz);
+	}
+
+	mutex_unlock(&stat->lock);
+	hrtimer_start(&stat->hr_timer_mag, stat->ktime_mag, HRTIMER_MODE_REL);
+}
+
+static enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct lsm303d_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm303d_status, hr_timer_acc);
+
+	queue_work(lsm303d_workqueue, &stat->input_work_acc);
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart poll_function_read_mag(struct hrtimer *timer)
+{
+	struct lsm303d_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm303d_status, hr_timer_mag);
+
+	queue_work(lsm303d_workqueue, &stat->input_work_mag);
+	return HRTIMER_NORESTART;
+}
+
+#ifdef CONFIG_OF
+static int32_t lsm303d_parse_dt(struct lsm303d_status *stat)
+{
+	struct device_node *dn;
+	uint8_t i, j;
+	uint32_t val, vect[9] = { 0 };
+	struct device *dev = stat->dev->dev;
+
+	if (of_match_device(stat->dev->dev_id, dev)) {
+		dn = dev->of_node;
+		//stat->pdata_main->of_node = dn;
+
+		stat->pdata_acc->gpio_int1 = of_get_gpio(dn, 0);
+		if (!gpio_is_valid(stat->pdata_acc->gpio_int1)) {
+			dev_err(dev, "failed to get gpio_int1\n");
+
+			stat->pdata_acc->gpio_int1 = DEFAULT_INT1_GPIO;
+		}
+
+		stat->pdata_acc->gpio_int2 = of_get_gpio(dn, 1);
+		if (!gpio_is_valid(stat->pdata_acc->gpio_int2)) {
+			dev_err(dev, "failed to get gpio_int2\n");
+
+			stat->pdata_acc->gpio_int2 = DEFAULT_INT2_GPIO;
+		}
+
+		if (of_property_read_u32_array(dn, "acc-rot-matrix", vect,
+		    ARRAY_SIZE(vect)) >= 0) {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					stat->pdata_acc->rot_matrix[i][j] =
+					(short)vect[3 * j + i];
+				}
+			}
+		} else {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					stat->pdata_acc->rot_matrix[i][j] =
+					default_lsm303d_acc_pdata.rot_matrix[i][j];
+				}
+			}
+		}
+
+		if (of_property_read_u32_array(dn, "mag-rot-matrix", vect,
+			ARRAY_SIZE(vect)) >= 0) {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					stat->pdata_mag->rot_matrix[i][j] =
+					(short)vect[3 * j + i];
+				}
+			}
+		} else {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					stat->pdata_mag->rot_matrix[i][j] =
+					default_lsm303d_mag_pdata.rot_matrix[i][j];
+				}
+			}
+		}
+
+		if (!of_property_read_u32(dn, "acc-poll-interval", &val)) {
+			stat->pdata_acc->poll_interval = val;
+		} else {
+			stat->pdata_acc->poll_interval =
+						LSM303D_ACC_DEF_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "mag-poll-interval", &val)) {
+			stat->pdata_mag->poll_interval = val;
+		} else {
+			stat->pdata_mag->poll_interval =
+						LSM303D_MAG_DEF_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "acc-min-interval", &val)) {
+			stat->pdata_acc->min_interval = val;
+		} else {
+			stat->pdata_acc->min_interval =
+						LSM303D_ACC_MIN_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "mag-min-interval", &val)) {
+			stat->pdata_mag->min_interval = val;
+		} else {
+			stat->pdata_mag->min_interval =
+						LSM303D_MAG_MIN_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "acc-fs-range", &val)) {
+			stat->pdata_acc->fs_range = val;
+		} else {
+			stat->pdata_acc->fs_range = LSM303D_ACC_FS_2G;
+		}
+
+		if (!of_property_read_u32(dn, "mag-fs-range", &val)) {
+			stat->pdata_mag->fs_range = val;
+		} else {
+			stat->pdata_mag->fs_range = LSM303D_MAG_FS_2G;
+		}
+
+		if (!of_property_read_u32(dn, "aa-filter-bw", &val)) {
+			stat->pdata_acc->aa_filter_bandwidth = val;
+		} else {
+			stat->pdata_acc->aa_filter_bandwidth = ANTI_ALIASING_773;
+		}
+
+		return 0;
+	}
+	return -1;
+}
+#endif
+
+int lsm303d_probe(struct lsm303d_dev *dev)
+{
+	int err;
+	struct lsm303d_status *stat = &dev->st;
+
+	if(lsm303d_workqueue == 0)
+		lsm303d_workqueue = create_workqueue("lsm303d_workqueue");
+
+	hrtimer_init(&stat->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_acc.function = &poll_function_read_acc;
+	hrtimer_init(&stat->hr_timer_mag, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_mag.function = &poll_function_read_mag;
+
+	mutex_init(&stat->lock);
+	mutex_lock(&stat->lock);
+
+	stat->pdata_acc = kzalloc(sizeof(*stat->pdata_acc), GFP_KERNEL);
+	stat->pdata_mag = kzalloc(sizeof(*stat->pdata_mag), GFP_KERNEL);
+	if ((stat->pdata_acc == NULL)||(stat->pdata_mag == NULL)) {
+		err = -ENOMEM;
+		dev_err(dev->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+#ifdef CONFIG_OF
+	lsm303d_parse_dt(stat);
+#else
+	if (client->dev.platform_data == NULL) {
+		memcpy(stat->pdata_acc, &default_lsm303d_acc_pdata,
+						sizeof(*stat->pdata_acc));
+		memcpy(stat->pdata_mag, &default_lsm303d_mag_pdata,
+						sizeof(*stat->pdata_mag));
+		dev_info(dev->dev, "using default plaform_data for "
+					"accelerometer and magnetometer\n");
+	} else {
+		struct lsm303d_main_platform_data *tmp;
+		tmp = kzalloc(sizeof(struct lsm303d_main_platform_data), 
+								GFP_KERNEL);
+		if(tmp == NULL)
+			goto exit_kfree_pdata;
+		memcpy(tmp, client->dev.platform_data, sizeof(*tmp));
+		if(tmp->pdata_acc == NULL) {
+			memcpy(stat->pdata_acc, &default_lsm303d_acc_pdata,
+						sizeof(*stat->pdata_acc));
+			dev_info(dev->dev, "using default plaform_data for "
+							"accelerometer\n");
+		} else {
+			memcpy(stat->pdata_acc, tmp->pdata_acc, 
+						sizeof(*stat->pdata_acc));
+		}
+		if(tmp->pdata_mag == NULL) {
+			memcpy(stat->pdata_mag, &default_lsm303d_mag_pdata,
+						sizeof(*stat->pdata_mag));
+			dev_info(dev->dev, "using default plaform_data for "
+							"magnetometer\n");
+		} else {
+			memcpy(stat->pdata_mag, tmp->pdata_mag, 
+						sizeof(*stat->pdata_mag));
+		}
+		kfree(tmp);
+	}
+#endif
+	err = lsm303d_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data for "
+							"accelerometer \n");
+		goto exit_kfree_pdata;
+	}
+
+	err = lsm303d_mag_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data for "
+							"magnetometer\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata_acc->init) {
+		err = stat->pdata_acc->init();
+		if (err < 0) {
+			dev_err(dev->dev, "accelerometer init failed: "
+								"%d\n", err);
+			goto err_pdata_acc_init;
+		}
+	}
+	if (stat->pdata_mag->init) {
+		err = stat->pdata_mag->init();
+		if (err < 0) {
+			dev_err(dev->dev, "magnetometer init failed: "
+								"%d\n", err);
+			goto err_pdata_mag_init;
+		}
+	}
+
+	if(stat->pdata_acc->gpio_int1 >= 0) {
+		if (!gpio_is_valid(stat->pdata_acc->gpio_int1)) {
+  			dev_err(dev->dev, "The requested GPIO [%d] is not "
+				"available\n", stat->pdata_acc->gpio_int1);
+			err = -EINVAL;
+  			goto err_gpio1_valid;
+		}
+		
+		err = gpio_request(stat->pdata_acc->gpio_int1, 
+						"INTERRUPT_PIN1_LSM303D");
+		if(err < 0) {
+			dev_err(dev->dev, "Unable to request GPIO [%d].\n",
+						stat->pdata_acc->gpio_int1);
+  			err = -EINVAL;
+			goto err_gpio1_valid;
+		}
+		gpio_direction_input(stat->pdata_acc->gpio_int1);
+		stat->irq1 = gpio_to_irq(stat->pdata_acc->gpio_int1);
+		if(stat->irq1 < 0) {
+			dev_err(dev->dev, "GPIO [%d] cannot be used as "
+				"interrupt.\n",	stat->pdata_acc->gpio_int1);
+			err = -EINVAL;
+			goto err_gpio1_irq;
+		}
+		pr_info("%s: %s has set irq1 to irq: %d, mapped on gpio:%d\n",
+			LSM303D_DEV_NAME, __func__, stat->irq1,
+						stat->pdata_acc->gpio_int1);
+	}
+
+	if(stat->pdata_acc->gpio_int2 >= 0) {
+		if (!gpio_is_valid(stat->pdata_acc->gpio_int2)) {
+  			dev_err(dev->dev, "The requested GPIO [%d] is not "
+				"available\n", stat->pdata_acc->gpio_int2);
+			err = -EINVAL;
+  			goto err_gpio2_valid;
+		}
+		
+		err = gpio_request(stat->pdata_acc->gpio_int2, 
+						"INTERRUPT_PIN2_LSM303D");
+		if(err < 0) {
+			dev_err(dev->dev, "Unable to request GPIO [%d].\n",
+						stat->pdata_acc->gpio_int2);
+  			err = -EINVAL;
+			goto err_gpio2_valid;
+		}
+		gpio_direction_input(stat->pdata_acc->gpio_int2);
+		stat->irq2 = gpio_to_irq(stat->pdata_acc->gpio_int2);
+		if(stat->irq2 < 0) {
+			dev_err(dev->dev, "GPIO [%d] cannot be used as "
+				"interrupt.\n", stat->pdata_acc->gpio_int2);
+			err = -EINVAL;
+			goto err_gpio2_irq;
+		}
+		pr_info("%s: %s has set irq2 to irq: %d, "
+							"mapped on gpio:%d\n",
+			LSM303D_DEV_NAME, __func__, stat->irq2,
+						stat->pdata_acc->gpio_int2);
+	}
+
+	err = lsm303d_hw_init(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm303d_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "accelerometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+	err = lsm303d_mag_device_power_on(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm303d_acc_update_fs_range(stat, stat->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range on accelerometer "
+								"failed\n");
+		goto  err_power_off_acc;
+	}
+
+	err = lsm303d_mag_update_fs_range(stat, stat->pdata_mag->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range on magnetometer "
+								"failed\n");
+		goto  err_power_off_mag;
+	}
+
+	err = lsm303d_acc_update_odr(stat, stat->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr on accelerometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303d_mag_update_odr(stat, stat->pdata_mag->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr on magnetometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303d_acc_update_filter(stat, 
+					stat->pdata_acc->aa_filter_bandwidth);
+	if (err < 0) {
+		dev_err(dev->dev, "update_filter on accelerometer "
+								"failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303d_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = lsm303d_mag_input_init(stat);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev);
+	if (err < 0) {
+		dev_err(dev->dev,
+		"device LSM303D_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm303d_acc_device_power_off(stat);
+	lsm303d_mag_device_power_off(stat);
+
+	if(stat->pdata_acc->gpio_int1 >= 0){
+		INIT_WORK(&stat->irq1_work, lsm303d_irq1_work_func);
+		stat->irq1_work_queue =
+				create_singlethread_workqueue("lsm303d_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, lsm303d_isr1,
+				IRQF_TRIGGER_RISING, "lsm303d_irq1", stat);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if(stat->pdata_acc->gpio_int2 >= 0){
+		INIT_WORK(&stat->irq2_work, lsm303d_irq2_work_func);
+		stat->irq2_work_queue =
+				create_singlethread_workqueue("lsm303d_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev,
+					"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, lsm303d_isr2,
+				IRQF_TRIGGER_RISING, "lsm303d_irq2", stat);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	INIT_WORK(&stat->input_work_acc, poll_function_work_acc);
+	INIT_WORK(&stat->input_work_mag, poll_function_work_mag);
+
+	mutex_unlock(&stat->lock);
+	dev_info(dev->dev, "%s: probed\n", LSM303D_DEV_NAME);
+	return 0;
+
+err_destoyworkqueue2:
+	destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(dev->dev);
+err_input_cleanup:
+	lsm303d_input_cleanup(stat);
+err_power_off:
+err_power_off_mag:
+	lsm303d_mag_device_power_off(stat);
+err_power_off_acc:
+	lsm303d_acc_device_power_off(stat);
+	kfree(stat->interrupt);
+err_hw_init:
+err_gpio2_irq:
+	gpio_free(stat->pdata_acc->gpio_int2);
+err_gpio2_valid:
+err_gpio1_irq:
+	gpio_free(stat->pdata_acc->gpio_int1);
+err_gpio1_valid:
+err_pdata_init:
+err_pdata_mag_init:
+	if (stat->pdata_mag->exit)
+		stat->pdata_mag->exit();
+err_pdata_acc_init:
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_mag);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+	if(lsm303d_workqueue) {
+		destroy_workqueue(lsm303d_workqueue);
+		lsm303d_workqueue = NULL;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(lsm303d_probe);
+
+int lsm303d_remove(struct lsm303d_dev *dev)
+{
+	struct lsm303d_status *stat = &dev->st;
+
+	lsm303d_acc_disable(stat);
+	lsm303d_mag_disable(stat);
+	lsm303d_temperature_disable(stat);
+
+	if(stat->pdata_acc->gpio_int1 >= 0) {
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata_acc->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if(stat->pdata_acc->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata_acc->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lsm303d_acc_input_cleanup(stat);
+	lsm303d_mag_input_cleanup(stat);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+	if (stat->pdata_mag->exit)
+		stat->pdata_mag->exit();
+
+	if ((stat->pdata_acc->gpio_int1 >= 0)||
+	    (stat->pdata_acc->gpio_int2 >= 0)) {
+		kfree(stat->interrupt);
+	}
+
+	if (lsm303d_workqueue) {
+		destroy_workqueue(lsm303d_workqueue);
+		lsm303d_workqueue = NULL;
+	}
+
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_mag);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303d_remove);
+
+MODULE_DESCRIPTION("lsm303d accelerometer and magnetometer driver");
+MODULE_AUTHOR("Matteo Dameno, Denis Ciocca, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/ecompass/lsm303d/lsm303d.h b/drivers/input/misc/st/ecompass/lsm303d/lsm303d.h
--- a/drivers/input/misc/st/ecompass/lsm303d/lsm303d.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303d/lsm303d.h	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,223 @@
+/******************** (C) COPYRIGHT 2013 STMicroelectronics *******************
+*
+* File Name          : lsm303d.h
+* Authors            : AMS - MSH Div - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+* 		     : Giuseppe Barba (giuseppe.barba@st.com)
+* Version            : V.1.0.7
+* Date               : 2014/Jun/29
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************/
+
+#ifndef	__LSM303D_H__
+#define	__LSM303D_H__
+
+#define	LSM303D_DEV_NAME	"lsm303d"
+#define	LSM303D_ACC_DEV_NAME	"lsm303d_acc"	/* Input file name */
+#define	LSM303D_MAG_DEV_NAME	"lsm303d_mag"	/* Input file name */
+
+#define LSM303D_SAD0L			(0x02)
+#define LSM303D_SAD0H			(0x01)
+#define LSM303D_I2C_SADROOT		(0x07)
+#define LSM303D_I2C_SAD_L		((LSM303D_I2C_SADROOT<<2) | \
+								LSM303D_SAD0L)
+#define LSM303D_I2C_SAD_H		((LSM303D_I2C_SADROOT<<2) | \
+								LSM303D_SAD0H)
+
+/************************************************/
+/* 	Output data			 	*/
+/*************************************************
+accelerometer: ug
+magnetometer: ugauss
+*************************************************/
+
+/************************************************/
+/* 	sysfs data			 	*/
+/*************************************************
+accelerometer:
+	- pollrate->ms
+	- fullscale->g
+magnetometer:
+	- pollrate->ms
+	- fullscale->gauss
+*************************************************/
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	LSM303D_ACC_FS_MASK	(0x18)
+#define LSM303D_ACC_FS_2G 	(0x00)	/* Full scale 2g */
+#define LSM303D_ACC_FS_4G 	(0x08)	/* Full scale 4g */
+#define LSM303D_ACC_FS_8G 	(0x18)	/* Full scale 8g */
+#define LSM303D_ACC_FS_16G	(0x20)	/* Full scale 16g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define ANTI_ALIASING_773	(0x00)
+#define ANTI_ALIASING_362	(0x40)
+#define ANTI_ALIASING_194	(0x80)
+#define ANTI_ALIASING_50	(0xc0)
+
+/************************************************/
+/* 	Magnetometer section defines	 	*/
+/************************************************/
+
+/* Magnetometer Sensor Full Scale */
+#define LSM303D_MAG_FS_MASK	(0x60)
+#define LSM303D_MAG_FS_2G	(0x00)	/* Full scale 2 gauss */
+#define LSM303D_MAG_FS_4G	(0x20)	/* Full scale 4 gauss */
+#define LSM303D_MAG_FS_8G	(0x40)	/* Full scale 8 gauss */
+#define LSM303D_MAG_FS_12G	(0x60)	/* Full scale 12 gauss */
+
+
+#ifdef	__KERNEL__
+
+#define DEFAULT_INT1_GPIO		(-EINVAL)
+#define DEFAULT_INT2_GPIO		(-EINVAL)
+
+#define	LSM303D_ACC_MIN_POLL_PERIOD_MS	1
+#define LSM303D_MAG_MIN_POLL_PERIOD_MS	5
+#define LSM303D_ACC_DEF_POLL_PERIOD_MS  100
+#define LSM303D_MAG_DEF_POLL_PERIOD_MS  100
+
+struct lsm303d_status {
+	struct lsm303d_dev *dev;
+	struct lsm303d_acc_platform_data *pdata_acc;
+	struct lsm303d_mag_platform_data *pdata_mag;
+	struct lsm303d_main_platform_data *pdata_main;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct work_struct input_work_mag;
+
+	struct hrtimer hr_timer_acc;
+	ktime_t ktime_acc;
+	struct hrtimer hr_timer_mag;
+	ktime_t ktime_mag;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_mag;
+	struct input_dev *input_dev_temp;
+
+	struct lsm303d_interrupt *interrupt;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+
+	atomic_t enabled_acc;
+	atomic_t enabled_mag;
+	atomic_t enabled_temp;
+
+	int temp_value_dec;
+	unsigned int temp_value_flo;
+
+	int on_before_suspend;
+	int use_smbus;
+
+	u16 sensitivity_acc;
+	u16 sensitivity_mag;
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+};
+
+struct lsm303d_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LSM303D_SPI) || \
+    defined(CONFIG_INPUT_LSM303D_SPI_MODULE)
+#define LSM303D_RX_MAX_LENGTH		500
+#define LSM303D_TX_MAX_LENGTH		500
+
+struct lsm303d_transfer_buffer {
+	u8 rx_buf[LSM303D_RX_MAX_LENGTH];
+	u8 tx_buf[LSM303D_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LSM303D_SPI */
+
+struct lsm303d_dev {
+	const char* name;
+	u16 bus_type;
+#ifdef CONFIG_OF
+	const struct of_device_id *dev_id;
+#endif
+	struct device *dev;
+	struct lsm303d_transfer_function *tf;
+	struct lsm303d_status st;
+#if defined(CONFIG_INPUT_LSM303D_SPI) || \
+    defined(CONFIG_INPUT_LSM303D_SPI_MODULE)
+	struct lsm303d_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM303D_SPI */
+};
+
+struct lsm303d_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	short rot_matrix[3][3];
+
+	u8 aa_filter_bandwidth;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lsm303d_mag_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	short rot_matrix[3][3];
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm303d_main_platform_data {
+	struct lsm303d_acc_platform_data *pdata_acc;
+	struct lsm303d_mag_platform_data *pdata_mag;
+#ifdef CONFIG_OF
+	struct device_node	*of_node;
+#endif
+};
+
+int lsm303d_probe(struct lsm303d_dev *dev);
+int lsm303d_remove(struct lsm303d_dev *dev);
+int lsm303d_enable(struct lsm303d_dev *dev);
+int lsm303d_disable(struct lsm303d_dev *dev);
+
+#endif	/* __KERNEL__ */
+#endif	/* __LSM303D_H__ */
diff -uNr a/drivers/input/misc/st/ecompass/lsm303d/lsm303d_i2c.c b/drivers/input/misc/st/ecompass/lsm303d/lsm303d_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303d/lsm303d_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303d/lsm303d_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm303d_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303d.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm303d_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm303d_i2c_write(struct device *dev, u8 addr, int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm303d_transfer_function lsm303d_i2c_tf = {
+	.write = lsm303d_i2c_write,
+	.read = lsm303d_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303d_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303d_dev *dev = i2c_get_clientdata(client);
+
+	return lsm303d_enable(dev);
+}
+
+static int lsm303d_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303d_dev *dev = i2c_get_clientdata(client);
+
+	return lsm303d_disable(dev);
+}
+
+static const struct dev_pm_ops lsm303d_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303d_i2c_suspend, lsm303d_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303d_i2c_id_table[] = {
+	{ .compatible = "st,lsm303d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303d_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303d_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303d_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm303d_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->st.dev = dev;
+	dev->tf = &lsm303d_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+#ifdef CONFIG_OF
+	dev->dev_id = lsm303d_i2c_id_table;
+#endif
+
+	err = lsm303d_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303d_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303d_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303d_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303d_i2c_id[] = {
+	{ "lsm303d", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303d_i2c_id);
+
+static struct i2c_driver lsm303d_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303d_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303d_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303d_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303d_i2c_probe,
+	.remove = lsm303d_i2c_remove,
+	.id_table = lsm303d_i2c_id,
+};
+
+module_i2c_driver(lsm303d_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303d i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303d/lsm303d_spi.c b/drivers/input/misc/st/ecompass/lsm303d/lsm303d_spi.c
--- a/drivers/input/misc/st/ecompass/lsm303d/lsm303d_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303d/lsm303d_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,196 @@
+/*
+ * STMicroelectronics lsm303d_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/input.h>
+
+#include "lsm303d.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold dev->lock */
+static int lsm303d_spi_read(struct device *device, u8 addr, int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303d_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm303d_spi_write(struct device *device, u8 addr, int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303d_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM303D_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm303d_transfer_function lsm303d_spi_tf = {
+	.write = lsm303d_spi_write,
+	.read = lsm303d_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303d_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303d_dev *dev = spi_get_drvdata(spi);
+
+	return lsm303d_disable(dev);
+}
+
+static int lsm303d_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm303d_dev *dev = spi_get_drvdata(spi);
+
+	return lsm303d_enable(dev);
+}
+
+static const struct dev_pm_ops lsm303d_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303d_spi_suspend, lsm303d_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303d_spi_id_table[] = {
+	{ .compatible = "st,lsm303d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303d_spi_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303d_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm303d_dev *dev;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->dev = &spi->dev;
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->st.dev = dev;
+	dev->tf = &lsm303d_spi_tf;
+
+	spi_set_drvdata(spi, dev);
+
+#ifdef CONFIG_OF
+	dev->dev_id = lsm303d_spi_id_table;
+#endif
+
+	err = lsm303d_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static int lsm303d_spi_remove(struct spi_device *spi)
+{
+	struct lsm303d_dev *dev = spi_get_drvdata(spi);
+
+	lsm303d_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm303d_spi_ids[] = {
+	{ "lsm303d", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm303d_spi_ids);
+
+static struct spi_driver lsm303d_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303d",
+#ifdef CONFIG_PM
+		.pm = &lsm303d_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303d_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe    = lsm303d_spi_probe,
+	.remove   = lsm303d_spi_remove,
+	.id_table = lsm303d_spi_ids,
+};
+
+module_spi_driver(lsm303d_spi_driver);
+
+MODULE_DESCRIPTION("lsm303d spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303d/Makefile b/drivers/input/misc/st/ecompass/lsm303d/Makefile
--- a/drivers/input/misc/st/ecompass/lsm303d/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303d/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,10 @@
+#
+# Makefile for the input misc lsm303d driver.
+#
+
+# Each configuration option enables a list of files.
+
+lsm303d-y += lsm303d_core.o
+obj-$(CONFIG_INPUT_LSM303D) += lsm303d.o
+obj-$(CONFIG_INPUT_LSM303D_I2C) += lsm303d_i2c.o
+obj-$(CONFIG_INPUT_LSM303D_SPI) += lsm303d_spi.o
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/Kconfig b/drivers/input/misc/st/ecompass/lsm303dlhc/Kconfig
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,15 @@
+
+config INPUT_LSM303DLHC
+         tristate "STM LSM303DLHC sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LSM303DLHC_I2C if (I2C)
+         help
+           This driver support the STMicroelectronics LSM303DLHC sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm303dlhc.
+
+config INPUT_LSM303DLHC_I2C
+         tristate
+         depends on INPUT_LSM303DLHC
+         depends on I2C
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc.c b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc.c
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,1360 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name	: lsm303dlhc_acc.c
+ * Authors	: MSH - Motion Mems BU - Application Team
+ *		: Matteo Dameno (matteo.dameno@st.com)
+ *		: Denis Ciocca (denis.ciocca@st.com)
+ *		: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+ *		: Authors are willing to be considered the contact
+ *		: and update points for the driver.
+ * Version	: V.1.0.13
+ * Date		: 2016/May/19
+ * Description	: LSM303DLHC accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ ******************************************************************************
+ Revision 1.0.6 15/11/2010
+  first revision
+  supports sysfs;
+  no more support for ioctl;
+ Revision 1.0.7 26/11/2010
+  checks for availability of interrupts pins
+  correction on FUZZ and FLAT values;
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7
+ Revision 1.0.9: 2011/May/23
+  update_odr func correction;
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ Revision 1.0.12.1: 2012/May/29
+  modified some defines;
+ Revision 1.0.13: 2012/Jun/30
+  mag: corrects saturation code management;
+  mag: changes sysfs range input commands to decimal mGauss;
+ ******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lsm303dlhc.h"
+
+
+#define SENSITIVITY_2G		1	/**	mg/LSB	*/
+#define SENSITIVITY_4G		2	/**	mg/LSB	*/
+#define SENSITIVITY_8G		4	/**	mg/LSB	*/
+#define SENSITIVITY_16G		12	/**	mg/LSB	*/
+
+/* Accelerometer Sensor Operating Mode */
+#define LSM303DLHC_ACC_ENABLE	(0x01)
+#define LSM303DLHC_ACC_DISABLE	(0x00)
+
+#define	HIGH_RESOLUTION		(0x08)
+
+#define	AXISDATA_REG		(0x28)
+#define WHOAMI_LSM303DLHC_ACC	(0x33)	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define WHO_AM_I		(0x0F)	/*	WhoAmI register		*/
+#define	TEMP_CFG_REG		(0x1F)	/*	temper sens control reg	*/
+/* ctrl 1: ODR3 ODR2 ODR ODR0 LPen Zenable Yenable Zenable */
+#define	CTRL_REG1		(0x20)	/*	control reg 1		*/
+#define	CTRL_REG2		(0x21)	/*	control reg 2		*/
+#define	CTRL_REG3		(0x22)	/*	control reg 3		*/
+#define	CTRL_REG4		(0x23)	/*	control reg 4		*/
+#define	CTRL_REG5		(0x24)	/*	control reg 5		*/
+#define	CTRL_REG6		(0x25)	/*	control reg 6		*/
+
+#define	FIFO_CTRL_REG		(0x2E)	/*	FiFo control reg	*/
+
+#define	INT_CFG1		(0x30)	/*	interrupt 1 config	*/
+#define	INT_SRC1		(0x31)	/*	interrupt 1 source	*/
+#define	INT_THS1		(0x32)	/*	interrupt 1 threshold	*/
+#define	INT_DUR1		(0x33)	/*	interrupt 1 duration	*/
+
+
+#define	TT_CFG			(0x38)	/*	tap config		*/
+#define	TT_SRC			(0x39)	/*	tap source		*/
+#define	TT_THS			(0x3A)	/*	tap threshold		*/
+#define	TT_LIM			(0x3B)	/*	tap time limit		*/
+#define	TT_TLAT			(0x3C)	/*	tap time latency	*/
+#define	TT_TW			(0x3D)	/*	tap time window		*/
+/*	end CONTROL REGISTRES	*/
+
+#define ENABLE_HIGH_RESOLUTION	1
+#define ALL_ZEROES		(0x00)
+
+#define LSM303DLHC_ACC_PM_OFF		(0x00)
+#define LSM303DLHC_ACC_ENABLE_ALL_AXES	(0x07)
+
+#define PMODE_MASK		(0x08)
+#define ODR_MASK		(0XF0)
+
+#define LSM303DLHC_ACC_ODR1	(0x10)  /* 1Hz output data rate */
+#define LSM303DLHC_ACC_ODR10	(0x20)  /* 10Hz output data rate */
+#define LSM303DLHC_ACC_ODR25	(0x30)  /* 25Hz output data rate */
+#define LSM303DLHC_ACC_ODR50	(0x40)  /* 50Hz output data rate */
+#define LSM303DLHC_ACC_ODR100	(0x50)  /* 100Hz output data rate */
+#define LSM303DLHC_ACC_ODR200	(0x60)  /* 200Hz output data rate */
+#define LSM303DLHC_ACC_ODR400	(0x70)  /* 400Hz output data rate */
+#define LSM303DLHC_ACC_ODR1250	(0x90)  /* 1250Hz output data rate */
+
+
+#define	IA			(0x40)
+#define	ZH			(0x20)
+#define	ZL			(0x10)
+#define	YH			(0x08)
+#define	YL			(0x04)
+#define	XH			(0x02)
+#define	XL			(0x01)
+/* */
+/* CTRL REG BITS*/
+#define	CTRL_REG3_I1_AOI1	(0x40)
+#define	CTRL_REG4_BDU_ENABLE	(0x80)
+#define	CTRL_REG4_BDU_MASK	(0x80)
+#define	CTRL_REG6_I2_TAPEN	(0x80)
+#define	CTRL_REG6_HLACTIVE	(0x02)
+/* */
+#define NO_MASK			(0xFF)
+#define INT1_DURATION_MASK	(0x7F)
+#define	INT1_THRESHOLD_MASK	(0x7F)
+#define TAP_CFG_MASK		(0x3F)
+#define	TAP_THS_MASK		(0x7F)
+#define	TAP_TLIM_MASK		(0x7F)
+#define	TAP_TLAT_MASK		NO_MASK
+#define	TAP_TW_MASK		NO_MASK
+
+
+/* TAP_SOURCE_REG BIT */
+#define	DTAP			(0x20)
+#define	STAP			(0x10)
+#define	SIGNTAP			(0x08)
+#define	ZTAP			(0x04)
+#define	YTAP			(0x02)
+#define	XTAZ			(0x01)
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+
+/* end RESUME STATE INDICES */
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lsm303dlhc_acc_odr_table[] = {
+	{    1, LSM303DLHC_ACC_ODR1250 },
+	{    3, LSM303DLHC_ACC_ODR400  },
+	{    5, LSM303DLHC_ACC_ODR200  },
+	{   10, LSM303DLHC_ACC_ODR100  },
+	{   20, LSM303DLHC_ACC_ODR50   },
+	{   40, LSM303DLHC_ACC_ODR25   },
+	{  100, LSM303DLHC_ACC_ODR10   },
+	{ 1000, LSM303DLHC_ACC_ODR1    },
+};
+
+static int int1_gpio = LSM303DLHC_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LSM303DLHC_ACC_DEFAULT_INT2_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+module_param(int2_gpio, int, S_IRUGO);
+
+static struct lsm303dlhc_acc_platform_data
+						default_lsm303dlhc_acc_pdata = {
+	.fs_range = LSM303DLHC_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LSM303DLHC_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LSM303DLHC_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LSM303DLHC_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lsm303dlhc_acc_hw_init(struct lsm303dlhc_acc_status *stat)
+{
+	int err = -1;
+	u8 buf[5];
+
+	pr_info("%s: hw init start\n", LSM303DLHC_ACC_DEV_NAME);
+
+	err = stat->tf->read(stat->dev, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I: is "
+				"device available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+	
+	if (buf[0] != WHOAMI_LSM303DLHC_ACC) {
+		dev_err(stat->dev,
+			"device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_LSM303DLHC_ACC, buf[0]);
+			err = -1; /* choose the right coded error */
+			goto err_unknown_device;
+	}
+
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TEMP_CFG_REG];
+	err = stat->tf->write(stat->dev, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_THS];
+	buf[1] = stat->resume_state[RES_TT_LIM];
+	buf[2] = stat->resume_state[RES_TT_TLAT];
+	buf[3] = stat->resume_state[RES_TT_TW];
+	err = stat->tf->write(stat->dev, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_TT_CFG];
+	err = stat->tf->write(stat->dev, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_THS1];
+	buf[1] = stat->resume_state[RES_INT_DUR1];
+	err = stat->tf->write(stat->dev, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG1];
+	err = stat->tf->write(stat->dev, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	buf[3] = stat->resume_state[RES_CTRL_REG5];
+	buf[4] = stat->resume_state[RES_CTRL_REG6];
+	err = stat->tf->write(stat->dev, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LSM303DLHC_ACC_DEV_NAME);
+	return 0;
+
+err_firstread:
+	stat->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+			buf[1], err);
+	return err;
+}
+
+static void lsm303dlhc_acc_device_power_off(struct lsm303dlhc_acc_status *stat)
+{
+	int err;
+	u8 buf[1] = { LSM303DLHC_ACC_PM_OFF };
+
+	err = stat->tf->write(stat->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off) {
+		if(stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if(stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+	if (stat->hw_initialized) {
+		if(stat->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(stat->irq1);
+		if(stat->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(stat->irq2);
+		stat->hw_initialized = 0;
+	}
+
+}
+
+static int lsm303dlhc_acc_device_power_on(struct lsm303dlhc_acc_status *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+					"power_on failed: %d\n", err);
+			return err;
+		}
+		if(stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if(stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+	if (!stat->hw_initialized) {
+		err = lsm303dlhc_acc_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lsm303dlhc_acc_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		if(stat->pdata->gpio_int1 >= 0)
+			enable_irq(stat->irq1);
+		if(stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+	return 0;
+}
+
+static irqreturn_t lsm303dlhc_acc_isr1(int irq, void *dev)
+{
+	struct lsm303dlhc_acc_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq1_work_queue, &stat->irq1_work);
+	pr_debug("%s: isr1 queued\n", LSM303DLHC_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lsm303dlhc_acc_isr2(int irq, void *dev)
+{
+	struct lsm303dlhc_acc_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s: isr2 queued\n", LSM303DLHC_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm303dlhc_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct lsm303dlhc_acc_status *stat =
+	container_of(work, struct lsm303dlhc_acc_status, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303dlhc_acc_get_int1_source(stat); */
+	/* ; */
+	pr_debug("%s: IRQ1 triggered\n", LSM303DLHC_ACC_DEV_NAME);
+/* exit: */
+	enable_irq(stat->irq1);
+}
+
+static void lsm303dlhc_acc_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm303dlhc_acc_status *stat =
+	container_of(work, struct lsm303dlhc_acc_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm303dlhc_acc_get_tap_source(stat); */
+	/* ; */
+	pr_debug("%s: IRQ2 triggered\n", LSM303DLHC_ACC_DEV_NAME);
+/* exit: */
+	enable_irq(stat->irq2);
+}
+
+static int lsm303dlhc_acc_update_fs_range(struct lsm303dlhc_acc_status *stat,
+							u8 new_fs_range)
+{
+	int err=-1;
+
+	u8 sensitivity;
+	u8 buf[2];
+	u8 updated_val;
+	u8 init_val;
+	u8 new_val;
+	u8 mask = LSM303DLHC_ACC_FS_MASK | HIGH_RESOLUTION;
+
+	switch (new_fs_range) {
+	case LSM303DLHC_ACC_G_2G:
+
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LSM303DLHC_ACC_G_4G:
+
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LSM303DLHC_ACC_G_8G:
+
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case LSM303DLHC_ACC_G_16G:
+
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid fs range requested: %u\n",
+				new_fs_range);
+		return -EINVAL;
+	}
+
+
+	/* Updates configuration register 4,
+	* which contains fs range setting */
+	err = stat->tf->read(stat->dev, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+	init_val = buf[0];
+	stat->resume_state[RES_CTRL_REG4] = init_val;
+	new_val = new_fs_range | HIGH_RESOLUTION;
+	updated_val = ((mask & new_val) | ((~mask) & init_val));
+
+	buf[0] = updated_val;
+	err = stat->tf->write(stat->dev, CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto error;
+	stat->resume_state[RES_CTRL_REG4] = updated_val;
+	stat->sensitivity = sensitivity;
+
+	return err;
+error:
+	dev_err(stat->dev,
+			"update fs range failed 0x%02x,0x%02x: %d\n",
+			buf[0], buf[1], err);
+
+	return err;
+}
+
+static int lsm303dlhc_acc_update_odr(struct lsm303dlhc_acc_status *stat,
+							int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 config[1];
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lsm303dlhc_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lsm303dlhc_acc_odr_table[i].cutoff_ms <= poll_interval_ms)
+								|| (i == 0))
+			break;
+	}
+
+	config[0] = lsm303dlhc_acc_odr_table[i].mask;
+	config[0] |= LSM303DLHC_ACC_ENABLE_ALL_AXES;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat->dev, CTRL_REG1, 1, config);
+		if (err < 0)
+			goto error;
+	}
+	stat->resume_state[RES_CTRL_REG1] = config[0];
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed 0x%02x: %d\n",
+		config[0], err);
+
+	return err;
+}
+
+
+
+static int lsm303dlhc_acc_register_write(struct lsm303dlhc_acc_status *stat,
+					u8 *buf, u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	int err;
+
+	mutex_lock(&stat->lock);
+	err = stat->tf->write(stat->dev, reg_address, 1, &new_value);
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+/*
+static int lsm303dlhc_acc_register_read(struct lsm303dlhc_acc_status *stat,
+							u8 *buf, u8 reg_address)
+{
+	return stat->tf->read(stat->dev, reg_address, 1, buf);
+}
+*/
+
+/*
+static int lsm303dlhc_acc_register_update(struct lsm303dlhc_acc_status *stat,
+		u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = lsm303dlhc_acc_register_read(stat, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[1];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = lsm303dlhc_acc_register_write(stat, buf, reg_address,
+				updated_val);
+	}
+	return err;
+}
+*/
+
+static int lsm303dlhc_acc_get_acceleration_data(struct lsm303dlhc_acc_status *stat,
+		int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat->dev, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+
+
+	hw_d[0] = hw_d[0] * stat->sensitivity;
+	hw_d[1] = hw_d[1] * stat->sensitivity;
+	hw_d[2] = hw_d[2] * stat->sensitivity;
+
+
+	xyz[0] = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+#ifdef LSM303DLHC_DEBUG
+/*
+	pr_debug("%s read x=%d, y=%d, z=%d\n",
+			LSM303DLHC_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+*/
+#endif
+	return err;
+}
+
+static void lsm303dlhc_acc_report_values(struct lsm303dlhc_acc_status *stat,
+					int *xyz)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(stat->input_dev);
+}
+
+int lsm303dlhc_acc_enable(struct lsm303dlhc_acc_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = lsm303dlhc_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+		schedule_delayed_work(&stat->input_work,
+			msecs_to_jiffies(stat->pdata->poll_interval));
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303dlhc_acc_enable);
+
+int lsm303dlhc_acc_disable(struct lsm303dlhc_acc_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&stat->input_work);
+
+		mutex_lock(&stat->lock);
+		lsm303dlhc_acc_device_power_off(stat);
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303dlhc_acc_disable);
+
+
+static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
+{
+	ssize_t ret;
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	int err;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	err = stat->tf->read(stat->dev, reg, 1, &data);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	ret = sprintf(buf, "0x%02x\n", data);
+	mutex_unlock(&stat->lock);
+
+	return ret;
+
+}
+
+static int write_reg(struct device *dev, const char *buf, u8 reg,
+		u8 mask, int resumeIndex)
+{
+	int err = -1;
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	u8 new_val;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	new_val=((u8) val & mask);
+	x[0] = reg;
+	x[1] = new_val;
+	err = lsm303dlhc_acc_register_write(stat, x,reg,new_val);
+	if (err < 0)
+		return err;
+	stat->resume_state[resumeIndex] = new_val;
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = max((unsigned int)interval_ms,stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	lsm303dlhc_acc_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	char val;
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	char range = 2;
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range ;
+	switch (val) {
+	case LSM303DLHC_ACC_G_2G:
+		range = 2;
+		break;
+	case LSM303DLHC_ACC_G_4G:
+		range = 4;
+		break;
+	case LSM303DLHC_ACC_G_8G:
+		range = 8;
+		break;
+	case LSM303DLHC_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM303DLHC_ACC_G_2G;
+		break;
+	case 4:
+		range = LSM303DLHC_ACC_G_4G;
+		break;
+	case 8:
+		range = LSM303DLHC_ACC_G_8G;
+		break;
+	case 16:
+		range = LSM303DLHC_ACC_G_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+				" discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm303dlhc_acc_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303dlhc_acc_enable(stat);
+	else
+		lsm303dlhc_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev,buf,INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev,buf, INT_THS1, INT1_THRESHOLD_MASK,RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev,buf,INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev,buf,INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+
+#ifdef LSM303DLHC_DEBUG
+/* PAY ATTENTION: These LSM303DLHC_DEBUG functions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	/*TODO: error need to be managed */
+	rc = stat->tf->write(stat->dev, stat->reg_addr, 1, &(u8)val);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	rc = stat->tf->read(stat->dev, stat->reg_addr, 1, &data);
+	mutex_unlock(&stat->lock);
+
+	/*TODO: error need to be managed */
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm303dlhc_acc_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	stat->reg_addr = val;
+	mutex_unlock(&stat->lock);
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+							attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+
+#ifdef LSM303DLHC_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void lsm303dlhc_acc_input_work_func(struct work_struct *work)
+{
+	struct lsm303dlhc_acc_status *stat;
+
+	int xyz[3] = { 0 };
+	int err;
+
+	stat = container_of((struct delayed_work *)work,
+			struct lsm303dlhc_acc_status, input_work);
+
+	mutex_lock(&stat->lock);
+	err = lsm303dlhc_acc_get_acceleration_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_acceleration_data failed\n");
+	else
+		lsm303dlhc_acc_report_values(stat, xyz);
+		
+	schedule_delayed_work(&stat->input_work, msecs_to_jiffies(
+			stat->pdata->poll_interval));
+	mutex_unlock(&stat->lock);
+}
+
+static int lsm303dlhc_acc_validate_pdata(struct lsm303dlhc_acc_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int)LSM303DLHC_ACC_MIN_POLL_PERIOD_MS,
+						stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+			stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+		stat->pdata->axis_map_y > 2 ||
+		 stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", stat->pdata->axis_map_x,
+					stat->pdata->axis_map_y,
+						stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1
+			|| stat->pdata->negate_z > 1) {
+		dev_err(stat->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", stat->pdata->negate_x,
+				stat->pdata->negate_y, stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lsm303dlhc_acc_input_init(struct lsm303dlhc_acc_status *stat)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&stat->input_work, lsm303dlhc_acc_input_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev->name = LSM303DLHC_ACC_DEV_NAME;
+	/* stat->input_dev->name = "accelerometer"; */
+	stat->input_dev->id.bustype = stat->bus_type;
+	stat->input_dev->dev.parent = stat->dev;
+
+	input_set_drvdata(stat->input_dev, stat);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+				"unable to register input device %s\n",
+				stat->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev);
+err0:
+	return err;
+}
+
+static void lsm303dlhc_acc_input_cleanup(struct lsm303dlhc_acc_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+int lsm303dlhc_acc_probe(struct lsm303dlhc_acc_status *stat)
+{
+
+	int err = -1;
+
+#ifdef LSM303DLHC_DEBUG
+	dev_info(stat->dev, "probe start.\n");
+#endif
+
+	mutex_lock(&stat->lock);
+
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+				"failed to allocate memory for pdata: %d\n",
+				err);
+		goto err_mutexunlock;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_lsm303dlhc_acc_pdata.gpio_int1 = int1_gpio;
+		default_lsm303dlhc_acc_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_lsm303dlhc_acc_pdata,
+							sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+							sizeof(*stat->pdata));
+	}
+
+	err = lsm303dlhc_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if(stat->pdata->gpio_int1 >= 0){
+		stat->irq1 = gpio_to_irq(stat->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, "
+							"mapped on gpio:%d\n",
+			LSM303DLHC_ACC_DEV_NAME, __func__, stat->irq1,
+							stat->pdata->gpio_int1);
+	}
+
+	if(stat->pdata->gpio_int2 >= 0){
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d, "
+							"mapped on gpio:%d\n",
+			LSM303DLHC_ACC_DEV_NAME, __func__, stat->irq2,
+							stat->pdata->gpio_int2);
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = (ALL_ZEROES |
+					LSM303DLHC_ACC_ENABLE_ALL_AXES);
+	stat->resume_state[RES_CTRL_REG4] = (ALL_ZEROES | CTRL_REG4_BDU_ENABLE);
+
+/*
+	stat->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG4] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG6] = ALL_ZEROES;
+
+	stat->resume_state[RES_TEMP_CFG_REG] = ALL_ZEROES;
+	stat->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+	stat->resume_state[RES_INT_CFG1] = ALL_ZEROES;
+	stat->resume_state[RES_INT_THS1] = ALL_ZEROES;
+	stat->resume_state[RES_INT_DUR1] = ALL_ZEROES;
+
+	stat->resume_state[RES_TT_CFG] = ALL_ZEROES;
+	stat->resume_state[RES_TT_THS] = ALL_ZEROES;
+	stat->resume_state[RES_TT_LIM] = ALL_ZEROES;
+	stat->resume_state[RES_TT_TLAT] = ALL_ZEROES;
+	stat->resume_state[RES_TT_TW] = ALL_ZEROES;
+*/
+
+	err = lsm303dlhc_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lsm303dlhc_acc_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303dlhc_acc_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm303dlhc_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+		   "device LSM303DLHC_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+
+	lsm303dlhc_acc_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if(stat->pdata->gpio_int1 >= 0){
+		INIT_WORK(&stat->irq1_work, lsm303dlhc_acc_irq1_work_func);
+		stat->irq1_work_queue =
+			create_singlethread_workqueue("lsm303dlhc_acc_wq1");
+		if (!stat->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(stat->irq1, lsm303dlhc_acc_isr1,
+			IRQF_TRIGGER_RISING, "lsm303dlhc_acc_irq1", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(stat->irq1);
+	}
+
+	if(stat->pdata->gpio_int2 >= 0){
+		INIT_WORK(&stat->irq2_work, lsm303dlhc_acc_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("lsm303dlhc_acc_wq2");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev,
+					"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(stat->irq2, lsm303dlhc_acc_isr2,
+			IRQF_TRIGGER_RISING, "lsm303dlhc_acc_irq2", stat);
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+#ifdef LSM303DLHC_DEBUG
+	dev_info(stat->dev, "%s: probed\n", LSM303DLHC_ACC_DEV_NAME);
+#endif
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(stat->pdata->gpio_int2 >= 0)
+		destroy_workqueue(stat->irq2_work_queue);
+err_free_irq1:
+	free_irq(stat->irq1, stat);
+err_destoyworkqueue1:
+	if(stat->pdata->gpio_int1 >= 0)
+		destroy_workqueue(stat->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(stat->dev);
+err_input_cleanup:
+	lsm303dlhc_acc_input_cleanup(stat);
+err_power_off:
+	lsm303dlhc_acc_device_power_off(stat);
+err_pdata_init:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm303dlhc_acc_probe);
+
+int lsm303dlhc_acc_remove(struct lsm303dlhc_acc_status *stat)
+{
+	if(stat->pdata->gpio_int1 >= 0){
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+
+	if(stat->pdata->gpio_int2 >= 0){
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lsm303dlhc_acc_input_cleanup(stat);
+	lsm303dlhc_acc_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303dlhc_acc_remove);
+
+MODULE_DESCRIPTION("lsm303dlhc accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc_i2c.c b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_acc_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm303dlhc_acc_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303dlhc.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold stat->lock */
+static int lsm303dlhc_acc_i2c_read(struct device *dev, u8 addr, int len,
+				   u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold stat->lock */
+static int lsm303dlhc_acc_i2c_write(struct device *dev, u8 addr, int len,
+				    u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm303dlhc_transfer_function lsm303dlhc_acc_i2c_tf = {
+	.write = lsm303dlhc_acc_i2c_write,
+	.read = lsm303dlhc_acc_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303dlhc_acc_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303dlhc_acc_status *stat = i2c_get_clientdata(client);
+
+	return lsm303dlhc_acc_enable(stat);
+}
+
+static int lsm303dlhc_acc_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303dlhc_acc_status *stat = i2c_get_clientdata(client);
+
+	return lsm303dlhc_acc_disable(stat);
+}
+
+static const struct dev_pm_ops lsm303dlhc_acc_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303dlhc_acc_i2c_suspend,
+				lsm303dlhc_acc_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303dlhc_acc_i2c_id_table[] = {
+	{ .compatible = "st,lsm303d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303dlhc_acc_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303dlhc_acc_i2c_probe(struct i2c_client *client,
+				    const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303dlhc_acc_status *stat;
+
+#ifdef lsm303dlhc_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct lsm303dlhc_acc_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bus_type = BUS_I2C;
+	stat->tf = &lsm303dlhc_acc_i2c_tf;
+
+	i2c_set_clientdata(client, stat);
+
+	mutex_init(&stat->lock);
+
+	err = lsm303dlhc_acc_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303dlhc_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303dlhc_acc_status *stat = i2c_get_clientdata(client);
+
+#ifdef lsm303dlhc_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303dlhc_acc_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303dlhc_acc_i2c_id[] = {
+	{ "lsm303dlhc_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303dlhc_acc_i2c_id);
+
+static struct i2c_driver lsm303dlhc_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303dlhc_acc_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303dlhc_acc_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303dlhc_acc_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303dlhc_acc_i2c_probe,
+	.remove = lsm303dlhc_acc_i2c_remove,
+	.id_table = lsm303dlhc_acc_i2c_id,
+};
+
+module_i2c_driver(lsm303dlhc_acc_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303dlhc acc i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc.h b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc.h
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,252 @@
+
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm303dlhc_sysfs.h
+* Authors            : MH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Carmine Iascone (carmine.iascone@st.com)
+* Version            : V.1.0.13
+* Date               : 2012/Jun/30
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+Revision 1-0-6 10/11/2010
+	ioclt not supported
+	sysfs support
+Revision 1-0-7 26/11/2010
+	moved to input/misc
+	manages use/non-use of interrupts on accelerometer side
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7 acc side
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7 acc side
+ Revision 1.0.9: 2011/May/23
+	SLEEP_MODE correction; update_odr correction; get/set_polling_rate corr.
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ Revision 1.0.12.1: 2012/May/29
+  renamed field g_range to fs_range in lsm303dlhc_acc_platform_data
+  replaced defines SA0L and SA0H with LSM303DLHC_SAD0x
+ Revision 1.0.13: 2012/Jun/30
+  mag: corrects saturation code management;
+  mag: changes sysfs range input commands to decimal mGauss;
+*******************************************************************************/
+
+#ifndef	__LSM303DLHC_H__
+#define	__LSM303DLHC_H__
+
+
+#define	LSM303DLHC_ACC_DEV_NAME		"lsm303dlhc_acc"
+#define LSM303DLHC_MAG_DEV_NAME		"lsm303dlhc_mag"
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+#define	LSM303DLHC_ACC_MIN_POLL_PERIOD_MS	1
+
+
+/************************************************/
+/* 	Magnetometer section defines	 	*/
+/************************************************/
+
+#define LSM303DLHC_MAG_MIN_POLL_PERIOD_MS	5
+
+/* Magnetometer Sensor Full Scale */
+#define LSM303DLHC_H_1_3G		(0x20)
+#define LSM303DLHC_H_1_9G		(0x40)
+#define LSM303DLHC_H_2_5G		(0x60)
+#define LSM303DLHC_H_4_0G		(0x80)
+#define LSM303DLHC_H_4_7G		(0xA0)
+#define LSM303DLHC_H_5_6G		(0xC0)
+#define LSM303DLHC_H_8_1G		(0xE0)
+
+#define LSM303DLHC_SAD0L		(0x00)
+#define LSM303DLHC_SAD0H		(0x01)
+
+/* magnetometer section */
+#define LSM303DLHC_MAG_I2C_SAD		(0x1E)
+
+/* Magnetic Sensor Operating Mode */
+#define LSM303DLHC_MAG_NORMAL_MODE	(0x00)
+#define LSM303DLHC_MAG_POS_BIAS		(0x01)
+#define LSM303DLHC_MAG_NEG_BIAS		(0x02)
+#define LSM303DLHC_MAG_CC_MODE		(0x00)
+#define LSM303DLHC_MAG_SC_MODE		(0x01)
+#define LSM303DLHC_MAG_SLEEP_MODE	(0x03)
+
+
+/* acc section */
+#define LSM303DLHC_ACC_I2C_SADROOT		(0x0C)
+/* I2C address if acc SA0 pin to GND */
+#define LSM303DLHC_ACC_I2C_SAD_L		((LSM303DLHC_ACC_I2C_SADROOT<<1)| \
+							LSM303DLHC_SAD0L)
+/* I2C address if acc SA0 pin to Vdd */
+#define LSM303DLHC_ACC_I2C_SAD_H		((LSM303DLHC_ACC_I2C_SADROOT<<1)| \
+							LSM303DLHC_SAD0H)
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones havew to be set to -EINVAL
+ */
+#define LSM303DLHC_ACC_DEFAULT_INT1_GPIO	(-EINVAL)
+#define LSM303DLHC_ACC_DEFAULT_INT2_GPIO	(-EINVAL)
+
+/* Accelerometer Sensor Full Scale */
+#define	LSM303DLHC_ACC_FS_MASK		(0x30)
+#define LSM303DLHC_ACC_G_2G		(0x00)
+#define LSM303DLHC_ACC_G_4G		(0x10)
+#define LSM303DLHC_ACC_G_8G		(0x20)
+#define LSM303DLHC_ACC_G_16G		(0x30)
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+
+struct lsm303dlhc_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+struct lsm303dlhc_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+#define	LSM303DLHC_ACC_RESUME_ENTRIES		17
+
+struct lsm303dlhc_acc_status {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	struct lsm303dlhc_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+
+	u8 sensitivity;
+
+	u8 resume_state[LSM303DLHC_ACC_RESUME_ENTRIES];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef LSM303DLHC_DEBUG
+	u8 reg_addr;
+#endif
+	struct lsm303dlhc_transfer_function *tf;
+};
+
+struct lsm303dlhc_mag_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+};
+
+struct lsm303dlhc_mag_status {
+	const char *name;
+	struct device *dev;
+	u16 bus_type;
+	struct lsm303dlhc_mag_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	atomic_t enabled;
+
+	u16 xy_sensitivity;
+	u16 z_sensitivity;
+
+	u8 reg_addr;
+	u8 resume_state[3];
+
+	struct lsm303dlhc_transfer_function *tf;
+};
+
+
+int lsm303dlhc_acc_enable(struct lsm303dlhc_acc_status *stat);
+int lsm303dlhc_acc_disable(struct lsm303dlhc_acc_status *stat);
+int lsm303dlhc_acc_probe(struct lsm303dlhc_acc_status *stat);
+int lsm303dlhc_acc_remove(struct lsm303dlhc_acc_status *stat);
+
+int lsm303dlhc_mag_probe(struct lsm303dlhc_mag_status *stat);
+int lsm303dlhc_mag_remove(struct lsm303dlhc_mag_status *stat);
+int lsm303dlhc_mag_enable(struct lsm303dlhc_mag_status *stat);
+int lsm303dlhc_mag_disable(struct lsm303dlhc_mag_status *stat);
+
+#endif	/* __LSM303DLHC_H__ */
+
+
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag.c b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag.c
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,857 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lsm303dlhc_mag_sys.c
+* Authors	: MSH - Motion Mems BU - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Denis Ciocca (denis.ciocca@st.com)
+*		: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*		: Authors are willing to be considered the contact
+*		: and update points for the driver.*
+* Version	: V.1.0.13
+* Date		: 2016/May/19
+* Description	: LSM303DLHC 6D module sensor device driver sysfs
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+ Revision 1.0.7: 2010/Nov/22
+  corrects bug in enable/disable of polling polled device;
+ Revision 1.0.9: 2011/May/23
+  SLEEP_MODE correction; update_odr func correct.; get/set_polling_rate f. corr.
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c; sensitivities correction;
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct;
+ Revision 1.0.13: 2012/Jun/30
+  mag: corrects saturation code management;
+  mag: changes sysfs range input commands to decimal mGauss;
+*******************************************************************************/
+
+#include <linux/mutex.h>
+#include <linux/input-polldev.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lsm303dlhc.h"
+
+/* Magnetometer registers */
+#define CRA_REG_M		(0x00)	/* Configuration register A */
+#define CRB_REG_M		(0x01)	/* Configuration register B */
+#define MR_REG_M		(0x02)	/* Mode register */
+
+/* resume state index */
+#define RES_CRA_REG_M		0	/* Configuration register A */
+#define RES_CRB_REG_M		1	/* Configuration register B */
+#define RES_MR_REG_M		2	/* Mode register */
+
+/* Output register start address*/
+#define OUT_X_M			(0x03)
+
+/* Magnetic Sensor Operation Mode */
+#define NORMAL_MODE		(0x00)
+#define POS_BIAS		(0x01)
+#define NEG_BIAS		(0x02)
+#define CC_MODE			(0x00)
+#define SC_MODE			(0x01)
+#define SLEEP_MODE		(0x03)
+
+/* Magnetometer X-Y sensitivity as [digit/Gauss] see Datasheet */
+#define XY_SENSITIVITY_1_3	1100	/* XY sensitivity at 1.3G */
+#define XY_SENSITIVITY_1_9	 855	/* XY sensitivity at 1.9G */
+#define XY_SENSITIVITY_2_5	 670	/* XY sensitivity at 2.5G */
+#define XY_SENSITIVITY_4_0	 450	/* XY sensitivity at 4.0G */
+#define XY_SENSITIVITY_4_7	 400	/* XY sensitivity at 4.7G */
+#define XY_SENSITIVITY_5_6	 330	/* XY sensitivity at 5.6G */
+#define XY_SENSITIVITY_8_1	 230	/* XY sensitivity at 8.1G */
+
+/* Magnetometer Z sensitivity as [digit/Gauss] see Datasheet */
+#define Z_SENSITIVITY_1_3	 980	/* Z sensitivity at 1.3G */
+#define Z_SENSITIVITY_1_9	 760	/* Z sensitivity at 1.9G */
+#define Z_SENSITIVITY_2_5	 600	/* Z sensitivity at 2.5G */
+#define Z_SENSITIVITY_4_0	 400	/* Z sensitivity at 4.0G */
+#define Z_SENSITIVITY_4_7	 355	/* Z sensitivity at 4.7G */
+#define Z_SENSITIVITY_5_6	 295	/* Z sensitivity at 5.6G */
+#define Z_SENSITIVITY_8_1	 205	/* Z sensitivity at 8.1G */
+
+/* Magnetometer output data rate  */
+#define LSM303DLHC_MAG_ODR_75		(0x00)	/* 0.75Hz output data rate */
+#define LSM303DLHC_MAG_ODR1_5		(0x04)	/* 1.5Hz output data rate */
+#define LSM303DLHC_MAG_ODR3_0		(0x08)	/* 3Hz output data rate */
+#define LSM303DLHC_MAG_ODR7_5		(0x0C)	/* 7.5Hz output data rate */
+#define LSM303DLHC_MAG_ODR15		(0x10)	/* 15Hz output data rate */
+#define LSM303DLHC_MAG_ODR30		(0x14)	/* 30Hz output data rate */
+#define LSM303DLHC_MAG_ODR75		(0x18)	/* 75Hz output data rate */
+#define LSM303DLHC_MAG_ODR220		(0x1C)	/* 220Hz output data rate */
+
+/* Used to Manage Output saturation Code */
+#define SATURATION_CODE		-4096
+#define MAX_POS_RAW_OUTPUT	+2047
+#define MAX_NEG_RAW_OUTPUT	-2048
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+	{	LSM303DLHC_MAG_MIN_POLL_PERIOD_MS,	LSM303DLHC_MAG_ODR220},
+	{	14,	LSM303DLHC_MAG_ODR75},
+	{	34,	LSM303DLHC_MAG_ODR30},
+	{	67,	LSM303DLHC_MAG_ODR15},
+	{	134,	LSM303DLHC_MAG_ODR7_5},
+	{	334,	LSM303DLHC_MAG_ODR3_0},
+	{	667,	LSM303DLHC_MAG_ODR1_5},
+	{	1334,	LSM303DLHC_MAG_ODR_75},
+};
+
+static const struct lsm303dlhc_mag_platform_data default_lsm303dlhc_mag_pdata = {
+	.poll_interval = 100,
+	.min_interval = LSM303DLHC_MAG_MIN_POLL_PERIOD_MS,
+	.fs_range = LSM303DLHC_H_1_3G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+};
+
+int lsm303dlhc_mag_update_fs_range(struct lsm303dlhc_mag_status *stat,
+								u8 new_fs_range)
+{
+	int err = -1;
+	u8 buf[1];
+
+	switch (new_fs_range) {
+	case LSM303DLHC_H_1_3G:
+		stat->xy_sensitivity = XY_SENSITIVITY_1_3;
+		stat->z_sensitivity = Z_SENSITIVITY_1_3;
+		break;
+	case LSM303DLHC_H_1_9G:
+		stat->xy_sensitivity = XY_SENSITIVITY_1_9;
+		stat->z_sensitivity = Z_SENSITIVITY_1_9;
+		break;
+	case LSM303DLHC_H_2_5G:
+		stat->xy_sensitivity = XY_SENSITIVITY_2_5;
+		stat->z_sensitivity = Z_SENSITIVITY_2_5;
+		break;
+	case LSM303DLHC_H_4_0G:
+		stat->xy_sensitivity = XY_SENSITIVITY_4_0;
+		stat->z_sensitivity = Z_SENSITIVITY_4_0;
+		break;
+	case LSM303DLHC_H_4_7G:
+		stat->xy_sensitivity = XY_SENSITIVITY_4_7;
+		stat->z_sensitivity = Z_SENSITIVITY_4_7;
+		break;
+	case LSM303DLHC_H_5_6G:
+		stat->xy_sensitivity = XY_SENSITIVITY_5_6;
+		stat->z_sensitivity = Z_SENSITIVITY_5_6;
+		break;
+	case LSM303DLHC_H_8_1G:
+		stat->xy_sensitivity = XY_SENSITIVITY_8_1;
+		stat->z_sensitivity = Z_SENSITIVITY_8_1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (atomic_read(&stat->enabled)) {
+		buf[0] = new_fs_range;
+		err = stat->tf->write(stat->dev, CRB_REG_M, 1, buf);
+		if (err < 0)
+			return err;
+		stat->resume_state[RES_CRB_REG_M] = new_fs_range;
+	}
+
+	return 0;
+}
+
+int lsm303dlhc_mag_update_odr(struct lsm303dlhc_mag_status *stat,
+							int poll_interval)
+{
+	int err = -1;
+	int i;
+	u8 config[0];
+
+	for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+		if ((odr_table[i].poll_rate_ms <= poll_interval)
+							|| (i == 0))
+			break;
+	}
+
+	config[0] = odr_table[i].mask;
+	config[0] |= NORMAL_MODE;
+
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat->dev, CRA_REG_M, 1, config);
+		if (err < 0)
+			return err;
+		stat->resume_state[RES_CRA_REG_M] = config[0];
+	}
+
+	return 0;
+}
+
+static int lsm303dlhc_mag_get_data(struct lsm303dlhc_mag_status *stat,
+					       int *xyz)
+{
+	static int prev_sign_x = 1;
+	static int prev_sign_y = 1;
+	static int prev_sign_z = 1;
+
+	int err = -1;
+	/* Data bytes from hardware HxL, HxH, HyL, HyH, HzL, HzH */
+	u8 mag_data[6];
+	/* x,y,z hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat->dev, OUT_X_M, 6, mag_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s32) (s16)((u16)((mag_data[0]) << 8) | mag_data[1]);
+	hw_d[1] = (s32) (s16)((u16)((mag_data[4]) << 8) | mag_data[5]);
+	hw_d[2] = (s32) (s16)((u16)((mag_data[2]) << 8) | mag_data[3]);
+
+#ifdef LSM303DLHC_DEBUG
+	pr_debug("%s %s read x=0x%02x 0x%02x (regH regL), x=%d (dec) [LSB]\n",
+		LSM303DLHC_MAG_DEV_NAME, __func__, mag_data[0], mag_data[1], hw_d[0]);
+	pr_debug("%s %s read y=0x%02x 0x%02x (regH regL), y=%d (dec) [LSB]\n",
+		LSM303DLHC_MAG_DEV_NAME, __func__, mag_data[4], mag_data[5], hw_d[1]);
+	pr_debug("%s %s read z=0x%02x 0x%02x (regH regL), z=%d (dec) [LSB]\n",
+		LSM303DLHC_MAG_DEV_NAME, __func__, mag_data[2], mag_data[3], hw_d[2]);
+#endif
+
+	if (hw_d[0] != SATURATION_CODE){
+		if (hw_d[0] < 0)
+			prev_sign_x = -1;
+		else
+			prev_sign_x = 1;
+	} else  {
+		if (prev_sign_x == -1) hw_d[0] = MAX_NEG_RAW_OUTPUT;
+		else hw_d[0] = MAX_POS_RAW_OUTPUT;
+	}
+
+	if(hw_d[1] != SATURATION_CODE) {
+		if (hw_d[1] < 0)
+			prev_sign_y = -1;
+		else
+			prev_sign_y = 1;
+	} else  {
+		if (prev_sign_y == -1) hw_d[1] = MAX_NEG_RAW_OUTPUT;
+		else hw_d[1] = MAX_POS_RAW_OUTPUT;
+	}
+
+	if (hw_d[2] != SATURATION_CODE) {
+		if (hw_d[2] < 0)
+			prev_sign_z = -1;
+		else
+			prev_sign_z = 1;
+	} else  {
+		if (prev_sign_z == -1) hw_d[2] = MAX_NEG_RAW_OUTPUT;
+		else hw_d[2] = MAX_POS_RAW_OUTPUT;
+	}
+
+	hw_d[0] = hw_d[0] * 10000 / (stat->xy_sensitivity * 10);
+	hw_d[1] = hw_d[1] * 10000 / (stat->xy_sensitivity * 10);
+	hw_d[2] = hw_d[2] * 10000 / (stat->z_sensitivity * 10);
+
+#ifdef LSM303DLHC_DEBUG
+	pr_debug("%s %s read x=0x%02x 0x%02x (regH regL), sensitivity: %d, x=%d [mGauss]\n",
+		LSM303DLHC_MAG_DEV_NAME, __func__, mag_data[0], mag_data[1], stat->xy_sensitivity, hw_d[0]);
+	pr_debug("%s %s read y=0x%02x 0x%02x (regH regL), sensitivity: %d, y=%d [mGauss]\n",
+		LSM303DLHC_MAG_DEV_NAME, __func__, mag_data[4], mag_data[5], stat->xy_sensitivity, hw_d[1]);
+	pr_debug("%s %s read z=0x%02x 0x%02x (regH regL), sensitivity: %d, z=%d [mGauss]\n",
+		LSM303DLHC_MAG_DEV_NAME, __func__, mag_data[2], mag_data[3], stat->z_sensitivity, hw_d[2]);
+#endif /* LSM303DLHC_DEBUG */	
+
+	xyz[0] = ((stat->pdata->negate_x) ?
+				(-hw_d[stat->pdata->axis_map_x])
+		   			: (hw_d[stat->pdata->axis_map_x]));
+	xyz[1] = ((stat->pdata->negate_y) ?
+				(-hw_d[stat->pdata->axis_map_y])
+		   			: (hw_d[stat->pdata->axis_map_y]));
+	xyz[2] = ((stat->pdata->negate_z) ?
+				(-hw_d[stat->pdata->axis_map_z])
+		   			: (hw_d[stat->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void lsm303dlhc_mag_report_values(struct lsm303dlhc_mag_status *stat,
+					int *xyz)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(stat->input_dev);
+}
+
+static int lsm303dlhc_mag_hw_init(struct lsm303dlhc_mag_status *stat)
+{
+	int err = -1;
+	u8 buf[3];
+
+	buf[0] = stat->resume_state[RES_CRA_REG_M];
+	buf[1] = stat->resume_state[RES_CRB_REG_M];
+	buf[2] = stat->resume_state[RES_MR_REG_M];
+	err = stat->tf->write(stat->dev, CRA_REG_M, 3, buf);
+	if (err < 0)
+		return err;
+
+	stat->hw_initialized = 1;
+
+	return 0;
+}
+
+static void lsm303dlhc_mag_device_power_off(struct lsm303dlhc_mag_status *stat)
+{
+	int err;
+	u8 buf[1] = { SLEEP_MODE };
+
+	err = stat->tf->write(stat->dev, MR_REG_M, 1, buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed\n");
+
+	if (stat->pdata->power_off) {
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+}
+
+static int lsm303dlhc_mag_device_power_on(struct lsm303dlhc_mag_status *stat)
+{
+	int err;
+	u8 buf[1] = { NORMAL_MODE };
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0)
+			return err;
+	}
+
+	if (!stat->hw_initialized) {
+		err = lsm303dlhc_mag_hw_init(stat);
+		if (err < 0) {
+			lsm303dlhc_mag_device_power_off(stat);
+			return err;
+		}
+	} else {
+		err = stat->tf->write(stat->dev, MR_REG_M, 1, buf);
+	}
+
+	return 0;
+}
+
+int lsm303dlhc_mag_enable(struct lsm303dlhc_mag_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = lsm303dlhc_mag_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+		schedule_delayed_work(&stat->input_work,
+			msecs_to_jiffies(stat->pdata->poll_interval));
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303dlhc_mag_enable);
+
+int lsm303dlhc_mag_disable(struct lsm303dlhc_mag_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&stat->input_work);
+
+		mutex_lock(&stat->lock);
+		lsm303dlhc_mag_device_power_off(stat);
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm303dlhc_mag_disable);
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = max((unsigned int)interval_ms,stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	stat->pdata->poll_interval = interval_ms;
+	lsm303dlhc_mag_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	int range = 0;
+	u8 val;
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range;
+	dev_dbg(stat->dev, "%s, fs_range = 0x%02x", __func__, val);
+	switch (val) {
+	case LSM303DLHC_H_1_3G:
+		range = 1300;
+		break;
+	case LSM303DLHC_H_1_9G:
+		range = 1900;
+		break;
+	case LSM303DLHC_H_2_5G:
+		range = 2500;
+		break;
+	case LSM303DLHC_H_4_0G:
+		range = 4000;
+		break;
+	case LSM303DLHC_H_4_7G:
+		range = 4700;
+		break;
+	case LSM303DLHC_H_5_6G:
+		range = 5600;
+		break;
+	case LSM303DLHC_H_8_1G:
+		range = 8100;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	
+	return sprintf(buf, "%d mGauss\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 1300:
+		range = LSM303DLHC_H_1_3G;
+		break;
+	case 1900:
+		range = LSM303DLHC_H_1_9G;
+		break;
+	case 2500:
+		range = LSM303DLHC_H_2_5G;
+		break;
+	case 4000:
+		range = LSM303DLHC_H_4_0G;
+		break;
+	case 4700:
+		range = LSM303DLHC_H_4_7G;
+		break;
+	case 5600:
+		range = LSM303DLHC_H_5_6G;
+		break;
+	case 8100:
+		range = LSM303DLHC_H_8_1G;
+		break;
+	default:
+		dev_err(stat->dev, "magnetometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	dev_dbg(stat->dev, "%s, range = 0x%02x, val = %lu",
+		__func__, range, val);
+
+	mutex_lock(&stat->lock);
+	err = lsm303dlhc_mag_update_fs_range(stat, range);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+	stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "magnetometer range set to 0x%02x:"
+					" %lu mGauss\n", range, val);
+	return size;
+	
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm303dlhc_mag_enable(stat);
+	else
+		lsm303dlhc_mag_disable(stat);
+
+	return size;
+}
+
+#ifdef LSM303DLHC_DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	rc = stat->tf->write(stat->dev, stat->reg_addr, 1, &(u8)val);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t ret;
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	rc = stat->tf->read(stat->dev, stat->reg_addr, 1, &data);
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm303dlhc_mag_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+
+	stat->reg_addr = val;
+
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif /* LSM303DLHC_DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(range, 0666, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0666, attr_get_enable, attr_set_enable),
+#ifdef LSM303DLHC_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif /* LSM303DLHC_DEBUG */
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void lsm303dlhc_mag_input_work_func(struct work_struct *work)
+{
+	struct lsm303dlhc_mag_status *stat;
+	int xyz[3] = { 0 };
+
+	int err;
+
+	stat = container_of((struct delayed_work *)work,
+			struct lsm303dlhc_mag_status, input_work);
+
+	mutex_lock(&stat->lock);
+	err = lsm303dlhc_mag_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get_magnetometer_data failed\n");
+	else
+		lsm303dlhc_mag_report_values(stat, xyz);
+
+	schedule_delayed_work(&stat->input_work, msecs_to_jiffies(
+			stat->pdata->poll_interval));
+
+	mutex_unlock(&stat->lock);
+}
+
+static int lsm303dlhc_mag_validate_pdata(struct lsm303dlhc_mag_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int) LSM303DLHC_MAG_MIN_POLL_PERIOD_MS,
+						stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 || stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			stat->pdata->axis_map_x, stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 || stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			stat->pdata->negate_x, stat->pdata->negate_y,
+			stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lsm303dlhc_mag_input_init(struct lsm303dlhc_mag_status *stat)
+{
+	int err = -1;
+
+	INIT_DELAYED_WORK(&stat->input_work, lsm303dlhc_mag_input_work_func);
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "input device allocate failed\n");
+		goto err0;
+	}
+	
+	stat->input_dev->name = LSM303DLHC_MAG_DEV_NAME;
+	stat->input_dev->id.bustype = stat->bus_type;
+	stat->input_dev->dev.parent = stat->dev;
+
+	input_set_drvdata(stat->input_dev, stat);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev);
+err0:
+	return err;
+}
+
+static void lsm303dlhc_mag_input_cleanup(struct lsm303dlhc_mag_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+int lsm303dlhc_mag_probe(struct lsm303dlhc_mag_status *stat)
+{
+	int err = -1;
+
+	mutex_lock(&stat->lock);
+	
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL)
+		goto err1;
+
+	if (stat->dev->platform_data == NULL) {	
+		memcpy(stat->pdata, &default_lsm303dlhc_mag_pdata,
+							sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+							sizeof(*stat->pdata));
+	}
+
+	err = lsm303dlhc_mag_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CRA_REG_M] =
+				LSM303DLHC_MAG_ODR15 | LSM303DLHC_MAG_NORMAL_MODE;
+	stat->resume_state[RES_CRB_REG_M] = LSM303DLHC_H_1_3G;
+	stat->resume_state[RES_MR_REG_M] = SLEEP_MODE;
+
+	err = lsm303dlhc_mag_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lsm303dlhc_mag_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = lsm303dlhc_mag_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = lsm303dlhc_mag_input_init(stat);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev, "%s register failed\n",
+						LSM303DLHC_MAG_DEV_NAME);
+		goto err4;
+	}
+
+	lsm303dlhc_mag_device_power_off(stat);
+
+	atomic_set(&stat->enabled, 0);
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "lsm303dlh_mag probed\n");
+
+	return 0;
+
+err4:
+	lsm303dlhc_mag_input_cleanup(stat);
+err3:
+	lsm303dlhc_mag_device_power_off(stat);
+err2:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+err1_1:
+	mutex_unlock(&stat->lock);
+	kfree(stat->pdata);
+err1:
+
+	return err;
+}
+EXPORT_SYMBOL(lsm303dlhc_mag_probe);
+
+int lsm303dlhc_mag_remove(struct lsm303dlhc_mag_status *stat)
+{
+#ifdef LSM303DLHC_DEBUG
+	pr_info("LSM303DLHC driver removing\n");
+#endif /* LSM303DLHC_DEBUG */
+	lsm303dlhc_mag_input_cleanup(stat);
+	lsm303dlhc_mag_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+
+	kfree(stat->pdata);
+	return 0;
+}
+EXPORT_SYMBOL(lsm303dlhc_mag_remove);
+
+MODULE_DESCRIPTION("lsm303dlhc driver for the magnetometer section");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag_i2c.c b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag_i2c.c
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/lsm303dlhc_mag_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm303dlhc_mag_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm303dlhc.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold stat->lock */
+static int lsm303dlhc_mag_i2c_read(struct device *dev, u8 addr, int len,
+				   u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold stat->lock */
+static int lsm303dlhc_mag_i2c_write(struct device *dev, u8 addr, int len,
+				    u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm303dlhc_transfer_function lsm303dlhc_mag_i2c_tf = {
+	.write = lsm303dlhc_mag_i2c_write,
+	.read = lsm303dlhc_mag_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm303dlhc_mag_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303dlhc_mag_status *stat = i2c_get_clientdata(client);
+
+	return lsm303dlhc_mag_enable(stat);
+}
+
+static int lsm303dlhc_mag_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm303dlhc_mag_status *stat = i2c_get_clientdata(client);
+
+	return lsm303dlhc_mag_disable(stat);
+}
+
+static const struct dev_pm_ops lsm303dlhc_mag_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm303dlhc_mag_i2c_suspend,
+				lsm303dlhc_mag_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm303dlhc_mag_i2c_id_table[] = {
+	{ .compatible = "st,lsm303dlhc_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm303dlhc_mag_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm303dlhc_mag_i2c_probe(struct i2c_client *client,
+				    const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm303dlhc_mag_status *stat;
+
+#ifdef LSM303DLHC_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct lsm303dlhc_mag_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bus_type = BUS_I2C;
+	stat->tf = &lsm303dlhc_mag_i2c_tf;
+
+	i2c_set_clientdata(client, stat);
+
+	mutex_init(&stat->lock);
+
+	err = lsm303dlhc_mag_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm303dlhc_mag_i2c_remove(struct i2c_client *client)
+{
+	struct lsm303dlhc_mag_status *stat = i2c_get_clientdata(client);
+
+#ifdef LSM303DLHC_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm303dlhc_mag_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm303dlhc_mag_i2c_id[] = {
+	{ "lsm303dlhc_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303dlhc_mag_i2c_id);
+
+static struct i2c_driver lsm303dlhc_mag_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm303dlhc_mag_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm303dlhc_mag_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm303dlhc_mag_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm303dlhc_mag_i2c_probe,
+	.remove = lsm303dlhc_mag_i2c_remove,
+	.id_table = lsm303dlhc_mag_i2c_id,
+};
+
+module_i2c_driver(lsm303dlhc_mag_i2c_driver);
+
+MODULE_DESCRIPTION("lsm303dlhc mag i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/ecompass/lsm303dlhc/Makefile b/drivers/input/misc/st/ecompass/lsm303dlhc/Makefile
--- a/drivers/input/misc/st/ecompass/lsm303dlhc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/lsm303dlhc/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the input misc lsm303dlhc driver.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_INPUT_LSM303DLHC) += lsm303dlhc_acc.o lsm303dlhc_mag.o
+obj-$(CONFIG_INPUT_LSM303DLHC_I2C) += lsm303dlhc_acc_i2c.o lsm303dlhc_mag_i2c.o
diff -uNr a/drivers/input/misc/st/ecompass/Makefile b/drivers/input/misc/st/ecompass/Makefile
--- a/drivers/input/misc/st/ecompass/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/ecompass/Makefile	2017-07-06 19:48:50.146213000 +0200
@@ -0,0 +1,5 @@
+obj-$(CONFIG_INPUT_LSM303AGR) += lsm303agr/
+obj-$(CONFIG_INPUT_LSM303AH) += lsm303ah/
+obj-$(CONFIG_INPUT_LSM303C) += lsm303c/
+obj-$(CONFIG_INPUT_LSM303D) += lsm303d/
+obj-$(CONFIG_INPUT_LSM303DLHC) += lsm303dlhc/
diff -uNr a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_core.c b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_core.c
--- a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_core.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,840 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: a3g4250d_core.c
+* Authors		: MH - C&I BU - Application Team
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.1.5
+* Date			: 2016/May/23
+* Description		: A3G4250D digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS		| DESCRIPTION
+* 1.0.0		| 2016/05/23	| Mario Tesi		| ported from l3g4200d
+*******************************************************************************/
+
+#include <linux/mutex.h>
+#include <linux/input-polldev.h>
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "a3g4250d.h"
+
+/** Maximum polled-device-reported rot speed value value in dps*/
+#define FS_MAX		32768
+
+/* a3g4250d gyroscope registers */
+#define WHO_AM_I        0x0F
+#define WHOAMI_A3G4250D	0xD3	/* Expected content for WAI register*/
+
+#define CTRL_REG1       0x20    /* CTRL REG1 */
+#define CTRL_REG2       0x21    /* CTRL REG2 */
+#define CTRL_REG3       0x22    /* CTRL_REG3 */
+#define CTRL_REG4       0x23    /* CTRL_REG4 */
+#define CTRL_REG5       0x24    /* CTRL_REG5 */
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	0x00
+#define PM_OFF		0x00
+#define PM_NORMAL	0x08
+#define ENABLE_ALL_AXES	0x07
+#define BW00		0x00
+#define BW01		0x10
+#define BW10		0x20
+#define BW11		0x30
+#define ODR100		0x00  /* ODR = 100Hz */
+#define ODR200		0x40  /* ODR = 200Hz */
+#define ODR400		0x80  /* ODR = 400Hz */
+#define ODR800		0xC0  /* ODR = 800Hz */
+
+/* CTRL_REG4 bits */
+#define	SELFTEST_MASK			0x06
+#define A3G4250D_SELFTEST_DIS		0x00
+#define A3G4250D_SELFTEST_EN_POS	0x02
+#define A3G4250D_SELFTEST_EN_NEG	0x04
+
+#define AXISDATA_REG			0x28
+
+#define AUTO_INCREMENT	0x80
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1	0
+#define	RES_CTRL_REG2	1
+#define	RES_CTRL_REG3	2
+#define	RES_CTRL_REG4	3
+#define	RES_CTRL_REG5	4
+
+#define MS_TO_NS(x)	((x)*1000000L)
+//#define DEBUG 1
+
+/*
+ * A3G4250D gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * signed short
+ */
+static const struct output_rate odr_table[] = {
+	{ 2, ODR800|BW10 },
+	{ 3, ODR400|BW01 },
+	{ 5, ODR200|BW00 },
+	{ 10, ODR100|BW00 },
+};
+
+static int a3g4250d_register_write(struct a3g4250d_data *gyro, u8 *buf,
+				   u8 reg_address, u8 new_value)
+{
+	int err = -1;
+
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+	err = gyro->tf->write(gyro, reg_address, 1, buf);
+	if (err < 0)
+		return err;
+
+	return err;
+}
+
+static int a3g4250d_register_read(struct a3g4250d_data *gyro, u8 *buf,
+				  u8 reg_address)
+{
+	return gyro->tf->read(gyro, reg_address, 1, buf);
+}
+
+static int a3g4250d_register_update(struct a3g4250d_data *gyro, u8 *buf,
+				    u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+
+	err = a3g4250d_register_read(gyro, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = a3g4250d_register_write(gyro, buf, reg_address,
+					      updated_val);
+	}
+
+	return err;
+}
+
+static int a3g4250d_selftest(struct a3g4250d_data *gyro, u8 enable)
+{
+	int err = -1;
+	u8 buf[2] = { 0x00,0x00 };
+	char reg_address, mask, bit_values;
+
+	reg_address = CTRL_REG4;
+	mask = SELFTEST_MASK;
+	if (enable > 0)
+		bit_values = A3G4250D_SELFTEST_EN_POS;
+	else
+		bit_values = A3G4250D_SELFTEST_DIS;
+
+	if (atomic_read(&gyro->enabled)) {
+		mutex_lock(&gyro->lock);
+		err = a3g4250d_register_update(gyro, buf, reg_address,
+					       mask, bit_values);
+		gyro->selftest_enabled = enable;
+		mutex_unlock(&gyro->lock);
+		if (err < 0)
+			return err;
+		gyro->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				( ~mask & gyro->resume_state[RES_CTRL_REG4]));
+	}
+	return err;
+}
+
+static int a3g4250d_update_odr(struct a3g4250d_data *gyro, int poll_interval)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+		if (odr_table[i].poll_rate_ms <= poll_interval || i == 0)
+			break;
+	}
+
+	config = odr_table[i].mask;
+	config |= (ENABLE_ALL_AXES + PM_NORMAL);
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&gyro->enabled)) {
+		err = gyro->tf->write(gyro, CTRL_REG1, 1, &config);
+		if (err < 0)
+			return err;
+		gyro->resume_state[RES_CTRL_REG1] = config;
+	}
+	gyro->poll_ktime = ktime_set(0, MS_TO_NS(poll_interval));
+
+	return err;
+}
+
+/* data readout */
+static int a3g4250d_get_data(struct a3g4250d_data *gyro,
+			     struct a3g4250d_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = gyro->tf->read(gyro, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s16)(((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s16)(((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s16)(((gyro_out[5]) << 8) | gyro_out[4]);
+
+	data->x = ((gyro->pdata->negate_x) ? (-hw_d[gyro->pdata->axis_map_x])
+		   : (hw_d[gyro->pdata->axis_map_x]));
+	data->y = ((gyro->pdata->negate_y) ? (-hw_d[gyro->pdata->axis_map_y])
+		   : (hw_d[gyro->pdata->axis_map_y]));
+	data->z = ((gyro->pdata->negate_z) ? (-hw_d[gyro->pdata->axis_map_z])
+		   : (hw_d[gyro->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void a3g4250d_report_values(struct a3g4250d_data *gyro,
+				   struct a3g4250d_triple *data)
+{
+	input_event(gyro->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, data->x);
+	input_event(gyro->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, data->y);
+	input_event(gyro->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, data->z);
+	input_event(gyro->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    gyro->timestamp >> 32);
+	input_event(gyro->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    gyro->timestamp & 0xffffffff);
+	input_sync(gyro->input_dev);
+}
+
+static int a3g4250d_hw_init(struct a3g4250d_data *gyro)
+{
+	int err = -1;
+	u8 buf[5];
+
+	pr_info("%s hw init\n", A3G4250D_DEV_NAME);
+
+	buf[0] = gyro->resume_state[RES_CTRL_REG1];
+	buf[1] = gyro->resume_state[RES_CTRL_REG2];
+	buf[2] = gyro->resume_state[RES_CTRL_REG3];
+	buf[3] = gyro->resume_state[RES_CTRL_REG4];
+	buf[4] = gyro->resume_state[RES_CTRL_REG5];
+
+	err = gyro->tf->write(gyro, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	gyro->hw_initialized = 1;
+
+	return err;
+}
+
+static void a3g4250d_device_power_off(struct a3g4250d_data *dev_data)
+{
+	int err;
+	u8 buf;
+
+	pr_info("%s power off\n", A3G4250D_DEV_NAME);
+
+	buf = PM_OFF;
+	err = dev_data->tf->write(dev_data, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(dev_data->dev, "soft power off failed\n");
+
+	if (dev_data->pdata->power_off) {
+		dev_data->pdata->power_off();
+		dev_data->hw_initialized = 0;
+	}
+
+	if (dev_data->hw_initialized)
+		dev_data->hw_initialized = 0;
+}
+
+static int a3g4250d_device_power_on(struct a3g4250d_data *dev_data)
+{
+	int err;
+
+	if (dev_data->pdata->power_on) {
+		err = dev_data->pdata->power_on();
+		if (err < 0)
+			return err;
+	}
+
+	if (!dev_data->hw_initialized) {
+		err = a3g4250d_hw_init(dev_data);
+		if (err < 0) {
+			a3g4250d_device_power_off(dev_data);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int _a3g4250d_enable(struct a3g4250d_data *gyro)
+{
+	int err;
+
+	err = a3g4250d_device_power_on(gyro);
+	if (err < 0) {
+		atomic_set(&gyro->enabled, 0);
+		return err;
+	}
+	hrtimer_start(&gyro->hr_timer, gyro->poll_ktime, HRTIMER_MODE_REL);
+
+	return 0;
+}
+
+static int a3g4250d_enable(struct a3g4250d_data *dev_data)
+{
+	int err = 0;
+
+	if (!atomic_cmpxchg(&dev_data->enabled, 0, 1)) {
+		err = _a3g4250d_enable(dev_data);
+	}
+
+	return err;
+}
+
+static void _a3g4250d_disable(struct a3g4250d_data *gyro)
+{
+	a3g4250d_device_power_off(gyro);
+
+	cancel_work_sync(&gyro->poll_work);
+	hrtimer_cancel(&gyro->hr_timer);
+}
+
+static int a3g4250d_disable(struct a3g4250d_data *dev_data)
+{
+	if (atomic_cmpxchg(&dev_data->enabled, 1, 0))
+		_a3g4250d_disable(dev_data);
+
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	int val;
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+
+	mutex_lock(&gyro->lock);
+	val = gyro->pdata->poll_interval;
+	mutex_unlock(&gyro->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms,gyro->pdata->min_interval);
+	mutex_lock(&gyro->lock);
+	gyro->pdata->poll_interval = interval_ms;
+	a3g4250d_update_odr(gyro, interval_ms);
+	mutex_unlock(&gyro->lock);
+
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	int val = atomic_read(&gyro->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		a3g4250d_enable(gyro);
+	else
+		a3g4250d_disable(gyro);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+
+	mutex_lock(&gyro->lock);
+	val = gyro->selftest_enabled;
+	mutex_unlock(&gyro->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	a3g4250d_selftest(gyro, val);
+
+	return size;
+}
+
+#ifdef DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x = val;
+	gyro->tf->write(gyro, gyro->reg_addr, 1, &x);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&gyro->lock);
+	data = gyro->reg_addr;
+	mutex_unlock(&gyro->lock);
+	rc = gyro->tf->read(gyro, gyro->reg_addr, 1, &data);
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct a3g4250d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&gyro->lock);
+
+	gyro->reg_addr = val;
+
+	mutex_unlock(&gyro->lock);
+
+	return size;
+}
+#endif /* DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_polling_rate_show,
+	       attr_polling_rate_store),
+	__ATTR(enable_device, 0666, attr_enable_show, attr_enable_store),
+	__ATTR(enable_selftest, 0666, attr_get_selftest, attr_set_selftest),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void a3g4250d_poll_work_func(struct work_struct *work)
+{
+	struct a3g4250d_data *gyro;
+	struct a3g4250d_triple data_out;
+	int err;
+
+	gyro = container_of((struct work_struct *) work, struct a3g4250d_data,
+			    poll_work);
+
+	err = a3g4250d_get_data(gyro, &data_out);
+	if (err < 0)
+		dev_err(gyro->dev, "get_gyroscope_data failed\n");
+	else
+		a3g4250d_report_values(gyro, &data_out);
+
+	hrtimer_start(&gyro->hr_timer, gyro->poll_ktime, HRTIMER_MODE_REL);
+}
+
+static enum hrtimer_restart a3g4250d_timer_poll(struct hrtimer *timer)
+{
+	struct a3g4250d_data *gyro;
+
+	gyro = container_of((struct hrtimer *)timer, struct a3g4250d_data,
+			    hr_timer);
+
+	gyro->timestamp = a3g4250d_get_time_ns();
+
+	queue_work(gyro->work_queue, &gyro->poll_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static int a3g4250d_validate_pdata(struct a3g4250d_data *gyro)
+{
+	/* checks for correctness of minimal polling period */
+	gyro->pdata->min_interval =
+		max((unsigned int)A3G4250D_MIN_POLL_PERIOD_MS,
+		    gyro->pdata->min_interval);
+
+	gyro->pdata->poll_interval = max(gyro->pdata->poll_interval,
+					 gyro->pdata->min_interval);
+
+	if (gyro->pdata->axis_map_x > 2 || gyro->pdata->axis_map_y > 2 ||
+	    gyro->pdata->axis_map_z > 2) {
+		dev_err(gyro->dev,
+			"invalid axis_map value x:%u y:%u z:%u\n",
+			gyro->pdata->axis_map_x,
+			gyro->pdata->axis_map_y,
+			gyro->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (gyro->pdata->negate_x > 1 || gyro->pdata->negate_y > 1 ||
+	    gyro->pdata->negate_z > 1) {
+		dev_err(gyro->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			gyro->pdata->negate_x,
+			gyro->pdata->negate_y,
+			gyro->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (gyro->pdata->poll_interval < gyro->pdata->min_interval) {
+		dev_err(gyro->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int a3g4250d_input_init(struct a3g4250d_data *gyro)
+{
+	int err = -1;
+
+	gyro->input_dev = input_allocate_device();
+	if (!gyro->input_dev) {
+		err = -ENOMEM;
+		dev_err(gyro->dev, "input device allocation failed\n");
+		return err;
+	}
+
+	gyro->input_dev->name = A3G4250D_DEV_NAME;
+	gyro->input_dev->id.bustype = gyro->bustype;
+	gyro->input_dev->dev.parent = gyro->dev;
+	input_set_drvdata(gyro->input_dev, gyro);
+
+	/* Set Misc event type */
+	__set_bit(INPUT_EVENT_TYPE, gyro->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, gyro->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, gyro->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Z, gyro->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, gyro->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, gyro->input_dev->mscbit);
+
+	err = input_register_device(gyro->input_dev);
+	if (err) {
+		dev_err(gyro->dev, "unable to register input device %s\n",
+			gyro->input_dev->name);
+		input_free_device(gyro->input_dev);
+
+		return err;
+	}
+
+	gyro->work_queue = create_workqueue("a3g4250d_wq");
+	if (!gyro->work_queue)
+		return -ENOMEM;
+
+	hrtimer_init(&gyro->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	gyro->hr_timer.function = &a3g4250d_timer_poll;
+
+	INIT_WORK(&gyro->poll_work, a3g4250d_poll_work_func);
+
+	return 0;
+}
+
+static void a3g4250d_input_cleanup(struct a3g4250d_data *gyro)
+{
+	if (gyro->work_queue) {
+		flush_workqueue(gyro->work_queue);
+		destroy_workqueue(gyro->work_queue);
+		gyro->work_queue = NULL;
+	}
+	input_unregister_device(gyro->input_dev);
+	input_free_device(gyro->input_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 a3g4250d_parse_dt(struct a3g4250d_data *gyro, struct device* dev)
+{
+	/* TODO: Add parsing of default configuration */
+	gyro->pdata->axis_map_x = 0;
+	gyro->pdata->axis_map_y = 1;
+	gyro->pdata->axis_map_z = 2;
+	gyro->pdata->negate_x = 0;
+	gyro->pdata->negate_y = 0;
+	gyro->pdata->negate_z = 0;
+
+	return 0;
+}
+#endif
+
+int a3g4250d_common_probe(struct a3g4250d_data *gyro)
+{
+	int err = -1;
+	u8 whoami;
+
+	pr_info("%s: probe start.\n", A3G4250D_DEV_NAME);
+	
+	mutex_init(&gyro->lock);
+	mutex_init(&gyro->tb.buf_lock);
+
+	err = gyro->tf->read(gyro, WHO_AM_I, 1, &whoami);
+	if (err < 0) {
+		dev_warn(gyro->dev, "Error reading WHO_AM_I: is device "
+			 "available/working?\n");
+		return -ENODEV;
+	}
+
+	if (whoami != WHOAMI_A3G4250D) {
+		dev_err(gyro->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_A3G4250D, whoami);
+		return -ENODEV;
+	}
+
+#ifndef CONFIG_OF
+	if (gyro->dev->platform_data == NULL) {
+		dev_err(gyro->dev, "platform data is NULL exiting.\n");
+		err = -ENODEV;
+		goto err0;
+	}
+#else
+	gyro->dev->platform_data = NULL;
+#endif
+
+	mutex_lock(&gyro->lock);
+
+	gyro->pdata = kzalloc(sizeof(struct a3g4250d_platform_data), GFP_KERNEL);
+	if (gyro->pdata == NULL) {
+		dev_err(gyro->dev, "failed to allocate memory for pdata: %d\n",
+			err);
+		goto err1;
+	}
+#ifdef CONFIG_OF
+	a3g4250d_parse_dt(gyro, gyro->dev);
+#else
+	memcpy(gyro->pdata, gyro->dev->platform_data,
+	       sizeof(*gyro->pdata));
+#endif
+
+	err = a3g4250d_validate_pdata(gyro);
+	if (err < 0) {
+		dev_err(gyro->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (gyro->pdata->init) {
+		err = gyro->pdata->init();
+		if (err < 0) {
+			dev_err(gyro->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	memset(gyro->resume_state, 0, ARRAY_SIZE(gyro->resume_state));
+
+	gyro->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES;
+	gyro->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	gyro->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	gyro->resume_state[RES_CTRL_REG4] = ALL_ZEROES;
+	gyro->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+
+	err = a3g4250d_device_power_on(gyro);
+	if (err < 0) {
+		dev_err(gyro->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&gyro->enabled, 1);
+
+	err = a3g4250d_update_odr(gyro, gyro->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(gyro->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = a3g4250d_input_init(gyro);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(gyro->dev);
+	if (err < 0) {
+		dev_err(gyro->dev, "%s device register failed\n",
+			A3G4250D_DEV_NAME);
+		goto err4;
+	}
+
+	a3g4250d_device_power_off(gyro);
+
+	/* As default, do not report information */
+	atomic_set(&gyro->enabled, 0);
+
+	mutex_unlock(&gyro->lock);
+
+	pr_info("%s: probed\n", A3G4250D_DEV_NAME);
+
+	return 0;
+
+err4:
+	a3g4250d_input_cleanup(gyro);
+err3:
+	a3g4250d_device_power_off(gyro);
+err2:
+	if (gyro->pdata->exit)
+		gyro->pdata->exit();
+err1_1:
+	mutex_unlock(&gyro->lock);
+	kfree(gyro->pdata);
+err1:
+	pr_err("%s: Driver Initialization failed\n", A3G4250D_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(a3g4250d_common_probe);
+
+int a3g4250d_common_remove(struct a3g4250d_data *gyro)
+{
+#ifdef DEBUG
+	pr_info(KERN_INFO "A3G4250D driver removing\n");
+#endif
+	a3g4250d_input_cleanup(gyro);
+	a3g4250d_device_power_off(gyro);
+	remove_sysfs_interfaces(gyro->dev);
+	kfree(gyro->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(a3g4250d_common_remove);
+
+#ifdef CONFIG_PM
+int a3g4250d_common_suspend(struct a3g4250d_data *gyro)
+{
+	if (atomic_read(&gyro->enabled))
+		_a3g4250d_disable(gyro);
+
+	return 0;
+}
+EXPORT_SYMBOL(a3g4250d_common_suspend);
+
+int a3g4250d_common_resume(struct a3g4250d_data *gyro)
+{
+	if (atomic_read(&gyro->enabled))
+		_a3g4250d_enable(gyro);
+
+	return 0;
+}
+EXPORT_SYMBOL(a3g4250d_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("a3g4250d digital gyro driver");
+MODULE_AUTHOR("Matteo Dameno, Carmine Iascone, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d.h b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d.h
--- a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,148 @@
+/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
+*
+* File Name		: a3g4250d.h
+* Authors		: MH - C&I BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.1.3 sysfs
+* Date			: 2016/May/23
+* Description		: A3G4250D digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS		| DESCRIPTION
+* 1.0.0		| 2016/05/23	| Mario Tesi		| ported from l3g4200d
+*******************************************************************************/
+
+#ifndef __A3G4250D_H__
+#define __A3G4250D_H__
+
+#define A3G4250D_MIN_POLL_PERIOD_MS	2
+
+#define A3G4250D_DEV_NAME	"a3g4250d_gyr"
+
+#define A3G4250D_GYR_ENABLED	1
+#define A3G4250D_GYR_DISABLED	0
+
+#ifdef __KERNEL__
+
+#define BUFF_RX_MAX_LENGTH	500
+#define BUFF_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		5
+
+struct a3g4250d_data;
+
+struct a3g4250d_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+struct a3g4250d_triple {
+	short x, y, z;
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+struct a3g4250d_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct a3g4250d_transfer_function {
+	int (*write)(struct a3g4250d_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct a3g4250d_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct a3g4250d_data {
+	const char *name;
+	struct device *dev;
+	struct a3g4250d_platform_data *pdata;
+	struct mutex lock;
+	u16 bustype;
+	int hw_initialized;
+	int selftest_enabled;
+	atomic_t enabled;
+
+	s64 timestamp;
+	struct hrtimer hr_timer;
+	ktime_t poll_ktime;
+	struct workqueue_struct *work_queue;
+	struct work_struct poll_work;
+	struct input_dev *input_dev;
+
+	u8 reg_addr;
+	u8 resume_state[RESUME_ENTRIES];
+	struct a3g4250d_transfer_function *tf;
+	struct a3g4250d_transfer_buffer tb;
+};
+
+static inline s64 a3g4250d_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+/* Input events used by a3g4250d driver */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int a3g4250d_common_probe(struct a3g4250d_data *gyro);
+int a3g4250d_common_remove(struct a3g4250d_data *gyro);
+
+#ifdef CONFIG_PM
+int a3g4250d_common_suspend(struct a3g4250d_data *gyro);
+int a3g4250d_common_resume(struct a3g4250d_data *gyro);
+#endif /* CONFIG_PM */
+
+#endif /* __KERNEL__ */
+
+#endif  /* __A3G4250D_H__ */
diff -uNr a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_i2c.c b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_i2c.c
--- a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,186 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: a3g4250d_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.0
+* Date		: 2016/May/23
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "a3g4250d.h"
+
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int a3g4250d_i2c_read(struct a3g4250d_data *cdata, u8 reg_addr,
+			     int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int a3g4250d_i2c_write(struct a3g4250d_data *cdata, u8 reg_addr,
+			      int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static struct a3g4250d_transfer_function a3g4250d_tf_i2c = {
+	.write = a3g4250d_i2c_write,
+	.read = a3g4250d_i2c_read,
+};
+
+static int a3g4250d_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	int err;
+	struct a3g4250d_data *cdata;
+
+	cdata = kzalloc(sizeof(struct a3g4250d_data), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bustype = BUS_I2C;
+	cdata->tf = &a3g4250d_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = a3g4250d_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int a3g4250d_i2c_remove(struct i2c_client *client)
+{
+	struct a3g4250d_data *cdata = i2c_get_clientdata(client);
+
+	a3g4250d_common_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int a3g4250d_suspend(struct device *dev)
+{
+	struct a3g4250d_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return a3g4250d_common_suspend(cdata);
+}
+
+static int a3g4250d_resume(struct device *dev)
+{
+	struct a3g4250d_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return a3g4250d_common_resume(cdata);
+}
+
+static const struct dev_pm_ops a3g4250d_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(a3g4250d_suspend, a3g4250d_resume)
+};
+
+#define A3G4250D_PM_OPS		(&a3g4250d_pm_ops)
+#else /* CONFIG_PM */
+#define A3G4250D_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id a3g4250d_ids[] = {
+	{ A3G4250D_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, a3g4250d_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id a3g4250d_id_table[] = {
+	{ .compatible = "st,a3g4250d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, a3g4250d_id_table);
+#endif
+
+static struct i2c_driver a3g4250d_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = A3G4250D_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = A3G4250D_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = a3g4250d_id_table,
+#endif
+	},
+	.remove = a3g4250d_i2c_remove,
+	.probe = a3g4250d_i2c_probe,
+	.id_table = a3g4250d_ids,
+};
+
+module_i2c_driver(a3g4250d_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics a3g4250d i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_spi.c b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_spi.c
--- a/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/a3g4250d/a3g4250d_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,209 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: a3g4250d_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.0
+* Date		: 2016/May/23
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "a3g4250d.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int a3g4250d_spi_read(struct a3g4250d_data *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int a3g4250d_spi_write(struct a3g4250d_data *cdata, u8 reg_addr, int len,
+			      u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static struct a3g4250d_transfer_function a3g4250d_tf_spi = {
+	.write = a3g4250d_spi_write,
+	.read = a3g4250d_spi_read,
+};
+
+static int a3g4250d_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct a3g4250d_data *cdata;
+
+	cdata = kzalloc(sizeof(struct a3g4250d_data), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->bustype = BUS_SPI;
+	cdata->tf = &a3g4250d_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = a3g4250d_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int a3g4250d_spi_remove(struct spi_device *spi)
+{
+	struct a3g4250d_data *cdata = spi_get_drvdata(spi);
+
+	a3g4250d_common_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int a3g4250d_suspend(struct device *dev)
+{
+	struct a3g4250d_data *cdata= spi_get_drvdata(to_spi_device(dev));
+
+	return a3g4250d_common_suspend(cdata);
+}
+
+static int a3g4250d_resume(struct device *dev)
+{
+	struct a3g4250d_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return a3g4250d_common_resume(cdata);
+}
+
+static const struct dev_pm_ops a3g4250d_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(a3g4250d_suspend, a3g4250d_resume)
+};
+
+#define A3G4250D_PM_OPS		(&a3g4250d_pm_ops)
+#else /* CONFIG_PM */
+#define A3G4250D_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id a3g4250d_ids[] = {
+	{ A3G4250D_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, a3g4250d_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id a3g4250d_id_table[] = {
+	{ .compatible = "st,a3g4250d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, a3g4250d_id_table);
+#endif
+
+static struct spi_driver a3g4250d_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = A3G4250D_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = A3G4250D_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = a3g4250d_id_table,
+#endif
+	},
+	.remove = a3g4250d_spi_remove,
+	.probe = a3g4250d_spi_probe,
+	.id_table = a3g4250d_ids,
+};
+
+module_spi_driver(a3g4250d_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics a3g4250d spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/a3g4250d/Kconfig b/drivers/input/misc/st/gyro/a3g4250d/Kconfig
--- a/drivers/input/misc/st/gyro/a3g4250d/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/a3g4250d/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,21 @@
+config INPUT_A3G4250D
+	tristate "STMicroelectronics A3G4250D sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_A3G4250D_I2C if (I2C)
+	select INPUT_A3G4250D_SPI if (SPI)
+	select INPUT_POLLDEV
+	help
+	   This driver support the STMicroelectronics A3G4250D sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called a3g4250d.
+
+config INPUT_A3G4250D_I2C
+	tristate
+	depends on INPUT_A3G4250D
+	depends on I2C
+
+config INPUT_A3G4250D_SPI
+	tristate
+	depends on INPUT_A3G4250D
+	depends on SPI
diff -uNr a/drivers/input/misc/st/gyro/a3g4250d/Makefile b/drivers/input/misc/st/gyro/a3g4250d/Makefile
--- a/drivers/input/misc/st/gyro/a3g4250d/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/a3g4250d/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc a3g4250d driver
+#
+a3g4250d-core-y += a3g4250d_core.o
+obj-$(CONFIG_INPUT_A3G4250D) += a3g4250d-core.o
+obj-$(CONFIG_INPUT_A3G4250D_I2C) += a3g4250d_i2c.o
+obj-$(CONFIG_INPUT_A3G4250D_SPI) += a3g4250d_spi.o
diff -uNr a/drivers/input/misc/st/gyro/Kconfig b/drivers/input/misc/st/gyro/Kconfig
--- a/drivers/input/misc/st/gyro/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,12 @@
+
+menuconfig INPUT_GYRO
+	tristate "Gyroscope"
+
+if INPUT_GYRO
+
+source "drivers/input/misc/st/gyro/l3g4200d/Kconfig"
+source "drivers/input/misc/st/gyro/l3gd20/Kconfig"
+source "drivers/input/misc/st/gyro/l3gd20h/Kconfig"
+source "drivers/input/misc/st/gyro/a3g4250d/Kconfig"
+
+endif # INPUT_GYRO
diff -uNr a/drivers/input/misc/st/gyro/l3g4200d/Kconfig b/drivers/input/misc/st/gyro/l3g4200d/Kconfig
--- a/drivers/input/misc/st/gyro/l3g4200d/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3g4200d/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,21 @@
+config INPUT_L3G4200D
+	tristate "STMicroelectronics L3G4200D sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_L3G4200D_I2C if (I2C)
+	select INPUT_L3G4200D_SPI if (SPI)
+	select INPUT_POLLDEV
+	help
+	   This driver support the STMicroelectronics L3G4200D sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called l3g4200d.
+
+config INPUT_L3G4200D_I2C
+	tristate
+	depends on INPUT_L3G4200D
+	depends on I2C
+
+config INPUT_L3G4200D_SPI
+	tristate
+	depends on INPUT_L3G4200D
+	depends on SPI
diff -uNr a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_core.c b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_core.c
--- a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_core.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,901 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: l3g4200d_gyr_sysfs.c
+* Authors		: MH - C&I BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+			: Mario Tesi (mario.tesi@st.com)
+*			: Both authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.1.5
+* Date			: 2016/Apr/28
+* Description		: L3G4200D digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS		| DESCRIPTION
+* 1.0		| 2010/11/19	| Carmine Iascone	| First Release
+* 1.1.0		| 2011/02/28	| Matteo Dameno		| Self Test Added
+* 1.1.1		| 2011/05/25	| Matteo Dameno		| Corrects Polling Bug
+* 1.1.2		| 2011/05/30	| Matteo Dameno		| Corrects ODR Bug
+* 1.1.3		| 2011/06/24	| Matteo Dameno		| Corrects ODR Bug
+* 1.1.4		| 2011/09/24	| Matteo Dameno		| forces BDU setting
+* 1.1.5		| 2016/04/28	| Mario Tesi		| add spi support
+*******************************************************************************/
+
+#include <linux/mutex.h>
+#include <linux/input-polldev.h>
+#include <linux/version.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "l3g4200d.h"
+
+/** Maximum polled-device-reported rot speed value value in dps*/
+#define FS_MAX		32768
+
+/* l3g4200d gyroscope registers */
+#define WHO_AM_I        0x0F
+#define WHOAMI_L3G4200D	0xD3	/* Expected content for WAI register*/
+
+
+#define CTRL_REG1       0x20    /* CTRL REG1 */
+#define CTRL_REG2       0x21    /* CTRL REG2 */
+#define CTRL_REG3       0x22    /* CTRL_REG3 */
+#define CTRL_REG4       0x23    /* CTRL_REG4 */
+#define CTRL_REG5       0x24    /* CTRL_REG5 */
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	0x00
+#define PM_OFF		0x00
+#define PM_NORMAL	0x08
+#define ENABLE_ALL_AXES	0x07
+#define BW00		0x00
+#define BW01		0x10
+#define BW10		0x20
+#define BW11		0x30
+#define ODR100		0x00  /* ODR = 100Hz */
+#define ODR200		0x40  /* ODR = 200Hz */
+#define ODR400		0x80  /* ODR = 400Hz */
+#define ODR800		0xC0  /* ODR = 800Hz */
+
+/* CTRL_REG4 bits */
+#define	FS_MASK				0x30
+#define	BDU_ENABLE			0x80
+
+#define	SELFTEST_MASK			0x06
+#define L3G4200D_SELFTEST_DIS		0x00
+#define L3G4200D_SELFTEST_EN_POS	0x02
+#define L3G4200D_SELFTEST_EN_NEG	0x04
+
+#define AXISDATA_REG			0x28
+
+#define FUZZ		0
+#define FLAT		0
+#define AUTO_INCREMENT	0x80
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1	0
+#define	RES_CTRL_REG2	1
+#define	RES_CTRL_REG3	2
+#define	RES_CTRL_REG4	3
+#define	RES_CTRL_REG5	4
+
+//#define DEBUG 1
+
+/*
+ * L3G4200D gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * signed short
+ */
+
+static const struct output_rate odr_table[] = {
+	{	2,	ODR800|BW10},
+	{	3,	ODR400|BW01},
+	{	5,	ODR200|BW00},
+	{	10,	ODR100|BW00},
+};
+
+static int l3g4200d_register_write(struct l3g4200d_data *gyro, u8 *buf,
+				   u8 reg_address, u8 new_value)
+{
+	int err = -1;
+
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	buf[0] = new_value;
+	err = gyro->tf->write(gyro, reg_address, 1, buf);
+	if (err < 0)
+		return err;
+
+	return err;
+}
+
+static int l3g4200d_register_read(struct l3g4200d_data *gyro, u8 *buf,
+				  u8 reg_address)
+{
+	return gyro->tf->read(gyro, reg_address, 1, buf);
+}
+
+static int l3g4200d_register_update(struct l3g4200d_data *gyro, u8 *buf,
+				    u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+
+	err = l3g4200d_register_read(gyro, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = l3g4200d_register_write(gyro, buf, reg_address,
+					      updated_val);
+	}
+
+	return err;
+}
+
+static int l3g4200d_update_fs_range(struct l3g4200d_data *gyro,
+				    u8 new_fs)
+{
+	int res ;
+	u8 buf[2];
+
+	buf[0] = CTRL_REG4;
+
+	res = l3g4200d_register_update(gyro, buf, CTRL_REG4,
+				       FS_MASK, new_fs);
+
+	if (res < 0) {
+		pr_err("%s : failed to update fs:0x%02x\n",
+			__func__, new_fs);
+		return res;
+	}
+	gyro->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs ) |
+		( ~FS_MASK & gyro->resume_state[RES_CTRL_REG4]));
+
+	return res;
+}
+
+static int l3g4200d_selftest(struct l3g4200d_data *gyro, u8 enable)
+{
+	int err = -1;
+	u8 buf[2] = {0x00,0x00};
+	char reg_address, mask, bit_values;
+
+	reg_address = CTRL_REG4;
+	mask = SELFTEST_MASK;
+	if (enable > 0)
+		bit_values = L3G4200D_SELFTEST_EN_POS;
+	else
+		bit_values = L3G4200D_SELFTEST_DIS;
+
+	if (atomic_read(&gyro->enabled)) {
+		mutex_lock(&gyro->lock);
+		err = l3g4200d_register_update(gyro, buf, reg_address,
+					       mask, bit_values);
+		gyro->selftest_enabled = enable;
+		mutex_unlock(&gyro->lock);
+		if (err < 0)
+			return err;
+		gyro->resume_state[RES_CTRL_REG4] = ((mask & bit_values) |
+				( ~mask & gyro->resume_state[RES_CTRL_REG4]));
+	}
+	return err;
+}
+
+static int l3g4200d_update_odr(struct l3g4200d_data *gyro,
+				int poll_interval)
+{
+	int err = -1;
+	int i;
+	u8 config;
+
+	for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+		if ((odr_table[i].poll_rate_ms <= poll_interval) || (i == 0))
+			break;
+	}
+
+	config = odr_table[i].mask;
+	config |= (ENABLE_ALL_AXES + PM_NORMAL);
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&gyro->enabled)) {
+		err = gyro->tf->write(gyro, CTRL_REG1, 1, &config);
+		if (err < 0)
+			return err;
+		gyro->resume_state[RES_CTRL_REG1] = config;
+	}
+
+	return err;
+}
+
+/* data readout */
+static int l3g4200d_get_data(struct l3g4200d_data *gyro,
+			     struct l3g4200d_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s16 hw_d[3] = { 0 };
+
+	err = gyro->tf->read(gyro, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s16)(((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s16)(((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s16)(((gyro_out[5]) << 8) | gyro_out[4]);
+
+	data->x = ((gyro->pdata->negate_x) ? (-hw_d[gyro->pdata->axis_map_x])
+		   : (hw_d[gyro->pdata->axis_map_x]));
+	data->y = ((gyro->pdata->negate_y) ? (-hw_d[gyro->pdata->axis_map_y])
+		   : (hw_d[gyro->pdata->axis_map_y]));
+	data->z = ((gyro->pdata->negate_z) ? (-hw_d[gyro->pdata->axis_map_z])
+		   : (hw_d[gyro->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void l3g4200d_report_values(struct l3g4200d_data *l3g,
+				   struct l3g4200d_triple *data)
+{
+	struct input_dev *input = l3g->input_poll_dev->input;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data->x);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, data->y);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, data->z);
+	input_sync(input);
+}
+
+static int l3g4200d_hw_init(struct l3g4200d_data *gyro)
+{
+	int err = -1;
+	u8 buf[5];
+
+	pr_info("%s hw init\n", L3G4200D_DEV_NAME);
+
+	buf[0] = gyro->resume_state[RES_CTRL_REG1];
+	buf[1] = gyro->resume_state[RES_CTRL_REG2];
+	buf[2] = gyro->resume_state[RES_CTRL_REG3];
+	buf[3] = gyro->resume_state[RES_CTRL_REG4];
+	buf[4] = gyro->resume_state[RES_CTRL_REG5];
+
+	err = gyro->tf->write(gyro, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	gyro->hw_initialized = 1;
+
+	return err;
+}
+
+static void l3g4200d_device_power_off(struct l3g4200d_data *dev_data)
+{
+	int err;
+	u8 buf;
+
+	pr_info("%s power off\n", L3G4200D_DEV_NAME);
+
+	buf = PM_OFF;
+	err = dev_data->tf->write(dev_data, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(dev_data->dev, "soft power off failed\n");
+
+	if (dev_data->pdata->power_off) {
+		dev_data->pdata->power_off();
+		dev_data->hw_initialized = 0;
+	}
+
+	if (dev_data->hw_initialized)
+		dev_data->hw_initialized = 0;
+}
+
+static int l3g4200d_device_power_on(struct l3g4200d_data *dev_data)
+{
+	int err;
+
+	if (dev_data->pdata->power_on) {
+		err = dev_data->pdata->power_on();
+		if (err < 0)
+			return err;
+	}
+
+	if (!dev_data->hw_initialized) {
+		err = l3g4200d_hw_init(dev_data);
+		if (err < 0) {
+			l3g4200d_device_power_off(dev_data);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int l3g4200d_enable(struct l3g4200d_data *dev_data)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&dev_data->enabled, 0, 1)) {
+		err = l3g4200d_device_power_on(dev_data);
+		if (err < 0) {
+			atomic_set(&dev_data->enabled, 0);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int l3g4200d_disable(struct l3g4200d_data *dev_data)
+{
+	if (atomic_cmpxchg(&dev_data->enabled, 1, 0))
+		l3g4200d_device_power_off(dev_data);
+
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	int val;
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+
+	mutex_lock(&gyro->lock);
+	val = gyro->input_poll_dev->poll_interval;
+	mutex_unlock(&gyro->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms,gyro->pdata->min_interval);
+	mutex_lock(&gyro->lock);
+	gyro->input_poll_dev->poll_interval = interval_ms;
+	gyro->pdata->poll_interval = interval_ms;
+	l3g4200d_update_odr(gyro, interval_ms);
+	mutex_unlock(&gyro->lock);
+
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	int range = 0;
+	char val;
+
+	mutex_lock(&gyro->lock);
+	val = gyro->pdata->fs_range;
+	switch (val) {
+	case L3G4200D_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case L3G4200D_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case L3G4200D_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&gyro->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&gyro->lock);
+	gyro->pdata->fs_range = val;
+	l3g4200d_update_fs_range(gyro, val);
+	mutex_unlock(&gyro->lock);
+
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	int val = atomic_read(&gyro->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		l3g4200d_enable(gyro);
+	else
+		l3g4200d_disable(gyro);
+
+	return size;
+}
+
+static ssize_t attr_get_selftest(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+
+	mutex_lock(&gyro->lock);
+	val = gyro->selftest_enabled;
+	mutex_unlock(&gyro->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_selftest(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	l3g4200d_selftest(gyro, val);
+
+	return size;
+}
+
+#ifdef DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	x = val;
+	gyro->tf->write(gyro, gyro->reg_addr, 1, &x);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&gyro->lock);
+	data = gyro->reg_addr;
+	mutex_unlock(&gyro->lock);
+	rc = gyro->tf->read(gyro, gyro->reg_addr, 1, &data);
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct l3g4200d_data *gyro = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&gyro->lock);
+
+	gyro->reg_addr = val;
+
+	mutex_unlock(&gyro->lock);
+
+	return size;
+}
+#endif /* DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_polling_rate_show,
+	       attr_polling_rate_store),
+	__ATTR(range, 0666, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0666, attr_enable_show, attr_enable_store),
+	__ATTR(enable_selftest, 0666, attr_get_selftest, attr_set_selftest),
+#ifdef DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void l3g4200d_input_poll_func(struct input_polled_dev *dev)
+{
+	struct l3g4200d_data *gyro = dev->private;
+	struct l3g4200d_triple data_out;
+	int err;
+
+	err = l3g4200d_get_data(gyro, &data_out);
+	if (err < 0)
+		dev_err(gyro->dev, "get_gyroscope_data failed\n");
+	else
+		l3g4200d_report_values(gyro, &data_out);
+}
+
+int l3g4200d_input_open(struct input_dev *input)
+{
+	struct l3g4200d_data *gyro = input_get_drvdata(input);
+
+	return l3g4200d_enable(gyro);
+}
+
+void l3g4200d_input_close(struct input_dev *dev)
+{
+	struct l3g4200d_data *gyro = input_get_drvdata(dev);
+
+	l3g4200d_disable(gyro);
+}
+
+static int l3g4200d_validate_pdata(struct l3g4200d_data *gyro)
+{
+	/* checks for correctness of minimal polling period */
+	gyro->pdata->min_interval =
+		max((unsigned int)L3G4200D_MIN_POLL_PERIOD_MS,
+		    gyro->pdata->min_interval);
+
+	gyro->pdata->poll_interval = max(gyro->pdata->poll_interval,
+					 gyro->pdata->min_interval);
+
+	if (gyro->pdata->axis_map_x > 2 ||
+	    gyro->pdata->axis_map_y > 2 ||
+	    gyro->pdata->axis_map_z > 2) {
+		dev_err(gyro->dev,
+			"invalid axis_map value x:%u y:%u z:%u\n",
+			gyro->pdata->axis_map_x,
+			gyro->pdata->axis_map_y,
+			gyro->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (gyro->pdata->negate_x > 1 ||
+	    gyro->pdata->negate_y > 1 ||
+	    gyro->pdata->negate_z > 1) {
+		dev_err(gyro->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			gyro->pdata->negate_x,
+			gyro->pdata->negate_y,
+			gyro->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (gyro->pdata->poll_interval < gyro->pdata->min_interval) {
+		dev_err(gyro->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int l3g4200d_input_init(struct l3g4200d_data *gyro)
+{
+	int err = -1;
+	struct input_dev *input;
+
+
+	gyro->input_poll_dev = input_allocate_polled_device();
+	if (!gyro->input_poll_dev) {
+		err = -ENOMEM;
+		dev_err(gyro->dev, "input device allocate failed\n");
+		goto err0;
+	}
+
+	gyro->input_poll_dev->private = gyro;
+	gyro->input_poll_dev->poll = l3g4200d_input_poll_func;
+	gyro->input_poll_dev->poll_interval = gyro->pdata->poll_interval;
+
+	input = gyro->input_poll_dev->input;
+	input->name = L3G4200D_DEV_NAME;
+	input->open = l3g4200d_input_open;
+	input->close = l3g4200d_input_close;
+	input->id.bustype = gyro->bustype;
+	input->dev.parent = gyro->dev;
+	input_set_drvdata(gyro->input_poll_dev->input, gyro);
+
+	__set_bit(INPUT_EVENT_TYPE, input->evbit );
+	__set_bit(INPUT_EVENT_X, input->mscbit);
+	__set_bit(INPUT_EVENT_Y, input->mscbit);
+	__set_bit(INPUT_EVENT_Z, input->mscbit);
+
+	err = input_register_polled_device(gyro->input_poll_dev);
+	if (err) {
+		dev_err(gyro->dev,
+			"unable to register input polled device %s\n",
+			gyro->input_poll_dev->input->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_polled_device(gyro->input_poll_dev);
+err0:
+	return err;
+}
+
+static void l3g4200d_input_cleanup(struct l3g4200d_data *gyro)
+{
+	input_unregister_polled_device(gyro->input_poll_dev);
+	input_free_polled_device(gyro->input_poll_dev);
+}
+
+#ifdef CONFIG_OF
+static u32 l3g4200d_parse_dt(struct l3g4200d_data *gyro, struct device* dev)
+{
+	/* TODO: Add parsing of default configuration */
+	gyro->pdata->axis_map_x = 0;
+	gyro->pdata->axis_map_y = 1;
+	gyro->pdata->axis_map_z = 2;
+	gyro->pdata->negate_x = 0;
+	gyro->pdata->negate_y = 0;
+	gyro->pdata->negate_z = 0;
+	gyro->pdata->fs_range = L3G4200D_GYR_FS_250DPS;
+
+	return 0;
+}
+#endif
+
+int l3g4200d_common_probe(struct l3g4200d_data *gyro)
+{
+	int err = -1;
+	u8 whoami;
+
+	pr_info("%s: probe start.\n", L3G4200D_DEV_NAME);
+	
+	mutex_init(&gyro->lock);
+	mutex_init(&gyro->tb.buf_lock);
+
+	err = gyro->tf->read(gyro, WHO_AM_I, 1, &whoami);
+	if (err < 0) {
+		dev_warn(gyro->dev, "Error reading WHO_AM_I: is device "
+			 "available/working?\n");
+		return -ENODEV;
+	}
+
+	if (whoami != WHOAMI_L3G4200D) {
+		dev_err(gyro->dev,
+			"device unknown. Expected: 0x%x,"
+			" Replies: 0x%x\n", WHOAMI_L3G4200D, whoami);
+		return -ENODEV;
+	}
+
+#ifndef CONFIG_OF
+	if (gyro->dev->platform_data == NULL) {
+		dev_err(gyro->dev, "platform data is NULL. exiting.\n");
+		err = -ENODEV;
+		goto err0;
+	}
+#else
+	gyro->dev->platform_data = NULL;
+#endif
+
+	mutex_lock(&gyro->lock);
+
+	gyro->pdata = kzalloc(sizeof(struct l3g4200d_platform_data), GFP_KERNEL);
+	if (gyro->pdata == NULL) {
+		dev_err(gyro->dev, "failed to allocate memory for pdata: %d\n",
+			err);
+		goto err1;
+	}
+#ifdef CONFIG_OF
+	l3g4200d_parse_dt(gyro, gyro->dev);
+#else
+	memcpy(gyro->pdata, gyro->dev->platform_data,
+	       sizeof(*gyro->pdata));
+#endif
+
+	err = l3g4200d_validate_pdata(gyro);
+	if (err < 0) {
+		dev_err(gyro->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (gyro->pdata->init) {
+		err = gyro->pdata->init();
+		if (err < 0) {
+			dev_err(gyro->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	memset(gyro->resume_state, 0, ARRAY_SIZE(gyro->resume_state));
+
+	gyro->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES;
+	gyro->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	gyro->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	gyro->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	gyro->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+
+	err = l3g4200d_device_power_on(gyro);
+	if (err < 0) {
+		dev_err(gyro->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&gyro->enabled, 1);
+
+	err = l3g4200d_update_fs_range(gyro, gyro->pdata->fs_range);
+	if (err < 0) {
+		dev_err(gyro->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = l3g4200d_update_odr(gyro, gyro->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(gyro->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = l3g4200d_input_init(gyro);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(gyro->dev);
+	if (err < 0) {
+		dev_err(gyro->dev, "%s device register failed\n",
+			L3G4200D_DEV_NAME);
+		goto err4;
+	}
+
+	l3g4200d_device_power_off(gyro);
+
+	/* As default, do not report information */
+	atomic_set(&gyro->enabled, 0);
+
+	mutex_unlock(&gyro->lock);
+
+	pr_info("%s: probed\n", L3G4200D_DEV_NAME);
+
+	return 0;
+
+err4:
+	l3g4200d_input_cleanup(gyro);
+err3:
+	l3g4200d_device_power_off(gyro);
+err2:
+	if (gyro->pdata->exit)
+		gyro->pdata->exit();
+err1_1:
+	mutex_unlock(&gyro->lock);
+	kfree(gyro->pdata);
+err1:
+	pr_err("%s: Driver Initialization failed\n", L3G4200D_DEV_NAME);
+	return err;
+}
+EXPORT_SYMBOL(l3g4200d_common_probe);
+
+int l3g4200d_common_remove(struct l3g4200d_data *gyro)
+{
+#ifdef DEBUG
+	pr_info(KERN_INFO "L3G4200D driver removing\n");
+#endif
+	l3g4200d_input_cleanup(gyro);
+	l3g4200d_device_power_off(gyro);
+	remove_sysfs_interfaces(gyro->dev);
+	kfree(gyro->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(l3g4200d_common_remove);
+
+#ifdef CONFIG_PM
+int l3g4200d_common_suspend(struct l3g4200d_data *gyro)
+{
+#ifdef DEBUG
+	pr_info(KERN_INFO "l3g4200d_suspend\n");
+#endif /* DEBUG */
+	return 0;
+}
+EXPORT_SYMBOL(l3g4200d_common_suspend);
+
+int l3g4200d_common_resume(struct l3g4200d_data *gyro)
+{
+#ifdef DEBUG
+	pr_info(KERN_INFO "l3g4200d_resume\n");
+#endif /*DEBUG */
+	return 0;
+}
+EXPORT_SYMBOL(l3g4200d_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("l3g4200d digital gyroscope sysfs driver");
+MODULE_AUTHOR("Matteo Dameno, Carmine Iascone, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d.h b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d.h
--- a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,139 @@
+/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
+*
+* File Name		: l3g4200d.h
+* Authors		: MH - C&I BU - Application Team
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Both authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.1.3 sysfs
+* Date			: 2011/Sep/24
+* Description		: L3G4200D digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS		| DESCRIPTION
+* 1.0		| 2010/Aug/19	| Carmine Iascone	| First Release
+* 1.1.0		| 2011/02/28	| Matteo Dameno		| Self Test Added
+* 1.1.1		| 2011/05/25	| Matteo Dameno		| Corrects Polling Bug
+* 1.1.2		| 2011/05/30	| Matteo Dameno		| Corrects ODR Bug
+* 1.1.3		| 2011/06/24	| Matteo Dameno		| Corrects ODR Bug
+* 1.1.4		| 2011/09/24	| Matteo Dameno		| forces BDU setting
+*******************************************************************************/
+
+#ifndef __L3G4200D_H__
+#define __L3G4200D_H__
+
+#define L3G4200D_MIN_POLL_PERIOD_MS	2
+
+#define L3G4200D_DEV_NAME	"l3g4200d_gyr"
+
+#define L3G4200D_GYR_FS_250DPS	0x00
+#define L3G4200D_GYR_FS_500DPS	0x10
+#define L3G4200D_GYR_FS_2000DPS	0x30
+
+#define L3G4200D_GYR_ENABLED	1
+#define L3G4200D_GYR_DISABLED	0
+
+#ifdef __KERNEL__
+
+#define BUFF_RX_MAX_LENGTH	500
+#define BUFF_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		5
+
+struct l3g4200d_data;
+
+struct l3g4200d_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+struct l3g4200d_triple {
+	short x, y, z;
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+struct l3g4200d_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[BUFF_RX_MAX_LENGTH];
+	u8 tx_buf[BUFF_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/* specific bus I/O functions */
+struct l3g4200d_transfer_function {
+	int (*write)(struct l3g4200d_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct l3g4200d_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct l3g4200d_data {
+	const char *name;
+	struct device *dev;
+	struct l3g4200d_platform_data *pdata;
+	struct mutex lock;
+	u16 bustype;
+	struct input_polled_dev *input_poll_dev;
+	int hw_initialized;
+	int selftest_enabled;
+	atomic_t enabled;
+
+	u8 reg_addr;
+	u8 resume_state[RESUME_ENTRIES];
+	struct l3g4200d_transfer_function *tf;
+	struct l3g4200d_transfer_buffer tb;
+};
+
+/* Input events used by l3g4200d driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+int l3g4200d_common_probe(struct l3g4200d_data *gyro);
+int l3g4200d_common_remove(struct l3g4200d_data *gyro);
+
+#ifdef CONFIG_PM
+int l3g4200d_common_suspend(struct l3g4200d_data *gyro);
+int l3g4200d_common_resume(struct l3g4200d_data *gyro);
+#endif /* CONFIG_PM */
+
+#endif /* __KERNEL__ */
+
+#endif  /* __L3G4200D_H__ */
diff -uNr a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_i2c.c b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_i2c.c
--- a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,186 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: l3g4200d_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "l3g4200d.h"
+
+#define	I2C_AUTO_INCREMENT	0x80
+
+static int l3g4200d_i2c_read(struct l3g4200d_data *cdata, u8 reg_addr,
+			       int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int l3g4200d_i2c_write(struct l3g4200d_data *cdata, u8 reg_addr,
+				int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+static struct l3g4200d_transfer_function l3g4200d_tf_i2c = {
+	.write = l3g4200d_i2c_write,
+	.read = l3g4200d_i2c_read,
+};
+
+static int l3g4200d_i2c_probe(struct i2c_client *client,
+			        const struct i2c_device_id *id)
+{
+	int err;
+	struct l3g4200d_data *cdata;
+
+	cdata = kmalloc(sizeof(struct l3g4200d_data), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bustype = BUS_I2C;
+	cdata->tf = &l3g4200d_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = l3g4200d_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int l3g4200d_i2c_remove(struct i2c_client *client)
+{
+	struct l3g4200d_data *cdata = i2c_get_clientdata(client);
+
+	l3g4200d_common_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int l3g4200d_suspend(struct device *dev)
+{
+	struct l3g4200d_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return l3g4200d_common_suspend(cdata);
+}
+
+static int l3g4200d_resume(struct device *dev)
+{
+	struct l3g4200d_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return l3g4200d_common_resume(cdata);
+}
+
+static const struct dev_pm_ops l3g4200d_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(l3g4200d_suspend, l3g4200d_resume)
+};
+
+#define L3G4200D_PM_OPS		(&l3g4200d_pm_ops)
+#else /* CONFIG_PM */
+#define L3G4200D_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id l3g4200d_ids[] = {
+	{ L3G4200D_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, l3g4200d_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3g4200d_id_table[] = {
+	{ .compatible = "st,l3g4200d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, l3g4200d_id_table);
+#endif
+
+static struct i2c_driver l3g4200d_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = L3G4200D_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = L3G4200D_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = l3g4200d_id_table,
+#endif
+	},
+	.remove = l3g4200d_i2c_remove,
+	.probe = l3g4200d_i2c_probe,
+	.id_table = l3g4200d_ids,
+};
+
+module_i2c_driver(l3g4200d_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics l3g4200d i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_spi.c b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_spi.c
--- a/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3g4200d/l3g4200d_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,209 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: l3g4200d_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		     : Giuseppe Barba <giuseppe.barba@st.com>
+*		     : Mario Tesi <mario.tesi@st.com>
+*		     : Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "l3g4200d.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+static int l3g4200d_spi_read(struct l3g4200d_data *cdata, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int l3g4200d_spi_write(struct l3g4200d_data *cdata, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= BUFF_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static struct l3g4200d_transfer_function l3g4200d_tf_spi = {
+	.write = l3g4200d_spi_write,
+	.read = l3g4200d_spi_read,
+};
+
+static int l3g4200d_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct l3g4200d_data *cdata;
+
+	cdata = kmalloc(sizeof(struct l3g4200d_data), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->bustype = BUS_SPI;
+	cdata->tf = &l3g4200d_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = l3g4200d_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int l3g4200d_spi_remove(struct spi_device *spi)
+{
+	struct l3g4200d_data *cdata = spi_get_drvdata(spi);
+
+	l3g4200d_common_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int l3g4200d_suspend(struct device *dev)
+{
+	struct l3g4200d_data *cdata= spi_get_drvdata(to_spi_device(dev));
+
+	return l3g4200d_common_suspend(cdata);
+}
+
+static int l3g4200d_resume(struct device *dev)
+{
+	struct l3g4200d_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return l3g4200d_common_resume(cdata);
+}
+
+static const struct dev_pm_ops l3g4200d_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(l3g4200d_suspend, l3g4200d_resume)
+};
+
+#define L3G4200D_PM_OPS		(&l3g4200d_pm_ops)
+#else /* CONFIG_PM */
+#define L3G4200D_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id l3g4200d_ids[] = {
+	{ L3G4200D_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, l3g4200d_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3g4200d_id_table[] = {
+	{ .compatible = "st,l3g4200d", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, l3g4200d_id_table);
+#endif
+
+static struct spi_driver l3g4200d_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = L3G4200D_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = L3G4200D_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = l3g4200d_id_table,
+#endif
+	},
+	.remove = l3g4200d_spi_remove,
+	.probe = l3g4200d_spi_probe,
+	.id_table = l3g4200d_ids,
+};
+
+module_spi_driver(l3g4200d_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics l3g4200d spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/l3g4200d/Makefile b/drivers/input/misc/st/gyro/l3g4200d/Makefile
--- a/drivers/input/misc/st/gyro/l3g4200d/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3g4200d/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc l3g4200d driver
+#
+l3g4200d-core-y += l3g4200d_core.o
+obj-$(CONFIG_INPUT_L3G4200D) += l3g4200d-core.o
+obj-$(CONFIG_INPUT_L3G4200D_I2C) += l3g4200d_i2c.o
+obj-$(CONFIG_INPUT_L3G4200D_SPI) += l3g4200d_spi.o
diff -uNr a/drivers/input/misc/st/gyro/l3gd20/Kconfig b/drivers/input/misc/st/gyro/l3gd20/Kconfig
--- a/drivers/input/misc/st/gyro/l3gd20/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,21 @@
+
+config INPUT_L3GD20
+         tristate "STMicroelectronics L3GD20 sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_L3GD20_I2C if (I2C)
+	 select INPUT_L3GD20_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics L3GD20 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called l3gd20.
+
+config INPUT_L3GD20_I2C
+         tristate
+         depends on INPUT_L3GD20
+         depends on I2C
+
+config INPUT_L3GD20_SPI
+         tristate
+         depends on INPUT_L3GD20
+         depends on SPI
diff -uNr a/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr.c b/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr.c
--- a/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,1507 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: l3gd20_gyr.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.3 sysfs
+* Date			: 2016/Jul/19
+* Description		: L3GD20 digital output gyroscope sensor API (I2C addr 0x6b)
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+* 1.2.2		| 2015/Mar/05	| Giuseppe Barba  | Fixed setting poll rate
+* 1.2.3		| 2016/Jul/19	| Mario Tesi	  | added timestamp for cts
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/stat.h>
+
+#include "l3gd20.h"
+
+/* Maximum polled-device-reported rot speed value value in dps */
+#define MS_TO_NS(x)	(x*1000000L)
+
+/* l3gd20 gyroscope registers */
+#define WHO_AM_I	(0x0F)
+
+#define SENSITIVITY_250		8750		/*	udps/LSB */
+#define SENSITIVITY_500		17500		/*	udps/LSB */
+#define SENSITIVITY_2000	70000		/*	udps/LSB */
+
+#define CTRL_REG1	(0x20)    /* CTRL REG1 */
+#define CTRL_REG2	(0x21)    /* CTRL REG2 */
+#define CTRL_REG3	(0x22)    /* CTRL_REG3 */
+#define CTRL_REG4	(0x23)    /* CTRL_REG4 */
+#define CTRL_REG5	(0x24)    /* CTRL_REG5 */
+#define	REFERENCE	(0x25)    /* REFERENCE REG */
+#define	FIFO_CTRL_REG	(0x2E)    /* FIFO CONTROL REGISTER */
+#define FIFO_SRC_REG	(0x2F)    /* FIFO SOURCE REGISTER */
+#define	OUT_X_L		(0x28)    /* 1st AXIS OUT REG of 6 */
+
+#define AXISDATA_REG	OUT_X_L
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	(0x00)
+#define PM_OFF		(0x00)
+#define PM_NORMAL	(0x08)
+#define ENABLE_ALL_AXES	(0x07)
+#define ENABLE_NO_AXES	(0x00)
+#define BW00		(0x00)
+#define BW01		(0x10)
+#define BW10		(0x20)
+#define BW11		(0x30)
+#define ODR095		(0x00)  /* ODR =  95Hz */
+#define ODR190		(0x40)  /* ODR = 190Hz */
+#define ODR380		(0x80)  /* ODR = 380Hz */
+#define ODR760		(0xC0)  /* ODR = 760Hz */
+
+/* CTRL_REG3 bits */
+#define	I2_DRDY		(0x08)
+#define	I2_WTM		(0x04)
+#define	I2_OVRUN	(0x02)
+#define	I2_EMPTY	(0x01)
+#define	I2_NONE		(0x00)
+#define	I2_MASK		(0x0F)
+
+/* CTRL_REG4 bits */
+#define	FS_MASK		(0x30)
+#define	BDU_ENABLE	(0x80)
+
+/* CTRL_REG5 bits */
+#define	FIFO_ENABLE	(0x40)
+#define HPF_ENALBE	(0x11)
+
+/* FIFO_CTRL_REG bits */
+#define	FIFO_MODE_MASK		(0xE0)
+#define	FIFO_MODE_BYPASS	(0x00)
+#define	FIFO_MODE_FIFO		(0x20)
+#define	FIFO_MODE_STREAM	(0x40)
+#define	FIFO_MODE_STR2FIFO	(0x60)
+#define	FIFO_MODE_BYPASS2STR	(0x80)
+#define	FIFO_WATERMARK_MASK	(0x1F)
+
+#define FIFO_STORED_DATA_MASK	(0x1F)
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_FIFO_CTRL_REG	5
+
+/* #define L3GD20_DEBUG 1 */
+
+/** Registers Contents */
+#define WHOAMI_L3GD20_GYR	(0xD4)  /* Expected content for WAI register*/
+
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_MSC		MSC_RAW
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+static int int1_gpio = L3GD20_GYR_DEFAULT_INT1_GPIO;
+static int int2_gpio = L3GD20_GYR_DEFAULT_INT2_GPIO;
+/* module_param(int1_gpio, int, S_IRUGO); */
+module_param(int2_gpio, int, S_IRUGO);
+
+/*
+ * L3GD20 gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * s32
+ */
+
+struct l3gd20_gyr_triple {
+	s32	x,	/* x-axis angular rate data. */
+		y,	/* y-axis angluar rate data. */
+		z;	/* z-axis angular rate data. */
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+
+	{	2,	ODR760|BW10},
+	{	3,	ODR380|BW01},
+	{	6,	ODR190|BW00},
+	{	11,	ODR095|BW00},
+};
+
+static struct l3gd20_gyr_platform_data default_l3gd20_gyr_pdata = {
+	.fs_range = L3GD20_GYR_FS_250DPS,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+
+	.poll_interval = 100,
+	.min_interval = L3GD20_GYR_MIN_POLL_PERIOD_MS, /* 2ms */
+
+	.gpio_int1 = L3GD20_GYR_DEFAULT_INT1_GPIO,
+	.gpio_int2 = L3GD20_GYR_DEFAULT_INT2_GPIO,	/* int for fifo */
+
+};
+
+static int l3gd20_gyr_register_write(struct l3gd20_gyr_status *stat,
+		u8 *buf, u8 reg_address, u8 new_value)
+{
+	return stat->tf->write(stat->dev, reg_address, 1, &new_value);
+}
+
+static int l3gd20_gyr_register_read(struct l3gd20_gyr_status *stat,
+				    u8 *buf, u8 reg_address)
+{
+	return stat->tf->read(stat->dev, reg_address, 1, buf);
+}
+
+static int l3gd20_gyr_register_update(struct l3gd20_gyr_status *stat,
+			u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = l3gd20_gyr_register_read(stat, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = l3gd20_gyr_register_write(stat, buf, reg_address,
+						updated_val);
+	}
+	return err;
+}
+
+
+static int l3gd20_gyr_update_watermark(struct l3gd20_gyr_status *stat,
+				       u8 watermark)
+{
+	int res = 0;
+	u8 buf[2];
+	u8 new_value;
+
+	mutex_lock(&stat->lock);
+	new_value = (watermark % 0x20);
+	res = l3gd20_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+			 FIFO_WATERMARK_MASK, new_value);
+	if (res < 0) {
+		dev_err(stat->dev, "failed to update watermark\n");
+		return res;
+	}
+	dev_dbg(stat->dev, "%s new_value:0x%02x,watermark:0x%02x\n",
+		__func__, new_value, watermark);
+
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_WATERMARK_MASK & new_value) |
+		 (~FIFO_WATERMARK_MASK &
+		 stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->watermark = new_value;
+	mutex_unlock(&stat->lock);
+	return res;
+}
+
+static int l3gd20_gyr_update_fifomode(struct l3gd20_gyr_status *stat,
+				      u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	u8 new_value;
+
+	new_value = fifomode;
+	res = l3gd20_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+					FIFO_MODE_MASK, new_value);
+	if (res < 0) {
+		dev_err(stat->dev, "failed to update fifoMode\n");
+		return res;
+	}
+	/*
+	dev_dbg(stat->dev, "new_value:0x%02x,prev fifomode:0x%02x\n",
+				__func__, new_value, stat->fifomode);
+	 */
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_MODE_MASK & new_value) |
+		 (~FIFO_MODE_MASK &
+		 stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->fifomode = new_value;
+
+	return res;
+}
+
+static int l3gd20_gyr_fifo_reset(struct l3gd20_gyr_status *stat)
+{
+	u8 oldmode;
+	int res;
+
+	oldmode = stat->fifomode;
+	res = l3gd20_gyr_update_fifomode(stat, FIFO_MODE_BYPASS);
+	if (res < 0)
+		return res;
+	res = l3gd20_gyr_update_fifomode(stat, oldmode);
+	if (res >= 0)
+		dev_dbg(stat->dev, "%s fifo reset to: 0x%02x\n",
+			__func__, oldmode);
+
+	return res;
+}
+
+static int l3gd20_gyr_fifo_hwenable(struct l3gd20_gyr_status *stat,
+				    u8 enable)
+{
+	int res;
+	u8 buf[2];
+	u8 set = 0x00;
+	if (enable)
+		set = FIFO_ENABLE;
+
+	res = l3gd20_gyr_register_update(stat, buf, CTRL_REG5,
+			FIFO_ENABLE, set);
+	if (res < 0) {
+		dev_err(stat->dev, "fifo_hw switch to:0x%02x failed\n",
+			set);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG5] =
+		((FIFO_ENABLE & set) |
+		(~FIFO_ENABLE & stat->resume_state[RES_CTRL_REG5]));
+	dev_dbg(stat->dev, "%s set to:0x%02x\n", __func__, set);
+	return res;
+}
+
+static int l3gd20_gyr_manage_int2settings(struct l3gd20_gyr_status *stat,
+					  u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	bool enable_fifo_hw;
+	bool recognized_mode = false;
+	u8 int2bits = I2_NONE;
+/*
+	if (stat->polling_enabled) {
+		fifomode = FIFO_MODE_BYPASS;
+		dbg_warn(stat->dev, "in polling mode, fifo mode forced"
+							" to BYPASS mode\n");
+	}
+*/
+
+	switch (fifomode) {
+	case FIFO_MODE_FIFO:
+		recognized_mode = true;
+
+		if (stat->polling_enabled) {
+			int2bits = I2_NONE;
+			enable_fifo_hw = false;
+		} else {
+			int2bits = (I2_WTM | I2_OVRUN);
+			enable_fifo_hw = true;
+		}
+		res = l3gd20_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update "
+				"CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~(I2_MASK) & stat->resume_state[RES_CTRL_REG3]));
+		/* enable_fifo_hw = true; */
+		break;
+
+	case FIFO_MODE_BYPASS:
+		recognized_mode = true;
+
+		if (stat->polling_enabled)
+			int2bits = I2_NONE;
+		else
+			int2bits = I2_DRDY;
+
+		res = l3gd20_gyr_register_update(stat, buf, CTRL_REG3,
+						 I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update"
+				" to CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		enable_fifo_hw = false;
+		break;
+
+	default:
+		recognized_mode = false;
+		res = l3gd20_gyr_register_update(stat, buf, CTRL_REG3,
+						 I2_MASK, I2_NONE);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update "
+				"CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		enable_fifo_hw = false;
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & 0x00) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		break;
+
+	}
+	if (recognized_mode) {
+		res = l3gd20_gyr_update_fifomode(stat, fifomode);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to "
+				"set fifoMode\n", __func__);
+			goto err_mutex_unlock;
+		}
+	}
+	res = l3gd20_gyr_fifo_hwenable(stat, enable_fifo_hw);
+
+err_mutex_unlock:
+	return res;
+}
+
+
+static int l3gd20_gyr_update_fs_range(struct l3gd20_gyr_status *stat,
+				      u8 new_fs)
+{
+	int res ;
+	u8 buf[2];
+
+	u32 sensitivity;
+
+	switch(new_fs) {
+		case L3GD20_GYR_FS_250DPS:
+			sensitivity = SENSITIVITY_250;
+			break;
+		case L3GD20_GYR_FS_500DPS:
+			sensitivity = SENSITIVITY_500;
+			break;
+		case L3GD20_GYR_FS_2000DPS:
+			sensitivity = SENSITIVITY_2000;
+			break;
+		default:
+			dev_err(stat->dev, "invalid g range "
+				"requested: %u\n", new_fs);
+			return -EINVAL;
+	}
+
+	buf[0] = CTRL_REG4;
+
+	res = l3gd20_gyr_register_update(stat, buf, CTRL_REG4,
+					 FS_MASK, new_fs);
+
+	if (res < 0) {
+		dev_err(stat->dev, "%s : failed to update fs:0x%02x\n",
+			__func__, new_fs);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs) |
+		(~FS_MASK & stat->resume_state[RES_CTRL_REG4]));
+
+	stat->sensitivity = sensitivity;
+	return res;
+}
+
+
+static int l3gd20_gyr_update_odr(struct l3gd20_gyr_status *stat,
+				 unsigned int poll_interval_ms)
+{
+	int err = 0;
+	int i;
+	u8 config[1];
+
+	for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+		if ((odr_table[i].poll_rate_ms <= poll_interval_ms) || (i == 0))
+			break;
+	}
+
+	config[0] = odr_table[i].mask;
+	config[0] |= (ENABLE_ALL_AXES + PM_NORMAL);
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat->dev, CTRL_REG1, 1, config);
+		if (err < 0)
+			return err;
+	}
+	stat->resume_state[RES_CTRL_REG1] = config[0];
+	stat->ktime = ktime_set(0, MS_TO_NS(poll_interval_ms));
+
+	return err;
+}
+
+static inline int64_t l3gd20_gyr_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+/* gyroscope data readout */
+static int l3gd20_gyr_get_data(struct l3gd20_gyr_status *stat,
+			       struct l3gd20_gyr_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat->dev, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s32) ((s16)((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s32) ((s16)((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s32) ((s16)((gyro_out[5]) << 8) | gyro_out[4]);
+
+	data->x = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	data->y = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	data->z = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+#ifdef L3GD20_DEBUG
+	/* dev_info(stat->dev, "gyro_out: x = %d, y = %d, z = %d\n",
+		data->x, data->y, data->z); */
+#endif
+
+	return err;
+}
+
+static void l3gd20_gyr_report_values(struct l3gd20_gyr_status *stat,
+				     struct l3gd20_gyr_triple *data)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    data->x);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    data->y);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    data->z);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    stat->timestamp >> 32);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    stat->timestamp & 0xffffffff);
+	input_sync(stat->input_dev);
+}
+
+static int l3gd20_gyr_check_whoami(struct l3gd20_gyr_status *stat)
+{
+	u8 whoami;
+	int err;
+
+	err = stat->tf->read(stat->dev, WHO_AM_I, 1, &whoami);
+	if (err < 0)
+		return err;
+
+	if (whoami != WHOAMI_L3GD20_GYR)
+		return -ENODEV;
+
+	return 0;
+}
+
+static int l3gd20_gyr_hw_init(struct l3gd20_gyr_status *stat)
+{
+	int err;
+	u8 buf[5];
+
+	dev_info(stat->dev, "hw init\n");
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	buf[1] = stat->resume_state[RES_CTRL_REG2];
+	buf[2] = stat->resume_state[RES_CTRL_REG3];
+	buf[3] = stat->resume_state[RES_CTRL_REG4];
+	buf[4] = stat->resume_state[RES_CTRL_REG5];
+
+	err = stat->tf->write(stat->dev, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		return err;
+
+	stat->hw_initialized = 1;
+
+	return err;
+}
+
+static void l3gd20_gyr_device_power_off(struct l3gd20_gyr_status *stat)
+{
+	int err;
+	u8 buf[1];
+
+	dev_info(stat->dev, "power off\n");
+
+	buf[0] = (PM_OFF);
+	err = stat->tf->write(stat->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed\n");
+
+	if (stat->pdata->power_off) {
+		/* disable_irq_nosync(acc->irq1); */
+		disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized) {
+		/*if (stat->pdata->gpio_int1 >= 0)*/
+		/*	disable_irq_nosync(stat->irq1);*/
+		if (stat->pdata->gpio_int2 >= 0) {
+			disable_irq_nosync(stat->irq2);
+			dev_info(stat->dev,
+				 "power off: irq2 disabled\n");
+		}
+		stat->hw_initialized = 0;
+	}
+}
+
+static int l3gd20_gyr_device_power_on(struct l3gd20_gyr_status *stat)
+{
+	int err;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0)
+			return err;
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+
+	if (!stat->hw_initialized) {
+		err = l3gd20_gyr_hw_init(stat);
+		if (err < 0) {
+			l3gd20_gyr_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		/* if (stat->pdata->gpio_int1) {
+			enable_irq(stat->irq1);
+			dev_info(stat->dev,
+				 "power on: irq1 enabled\n");
+		} */
+		dev_dbg(stat->dev, "stat->pdata->gpio_int2 = %d\n",
+			stat->pdata->gpio_int2);
+		if (stat->pdata->gpio_int2 >= 0) {
+			enable_irq(stat->irq2);
+			dev_info(stat->dev,
+				"power on: irq2 enabled\n");
+		}
+	}
+
+	return 0;
+}
+
+static int l3gd20_gyr_enable(struct l3gd20_gyr_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = l3gd20_gyr_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+
+		if (stat->polling_enabled) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime, HRTIMER_MODE_REL);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+
+static int l3gd20_gyr_disable(struct l3gd20_gyr_status *stat)
+{
+	dev_dbg(stat->dev, "%s: stat->enabled = %d\n", __func__,
+		atomic_read(&stat->enabled));
+
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		mutex_lock(&stat->lock);
+		l3gd20_gyr_device_power_off(stat);
+		mutex_unlock(&stat->lock);
+
+		hrtimer_cancel(&stat->hr_timer);
+		dev_dbg(stat->dev, "%s: cancel_hrtimer ", __func__);
+	}
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	int err;
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	err = l3gd20_gyr_update_odr(stat, interval_ms);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return -EINVAL;
+	}
+
+	stat->pdata->poll_interval = interval_ms;
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	int range = 0;
+	u8 val;
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range;
+
+	switch (val) {
+	case L3GD20_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case L3GD20_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case L3GD20_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 250:
+		range = L3GD20_GYR_FS_250DPS;
+		break;
+	case 500:
+		range = L3GD20_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = L3GD20_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = l3gd20_gyr_update_fs_range(stat, range);
+	if (err >= 0)
+		stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu dps\n", val);
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		l3gd20_gyr_enable(stat);
+	else
+		l3gd20_gyr_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_polling_mode_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int val = 0;
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	if (stat->polling_enabled)
+		val = 1;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_mode_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	if (val) {
+		stat->polling_enabled = true;
+		l3gd20_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_info(dev, "polling mode enabled\n");
+		if (atomic_read(&stat->enabled)) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime, HRTIMER_MODE_REL);
+		}
+	} else {
+		if (stat->polling_enabled) {
+			hrtimer_cancel(&stat->hr_timer);
+		}
+		stat->polling_enabled = false;
+		l3gd20_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_info(dev, "polling mode disabled\n");
+	}
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_watermark_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long watermark;
+	int res;
+
+	if (strict_strtoul(buf, 16, &watermark))
+		return -EINVAL;
+
+	res = l3gd20_gyr_update_watermark(stat, watermark);
+	if (res < 0)
+		return res;
+
+	return size;
+}
+
+static ssize_t attr_watermark_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	int val = stat->watermark;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_fifomode_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long fifomode;
+	int res;
+
+	if (strict_strtoul(buf, 16, &fifomode))
+		return -EINVAL;
+	/* if (!fifomode)
+		return -EINVAL; */
+
+	dev_dbg(dev, "%s, got value:0x%02x\n", __func__, (u8)fifomode);
+
+	mutex_lock(&stat->lock);
+	res = l3gd20_gyr_manage_int2settings(stat, (u8) fifomode);
+	mutex_unlock(&stat->lock);
+
+	if (res < 0)
+		return res;
+	return size;
+}
+
+static ssize_t attr_fifomode_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	u8 val = stat->fifomode;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+#ifdef L3GD20_DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	u8 x[2];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	x[0] = val;
+	rc = stat->tf->write(stat->dev,  stat->reg_addr, 1, x);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	err = stat->tf->read(stat->dev, stat->reg_addr, 1, &data);
+	mutex_unlock(&stat->lock);
+
+	ret = sprintf(buf, "0x%02x\n", data);
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct l3gd20_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+
+	stat->reg_addr = val;
+
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif /* L3GD20_DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_polling_rate_show,
+	       attr_polling_rate_store),
+	__ATTR(range, 0666, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0666, attr_enable_show, attr_enable_store),
+	__ATTR(enable_polling, 0666, attr_polling_mode_show,
+	       attr_polling_mode_store),
+	__ATTR(fifo_samples, 0666, attr_watermark_show, attr_watermark_store),
+	__ATTR(fifo_mode, 0666, attr_fifomode_show, attr_fifomode_store),
+#ifdef L3GD20_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void l3gd20_gyr_report_triple(struct l3gd20_gyr_status *stat)
+{
+	int err;
+	struct l3gd20_gyr_triple data_out;
+
+	err = l3gd20_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(stat->dev, "get_gyroscope_data failed\n");
+	else
+		l3gd20_gyr_report_values(stat, &data_out);
+}
+
+
+static void l3gd20_gyr_irq2_fifo(struct l3gd20_gyr_status *stat)
+{
+	int err;
+	u8 buf[2];
+	u8 int_source;
+	u8 samples;
+	u8 workingmode;
+	u8 stored_samples;
+
+	mutex_lock(&stat->lock);
+
+	workingmode = stat->fifomode;
+
+	dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__, workingmode);
+
+	switch (workingmode) {
+	case FIFO_MODE_BYPASS:
+	{
+		dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+			stat->fifomode);
+		l3gd20_gyr_report_triple(stat);
+		break;
+	}
+	case FIFO_MODE_FIFO:
+		samples = (stat->watermark) + 1;
+		dev_dbg(stat->dev,
+			"%s : FIFO_SRC_REG init samples:%d\n",
+			__func__, samples);
+		err = l3gd20_gyr_register_read(stat, buf, FIFO_SRC_REG);
+		if (err < 0)
+			dev_err(stat->dev,
+				"error reading fifo source reg\n");
+
+		int_source = buf[0];
+		dev_dbg(stat->dev, "%s :FIFO_SRC_REG content:0x%02x\n",
+			__func__, int_source);
+
+		stored_samples = int_source & FIFO_STORED_DATA_MASK;
+		dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+			stat->fifomode);
+
+		dev_dbg(stat->dev, "%s : samples:%d stored:%d\n",
+			__func__, samples, stored_samples);
+
+		for (; samples > 0; samples--) {
+#ifdef L3GD20_DEBUG
+			input_event(stat->input_dev, INPUT_EVENT_TYPE,
+				    INPUT_EVENT_MSC, 1);
+			input_sync(stat->input_dev);
+#endif
+			dev_dbg(stat->dev, "%s : current sample:%d\n",
+				__func__, samples);
+
+			l3gd20_gyr_report_triple(stat);
+
+#ifdef L3GD20_DEBUG
+			input_event(stat->input_dev, INPUT_EVENT_TYPE,
+				    INPUT_EVENT_MSC, 0);
+			input_sync(stat->input_dev);
+#endif
+		}
+		l3gd20_gyr_fifo_reset(stat);
+		break;
+	}
+#ifdef L3GD20_DEBUG
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_MSC, 3);
+	input_sync(stat->input_dev);
+#endif
+
+	mutex_unlock(&stat->lock);
+}
+
+static irqreturn_t l3gd20_gyr_isr2(int irq, void *dev)
+{
+	struct l3gd20_gyr_status *stat = dev;
+
+	disable_irq_nosync(irq);
+#ifdef L3GD20_DEBUG
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_MSC, 2);
+	input_sync(stat->input_dev->input);
+#endif
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s %s: isr2 queued\n", L3GD20_GYR_DEV_NAME, __func__);
+
+	return IRQ_HANDLED;
+}
+
+static void l3gd20_gyr_irq2_work_func(struct work_struct *work)
+{
+
+	struct l3gd20_gyr_status *stat =
+		container_of(work, struct l3gd20_gyr_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:l3gd20_gyr_irq2_XXX(stat); */
+	l3gd20_gyr_irq2_fifo(stat);
+	/*  */
+	pr_debug("%s %s: IRQ2 served\n", L3GD20_GYR_DEV_NAME, __func__);
+	enable_irq(stat->irq2);
+}
+
+static int l3gd20_gyr_validate_pdata(struct l3gd20_gyr_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int) L3GD20_GYR_MIN_POLL_PERIOD_MS,
+		    stat->pdata->min_interval);
+
+	stat->pdata->poll_interval =
+		max(stat->pdata->poll_interval, stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 ||
+	    stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			stat->pdata->negate_x,
+			stat->pdata->negate_y,
+			stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int l3gd20_gyr_input_init(struct l3gd20_gyr_status *stat)
+{
+	int err = -1;
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev->name = L3GD20_GYR_DEV_NAME;
+
+	stat->input_dev->id.bustype = stat->bus_type;
+	stat->input_dev->dev.parent = stat->dev;
+
+	input_set_drvdata(stat->input_dev, stat);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev->mscbit);
+
+#ifdef L3GD20_DEBUG
+	set_bit(INPUT_EVENT_MSC, stat->input_dev->mscbit)
+#endif
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev);
+err0:
+	return err;
+}
+
+static void l3gd20_gyr_input_cleanup(struct l3gd20_gyr_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+static void poll_function_work(struct work_struct *polling_task)
+{
+	struct l3gd20_gyr_status *stat;
+	struct l3gd20_gyr_triple data_out;
+	int err;
+	ktime_t tmpkt;
+
+	stat = container_of((struct work_struct *)polling_task,
+			    struct l3gd20_gyr_status, polling_task);
+
+	/* Adjust new timeout */
+	tmpkt = ktime_sub(stat->ktime, ktime_set(0, (l3gd20_gyr_get_time_ns() -
+						     stat->timestamp)));
+	hrtimer_start(&stat->hr_timer, tmpkt, HRTIMER_MODE_REL);
+	mutex_lock(&stat->lock);
+	err = l3gd20_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(stat->dev, "get_rotation_data failed.\n");
+	else
+		l3gd20_gyr_report_values(stat, &data_out);
+	mutex_unlock(&stat->lock);
+}
+
+static enum hrtimer_restart poll_function_read(struct hrtimer *timer)
+{
+	struct l3gd20_gyr_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+			    struct l3gd20_gyr_status, hr_timer);
+	stat->timestamp = l3gd20_gyr_get_time_ns();
+
+	queue_work(stat->gyr_workqueue, &stat->polling_task);
+
+	return HRTIMER_NORESTART;
+}
+
+int l3gd20_gyr_probe(struct l3gd20_gyr_status *stat)
+{
+	int err;
+
+	mutex_lock(&stat->lock);
+
+	err = l3gd20_gyr_check_whoami(stat);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err1;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_l3gd20_gyr_pdata.gpio_int1 = int1_gpio;
+		default_l3gd20_gyr_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_l3gd20_gyr_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = l3gd20_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES |
+					    PM_NORMAL;
+	stat->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	stat->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	stat->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+
+	stat->polling_enabled = true;
+	dev_info(stat->dev, "polling mode enabled\n");
+
+	err = l3gd20_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = l3gd20_gyr_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = l3gd20_gyr_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = l3gd20_gyr_input_init(stat);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"%s device register failed\n", L3GD20_GYR_DEV_NAME);
+		goto err4;
+	}
+
+	l3gd20_gyr_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+	stat->irq2_work_queue = NULL;
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		dev_info(stat->dev, "%s: %s has set irq2 to irq:"
+			 " %d mapped on gpio:%d\n",
+			 L3GD20_GYR_DEV_NAME, __func__, stat->irq2,
+			 stat->pdata->gpio_int2);
+
+		INIT_WORK(&stat->irq2_work, l3gd20_gyr_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("l3gd20_gyr_irq2_wq");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev, "cannot create "
+				"work queue2: %d\n", err);
+			goto err5;
+		}
+
+		err = request_irq(stat->irq2, l3gd20_gyr_isr2,
+				  IRQF_TRIGGER_HIGH, "l3gd20_gyr_irq2", stat);
+
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err5;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	stat->gyr_workqueue = create_workqueue("l3gd20_gyr_workqueue");
+	if (!stat->gyr_workqueue)
+		goto err5;
+
+	hrtimer_init(&stat->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer.function = &poll_function_read;
+
+	INIT_WORK(&stat->polling_task, poll_function_work);
+
+	mutex_unlock(&stat->lock);
+
+	return 0;
+
+err5:
+	if (stat->irq2_work_queue) {
+		destroy_workqueue(stat->irq2_work_queue);
+		stat->irq2_work_queue = NULL;
+	}
+	l3gd20_gyr_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+err4:
+	l3gd20_gyr_input_cleanup(stat);
+err3:
+	l3gd20_gyr_device_power_off(stat);
+err2:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+err1_1:
+	mutex_unlock(&stat->lock);
+	kfree(stat->pdata);
+err1:
+	return err;
+}
+EXPORT_SYMBOL(l3gd20_gyr_probe);
+
+int l3gd20_gyr_remove(struct l3gd20_gyr_status *stat)
+{
+	cancel_work_sync(&stat->polling_task);
+	if(stat->gyr_workqueue) {
+		destroy_workqueue(stat->gyr_workqueue);
+		stat->gyr_workqueue = NULL;
+	}
+	/*
+	if (stat->pdata->gpio_int1 >= 0)
+	{
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+	*/
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+		stat->irq2_work_queue = NULL;
+	}
+
+	l3gd20_gyr_disable(stat);
+	l3gd20_gyr_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(l3gd20_gyr_remove);
+
+int l3gd20_gyr_suspend(struct l3gd20_gyr_status *stat)
+{
+	int err = 0;
+#define SLEEP
+#ifdef CONFIG_PM
+	u8 buf[2];
+
+	if (atomic_read(&stat->enabled)) {
+		mutex_lock(&stat->lock);
+		if (stat->polling_enabled) {
+			dev_info(stat->dev, "polling mode disabled\n");
+			hrtimer_cancel(&stat->hr_timer);
+		}
+#ifdef SLEEP
+		err = l3gd20_gyr_register_update(stat, buf, CTRL_REG1,
+				0x0F, (ENABLE_NO_AXES | PM_NORMAL));
+#else
+		err = l3gd20_gyr_register_update(stat, buf, CTRL_REG1,
+				0x08, PM_OFF);
+#endif /*SLEEP*/
+		mutex_unlock(&stat->lock);
+	}
+#endif /*CONFIG_PM*/
+	return (err < 0) ? err : 0;
+}
+EXPORT_SYMBOL(l3gd20_gyr_suspend);
+
+int l3gd20_gyr_resume(struct l3gd20_gyr_status *stat)
+{
+	int err = 0;
+#ifdef CONFIG_PM
+	u8 buf[2];
+
+	if (atomic_read(&stat->enabled)) {
+		mutex_lock(&stat->lock);
+		if (stat->polling_enabled) {
+			dev_info(stat->dev, "polling mode enabled\n");
+			hrtimer_start(&stat->hr_timer, stat->ktime, HRTIMER_MODE_REL);
+		}
+#ifdef SLEEP
+		err = l3gd20_gyr_register_update(stat, buf, CTRL_REG1,
+				0x0F, (ENABLE_ALL_AXES | PM_NORMAL));
+#else
+		err = l3gd20_gyr_register_update(stat, buf, CTRL_REG1,
+				0x08, PM_NORMAL);
+#endif
+		mutex_unlock(&stat->lock);
+
+	}
+#endif /*CONFIG_PM*/
+	return (err < 0) ? err : 0;
+}
+EXPORT_SYMBOL(l3gd20_gyr_resume);
+
+MODULE_DESCRIPTION("l3gd20 gyroscope driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_i2c.c b/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_i2c.c
--- a/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,185 @@
+/*
+ * STMicroelectronics l3gd20_gyr_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "l3gd20.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold stat->lock */
+static int l3gd20_gyr_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold stat->lock */
+static int l3gd20_gyr_i2c_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct l3gd20_gyr_transfer_function l3gd20_gyr_i2c_tf = {
+	.write = l3gd20_gyr_i2c_write,
+	.read = l3gd20_gyr_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int l3gd20_gyr_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct l3gd20_gyr_status *stat = i2c_get_clientdata(client);
+
+	return l3gd20_gyr_resume(stat);
+}
+
+static int l3gd20_gyr_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct l3gd20_gyr_status *stat = i2c_get_clientdata(client);
+
+	return l3gd20_gyr_suspend(stat);
+}
+
+static const struct dev_pm_ops l3gd20_gyr_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(l3gd20_gyr_i2c_suspend,
+				l3gd20_gyr_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int l3gd20_gyr_i2c_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int err;
+	struct l3gd20_gyr_status *stat;
+
+#ifdef L3GD20_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct l3gd20_gyr_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bus_type = BUS_I2C;
+	stat->tf = &l3gd20_gyr_i2c_tf;
+
+	i2c_set_clientdata(client, stat);
+
+	mutex_init(&stat->lock);
+
+	err = l3gd20_gyr_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int l3gd20_gyr_i2c_remove(struct i2c_client *client)
+{
+	struct l3gd20_gyr_status *stat = i2c_get_clientdata(client);
+
+#ifdef L3GD20_DEBUG
+	dev_info(stat->dev, "driver removing\n");
+#endif
+
+	l3gd20_gyr_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct i2c_device_id l3gd20_gyr_i2c_id[] = {
+	{ "l3gd20_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, l3gd20_gyr_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3gd20_gyr_i2c_id_table[] = {
+	{ .compatible = "st,l3gd20_gyr", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, l3gd20_gyr_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver l3gd20_gyr_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "l3gd20_gyr_i2c",
+#ifdef CONFIG_PM
+		.pm = &l3gd20_gyr_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = l3gd20_gyr_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = l3gd20_gyr_i2c_probe,
+	.remove = l3gd20_gyr_i2c_remove,
+	.id_table = l3gd20_gyr_i2c_id,
+};
+
+module_i2c_driver(l3gd20_gyr_i2c_driver);
+
+MODULE_DESCRIPTION("l3gd20 gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_spi.c b/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_spi.c
--- a/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20/l3gd20_gyr_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,200 @@
+/*
+ * STMicroelectronics l3gd20_gyr_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "l3gd20.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold stat->lock */
+static int l3gd20_gyr_spi_read(struct device *device, u8 addr, int len,
+				u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20_gyr_status *stat = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	stat->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold stat->lock */
+static int l3gd20_gyr_spi_write(struct device *device, u8 addr, int len,
+				     u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20_gyr_status *stat = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= L3GD20_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	stat->tb.tx_buf[0] = addr;
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct l3gd20_gyr_transfer_function l3gd20_gyr_spi_tf = {
+	.write = l3gd20_gyr_spi_write,
+	.read = l3gd20_gyr_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int l3gd20_gyr_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20_gyr_status *stat = spi_get_drvdata(spi);
+
+	return l3gd20_gyr_resume(stat);
+}
+
+static int l3gd20_gyr_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20_gyr_status *stat = spi_get_drvdata(spi);
+
+	return l3gd20_gyr_suspend(stat);
+}
+
+static const struct dev_pm_ops l3gd20_gyr_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(l3gd20_gyr_spi_suspend,
+				l3gd20_gyr_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int l3gd20_gyr_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct l3gd20_gyr_status *stat;
+
+#ifdef L3GD20_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct l3gd20_gyr_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->name = spi->modalias;
+	stat->bus_type = BUS_SPI;
+	stat->tf = &l3gd20_gyr_spi_tf;
+	stat->dev = &spi->dev;
+
+	spi_set_drvdata(spi, stat);
+
+	mutex_init(&stat->lock);
+
+	err = l3gd20_gyr_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+		return err;
+	}
+
+	return 0;
+}
+
+int l3gd20_gyr_spi_remove(struct spi_device *spi)
+{
+	struct l3gd20_gyr_status *stat = spi_get_drvdata(spi);
+
+#ifdef L3GD20_DEBUG
+	dev_info(stat->dev, "driver removing\n");
+#endif
+
+	l3gd20_gyr_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct spi_device_id l3gd20_gyr_spi_id[] = {
+	{ "l3gd20_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, l3gd20_gyr_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3gd20_gyr_spi_id_table[] = {
+	{ .compatible = "st,l3gd20_gyr" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, l3gd20_gyr_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver l3gd20_gyr_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "l3gd20_gyr_spi",
+#ifdef CONFIG_PM
+		.pm = &l3gd20_gyr_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = l3gd20_gyr_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = l3gd20_gyr_spi_probe,
+	.remove = l3gd20_gyr_spi_remove,
+	.id_table = l3gd20_gyr_spi_id,
+};
+
+module_spi_driver(l3gd20_gyr_spi_driver);
+
+MODULE_DESCRIPTION("l3gd20 gyr spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/gyro/l3gd20/l3gd20.h b/drivers/input/misc/st/gyro/l3gd20/l3gd20.h
--- a/drivers/input/misc/st/gyro/l3gd20/l3gd20.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20/l3gd20.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,164 @@
+/******************** (C) COPYRIGHT 2012 STMicroelectronics ********************
+*
+* File Name		: l3gd20.h
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.2 sysfs
+* Date			: 2016/Jul/19
+* Description		: L3GD20 digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+* 1.2.2		| 2016/Jul/19	| Mario Tesi	  | added timestamp for cts
+*******************************************************************************/
+
+#ifndef __L3GD20_GYR_H__
+#define __L3GD20_GYR_H__
+
+#define L3GD20_GYR_DEV_NAME		"l3gd20_gyr"
+
+#define L3GD20_GYR_ENABLED		1
+#define L3GD20_GYR_DISABLED		0
+
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones havew to be set to -EINVAL
+ */
+#define L3GD20_GYR_DEFAULT_INT1_GPIO		(-EINVAL)
+#define L3GD20_GYR_DEFAULT_INT2_GPIO		(-EINVAL)
+
+#define L3GD20_GYR_MIN_POLL_PERIOD_MS	2
+
+#define L3GD20_GYR_FS_250DPS		(0x00)
+#define L3GD20_GYR_FS_500DPS		(0x10)
+#define L3GD20_GYR_FS_2000DPS	(0x30)
+
+struct l3gd20_gyr_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	/* gpio ports for interrupt pads */
+	int gpio_int1;
+	int gpio_int2;		/* int for fifo */
+
+	/* axis mapping */
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+#define	RESUME_ENTRIES		6
+
+#if defined(CONFIG_INPUT_L3GD20_SPI) || \
+    defined(CONFIG_INPUT_L3GD20_SPI_MODULE)
+#define L3GD20_RX_MAX_LENGTH		500
+#define L3GD20_TX_MAX_LENGTH		500
+
+struct l3gd20_gyr_transfer_buffer {
+	u8 rx_buf[L3GD20_RX_MAX_LENGTH];
+	u8 tx_buf[L3GD20_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif
+
+struct l3gd20_gyr_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+struct l3gd20_gyr_status {
+	const char *name;
+	struct device *dev;
+	u16 bus_type;
+	struct i2c_client *client;
+	struct l3gd20_gyr_platform_data *pdata;
+
+	struct mutex lock;
+	struct workqueue_struct *gyr_workqueue;
+	struct input_dev *input_dev;
+	int64_t timestamp;
+
+	int hw_initialized;
+	atomic_t enabled;
+
+	u8 reg_addr;
+	u8 resume_state[RESUME_ENTRIES];
+
+	u32 sensitivity;
+
+	/* interrupt related */
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	bool polling_enabled;
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+	struct work_struct polling_task;
+
+	struct l3gd20_gyr_transfer_function *tf;
+#if defined(CONFIG_INPUT_L3GD20_SPI) || \
+    defined(CONFIG_INPUT_L3GD20_SPI_MODULE)
+	struct l3gd20_gyr_transfer_buffer tb;
+#endif /* CONFIG_INPUT_L3GD20_SPI */
+};
+
+int l3gd20_gyr_probe(struct l3gd20_gyr_status *stat);
+int l3gd20_gyr_remove(struct l3gd20_gyr_status *stat);
+int l3gd20_gyr_suspend(struct l3gd20_gyr_status *stat);
+int l3gd20_gyr_resume(struct l3gd20_gyr_status *stat);
+
+#endif  /* __L3GD20_GYR_H__ */
diff -uNr a/drivers/input/misc/st/gyro/l3gd20/Makefile b/drivers/input/misc/st/gyro/l3gd20/Makefile
--- a/drivers/input/misc/st/gyro/l3gd20/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,11 @@
+#
+# Makefile for the input misc l3gd20 driver.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_INPUT_L3GD20) += l3gd20_gyr.o
+obj-$(CONFIG_INPUT_L3GD20_I2C) += l3gd20_gyr_i2c.o
+obj-$(CONFIG_INPUT_L3GD20_SPI) += l3gd20_gyr_spi.o
+
+# ccflags-y += -DL3GD20_DEBUG
diff -uNr a/drivers/input/misc/st/gyro/l3gd20h/Kconfig b/drivers/input/misc/st/gyro/l3gd20h/Kconfig
--- a/drivers/input/misc/st/gyro/l3gd20h/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20h/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,21 @@
+
+config INPUT_L3GD20H
+         tristate "STMicroelectronics L3GD20H sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_L3GD20H_I2C if (I2C)
+	 select INPUT_L3GD20H_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics L3GD20H sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called l3gd20h.
+
+config INPUT_L3GD20H_I2C
+         tristate
+         depends on INPUT_L3GD20H
+         depends on I2C
+
+config INPUT_L3GD20H_SPI
+         tristate
+         depends on INPUT_L3GD20H
+         depends on SPI
diff -uNr a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr.c b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr.c
--- a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,1510 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: l3gd20h_gyr.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.2 sysfs
+* Date			: 2016/Jul/19
+* Description		: L3GD20H digital output gyroscope sensor API (I2C addr 0x6b)
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+* 1.2.2		| 2016/Jul/19	| Mario Tesi	  | added timestamp for cts
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/stat.h>
+
+#include "l3gd20h.h"
+
+/* Maximum polled-device-reported rot speed value value in dps */
+#define MS_TO_NS(x)		(x*1000000L)
+
+/* l3gd20h gyroscope registers */
+#define WHO_AM_I	(0x0F)
+
+#define SENSITIVITY_250		8750		/*	udps/LSB */
+#define SENSITIVITY_500		17500		/*	udps/LSB */
+#define SENSITIVITY_2000	70000		/*	udps/LSB */
+
+#define CTRL_REG1	(0x20)    /* CTRL REG1 */
+#define CTRL_REG2	(0x21)    /* CTRL REG2 */
+#define CTRL_REG3	(0x22)    /* CTRL_REG3 */
+#define CTRL_REG4	(0x23)    /* CTRL_REG4 */
+#define CTRL_REG5	(0x24)    /* CTRL_REG5 */
+#define	REFERENCE	(0x25)    /* REFERENCE REG */
+#define	FIFO_CTRL_REG	(0x2E)    /* FIFO CONTROL REGISTER */
+#define FIFO_SRC_REG	(0x2F)    /* FIFO SOURCE REGISTER */
+#define	OUT_X_L		(0x28)    /* 1st AXIS OUT REG of 6 */
+
+#define AXISDATA_REG	OUT_X_L
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	(0x00)
+#define PM_OFF		(0x00)
+#define PM_NORMAL	(0x08)
+#define ENABLE_ALL_AXES	(0x07)
+#define ENABLE_NO_AXES	(0x00)
+#define BW00		(0x00)
+#define BW01		(0x10)
+#define BW10		(0x20)
+#define BW11		(0x30)
+#define ODR12		(0x00)  /* ODR = 12.5Hz */
+#define ODR25		(0x40)  /* ODR = 25Hz */
+#define ODR50		(0x80)  /* ODR = 50Hz */
+#define ODR100		(0x00)  /* ODR = 100Hz */
+#define ODR200		(0x40)  /* ODR = 200Hz */
+#define ODR400		(0x80)  /* ODR = 400Hz */
+#define ODR800		(0xC0)  /* ODR = 800Hz */
+
+/* CTRL_REG3 bits */
+#define	I2_DRDY		(0x08)
+#define	I2_WTM		(0x04)
+#define	I2_OVRUN	(0x02)
+#define	I2_EMPTY	(0x01)
+#define	I2_NONE		(0x00)
+#define	I2_MASK		(0x0F)
+
+/* CTRL_REG4 bits */
+#define	FS_MASK		(0x30)
+#define	BDU_ENABLE	(0x80)
+
+/* CTRL_REG5 bits */
+#define	FIFO_ENABLE	(0x40)
+#define HPF_ENALBE	(0x11)
+
+/* FIFO_CTRL_REG bits */
+#define	FIFO_MODE_MASK		(0xE0)
+#define	FIFO_MODE_BYPASS	(0x00)
+#define	FIFO_MODE_FIFO		(0x20)
+#define	FIFO_MODE_STREAM	(0x40)
+#define	FIFO_MODE_STR2FIFO	(0x60)
+#define	FIFO_MODE_BYPASS2STR	(0x80)
+#define	FIFO_WATERMARK_MASK	(0x1F)
+
+#define FIFO_STORED_DATA_MASK	(0x1F)
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_FIFO_CTRL_REG	5
+
+/* LOW_ODR REGISTER */
+#define LOW_ODR_REGISTER	(0x39)
+#define LOW_ODR_DISABLE		(0x00)
+#define LOW_ODR_ENABLE		(0x01)
+#define LOW_ODR_MASK		(0x01)
+
+/** Registers Contents */
+#define WHOAMI_L3GD20H_GYR	(0xD7)  /* Expected content for WAI register*/
+
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+static int int2_gpio = L3GD20H_GYR_DEFAULT_INT2_GPIO;
+
+module_param(int2_gpio, int, S_IRUGO);
+
+/*
+ * L3GD20H gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * s32
+ */
+
+struct l3gd20h_gyr_triple {
+	s32	x,	/* x-axis angular rate data. */
+		y,	/* y-axis angluar rate data. */
+		z;	/* z-axis angular rate data. */
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+	{	1,	ODR800|BW10},
+	{	2,	ODR400|BW01},
+	{	5,	ODR200|BW00},
+	{	10,	ODR100|BW00},
+};
+
+static const struct output_rate odr_table_low_odr[] = {
+	{	20,	ODR50|BW10},
+	{	40,	ODR25|BW01},
+	{	80,	ODR12|BW00},
+};
+
+static struct l3gd20h_gyr_platform_data default_l3gd20h_gyr_pdata = {
+	.fs_range = L3GD20H_GYR_FS_250DPS,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+
+	.poll_interval = 100,
+	.min_interval = L3GD20H_GYR_MIN_POLL_PERIOD_MS, /* 2ms */
+
+	.gpio_int2 = L3GD20H_GYR_DEFAULT_INT2_GPIO,	/* int for fifo */
+
+};
+
+static int l3gd20h_gyr_register_write(struct l3gd20h_gyr_status *stat,
+		u8 *buf, u8 reg_address, u8 new_value)
+{
+	return stat->tf->write(stat->dev, reg_address, 1, &new_value);
+}
+
+static int l3gd20h_gyr_register_read(struct l3gd20h_gyr_status *stat,
+				     u8 *buf, u8 reg_address)
+{
+	return stat->tf->read(stat->dev, reg_address, 1, buf);
+}
+
+static int l3gd20h_gyr_register_update(struct l3gd20h_gyr_status *stat,
+			u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = l3gd20h_gyr_register_read(stat, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = l3gd20h_gyr_register_write(stat, buf, reg_address,
+						 updated_val);
+	}
+	return err;
+}
+
+static int l3gd20h_gyr_update_watermark(struct l3gd20h_gyr_status *stat,
+					u8 watermark)
+{
+	int res = 0;
+	u8 buf[2];
+	u8 new_value;
+
+	mutex_lock(&stat->lock);
+	new_value = (watermark % 0x20);
+	res = l3gd20h_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+			 FIFO_WATERMARK_MASK, new_value);
+	if (res < 0) {
+		dev_err(stat->dev, "failed to update watermark\n");
+		return res;
+	}
+	dev_dbg(stat->dev, "%s new_value:0x%02x,watermark:0x%02x\n",
+			   __func__, new_value, watermark);
+
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_WATERMARK_MASK & new_value) |
+		(~FIFO_WATERMARK_MASK &
+		 stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->watermark = new_value;
+	mutex_unlock(&stat->lock);
+	return res;
+}
+
+static int l3gd20h_gyr_update_fifomode(struct l3gd20h_gyr_status *stat,
+				       u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	u8 new_value;
+
+	new_value = fifomode;
+	res = l3gd20h_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+					  FIFO_MODE_MASK, new_value);
+	if (res < 0) {
+		dev_err(stat->dev, "failed to update fifoMode\n");
+		return res;
+	}
+
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_MODE_MASK & new_value) |
+		(~FIFO_MODE_MASK &
+		 stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->fifomode = new_value;
+
+	return res;
+}
+
+static int l3gd20h_gyr_fifo_reset(struct l3gd20h_gyr_status *stat)
+{
+	u8 oldmode;
+	int res;
+
+	oldmode = stat->fifomode;
+	res = l3gd20h_gyr_update_fifomode(stat, FIFO_MODE_BYPASS);
+	if (res < 0)
+		return res;
+	res = l3gd20h_gyr_update_fifomode(stat, oldmode);
+	if (res >= 0)
+		dev_dbg(stat->dev, "%s fifo reset to: 0x%02x\n",
+			__func__, oldmode);
+
+	return res;
+}
+
+static int l3gd20h_gyr_fifo_hwenable(struct l3gd20h_gyr_status *stat,
+				     u8 enable)
+{
+	int res;
+	u8 buf[2];
+	u8 set = 0x00;
+	if (enable)
+		set = FIFO_ENABLE;
+
+	res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG5,
+			FIFO_ENABLE, set);
+	if (res < 0) {
+		dev_err(stat->dev, "fifo_hw switch to:0x%02x failed\n", set);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG5] =
+		((FIFO_ENABLE & set) |
+		(~FIFO_ENABLE & stat->resume_state[RES_CTRL_REG5]));
+	dev_dbg(stat->dev, "%s set to:0x%02x\n", __func__, set);
+	return res;
+}
+
+static int l3gd20h_gyr_manage_int2settings(struct l3gd20h_gyr_status *stat,
+					   u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	bool enable_fifo_hw;
+	bool recognized_mode = false;
+	u8 int2bits = I2_NONE;
+
+	switch (fifomode) {
+	case FIFO_MODE_FIFO:
+		recognized_mode = true;
+
+		if (stat->polling_enabled) {
+			int2bits = I2_NONE;
+			enable_fifo_hw = false;
+		} else {
+			int2bits = (I2_WTM | I2_OVRUN);
+			enable_fifo_hw = true;
+		}
+		res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG3,
+						  I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update "
+				"CTRL_REG3:0x%02x\n", __func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~(I2_MASK) & stat->resume_state[RES_CTRL_REG3]));
+		/* enable_fifo_hw = true; */
+		break;
+
+	case FIFO_MODE_BYPASS:
+		recognized_mode = true;
+
+		if (stat->polling_enabled)
+			int2bits = I2_NONE;
+		else
+			int2bits = I2_DRDY;
+
+		res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG3,
+						  I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update"
+				" to CTRL_REG3:0x%02x\n", __func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		enable_fifo_hw = false;
+		break;
+
+	default:
+		recognized_mode = false;
+		res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG3,
+						  I2_MASK, I2_NONE);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update "
+				"CTRL_REG3:0x%02x\n", __func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		enable_fifo_hw = false;
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & 0x00) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		break;
+
+	}
+	if (recognized_mode) {
+		res = l3gd20h_gyr_update_fifomode(stat, fifomode);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to "
+				"set fifoMode\n", __func__);
+			goto err_mutex_unlock;
+		}
+	}
+	res = l3gd20h_gyr_fifo_hwenable(stat, enable_fifo_hw);
+
+err_mutex_unlock:
+	return res;
+}
+
+static int l3gd20h_gyr_update_fs_range(struct l3gd20h_gyr_status *stat,
+				       u8 new_fs)
+{
+	int res ;
+	u8 buf[2];
+
+	u32 sensitivity;
+
+	switch(new_fs) {
+		case L3GD20H_GYR_FS_250DPS:
+			sensitivity = SENSITIVITY_250;
+			break;
+		case L3GD20H_GYR_FS_500DPS:
+			sensitivity = SENSITIVITY_500;
+			break;
+		case L3GD20H_GYR_FS_2000DPS:
+			sensitivity = SENSITIVITY_2000;
+			break;
+		default:
+			dev_err(stat->dev, "invalid g range "
+				"requested: %u\n", new_fs);
+			return -EINVAL;
+	}
+
+	buf[0] = CTRL_REG4;
+
+	res = l3gd20h_gyr_register_update(stat, buf, CTRL_REG4,
+					  FS_MASK, new_fs);
+
+	if (res < 0) {
+		dev_err(stat->dev, "%s : failed to update fs:0x%02x\n",
+			__func__, new_fs);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs) |
+		(~FS_MASK & stat->resume_state[RES_CTRL_REG4]));
+
+	stat->sensitivity = sensitivity;
+	return res;
+}
+
+static int l3gd20h_gyr_update_odr(struct l3gd20h_gyr_status *stat,
+				  unsigned int poll_interval_ms)
+{
+	int i, err = 0;
+	u8 config[1];
+
+	if (!atomic_read(&stat->low_odr_enabled)) {
+		for(i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+			if(odr_table[i].poll_rate_ms <= poll_interval_ms)
+				break;
+		}
+		config[0] = odr_table[i].mask;
+	} else {
+		for(i = ARRAY_SIZE(odr_table_low_odr) - 1; i >= 0; i--) {
+			if(odr_table_low_odr[i].poll_rate_ms <= poll_interval_ms)
+				break;
+		}
+		config[0] = odr_table_low_odr[i].mask;
+	}
+	config[0] |= (ENABLE_ALL_AXES + PM_NORMAL);
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat->dev, CTRL_REG1, 1, config);
+		if (err < 0)
+			return err;
+	}
+	stat->resume_state[RES_CTRL_REG1] = config[0];
+	stat->ktime = ktime_set(0, MS_TO_NS(poll_interval_ms));
+
+	return err;
+}
+
+static int l3gd20h_gyr_enable_low_odr(struct l3gd20h_gyr_status *stat,
+				      unsigned int enable)
+{
+	int res;
+	int status;
+	u8 buf[1];
+
+	res = stat->tf->read(stat->dev, LOW_ODR_REGISTER, 1, buf);
+	if(res<0)
+		return -1;
+	status = (int)(buf[0] & LOW_ODR_MASK);
+	buf[0] = (enable > 0) ? LOW_ODR_ENABLE : LOW_ODR_DISABLE;
+	res = stat->tf->write(stat->dev, LOW_ODR_REGISTER, 1, buf);
+	if(res<0) {
+		if(status > 0)
+			return 1;
+		else
+			return -1;
+	}
+	return enable;
+}
+
+static inline int64_t l3gd20h_gyr_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+/* gyroscope data readout */
+static int l3gd20h_gyr_get_data(struct l3gd20h_gyr_status *stat,
+				struct l3gd20h_gyr_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat->dev, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s32) ((s16)((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s32) ((s16)((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s32) ((s16)((gyro_out[5]) << 8) | gyro_out[4]);
+
+	data->x = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	data->y = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	data->z = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void l3gd20h_gyr_report_values(struct l3gd20h_gyr_status *stat,
+				      struct l3gd20h_gyr_triple *data)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    data->x);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    data->y);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    data->z);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    stat->timestamp >> 32);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    stat->timestamp & 0xffffffff);
+	input_sync(stat->input_dev);
+}
+
+static int l3gd20h_gyr_check_whoami(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 data;
+
+	err = stat->tf->read(stat->dev, WHO_AM_I, 1, &data);
+	if (err < 0) {
+		dev_err(stat->dev, "%s: error reading whoami register\n",
+			__func__);
+		return err;
+	}
+
+	if (data != WHOAMI_L3GD20H_GYR) {
+		dev_err(stat->dev, "whoami_check failed [%02x-%02x]\n",
+			data, WHOAMI_L3GD20H_GYR);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int l3gd20h_gyr_hw_init(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 buf[5];
+
+	dev_info(stat->dev, "hw init\n");
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	buf[1] = stat->resume_state[RES_CTRL_REG2];
+	buf[2] = stat->resume_state[RES_CTRL_REG3];
+	buf[3] = stat->resume_state[RES_CTRL_REG4];
+	buf[4] = stat->resume_state[RES_CTRL_REG5];
+
+	err = stat->tf->write(stat->dev, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+			return err;
+
+	stat->hw_initialized = 1;
+
+	return err;
+}
+
+static void l3gd20h_gyr_device_power_off(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 buf[1];
+
+	dev_info(stat->dev, "power off\n");
+
+	buf[0] = (PM_OFF);
+	err = stat->tf->write(stat->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed\n");
+
+	if (stat->pdata->power_off) {
+		disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized) {
+		if (stat->pdata->gpio_int2 >= 0) {
+			disable_irq_nosync(stat->irq2);
+			dev_info(stat->dev,
+				 "power off: irq2 disabled\n");
+		}
+		stat->hw_initialized = 0;
+	}
+}
+
+static int l3gd20h_gyr_device_power_on(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0)
+			return err;
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+
+	if (!stat->hw_initialized) {
+		err = l3gd20h_gyr_hw_init(stat);
+		if (err < 0) {
+			l3gd20h_gyr_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		dev_dbg(stat->dev, "stat->pdata->gpio_int2 = %d\n",
+			stat->pdata->gpio_int2);
+		if (stat->pdata->gpio_int2 >= 0) {
+			enable_irq(stat->irq2);
+			dev_info(stat->dev,
+				 "power on: irq2 enabled\n");
+		}
+	}
+
+	return 0;
+}
+
+static int l3gd20h_gyr_enable(struct l3gd20h_gyr_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = l3gd20h_gyr_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+
+		if (stat->polling_enabled) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime,
+				      HRTIMER_MODE_REL);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+
+static int l3gd20h_gyr_disable(struct l3gd20h_gyr_status *stat)
+{
+	dev_dbg(stat->dev, "%s: stat->enabled = %d\n", __func__,
+		atomic_read(&stat->enabled));
+
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		mutex_lock(&stat->lock);
+		l3gd20h_gyr_device_power_off(stat);
+		mutex_unlock(&stat->lock);
+
+		hrtimer_cancel(&stat->hr_timer);
+		dev_dbg(stat->dev, "%s: cancel_hrtimer ", __func__);
+	}
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	int err;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	err = l3gd20h_gyr_update_odr(stat, interval_ms);
+	if(err >= 0)
+		stat->pdata->poll_interval = interval_ms;
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int range = 0;
+	u8 val;
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range;
+
+	switch (val) {
+	case L3GD20H_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case L3GD20H_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case L3GD20H_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 250:
+		range = L3GD20H_GYR_FS_250DPS;
+		break;
+	case 500:
+		range = L3GD20H_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = L3GD20H_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+			" discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = l3gd20h_gyr_update_fs_range(stat, range);
+	if (err >= 0)
+		stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu dps\n", val);
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		l3gd20h_gyr_enable(stat);
+	else
+		l3gd20h_gyr_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_polling_mode_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int val = 0;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	if (stat->polling_enabled)
+		val = 1;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_mode_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	if (val) {
+		stat->polling_enabled = true;
+		l3gd20h_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_info(dev, "polling mode enabled\n");
+		if (atomic_read(&stat->enabled)) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime, HRTIMER_MODE_REL);
+		}
+	} else {
+		if (stat->polling_enabled) {
+			hrtimer_cancel(&stat->hr_timer);
+		}
+		stat->polling_enabled = false;
+		l3gd20h_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_info(dev, "polling mode disabled\n");
+	}
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_watermark_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long watermark;
+	int res;
+
+	if (strict_strtoul(buf, 16, &watermark))
+		return -EINVAL;
+
+	res = l3gd20h_gyr_update_watermark(stat, watermark);
+	if (res < 0)
+		return res;
+
+	return size;
+}
+
+static ssize_t attr_watermark_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int val = stat->watermark;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_fifomode_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long fifomode;
+	int res;
+
+	if (strict_strtoul(buf, 16, &fifomode))
+		return -EINVAL;
+	/* if (!fifomode)
+		return -EINVAL; */
+
+	dev_dbg(dev, "%s, got value:0x%02x\n", __func__, (u8)fifomode);
+
+	mutex_lock(&stat->lock);
+	res = l3gd20h_gyr_manage_int2settings(stat, (u8) fifomode);
+	mutex_unlock(&stat->lock);
+
+	if (res < 0)
+		return res;
+	return size;
+}
+
+static ssize_t attr_fifomode_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	u8 val = stat->fifomode;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_get_low_odr(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->low_odr_enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_low_odr(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long enable;
+	int res;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	res = l3gd20h_gyr_enable_low_odr(stat, enable);
+	if(res<=0)
+		atomic_set(&stat->low_odr_enabled,0);
+	else
+		atomic_set(&stat->low_odr_enabled,1);
+	l3gd20h_gyr_update_odr(stat, stat->pdata->poll_interval);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+#ifdef L3GD20H_DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	u8 data;
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	data = (u8)val;
+	mutex_lock(&stat->lock);
+	rc = stat->tf->write(stat->dev, stat->reg_addr, 1, &data);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	rc = stat->tf->read(stat->dev, stat->reg_addr, 1, &data);
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct l3gd20h_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+
+	stat->reg_addr = val;
+
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif /* L3GD20H_DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_polling_rate_show,
+	       attr_polling_rate_store),
+	__ATTR(range, 0666, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0666, attr_enable_show, attr_enable_store),
+	__ATTR(enable_polling, 0666, attr_polling_mode_show,
+	       attr_polling_mode_store),
+	__ATTR(fifo_samples, 0666, attr_watermark_show, attr_watermark_store),
+	__ATTR(fifo_mode, 0666, attr_fifomode_show, attr_fifomode_store),
+	__ATTR(enable_low_odr, 0666, attr_get_low_odr, attr_set_low_odr),
+#ifdef L3GD20H_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void l3gd20h_gyr_report_triple(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	struct l3gd20h_gyr_triple data_out;
+
+	err = l3gd20h_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(stat->dev, "get_gyroscope_data failed\n");
+	else
+		l3gd20h_gyr_report_values(stat, &data_out);
+}
+
+
+static void l3gd20h_gyr_irq2_fifo(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+	u8 buf[2];
+	u8 int_source;
+	u8 samples;
+	u8 workingmode;
+	u8 stored_samples;
+
+	mutex_lock(&stat->lock);
+
+	workingmode = stat->fifomode;
+
+	dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+		workingmode);
+
+	switch (workingmode) {
+	case FIFO_MODE_BYPASS:
+	{
+		dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+			stat->fifomode);
+		l3gd20h_gyr_report_triple(stat);
+		break;
+	}
+	case FIFO_MODE_FIFO:
+		samples = (stat->watermark)+1;
+		dev_dbg(stat->dev,
+			"%s : FIFO_SRC_REG init samples:%d\n",
+			__func__, samples);
+		err = l3gd20h_gyr_register_read(stat, buf, FIFO_SRC_REG);
+		if (err < 0)
+			dev_err(stat->dev,
+				"error reading fifo source reg\n");
+
+		int_source = buf[0];
+		dev_dbg(stat->dev, "%s :FIFO_SRC_REG content:0x%02x\n",
+			__func__, int_source);
+
+		stored_samples = int_source & FIFO_STORED_DATA_MASK;
+		dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+			stat->fifomode);
+
+		dev_dbg(stat->dev, "%s : samples:%d stored:%d\n",
+			__func__, samples, stored_samples);
+
+		for (; samples > 0; samples--)
+			l3gd20h_gyr_report_triple(stat);
+		l3gd20h_gyr_fifo_reset(stat);
+		break;
+	}
+
+	mutex_unlock(&stat->lock);
+}
+
+static irqreturn_t l3gd20h_gyr_isr2(int irq, void *dev)
+{
+	struct l3gd20h_gyr_status *stat = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s %s: isr2 queued\n", L3GD20H_GYR_DEV_NAME, __func__);
+
+	return IRQ_HANDLED;
+}
+
+static void l3gd20h_gyr_irq2_work_func(struct work_struct *work)
+{
+
+	struct l3gd20h_gyr_status *stat =
+		container_of(work, struct l3gd20h_gyr_status, irq2_work);
+
+	l3gd20h_gyr_irq2_fifo(stat);
+	pr_debug("%s %s: IRQ2 served\n", L3GD20H_GYR_DEV_NAME, __func__);
+
+	enable_irq(stat->irq2);
+}
+
+static int l3gd20h_gyr_validate_pdata(struct l3gd20h_gyr_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int) L3GD20H_GYR_MIN_POLL_PERIOD_MS,
+						stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+			stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 ||
+	    stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			stat->pdata->negate_x,
+			stat->pdata->negate_y,
+			stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int l3gd20h_gyr_input_init(struct l3gd20h_gyr_status *stat)
+{
+	int err = -1;
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev->name = L3GD20H_GYR_DEV_NAME;
+
+	stat->input_dev->id.bustype = stat->bus_type;
+	stat->input_dev->dev.parent = stat->dev;
+
+	input_set_drvdata(stat->input_dev, stat);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev);
+err0:
+	return err;
+}
+
+static void l3gd20h_gyr_input_cleanup(struct l3gd20h_gyr_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+static void poll_function_work(struct work_struct *polling_task)
+{
+	struct l3gd20h_gyr_status *stat;
+	struct l3gd20h_gyr_triple data_out;
+	int err;
+	ktime_t tmpkt;
+
+	stat = container_of((struct work_struct *)polling_task,
+			    struct l3gd20h_gyr_status, polling_task);
+
+	/* Adjust new timeout */
+	tmpkt = ktime_sub(stat->ktime,
+			  ktime_set(0, 
+			  (l3gd20h_gyr_get_time_ns() - stat->timestamp)));
+	hrtimer_start(&stat->hr_timer, tmpkt, HRTIMER_MODE_REL);
+	mutex_lock(&stat->lock);
+	err = l3gd20h_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(stat->dev, "get_rotation_data failed.\n");
+	else
+		l3gd20h_gyr_report_values(stat, &data_out);
+	mutex_unlock(&stat->lock);
+}
+
+static enum hrtimer_restart poll_function_read(struct hrtimer *timer)
+{
+	struct l3gd20h_gyr_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+			    struct l3gd20h_gyr_status, hr_timer);
+	stat->timestamp = l3gd20h_gyr_get_time_ns();
+	queue_work(stat->gyr_workqueue, &stat->polling_task);
+
+	return HRTIMER_NORESTART;
+}
+
+int l3gd20h_gyr_probe(struct l3gd20h_gyr_status *stat)
+{
+	int err;
+
+	mutex_lock(&stat->lock);
+
+	err = l3gd20h_gyr_check_whoami(stat);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err1;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_l3gd20h_gyr_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_l3gd20h_gyr_pdata,
+							sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data, sizeof(*stat->pdata));
+	}
+
+	err = l3gd20h_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES |
+					    PM_NORMAL;
+	stat->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	stat->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	stat->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+
+	stat->polling_enabled = true;
+	dev_info(stat->dev, "polling mode enabled\n");
+
+	err = l3gd20h_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = l3gd20h_gyr_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = l3gd20h_gyr_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = l3gd20h_gyr_input_init(stat);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"%s device register failed\n", L3GD20H_GYR_DEV_NAME);
+		goto err4;
+	}
+
+	l3gd20h_gyr_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+	stat->irq2_work_queue = NULL;
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		dev_info(stat->dev, "%s: %s has set irq2 to irq:"
+			 " %d mapped on gpio:%d\n",
+			 L3GD20H_GYR_DEV_NAME, __func__, stat->irq2,
+			 stat->pdata->gpio_int2);
+
+		INIT_WORK(&stat->irq2_work, l3gd20h_gyr_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("l3gd20h_gyr_irq2_wq");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev, "cannot create "
+				"work queue2: %d\n", err);
+			goto err5;
+		}
+
+		err = request_irq(stat->irq2, l3gd20h_gyr_isr2,
+				IRQF_TRIGGER_HIGH, "l3gd20h_gyr_irq2", stat);
+
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err5;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	mutex_unlock(&stat->lock);
+
+	stat->gyr_workqueue = create_workqueue("l3gd20h_gyr_workqueue");
+	if (!stat->gyr_workqueue)
+		goto err5;
+
+	hrtimer_init(&stat->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer.function = &poll_function_read;
+
+	INIT_WORK(&stat->polling_task, poll_function_work);
+
+	return 0;
+
+err5:
+	if (stat->irq2_work_queue) {
+		destroy_workqueue(stat->irq2_work_queue);
+		stat->irq2_work_queue = NULL;
+	}
+	l3gd20h_gyr_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+err4:
+	l3gd20h_gyr_input_cleanup(stat);
+err3:
+	l3gd20h_gyr_device_power_off(stat);
+err2:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+err1_1:
+	mutex_unlock(&stat->lock);
+	kfree(stat->pdata);
+err1:
+	return err;
+}
+EXPORT_SYMBOL(l3gd20h_gyr_probe);
+
+int l3gd20h_gyr_remove(struct l3gd20h_gyr_status *stat)
+{
+	cancel_work_sync(&stat->polling_task);
+	if (stat->gyr_workqueue) {
+		destroy_workqueue(stat->gyr_workqueue);
+		stat->gyr_workqueue = NULL;
+	}
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+		stat->irq2_work_queue = NULL;
+	}
+
+	l3gd20h_gyr_disable(stat);
+	l3gd20h_gyr_input_cleanup(stat);
+	remove_sysfs_interfaces(stat->dev);
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(l3gd20h_gyr_remove);
+
+int l3gd20h_gyr_suspend(struct l3gd20h_gyr_status *stat)
+{
+	int err = 0;
+#define SLEEP
+#ifdef CONFIG_PM
+	u8 buf[2];
+
+	if (atomic_read(&stat->enabled)) {
+		mutex_lock(&stat->lock);
+		if (stat->polling_enabled) {
+			dev_info(stat->dev, "polling mode disabled\n");
+			hrtimer_cancel(&stat->hr_timer);
+		}
+#ifdef SLEEP
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x0F, (ENABLE_NO_AXES | PM_NORMAL));
+#else
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x08, PM_OFF);
+#endif /*SLEEP*/
+		mutex_unlock(&stat->lock);
+	}
+#endif /*CONFIG_PM*/
+	return (err < 0) ? err : 0;
+}
+EXPORT_SYMBOL(l3gd20h_gyr_suspend);
+
+int l3gd20h_gyr_resume(struct l3gd20h_gyr_status *stat)
+{
+	int err = 0;
+#ifdef CONFIG_PM
+	u8 buf[2];
+
+	if (atomic_read(&stat->enabled)) {
+		mutex_lock(&stat->lock);
+		if (stat->polling_enabled) {
+			dev_info(stat->dev, "polling mode enabled\n");
+			hrtimer_start(&stat->hr_timer, stat->ktime,
+				      HRTIMER_MODE_REL);
+		}
+#ifdef SLEEP
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x0F, (ENABLE_ALL_AXES | PM_NORMAL));
+#else
+		err = l3gd20h_gyr_register_update(stat, buf, CTRL_REG1,
+				0x08, PM_NORMAL);
+#endif
+		mutex_unlock(&stat->lock);
+
+	}
+#endif /*CONFIG_PM*/
+	return (err < 0) ? err : 0;
+}
+EXPORT_SYMBOL(l3gd20h_gyr_resume);
+
+MODULE_DESCRIPTION("l3gd20h gyroscope driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_i2c.c b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_i2c.c
--- a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,185 @@
+/*
+ * STMicroelectronics l3gd20h_gyr_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "l3gd20h.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int l3gd20h_gyr_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int l3gd20h_gyr_i2c_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct l3gd20h_gyr_transfer_function l3gd20h_gyr_i2c_tf = {
+	.write = l3gd20h_gyr_i2c_write,
+	.read = l3gd20h_gyr_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int l3gd20h_gyr_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct l3gd20h_gyr_status *stat = i2c_get_clientdata(client);
+
+	return l3gd20h_gyr_resume(stat);
+}
+
+static int l3gd20h_gyr_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct l3gd20h_gyr_status *stat = i2c_get_clientdata(client);
+
+	return l3gd20h_gyr_suspend(stat);
+}
+
+static const struct dev_pm_ops l3gd20h_gyr_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(l3gd20h_gyr_i2c_suspend,
+				l3gd20h_gyr_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int l3gd20h_gyr_i2c_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int err;
+	struct l3gd20h_gyr_status *stat;
+
+#ifdef L3GD20H_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct l3gd20h_gyr_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bus_type = BUS_I2C;
+	stat->tf = &l3gd20h_gyr_i2c_tf;
+
+	i2c_set_clientdata(client, stat);
+
+	mutex_init(&stat->lock);
+
+	err = l3gd20h_gyr_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int l3gd20h_gyr_i2c_remove(struct i2c_client *client)
+{
+	struct l3gd20h_gyr_status *stat = i2c_get_clientdata(client);
+
+#ifdef L3GD20H_DEBUG
+	dev_info(stat->dev, "driver removing\n");
+#endif
+
+	l3gd20h_gyr_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct i2c_device_id l3gd20h_gyr_i2c_id[] = {
+	{ "l3gd20h_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, l3gd20h_gyr_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3gd20h_gyr_i2c_id_table[] = {
+	{ .compatible = "st,l3gd20h_gyr", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, l3gd20h_gyr_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver l3gd20h_gyr_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "l3gd20h_gyr_i2c",
+#ifdef CONFIG_PM
+		.pm = &l3gd20h_gyr_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = l3gd20h_gyr_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = l3gd20h_gyr_i2c_probe,
+	.remove = l3gd20h_gyr_i2c_remove,
+	.id_table = l3gd20h_gyr_i2c_id,
+};
+
+module_i2c_driver(l3gd20h_gyr_i2c_driver);
+
+MODULE_DESCRIPTION("l3gd20h gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_spi.c b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_spi.c
--- a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h_gyr_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,200 @@
+/*
+ * STMicroelectronics l3gd20h_gyr_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "l3gd20h.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold stat->lock */
+static int l3gd20h_gyr_spi_read(struct device *device, u8 addr, int len,
+				u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20h_gyr_status *stat = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	stat->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold stat->lock */
+static int l3gd20h_gyr_spi_write(struct device *device, u8 addr, int len,
+				     u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20h_gyr_status *stat = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= L3GD20H_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	stat->tb.tx_buf[0] = addr;
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct l3gd20h_gyr_transfer_function l3gd20h_gyr_spi_tf = {
+	.write = l3gd20h_gyr_spi_write,
+	.read = l3gd20h_gyr_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int l3gd20h_gyr_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20h_gyr_status *stat = spi_get_drvdata(spi);
+
+	return l3gd20h_gyr_resume(stat);
+}
+
+static int l3gd20h_gyr_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct l3gd20h_gyr_status *stat = spi_get_drvdata(spi);
+
+	return l3gd20h_gyr_suspend(stat);
+}
+
+static const struct dev_pm_ops l3gd20h_gyr_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(l3gd20h_gyr_spi_suspend,
+				l3gd20h_gyr_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int l3gd20h_gyr_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct l3gd20h_gyr_status *stat;
+
+#ifdef L3GD20H_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct l3gd20h_gyr_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->name = spi->modalias;
+	stat->bus_type = BUS_SPI;
+	stat->tf = &l3gd20h_gyr_spi_tf;
+	stat->dev = &spi->dev;
+
+	spi_set_drvdata(spi, stat);
+
+	mutex_init(&stat->lock);
+
+	err = l3gd20h_gyr_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+		return err;
+	}
+
+	return 0;
+}
+
+int l3gd20h_gyr_spi_remove(struct spi_device *spi)
+{
+	struct l3gd20h_gyr_status *stat = spi_get_drvdata(spi);
+
+#ifdef L3GD20H_DEBUG
+	dev_info(stat->dev, "driver removing\n");
+#endif
+
+	l3gd20h_gyr_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct spi_device_id l3gd20h_gyr_spi_id[] = {
+	{ "l3gd20h_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, l3gd20h_gyr_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id l3gd20h_gyr_spi_id_table[] = {
+	{ .compatible = "st,l3gd20h_gyr" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, l3gd20h_gyr_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver l3gd20h_gyr_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "l3gd20h_gyr_spi",
+#ifdef CONFIG_PM
+		.pm = &l3gd20h_gyr_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = l3gd20h_gyr_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = l3gd20h_gyr_spi_probe,
+	.remove = l3gd20h_gyr_spi_remove,
+	.id_table = l3gd20h_gyr_spi_id,
+};
+
+module_spi_driver(l3gd20h_gyr_spi_driver);
+
+MODULE_DESCRIPTION("l3gd20h gyr spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h.h b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h.h
--- a/drivers/input/misc/st/gyro/l3gd20h/l3gd20h.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20h/l3gd20h.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,162 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: l3gd20h.h
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.2 sysfs
+* Date			: 2016/Jul/19
+* Description		: L3GD20H digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+* 1.2.2		| 2016/Jul/19	| Mario Tesi	  | added timestamp for cts
+*******************************************************************************/
+
+#ifndef __L3GD20H_GYR_H__
+#define __L3GD20H_GYR_H__
+
+#define L3GD20H_GYR_DEV_NAME		"l3gd20h_gyr"
+
+#define L3GD20H_GYR_ENABLED		1
+#define L3GD20H_GYR_DISABLED		0
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones havew to be set to -EINVAL
+ */
+#define L3GD20H_GYR_DEFAULT_INT2_GPIO		(-EINVAL)
+
+#define L3GD20H_GYR_MIN_POLL_PERIOD_MS	2
+
+#define L3GD20H_GYR_FS_250DPS		(0x00)
+#define L3GD20H_GYR_FS_500DPS		(0x10)
+#define L3GD20H_GYR_FS_2000DPS	(0x30)
+
+struct l3gd20h_gyr_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_L3GD20H_SPI) || \
+    defined(CONFIG_INPUT_L3GD20H_SPI_MODULE)
+#define L3GD20H_RX_MAX_LENGTH		500
+#define L3GD20H_TX_MAX_LENGTH		500
+
+struct l3gd20h_gyr_transfer_buffer {
+	u8 rx_buf[L3GD20H_RX_MAX_LENGTH];
+	u8 tx_buf[L3GD20H_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif
+
+struct l3gd20h_gyr_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	/* gpio ports for interrupt pads */
+	int gpio_int2;		/* int for fifo */
+
+	/* axis mapping */
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+#define RESUME_ENTRIES		6
+
+struct l3gd20h_gyr_status {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	struct l3gd20h_gyr_platform_data *pdata;
+
+	struct mutex lock;
+	struct workqueue_struct *gyr_workqueue;
+	struct input_dev *input_dev;
+	int64_t timestamp;
+
+	int hw_initialized;
+	atomic_t enabled;
+	atomic_t low_odr_enabled;
+
+	u8 reg_addr;
+	u8 resume_state[RESUME_ENTRIES];
+
+	u32 sensitivity;
+
+	/* interrupt related */
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	bool polling_enabled;
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+	struct work_struct polling_task;
+
+	struct l3gd20h_gyr_transfer_function *tf;
+#if defined(CONFIG_INPUT_L3GD20H_SPI) || \
+    defined(CONFIG_INPUT_L3GD20H_SPI_MODULE)
+	struct l3gd20h_gyr_transfer_buffer tb;
+#endif /* CONFIG_INPUT_L3GD20H_SPI */
+};
+
+int l3gd20h_gyr_probe(struct l3gd20h_gyr_status *stat);
+int l3gd20h_gyr_remove(struct l3gd20h_gyr_status *stat);
+int l3gd20h_gyr_suspend(struct l3gd20h_gyr_status *stat);
+int l3gd20h_gyr_resume(struct l3gd20h_gyr_status *stat);
+
+#endif  /* __L3GD20H_GYR_H__ */
diff -uNr a/drivers/input/misc/st/gyro/l3gd20h/Makefile b/drivers/input/misc/st/gyro/l3gd20h/Makefile
--- a/drivers/input/misc/st/gyro/l3gd20h/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/l3gd20h/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,11 @@
+#
+# Makefile for the input misc l3gd20h driver.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_INPUT_L3GD20H) += l3gd20h_gyr.o
+obj-$(CONFIG_INPUT_L3GD20H_I2C) += l3gd20h_gyr_i2c.o
+obj-$(CONFIG_INPUT_L3GD20H_SPI) += l3gd20h_gyr_spi.o
+
+ccflags-y += -DL3GD20H_DEBUG
diff -uNr a/drivers/input/misc/st/gyro/Makefile b/drivers/input/misc/st/gyro/Makefile
--- a/drivers/input/misc/st/gyro/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/gyro/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the input misc STM gyro drivers.
+#
+
+obj-$(CONFIG_INPUT_L3G4200D) += l3g4200d/
+obj-$(CONFIG_INPUT_L3GD20) += l3gd20/
+obj-$(CONFIG_INPUT_L3GD20H) += l3gd20h/
+obj-$(CONFIG_INPUT_A3G4250D) += a3g4250d/
diff -uNr a/drivers/input/misc/st/humidity/hts221/hts221_core.c b/drivers/input/misc/st/humidity/hts221/hts221_core.c
--- a/drivers/input/misc/st/humidity/hts221/hts221_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/hts221/hts221_core.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,916 @@
+/*
+ * STMicroelectronics hts221_core.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+
+#include "hts221_core.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 0, 0)
+#define	kstrtoul(x, y, z) strict_strtoul(x, y, z)
+#endif
+
+#define MS_TO_NS(x)		((x) *1000000L)
+
+#define REG_WHOAMI_ADDR		0x0f  /* Who am i address register */
+#define REG_H_RES_ADDR		0x10  /* Humidity res conf register */
+#define REG_T_RES_ADDR		0x10  /* Temperature res conf register */
+#define REG_CNTRL1_ADDR		0x20  /* CNTRL1 address register */
+#define REG_CNTRL2_ADDR		0x21  /* CNTRL2 address register */
+#define REG_H_OUT_L		0x28  /* OUT humidity address register */
+#define REG_T_OUT_L		0x2A  /* OUT temperature address register */
+#define REG_0RH_CAL_X_H		0x36  /* Calibration H 0 address register */
+#define REG_1RH_CAL_X_H		0x3a  /* Calibration H 1 address register */
+#define REG_0RH_CAL_Y_H		0x30  /* Calibration H 0 RH address register */
+#define REG_1RH_CAL_Y_H		0x31  /* Calibration H 1 RH address register */
+#define REG_0T_CAL_X_L		0x3c  /* Calibration T 0 address register */
+#define REG_1T_CAL_X_L		0x3e  /* Calibration T 1 address register */
+#define REG_0T_CAL_Y_H		0x32  /* Calibration T 0 C address register */
+#define REG_1T_CAL_Y_H		0x33  /* Calibration T 1 C address register */
+#define REG_STATUS		0x27  /* Status address register */
+
+#define REG_T1_T0_CAL_Y_H	0x35  /* Calibration T0 and T! Address register */
+
+#define MASK_ENABLE		0x80
+#define ENABLE_SENSOR		0x80
+#define DISABLE_SENSOR		0x00
+
+/* Sensor Resolution */
+#define HTS221_H_RESOLUTION_MASK	0xf8
+#define HTS221_T_RESOLUTION_MASK	0xC7
+
+/* Default values loaded in probe function */
+#define WHOIAM_VALUE		0xbc /* Who Am I default value */
+#define REG_DEF_H_RES_ADDR	0x00 /* Humidity res register */
+#define REG_DEF_T_RES_ADDR	0x00 /* Temperature res register */
+#define REG_DEF_CNTRL1		0x00 /* CNTRL1 default value */
+#define REG_DEF_CNTRL2		0x00 /* CNTRL2 default value */
+
+#define REG_DEF_ALL_ZEROS	0x00
+#define REG_DEF_BDU		0x04
+
+#define HTS221_BDU		1
+
+#define HTS221_DEV_NAME_H	"hts221_humidity"
+#define HTS221_DEV_NAME_T	"hts221_temperature"
+
+#define ENABLE_MASK	0x80 /* Power Normal Mode*/
+#define PM_NORMAL	0x80 /* Power Normal Mode*/
+#define PM_OFF		0x00 /* Power Down */
+#define ODR_1		0x01
+
+#define RES_MAX	(RES_AVGTEMP_064 | RES_AVGPRES_512) /* Max Resol */
+#define ODR_MASK	0x03	/* CHANGE*/
+
+/* Humidity and Termometer output data rate ODR */
+#define ODR_ONESH	0x00	/* one shot */
+#define ODR_1_1		0x01	/* 1  Hz */
+#define ODR_7_7		0x02	/* 7  Hz */
+#define ODR_12_12	0x03	/* 12.5Hz */
+
+/* Humidity Sensor Resolution */
+#define HTS221_H_RESOLUTION_4		0x00  /* Resolution set to 0.4 %RH */
+#define HTS221_H_RESOLUTION_8		0x01  /* Resolution set to 0.3 %RH */
+#define HTS221_H_RESOLUTION_16		0x02  /* Resolution set to 0.2 %RH */
+#define HTS221_H_RESOLUTION_32		0x03  /* Resolution set to 0.15 %RH */
+#define HTS221_H_RESOLUTION_64		0x04  /* Resolution set to 0.1 %RH */
+#define HTS221_H_RESOLUTION_128		0x05  /* Resolution set to 0.07 %RH */
+#define HTS221_H_RESOLUTION_256		0x06  /* Resolution set to 0.05 %RH */
+#define HTS221_H_RESOLUTION_512		0x07  /* Resolution set to 0.03 %RH */
+
+/* Temperature Sensor Resolution */
+#define HTS221_T_RESOLUTION_2		0x00  /* Resolution set to 0.08 DegC */
+#define HTS221_T_RESOLUTION_4		0x08  /* Resolution set to 0.05 DegC */
+#define HTS221_T_RESOLUTION_8		0x10  /* Resolution set to 0.04 DegC */
+#define HTS221_T_RESOLUTION_16		0x18  /* Resolution set to 0.03 DegC */
+#define HTS221_T_RESOLUTION_32		0x20  /* Resolution set to 0.02 DegC */
+#define HTS221_T_RESOLUTION_64		0x28  /* Resolution set to 0.015 DegC */
+#define HTS221_T_RESOLUTION_128		0x30  /* Resolution set to 0.01 DegC */
+#define HTS221_T_RESOLUTION_256		0x38  /* Resolution set to 0.007 DegC */
+
+#define HTS221_DEFAULT_POLL_PERIOD_MS	100
+
+struct hts221_odr {
+	u32 cutoff;
+	u32 mask;
+};
+
+static const struct hts221_odr hts221_odr_table[] = {
+	{ 80, ODR_12_12 },
+	{ 143, ODR_7_7 },
+	{ 1000, ODR_1_1 },
+};
+
+struct hts221_resolution {
+	u32 res;
+	u8 value;
+};
+
+static struct hts221_resolution hts221_resolution_h[] = {
+	{ 4, HTS221_H_RESOLUTION_4 },
+	{ 8, HTS221_H_RESOLUTION_8 },
+	{ 16, HTS221_H_RESOLUTION_16 },
+	{ 32, HTS221_H_RESOLUTION_32 },
+	{ 64, HTS221_H_RESOLUTION_64 },
+	{ 128, HTS221_H_RESOLUTION_128 },
+	{ 256, HTS221_H_RESOLUTION_256 },
+	{ 512, HTS221_H_RESOLUTION_512 },
+};
+
+static struct hts221_resolution hts221_resolution_t[] = {
+	{ 2, HTS221_T_RESOLUTION_2 },
+	{ 4, HTS221_T_RESOLUTION_4 },
+	{ 8, HTS221_T_RESOLUTION_8 },
+	{ 16, HTS221_T_RESOLUTION_16 },
+	{ 32, HTS221_T_RESOLUTION_32 },
+	{ 64, HTS221_T_RESOLUTION_64 },
+	{ 128, HTS221_T_RESOLUTION_128 },
+	{ 256, HTS221_T_RESOLUTION_256 },
+};
+
+static int hts221_hw_init(struct hts221_dev *dev)
+{
+	u8 wai;
+	int err;
+
+	err = dev->tf->read(dev->dev, REG_WHOAMI_ADDR, 1, &wai);
+	if (err < 0) {
+		dev_err(dev->dev, "error reading WHOAMI register\n");
+		return err;
+	}
+
+	if (WHOIAM_VALUE != wai) {
+		dev_err(dev->dev, "device unknown {0x%02x-0x%02x}\n",
+			WHOIAM_VALUE, wai);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int hts221_update_odr(struct hts221_dev *dev, u32 poll_interval)
+{
+	int i, err;
+	u8 data = DISABLE_SENSOR;
+
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	msleep(50);
+	/**
+	 * Following, looks for the longest possible odr interval scrolling
+	 * the odr_table vector from the end (longest period) backward
+	 * (shortest period), to support the poll_interval requested by the
+	 * system. It must be the longest period shorter then the set poll
+	 * period
+	 */
+	for (i = ARRAY_SIZE(hts221_odr_table) - 1; i > 0; i--) {
+		if (hts221_odr_table[i].cutoff <= poll_interval)
+			break;
+	}
+
+	dev->odr = hts221_odr_table[i].mask;
+	msleep(20);
+
+	data = ENABLE_SENSOR | dev->odr;
+#ifdef HTS221_BDU
+	data |= REG_DEF_BDU;
+#endif
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int hts221_device_power_on(struct hts221_dev *dev)
+{
+	u8 data;
+	int err;
+
+	data = dev->sensors[HTS221_SENSOR_H].res;
+	err = dev->tf->write(dev->dev, REG_H_RES_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	data = dev->sensors[HTS221_SENSOR_T].res;
+	err = dev->tf->write(dev->dev, REG_T_RES_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	/* power off */
+	data = DISABLE_SENSOR;
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+	msleep(50);
+
+	data = ENABLE_SENSOR | dev->odr;
+#ifdef HTS221_BDU
+	data |= REG_DEF_BDU;
+#endif
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+	msleep(50);
+
+	dev->enabled = true;
+
+	return 0;
+}
+
+static int hts221_device_power_off(struct hts221_dev *dev)
+{
+	int err;
+	u8 data[4], val = DISABLE_SENSOR;
+
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &val);
+	if (err < 0)
+		return err;
+
+	err = dev->tf->read(dev->dev, REG_H_OUT_L, 4 * sizeof(u8), data);
+	if (err < 0)
+		return err;
+
+	err = dev->tf->write(dev->dev, REG_CNTRL2_ADDR, 1, &val);
+	if (err < 0)
+		return err;
+
+	dev->enabled = false;
+
+	return 0;
+}
+
+static int hts221_update_res(struct hts221_dev *dev,
+			     enum hts221_sensor_type type,
+			     u16 val)
+{
+	int err;
+	u8 addr, data, res;
+
+	switch (type) {
+	case HTS221_SENSOR_T:
+		addr = REG_T_RES_ADDR;
+		err = dev->tf->read(dev->dev, REG_T_RES_ADDR, 1 , &data);
+		if (err < 0)
+			return err;
+		res = (data & HTS221_T_RESOLUTION_MASK) | val;
+		break;
+	case HTS221_SENSOR_H:
+		addr = REG_H_RES_ADDR;
+		err = dev->tf->read(dev->dev, REG_H_RES_ADDR, 1 , &data);
+		if (err < 0)
+			return err;
+		res = (data & HTS221_H_RESOLUTION_MASK) | val;
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	err = dev->tf->write(dev->dev, addr, 1 , &res);
+	if (!err)
+		dev->sensors[type].res = res;
+	return err;
+}
+
+static int hts221_input_init(struct hts221_dev *dev, const char *description)
+{
+	int err;
+
+	dev->input_dev = input_allocate_device();
+	if (!dev->input_dev)
+		return -ENOMEM;
+
+	dev->input_dev->name = description;
+	dev->input_dev->id.bustype = dev->bus_type;
+	dev->input_dev->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev, dev);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev->evbit);
+	set_bit(INPUT_EVENT_TIME_MSB, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev->mscbit);
+
+	err = input_register_device(dev->input_dev);
+	if (err) {
+		dev_err(dev->dev, "unable to register input device %s\n",
+			dev->input_dev->name);
+		input_free_device(dev->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int hts221_enable(struct hts221_dev *dev)
+{
+	int err = 0;
+
+	mutex_lock(&dev->lock);
+	if (!dev->enabled) {
+		err = hts221_device_power_on(dev);
+		schedule_delayed_work(&dev->input_work,
+				      msecs_to_jiffies(dev->poll_interval));
+	}
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(hts221_enable);
+
+int hts221_disable(struct hts221_dev *dev)
+{
+	int err = 0;
+
+	cancel_delayed_work_sync(&dev->input_work);
+
+	mutex_lock(&dev->lock);
+	if (dev->enabled)
+		err = hts221_device_power_off(dev);
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(hts221_disable);
+
+static void hts221_input_cleanup(struct hts221_dev *dev)
+{
+	input_unregister_device(dev->input_dev);
+	input_free_device(dev->input_dev);
+}
+
+static ssize_t attr_get_polling_rate(struct device *device,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	u32 val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->poll_interval;
+	mutex_unlock(&dev->lock);
+
+        return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *device,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	unsigned long val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val) || !val)
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	dev->poll_interval = (u32)val;
+	hts221_update_odr(dev, dev->poll_interval);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_res_h(struct device *device,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	u8 val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->sensors[HTS221_SENSOR_H].res;
+	mutex_unlock(&dev->lock);
+
+        return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_res_h(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	int i, err;
+	unsigned long val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(hts221_resolution_h); i++) {
+		if (val == hts221_resolution_h[i].res)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(hts221_resolution_h))
+		return size;
+
+	mutex_lock(&dev->lock);
+	err = hts221_update_res(dev, HTS221_SENSOR_H,
+				hts221_resolution_h[i].value);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_res_t(struct device *device,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	u8 val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->sensors[HTS221_SENSOR_T].res;
+	mutex_unlock(&dev->lock);
+
+        return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_res_t(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	int i, err;
+	unsigned long val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(hts221_resolution_t); i++) {
+		if (val == hts221_resolution_t[i].res)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(hts221_resolution_t))
+		return size;
+
+	mutex_lock(&dev->lock);
+	err = hts221_update_res(dev, HTS221_SENSOR_T,
+				hts221_resolution_t[i].value);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_set_oneshot(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	unsigned long val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val != 0) {
+		int err;
+		u8 data = DISABLE_SENSOR;
+		mutex_lock(&dev->lock);
+
+		err = dev->tf->write(device, REG_CNTRL1_ADDR, 1, &data);
+		if (err < 0) {
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		msleep(20);
+
+		data = ENABLE_SENSOR;
+#ifdef HTS221_BDU
+		data |= REG_DEF_BDU;
+#endif
+
+		err = dev->tf->write(device, REG_CNTRL1_ADDR, 1, &data);
+		if (err < 0) {
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		dev->odr = ODR_ONESH;
+
+		mutex_unlock(&dev->lock);
+	}
+
+	return size;
+}
+
+static ssize_t attr_get_heater(struct device *device,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	u8 val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->heater;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_heater(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	u8 data;
+	int err;
+	unsigned long val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	data = (!val) ? DISABLE_SENSOR : 0x02;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(device, REG_CNTRL2_ADDR, 1, &data);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->heater = true;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *device,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	bool enabled;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	enabled = dev->enabled;
+	mutex_unlock(&dev->lock);
+
+	return  sprintf(buf, "%d\n", enabled);
+}
+
+static ssize_t attr_set_enable(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	unsigned long val;
+	struct hts221_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		hts221_enable(dev);
+	else
+		hts221_disable(dev);
+
+	return size;
+}
+
+static struct device_attribute hts221_sysfs_attributes[] = {
+	__ATTR(poll_ms, 0644, attr_get_polling_rate, attr_set_polling_rate),
+	__ATTR(h_res, 0644, attr_get_res_h, attr_set_res_h),
+	__ATTR(t_res, 0644, attr_get_res_t, attr_set_res_t),
+	__ATTR(oneshot, 0200, NULL, attr_set_oneshot),
+	__ATTR(heater, 0644, attr_get_heater, attr_set_heater),
+	__ATTR(enable_device, 0644, attr_get_enable, attr_set_enable),
+};
+
+static int hts221_sysfs_init(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hts221_sysfs_attributes); i++) {
+		if (device_create_file(dev, hts221_sysfs_attributes + i))
+			goto err;
+	}
+
+	return 0;
+
+err:
+	for (; i >= 0; i--)
+		device_remove_file(dev, hts221_sysfs_attributes + i);
+
+	return -1;
+}
+
+static void hts221_sysfs_remove(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hts221_sysfs_attributes); i++)
+		device_remove_file(dev, hts221_sysfs_attributes + i);
+}
+
+static int hts221_get_cal_data(struct hts221_dev *dev,
+			       enum hts221_sensor_type type)
+{
+	int err, *slope, *b_gen, cal_x0, cal_x1, cal_y0, cal_y1;
+	u8 addr_x0, addr_x1, data[2];
+
+	switch (type) {
+	case HTS221_SENSOR_T: {
+		u16 cal0, cal1;
+
+		addr_x0 = REG_0T_CAL_X_L;
+		addr_x1 = REG_1T_CAL_X_L;
+
+		err = dev->tf->read(dev->dev, REG_0T_CAL_Y_H, 1, &data[0]);
+		if (err < 0)
+			return err;
+		cal0 = data[0];
+
+		err = dev->tf->read(dev->dev, REG_T1_T0_CAL_Y_H, 1, &data[0]);
+		if (err < 0)
+			return err;
+		cal1 = data[0] & 0x3;
+		cal_y0 = (s32)((cal1 << 8) | cal0);
+
+		err = dev->tf->read(dev->dev, REG_1T_CAL_Y_H, 1, &data[0]);
+		if (err < 0)
+			return err;
+		cal0 = data[0];
+
+		err = dev->tf->read(dev->dev, REG_T1_T0_CAL_Y_H, 1, &data[0]);
+		if (err < 0)
+			return err;
+		cal1 = data[0] & 0xc;
+		cal1 >>= 2;
+		cal_y1 = (s32)((cal1 << 8) | cal0);
+		break;
+	}
+	case HTS221_SENSOR_H:
+		addr_x0 = REG_0RH_CAL_X_H;
+		addr_x1 = REG_1RH_CAL_X_H;
+
+		err = dev->tf->read(dev->dev, REG_0RH_CAL_Y_H, 1, &data[0]);
+		if (err < 0)
+			return err;
+		cal_y0 = data[0];
+
+		err = dev->tf->read(dev->dev, REG_1RH_CAL_Y_H, 1, &data[0]);
+		if (err < 0)
+			return err;
+		cal_y1 = data[0];
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	err = dev->tf->read(dev->dev, addr_x0, 2, data);
+	if (err < 0)
+		return err;
+	cal_x0 = (s16)((data[1] << 8) | data[0]);
+
+	err = dev->tf->read(dev->dev, addr_x1, 2, data);
+	if (err < 0)
+		return err;
+	cal_x1 = (s16)((data[1] << 8) | data[0]);
+
+	slope = &dev->sensors[type].slope;
+	b_gen = &dev->sensors[type].b_gen;
+
+	*slope = ((cal_y1 - cal_y0) * 8000) / (cal_x1 - cal_x0);
+	*b_gen = ((cal_x1 * cal_y0 - cal_x0 * cal_y1) * 1000) /
+		 (cal_x1 - cal_x0);
+	*b_gen *= 8;
+
+#ifdef HTS221_DEBUG
+	dev_info(dev->dev, "slope=%d\tb_gen=%d\n", *slope, *b_gen);
+	dev_info(dev->dev, "cal_x0=%d\tcal_x1=%d\n", cal_x0, cal_x1);
+	dev_info(dev->dev, "cal_y0=%d\tcal_y1=%d\n", cal_y0, cal_y1);
+#endif
+
+	return 0;
+}
+
+/**
+ * hts221_convert - linear interpolation
+ * (x0,y0) (x1,y1) y = mx + b
+ *
+ * m = (y1 - y0) / (x1 - x0)
+ * b = (x0 * y1 - x1 * y0) / (x1 - x0)
+ *
+ * Humidity
+ * {x1,y1} = {H1_T0_OUT,H1_RH}
+ * {x0,y0} = {H0_T0_OUT,H0_RH}
+ * x = H_OUT
+ *
+ * Temperature
+ * {x1,y1} = {T1_OUT,T1_DegC}
+ * {x0,y0} = {T0_OUT,T0_DegC}
+ * x = T_OUT
+ */
+static int hts221_convert(int slope, int b_gen, int x,
+			  enum hts221_sensor_type type)
+{
+	int res = 0;
+
+	res = (slope * x) + b_gen;
+	switch (type) {
+	case HTS221_SENSOR_T:
+		res >>= 6;
+		break;
+	case HTS221_SENSOR_H:
+		res >>= 4;
+		break;
+	default:
+		break;
+	}
+
+	return res;
+}
+
+static int hts221_get_data(struct hts221_dev *dev, int *data_t, int *data_h)
+{
+	int err;
+	u8 data[2];
+
+	if (dev->odr == ODR_ONESH) {
+		u8 tmp_data = 1;
+        	static u8 cntx = 0;
+
+		err = dev->tf->write(dev->dev, REG_CNTRL2_ADDR, 1, &tmp_data);
+		if (err < 0)
+			return err;
+
+		do {
+			 err = dev->tf->read(dev->dev, REG_STATUS, 1,
+					     &tmp_data);
+			 if (err < 0)
+				 return err;
+			 msleep(45);
+		} while (((tmp_data & 3) != 3) && (3 >= cntx++));
+		cntx = 0;
+	}
+
+	err = dev->tf->read(dev->dev, REG_H_OUT_L, 2, data);
+	if (err < 0)
+		return err;
+	*data_h = (s16)((data[1] << 8) | data[0]);
+	*data_h = hts221_convert(dev->sensors[HTS221_SENSOR_H].slope,
+				 dev->sensors[HTS221_SENSOR_H].b_gen,
+				 *data_h, HTS221_SENSOR_H);
+
+	err = dev->tf->read(dev->dev, REG_T_OUT_L, 2, data);
+	if (err < 0)
+		return err;
+	*data_t = (s16)((data[1] << 8) | data[0]);
+	*data_t = hts221_convert(dev->sensors[HTS221_SENSOR_T].slope,
+				 dev->sensors[HTS221_SENSOR_T].b_gen,
+				 *data_t, HTS221_SENSOR_T);
+
+#ifdef HTS221_DEBUG
+	dev_info(dev->dev, "data_h=%d\tdata_t=%d\n", *data_h, *data_t);
+#endif
+
+	return 0;
+}
+
+static void hts221_report_data(struct hts221_dev *dev, int data_t, int data_h,
+			       s64 timestamp)
+{
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, data_t);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, data_h);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(dev->input_dev);
+}
+
+static void hts221_input_work_fn(struct work_struct *work)
+{
+	int err, data_t, data_h;
+	struct hts221_dev *dev;
+
+	dev = container_of((struct delayed_work *)work,
+			   struct hts221_dev, input_work);
+
+	mutex_lock(&dev->lock);
+
+	err = hts221_get_data(dev, &data_t, &data_h);
+	if (err < 0)
+		dev_err(dev->dev, "get data failed\n");
+	else
+		hts221_report_data(dev, data_t, data_h, hts221_get_time_ns());
+
+	mutex_unlock(&dev->lock);
+
+	schedule_delayed_work(&dev->input_work,
+			      msecs_to_jiffies(dev->poll_interval));
+}
+
+int hts221_probe(struct hts221_dev *dev)
+{
+	int err;
+
+	BUILD_BUG_ON(!ARRAY_SIZE(hts221_odr_table));
+
+	mutex_lock(&dev->lock);
+
+	dev->poll_interval = 100;
+
+	err =  hts221_hw_init(dev);
+	if (err < 0) {
+                dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto unlock;
+	}
+
+	err = hts221_update_odr(dev, HTS221_DEFAULT_POLL_PERIOD_MS);
+	if (err < 0) {
+                dev_err(dev->dev, "set odr failed: %d\n", err);
+		goto unlock;
+	}
+
+	err = hts221_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power on failed: %d\n", err);
+		goto unlock;
+	}
+
+	err = hts221_update_res(dev, HTS221_SENSOR_T, REG_DEF_T_RES_ADDR);
+	if (err < 0) {
+		dev_err(dev->dev, "update T resolution failed: %d\n", err);
+		goto power_off;
+	}
+
+	err = hts221_update_res(dev, HTS221_SENSOR_H, REG_DEF_H_RES_ADDR);
+	if (err < 0) {
+		dev_err(dev->dev, "update H resolution failed: %d\n", err);
+		goto power_off;
+	}
+
+	err = hts221_input_init(dev, "hts221");
+	if (err < 0) {
+		dev_err(dev->dev, "input init failed: %d\n", err);
+		goto power_off;
+	}
+
+	err = hts221_sysfs_init(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "sysfs register failed\n");
+		goto input_cleanup;
+	}
+
+	err = hts221_device_power_off(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power off failed: %d\n", err);
+		goto input_cleanup;
+	}
+
+	/* get calibration data */
+	if ((hts221_get_cal_data(dev, HTS221_SENSOR_T) < 0) ||
+	    (hts221_get_cal_data(dev, HTS221_SENSOR_H) < 0)) {
+		dev_err(dev->dev, "get calibration data failed: %d\n", err);
+		goto input_cleanup;
+	}
+
+	INIT_DELAYED_WORK(&dev->input_work, hts221_input_work_fn);
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+input_cleanup:
+	hts221_input_cleanup(dev);
+power_off:
+	hts221_device_power_off(dev);
+unlock:
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(hts221_probe);
+
+void hts221_remove(struct hts221_dev *dev)
+{
+	cancel_delayed_work_sync(&dev->input_work);
+	hts221_device_power_off(dev);
+	hts221_input_cleanup(dev);
+	hts221_sysfs_remove(dev->dev);
+}
+EXPORT_SYMBOL(hts221_remove);
+
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/humidity/hts221/hts221_core.h b/drivers/input/misc/st/humidity/hts221/hts221_core.h
--- a/drivers/input/misc/st/humidity/hts221/hts221_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/hts221/hts221_core.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,91 @@
+/*
+ * STMicroelectronics hts221_core driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef _HTS221_H_
+#define _HTS221_H_
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+/* Input events used by lsm303agr driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#if defined(CONFIG_INPUT_HTS221_SPI) || \
+    defined(CONFIG_INPUT_HTS221_SPI_MODULE)
+#define HTS221_RX_MAX_LENGTH		500
+#define HTS221_TX_MAX_LENGTH		500
+
+struct hts221_transfer_buffer {
+	u8 rx_buf[HTS221_RX_MAX_LENGTH];
+	u8 tx_buf[HTS221_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_HTS221_SPI */
+
+struct hts221_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+enum hts221_sensor_type {
+	HTS221_SENSOR_T,
+	HTS221_SENSOR_H,
+	HTS221_SENSOR_MAX,
+};
+
+struct hts221_sensor {
+	u8 res;
+	int slope;
+	int b_gen;
+};
+
+struct hts221_dev {
+	const char *name;
+	u16 bus_type;
+	struct mutex lock;
+	struct device *dev;
+	struct input_dev *input_dev;
+	struct delayed_work input_work;
+	const struct hts221_transfer_function *tf;
+#if defined(CONFIG_INPUT_HTS221_SPI) || \
+    defined(CONFIG_INPUT_HTS221_SPI_MODULE)
+	struct hts221_transfer_buffer tb;
+#endif /* CONFIG_INPUT_HTS221_SPI */
+
+	u8 odr;
+	u8 poll_interval;
+	bool heater;
+        bool enabled;
+	struct hts221_sensor sensors[HTS221_SENSOR_MAX];
+};
+
+static inline s64 hts221_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	ktime_get_real_ts(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+int hts221_probe(struct hts221_dev *dev);
+void hts221_remove(struct hts221_dev *dev);
+int hts221_enable(struct hts221_dev *dev);
+int hts221_disable(struct hts221_dev *dev);
+
+#endif /* _HTS221_H_ */
diff -uNr a/drivers/input/misc/st/humidity/hts221/hts221_i2c.c b/drivers/input/misc/st/humidity/hts221/hts221_i2c.c
--- a/drivers/input/misc/st/humidity/hts221/hts221_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/hts221/hts221_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,173 @@
+/*
+ * STMicroelectronics hts221_i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+
+#include "hts221_core.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int hts221_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold cdata->lock */
+static int hts221_i2c_write(struct device *dev, u8 addr, int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len + 1;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct hts221_transfer_function hts221_i2c_tf = {
+	.write = hts221_i2c_write,
+	.read = hts221_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int hts221_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct hts221_dev *dev = i2c_get_clientdata(client);
+
+	return hts221_enable(dev);
+}
+
+static int hts221_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct hts221_dev *dev = i2c_get_clientdata(client);
+
+	return hts221_disable(dev);
+}
+
+static const struct dev_pm_ops hts221_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(hts221_i2c_suspend,
+				hts221_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int hts221_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct hts221_dev *dev;
+
+#ifdef HTS221_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct hts221_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &hts221_i2c_tf;
+	dev->dev = &client->dev;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = hts221_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int hts221_i2c_remove(struct i2c_client *client)
+{
+	struct hts221_dev *dev = i2c_get_clientdata(client);
+
+#ifdef HTS221_DEBUG
+	dev_info(&client->dev, "driver removing\n");
+#endif
+
+	hts221_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id hts221_i2c_id[] = {
+	{ "hts221", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, hts221_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id hts221_i2c_id_table[] = {
+	{ .compatible = "st,hts221" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hts221_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver hts221_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "hts221_i2c",
+#ifdef CONFIG_PM
+		.pm = &hts221_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = hts221_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = hts221_i2c_probe,
+	.remove = hts221_i2c_remove,
+	.id_table = hts221_i2c_id,
+};
+
+module_i2c_driver(hts221_i2c_driver);
+
+MODULE_DESCRIPTION("hts221 i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/humidity/hts221/hts221_spi.c b/drivers/input/misc/st/humidity/hts221/hts221_spi.c
--- a/drivers/input/misc/st/humidity/hts221/hts221_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/hts221/hts221_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,196 @@
+/*
+ * STMicroelectronics hts221_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+
+#include "hts221_core.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int hts221_spi_read(struct device *device, u8 addr, int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct hts221_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int hts221_spi_write(struct device *device, u8 addr, int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct hts221_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= HTS221_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static const struct hts221_transfer_function hts221_spi_tf = {
+	.write = hts221_spi_write,
+	.read = hts221_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int hts221_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct hts221_dev *dev = spi_get_drvdata(spi);
+
+	return hts221_enable(dev);
+}
+
+static int hts221_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct hts221_dev *dev = spi_get_drvdata(spi);
+
+	return hts221_disable(dev);
+}
+
+static const struct dev_pm_ops hts221_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(hts221_spi_suspend,
+				hts221_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int hts221_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct hts221_dev *dev;
+
+#ifdef HTS221_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct hts221_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &hts221_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = hts221_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int hts221_spi_remove(struct spi_device *spi)
+{
+	struct hts221_dev *dev = spi_get_drvdata(spi);
+
+#ifdef HTS221_DEBUG
+	dev_info(&client->dev, "driver removing\n");
+#endif
+
+	hts221_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id hts221_spi_id[] = {
+	{ "hts221", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, hts221_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id hts221_spi_id_table[] = {
+	{ .compatible = "st,hts221" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hts221_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver hts221_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "hts221_spi",
+#ifdef CONFIG_PM
+		.pm = &hts221_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = hts221_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = hts221_spi_probe,
+	.remove = hts221_spi_remove,
+	.id_table = hts221_spi_id,
+};
+
+module_spi_driver(hts221_spi_driver);
+
+MODULE_DESCRIPTION("hts221 spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/humidity/hts221/Kconfig b/drivers/input/misc/st/humidity/hts221/Kconfig
--- a/drivers/input/misc/st/humidity/hts221/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/hts221/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,22 @@
+
+config INPUT_HTS221
+         tristate "STM HTS221 sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_HTS221_I2C if (I2C)
+	 select INPUT_HTS221_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics HTS221 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called hts221.
+
+config INPUT_HTS221_I2C
+         tristate
+         depends on INPUT_HTS221
+         depends on I2C
+
+config INPUT_HTS221_SPI
+         tristate
+         depends on INPUT_HTS221
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/humidity/hts221/Makefile b/drivers/input/misc/st/humidity/hts221/Makefile
--- a/drivers/input/misc/st/humidity/hts221/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/hts221/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,10 @@
+#
+# Makefile for the input misc hts221 driver.
+#
+
+hts221-y += hts221_core.o
+obj-$(CONFIG_INPUT_HTS221) += hts221.o
+obj-$(CONFIG_INPUT_HTS221_I2C) += hts221_i2c.o
+obj-$(CONFIG_INPUT_HTS221_SPI) += hts221_spi.o
+
+# ccflags-y += -DHTS221_DEBUG
diff -uNr a/drivers/input/misc/st/humidity/Kconfig b/drivers/input/misc/st/humidity/Kconfig
--- a/drivers/input/misc/st/humidity/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,9 @@
+
+menuconfig INPUT_HUMIDITY
+	tristate "Humidity"
+
+if INPUT_HUMIDITY
+
+source "drivers/input/misc/st/humidity/hts221/Kconfig"
+
+endif # INPUT_HUMIDITY
diff -uNr a/drivers/input/misc/st/humidity/Makefile b/drivers/input/misc/st/humidity/Makefile
--- a/drivers/input/misc/st/humidity/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/humidity/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_INPUT_HTS221) += hts221/
diff -uNr a/drivers/input/misc/st/imu/asm330lxh/asm330lxh.c b/drivers/input/misc/st/imu/asm330lxh/asm330lxh.c
--- a/drivers/input/misc/st/imu/asm330lxh/asm330lxh.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/asm330lxh/asm330lxh.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,1867 @@
+/******************** (C) COPYRIGHT 2014 STMicroelectronics ******************
+ *
+ * File Name		: asm330lxh.c
+ * Author		: MSH - C&I BU - Application Team
+ *			: Giuseppe Barba (giuseppe.barba@st.com)
+ *			: Alberto MARINONI (alberto.marinoni@st.com)
+ *			: Mario Tesi (mario.tesi@st.com)
+ *			: Authors is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V.1.0.1
+ * Date			: 2016/Jul/07
+ * Description	: STMicroelectronics asm330lxh driver
+ *
+ ******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ *****************************************************************************/
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/module.h>
+#endif
+
+#include "asm330lxh.h"
+
+#define MS_TO_US(x)		(x * 1000L)
+#define US_TO_NS(x)		(x * 1000L)
+#define MS_TO_NS(x)		(US_TO_NS(MS_TO_US(x)))
+#define NS_TO_US(x)		(x / 1000)
+#define US_TO_MS(x)		(x / 1000)
+#define NS_TO_MS(x)		(US_TO_MS(NS_TO_US(x)))
+
+#define DEFAULT_POLL_RATE_15HZ_US	66666
+
+/* TODO: check the following values */
+/* Sensitivity */
+#define SENSITIVITY_ACC_2G	61	/** ug/LSB */
+#define SENSITIVITY_ACC_4G	122	/** ug/LSB */
+#define SENSITIVITY_ACC_8G	244	/** ug/LSB */
+#define SENSITIVITY_ACC_16G	488	/** ug/LSB */
+
+#define SENSITIVITY_GYR_125	4370	/** udps/LSB */
+#define SENSITIVITY_GYR_250	8750	/** udps/LSB */
+#define SENSITIVITY_GYR_500	17500	/** udps/LSB */
+#define SENSITIVITY_GYR_1000	35000	/** udps/LSB */
+#define SENSITIVITY_GYR_2000	70000	/** udps/LSB */
+
+#define SENSITIVITY_TEMP	16	/** LSB/C */
+#define OFFSET_TEMP		25	/** Offset temperature */
+
+#define ACC_G_MAX_POS		(32767 * SENSITIVITY_ACC_16G)	/** max positive value acc [ug] */
+#define ACC_G_MAX_NEG		(-ACC_G_MAX_POS)		/** max negative value acc [ug] */
+#define GYR_DPS_MAX_POS		(28571 * SENSITIVITY_GYR_2000)	/** max positive value gyr [udps] */
+#define GYR_DPS_MAX_NEG		(-GYR_DPS_MAX_POS)		/** max negative value gyr [udps] */
+#define FUZZ			0
+#define FLAT			0
+
+/* Device Registers */
+#define DEF_ZERO		0x00
+#define UNDEF			0x00
+
+#define INT_CFG2_XL		0x01
+#define INT_THS2_XL		0x02
+#define INT_DUR2_XL		0x03
+#define ACT_THS			0x04
+#define ACT_DUR			0x05
+#define INT_CFG1_XL		0x06
+#define INT_THS_X1_XL		0x07
+#define INT_THS_Y1_XL		0x08
+#define INT_THS_Z1_XL		0x09
+#define INT_DUR1_XL		0x0A
+#define ORIENT_CFG_G		0x0B
+#define REFERENCE_G		0x0C
+#define INT1_CTRL		0x0D
+#define INT2_CTRL		0x0E
+#define WHO_AM_I		0x0F
+#define WHO_AM_I_VAL		0x61
+#define CTRL1_XL		0x10
+#define CTRL2_G			0x11
+#define CTRL3_C			0x12
+#define CTRL3_IF_ADD_INC	0x04
+#define CTRL3_C_BDU		0x40
+#define CTRL4_C			0x13
+#define CTRL5_C			0x14
+#define CTRL6_G			0x15
+#define CTRL7_G			0x16
+#define CTRL8_XL		0x17
+#define CTRL9_XL		0x18
+#define CTRL9_XL_DEF		0x38
+#define CTRL10_C		0x19
+#define CTRL10_C_DEF		0x38
+#define CTRL10_C_ALLAXIS_EN	0x38
+#define FIFO_CTRL		0x1A
+#define INT_SRC_G		0x1B
+#define INT_SRC2_XL		0x1C
+#define INT_SRC1_XL		0x1D
+#define FIFO_SRC		0x1E
+#define STATUS_REG		0x1F
+#define OUT_TEMP_L		0x20
+#define OUT_TEMP_H		0x21
+#define	OUT_X_L_G		0x22	/* 1st AXIS OUT REG of 6 */
+#define OUT_X_L_XL		0x28	/* 1st AXIS OUT REG of 6 */
+#define INT_GEN_CFG_G		0x30
+#define INT_GEN_THS_XH_G	0x31
+#define INT_GEN_THS_XL_G	0x32
+#define INT_GEN_THS_YH_G	0x33
+#define INT_GEN_THS_YL_G	0x34
+#define INT_GEN_THS_ZH_G	0x35
+#define INT_GEN_THS_ZL_G	0x36
+#define INT_GEN_DUR_G		0x37
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+static struct kobject *acc_kobj;
+static struct kobject *gyr_kobj;
+
+struct workqueue_struct *asm330lxh_workqueue = 0;
+
+struct reg_rw {
+	uint8_t address;
+	uint8_t default_val;
+	uint8_t resume_val;
+};
+
+struct reg_r {
+	uint8_t address;
+	uint8_t default_val;
+};
+
+static struct device_registers {
+	struct reg_rw ctrl1_xl;
+	struct reg_rw ctrl2_g;
+	struct reg_rw ctrl3_c;
+	struct reg_rw ctrl4_c;
+	struct reg_rw ctrl5_c;
+	struct reg_rw ctrl6_g;
+	struct reg_rw ctrl7_g;
+	struct reg_rw ctrl8_xl;
+	struct reg_rw ctrl9_xl;
+	struct reg_rw ctrl10_c;
+} device_registers = {
+	.ctrl1_xl = {
+		.address = CTRL1_XL,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl2_g = {
+		.address = CTRL2_G,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl3_c = {
+		/* Set address auto increment */
+		.address = CTRL3_C,
+		.default_val = (CTRL3_IF_ADD_INC | CTRL3_C_BDU),
+		.resume_val = (CTRL3_IF_ADD_INC | CTRL3_C_BDU),
+	},
+	.ctrl4_c = {
+		.address = CTRL4_C,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl5_c = {
+		.address = CTRL5_C,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl6_g = {
+		.address = CTRL6_G,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl7_g = {
+		.address = CTRL7_G,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl8_xl = {
+		.address = CTRL8_XL,
+		.default_val = DEF_ZERO,
+		.resume_val = DEF_ZERO,
+	},
+	.ctrl9_xl = {
+		.address = CTRL9_XL,
+		.default_val = CTRL9_XL_DEF,
+		.resume_val = CTRL9_XL_DEF,
+	},
+	.ctrl10_c = {
+		.address = CTRL10_C,
+		.default_val = CTRL10_C_DEF,
+		.resume_val = CTRL10_C_DEF,
+	},
+};
+
+struct output_rate {
+	uint32_t odr_us;
+	uint8_t value;
+};
+
+static const struct output_rate asm330lxh_gyr_odr_table[] = {
+	{ ASM330LXH_ODR_PERIOD_US_800_HZ,
+	 (ASM330LXH_GYR_ODR_110 | ASM330LXH_GYR_BW_00) },
+	{ ASM330LXH_ODR_PERIOD_US_400_HZ,
+	 (ASM330LXH_GYR_ODR_101 | ASM330LXH_GYR_BW_00) },
+	{ ASM330LXH_ODR_PERIOD_US_200_HZ,
+	 (ASM330LXH_GYR_ODR_100 | ASM330LXH_GYR_BW_00) },
+	{ ASM330LXH_ODR_PERIOD_US_100_HZ,
+	 (ASM330LXH_GYR_ODR_011 | ASM330LXH_GYR_BW_00) },
+	{ ASM330LXH_ODR_PERIOD_US_50_HZ,
+	 (ASM330LXH_GYR_ODR_010 | ASM330LXH_GYR_BW_00) },
+	{ ASM330LXH_ODR_PERIOD_US_12_5_HZ,
+	 (ASM330LXH_GYR_ODR_001 | ASM330LXH_GYR_BW_00) },
+};
+
+static const struct output_rate asm330lxh_acc_odr_table[] = {
+	{ ASM330LXH_ODR_PERIOD_US_800_HZ, (ASM330LXH_GYR_ODR_110) },
+	{ ASM330LXH_ODR_PERIOD_US_400_HZ, (ASM330LXH_GYR_ODR_101) },
+	{ ASM330LXH_ODR_PERIOD_US_200_HZ, (ASM330LXH_GYR_ODR_100) },
+	{ ASM330LXH_ODR_PERIOD_US_100_HZ, (ASM330LXH_GYR_ODR_011) },
+	{ ASM330LXH_ODR_PERIOD_US_50_HZ, (ASM330LXH_GYR_ODR_010) },
+	{ ASM330LXH_ODR_PERIOD_US_12_5_HZ, (ASM330LXH_GYR_ODR_001) },
+};
+
+static const struct axl_turn_on_time {
+	uint32_t odr_us;
+	uint32_t samples_to_discard;
+} asm330lxh_axl_turn_on_time[] = { 
+	{ ASM330LXH_ODR_PERIOD_US_800_HZ, 2 },
+	{ ASM330LXH_ODR_PERIOD_US_400_HZ, 2 },
+	{ ASM330LXH_ODR_PERIOD_US_200_HZ, 2 },
+	{ ASM330LXH_ODR_PERIOD_US_100_HZ, 2 },
+	{ ASM330LXH_ODR_PERIOD_US_50_HZ, 0 },
+	{ ASM330LXH_ODR_PERIOD_US_12_5_HZ, 0 },
+};
+
+static const struct gyr_turn_on_time {
+	uint32_t odr_us;
+	uint32_t samples_to_discard;
+} asm330lxh_gyr_turn_on_time[] = {
+		{ ASM330LXH_ODR_PERIOD_US_800_HZ, 9 },
+		{ ASM330LXH_ODR_PERIOD_US_400_HZ, 7 },
+		{ ASM330LXH_ODR_PERIOD_US_200_HZ, 5 },
+		{ ASM330LXH_ODR_PERIOD_US_100_HZ, 4 },
+		{ ASM330LXH_ODR_PERIOD_US_50_HZ, 4 },
+		{ ASM330LXH_ODR_PERIOD_US_12_5_HZ, 2 },
+};
+
+static const struct asm330lxh_acc_platform_data default_asm330lxh_acc_pdata = {
+	.fs_range = ASM330LXH_ACC_FS_4G,
+	.poll_interval = ASM330LXH_ACC_POLL_INTERVAL_DEF,
+	.min_interval = ASM330LXH_ACC_MIN_POLL_PERIOD_US,
+};
+
+static const struct asm330lxh_gyr_platform_data default_asm330lxh_gyr_pdata = {
+	.fs_range = ASM330LXH_GYR_FS_2000DPS,
+	.poll_interval = ASM330LXH_GYR_POLL_INTERVAL_DEF,
+	.min_interval = ASM330LXH_GYR_MIN_POLL_PERIOD_US,
+};
+
+static inline s64 asm330lxh_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+struct asm330lxh_main_platform_data default_asm330lxh_main_platform_data = {
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+	.gpio_int1 = ASM330LXH_INT1_GPIO_DEF,
+	.gpio_int2 = ASM330LXH_INT2_GPIO_DEF,
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	uint8_t address;
+	uint8_t mask;
+};
+
+struct interrupt_value {
+	int32_t value;
+	uint8_t address;
+};
+
+/* Function Prototype */
+static int32_t asm330lxh_gyr_update_odr(struct asm330lxh_status *stat,
+					uint32_t poll_interval_us);
+
+static int32_t asm330lxh_acc_device_power_off(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf = (ASM330LXH_ACC_ODR_MASK & ASM330LXH_ACC_ODR_OFF) | 
+		       ((~ASM330LXH_ACC_ODR_MASK) & 
+		       device_registers.ctrl1_xl.resume_val);
+
+	err = stat->tf->write(stat, device_registers.ctrl1_xl.address, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "accelerometer soft power off "
+			"failed: %d\n", err);
+
+	if (stat->pdata_acc->power_off) {
+		stat->pdata_acc->power_off();
+	}
+
+	if (!atomic_read(&stat->on_before_suspend))
+		atomic_set(&stat->enabled_acc, 0);
+	
+	dev_info(stat->dev, "accelerometer switched off.");
+
+	/* Restore Gyro ODR */
+	if (atomic_read(&stat->enabled_gyr)) {
+		// If gyro ODR != of latest requested ODR
+		if (stat->pdata_gyr->poll_interval != stat->gyr_current_ODR_interval_us)
+			asm330lxh_gyr_update_odr(stat, stat->pdata_gyr->poll_interval);
+	}
+
+	return 0;
+}
+
+static int32_t asm330lxh_gyr_device_power_off(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf = (ASM330LXH_GYR_ODR_MASK & ASM330LXH_GYR_ODR_OFF) | 
+		       ((~ASM330LXH_GYR_ODR_MASK) & 
+		       device_registers.ctrl2_g.resume_val);
+
+	err = stat->tf->write(stat, device_registers.ctrl2_g.address, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "gyroscope soft power off "
+			"failed: %d\n", err);
+
+	if (stat->pdata_gyr->power_off)
+		stat->pdata_gyr->power_off();
+
+	if (!atomic_read(&stat->on_before_suspend))
+		atomic_set(&stat->enabled_gyr, 0);
+
+	dev_info(stat->dev, "gyroscope switched off.");
+
+	return 0;
+}
+
+static int32_t _asm330lxh_gyr_disable(struct asm330lxh_status *stat)
+{
+	cancel_work_sync(&stat->input_work_gyr);
+	hrtimer_cancel(&stat->hr_timer_gyr);
+	asm330lxh_gyr_device_power_off(stat);
+
+	return 0;
+}
+
+static int32_t asm330lxh_gyr_disable(struct asm330lxh_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_gyr, 1, 0))
+		return _asm330lxh_gyr_disable(stat);
+
+	return 0;
+}
+
+static int32_t _asm330lxh_acc_disable(struct asm330lxh_status *stat)
+{
+	cancel_work_sync(&stat->input_work_acc);
+	hrtimer_cancel(&stat->hr_timer_acc);
+	asm330lxh_acc_device_power_off(stat);
+
+	return 0;
+}
+
+static int32_t asm330lxh_acc_disable(struct asm330lxh_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_acc, 1, 0))
+		return _asm330lxh_acc_disable(stat);
+
+	return 0;
+}
+
+static void asm330lxh_acc_input_cleanup(struct asm330lxh_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+}
+
+static void asm330lxh_gyr_input_cleanup(struct asm330lxh_status *stat)
+{
+	input_unregister_device(stat->input_dev_gyr);
+	input_free_device(stat->input_dev_gyr);
+}
+
+static enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct asm330lxh_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+			    struct asm330lxh_status, hr_timer_acc);
+
+	stat->acc_ts = asm330lxh_get_time_ns();
+
+	queue_work(asm330lxh_workqueue, &stat->input_work_acc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart poll_function_read_gyr(struct hrtimer *timer)
+{
+	struct asm330lxh_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+			    struct asm330lxh_status, hr_timer_gyr);
+
+	stat->gyr_ts = asm330lxh_get_time_ns();
+
+	queue_work(asm330lxh_workqueue, &stat->input_work_gyr);
+
+	return HRTIMER_NORESTART;
+}
+
+static void asm330lxh_validate_polling(uint32_t * min_interval,
+				       uint32_t * poll_interval, uint32_t min)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int32_t asm330lxh_acc_validate_pdata(struct asm330lxh_status *stat)
+{
+
+	asm330lxh_validate_polling(&stat->pdata_acc->min_interval,
+				   &stat->pdata_acc->poll_interval,
+				   (unsigned int)
+				   ASM330LXH_ACC_MIN_POLL_PERIOD_US);
+
+	return 1;
+}
+
+static int32_t asm330lxh_gyr_validate_pdata(struct asm330lxh_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	asm330lxh_validate_polling(&stat->pdata_gyr->min_interval,
+				   &stat->pdata_gyr->poll_interval,
+				   (unsigned int)
+				   ASM330LXH_GYR_MIN_POLL_PERIOD_US);
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata_gyr->poll_interval < stat->pdata_gyr->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int32_t asm330lxh_acc_gyr_hw_init(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf;
+
+	dev_info(stat->dev, "%s: hw init start\n", ASM330LXH_ACC_GYR_DEV_NAME);
+
+	err = stat->tf->read(stat, WHO_AM_I, 1, &buf);
+	if (err < 0) {
+		dev_warn(stat->dev, 
+			 "Error reading WHO_AM_I: is device available/working?\n");
+		return err;
+	}
+
+	if (buf != WHO_AM_I_VAL) {
+		dev_err(stat->dev, "device unknown: Expected: 0x%02x Replies: 0x%02x\n",
+			WHO_AM_I_VAL, buf);
+		return -1;
+	}
+
+	stat->acc_discard_samples = 0;
+	stat->gyr_discard_samples = 0;
+
+	dev_info(stat->dev, "%s: hw init done\n", ASM330LXH_ACC_GYR_DEV_NAME);
+
+	return 0;
+}
+
+static int32_t asm330lxh_acc_device_power_on(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf[3] = { 0 };
+
+	if (stat->pdata_acc->power_on) {
+		err = stat->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(stat->dev, "accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	err = stat->tf->write(stat, device_registers.ctrl1_xl.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = device_registers.ctrl3_c.resume_val;
+	buf[1] = device_registers.ctrl4_c.resume_val;
+	buf[2] = device_registers.ctrl5_c.resume_val;
+	err = stat->tf->write(stat, device_registers.ctrl3_c.address, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = device_registers.ctrl8_xl.resume_val;
+	buf[1] = device_registers.ctrl9_xl.resume_val;
+	buf[2] = device_registers.ctrl10_c.resume_val;
+	err = stat->tf->write(stat, device_registers.ctrl8_xl.address, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&stat->enabled_acc, 1);
+	
+	return 0;
+
+err_resume_state:
+	atomic_set(&stat->enabled_acc, 0);
+	dev_err(stat->dev, "accelerometer hw power on error : %d\n", err);
+
+	return err;
+}
+
+static int32_t asm330lxh_gyr_device_power_on(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf[6] = { 0 };
+
+	if (stat->pdata_gyr->power_on) {
+		err = stat->pdata_gyr->power_on();
+		if (err < 0) {
+			dev_err(stat->dev, "gyroscope power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = device_registers.ctrl2_g.resume_val;
+	buf[1] = device_registers.ctrl3_c.resume_val;
+	buf[2] = device_registers.ctrl4_c.resume_val;
+	buf[3] = device_registers.ctrl5_c.resume_val;
+	buf[4] = device_registers.ctrl6_g.resume_val;
+	buf[5] = device_registers.ctrl7_g.resume_val;
+	err = stat->tf->write(stat, device_registers.ctrl2_g.address, 6, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = device_registers.ctrl10_c.resume_val;
+	err = stat->tf->write(stat, device_registers.ctrl10_c.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&stat->enabled_gyr, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&stat->enabled_gyr, 0);
+	dev_err(stat->dev, "gyroscope hw power on error: %d\n", err);
+
+	return err;
+}
+
+static int32_t asm330lxh_acc_update_fs_range(struct asm330lxh_status *stat,
+					     uint8_t new_fs_range)
+{
+	int32_t sensitivity, err = -1;
+	uint8_t val;
+
+	switch (new_fs_range) {
+	case ASM330LXH_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case ASM330LXH_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case ASM330LXH_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	case ASM330LXH_ACC_FS_16G:
+		sensitivity = SENSITIVITY_ACC_16G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+			"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	val = ((ASM330LXH_ACC_FS_MASK & new_fs_range) |
+	       ((~ASM330LXH_ACC_FS_MASK) & device_registers.ctrl1_xl.resume_val));
+
+	err = stat->tf->write(stat, device_registers.ctrl1_xl.address, 1, &val);
+	if (err < 0)
+		goto error;
+
+	device_registers.ctrl1_xl.resume_val = val;
+
+	mutex_lock(&stat->lock);
+	stat->sensitivity_acc = sensitivity;
+	mutex_unlock(&stat->lock);
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer fs range failed: %d\n", err);
+
+	return err;
+}
+
+static int32_t asm330lxh_gyr_update_fs_range(struct asm330lxh_status *stat,
+					     uint8_t new_fs_range)
+{
+	int32_t err = -1;
+	uint8_t updated_val, buf;
+	u32 sensitivity;
+
+	switch (new_fs_range) {
+	case ASM330LXH_GYR_FS_245DPS:
+		sensitivity = SENSITIVITY_GYR_250;
+		break;
+	case ASM330LXH_GYR_FS_500DPS:
+		sensitivity = SENSITIVITY_GYR_500;
+		break;
+	case ASM330LXH_GYR_FS_1000DPS:
+		sensitivity = SENSITIVITY_GYR_1000;
+		break;
+	case ASM330LXH_GYR_FS_2000DPS:
+		sensitivity = SENSITIVITY_GYR_2000;
+		break;
+	default:
+		dev_err(stat->dev, "invalid g range "
+			"requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	err = stat->tf->read(stat, device_registers.ctrl2_g.address, 1, &buf);
+	if (err < 0)
+		goto error;
+
+	updated_val = ((ASM330LXH_GYR_FS_MASK & new_fs_range) |
+		       ((~ASM330LXH_GYR_FS_MASK) & buf));
+
+	err = stat->tf->write(stat, device_registers.ctrl2_g.address, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	device_registers.ctrl2_g.resume_val = updated_val;
+
+	mutex_lock(&stat->lock);
+	stat->sensitivity_gyr = sensitivity;
+	mutex_unlock(&stat->lock);
+
+error:
+	return err;
+}
+
+static int32_t asm330lxh_acc_update_odr(struct asm330lxh_status *stat,
+					uint32_t poll_interval_us)
+{
+	int32_t err = -1;
+	uint8_t buf;
+	uint32_t i;
+
+	if (atomic_read(&stat->enabled_acc)) {
+		for (i = ARRAY_SIZE(asm330lxh_acc_odr_table) - 1; i >= 0; i--) {
+			if (((uint32_t)asm330lxh_acc_odr_table[i].odr_us
+			     <= poll_interval_us) || (i == 0))
+				break;
+		}
+
+		buf = ASM330LXH_ACC_ODR_MASK & asm330lxh_acc_odr_table[i].value;
+		buf |= (~ASM330LXH_ACC_ODR_MASK) & device_registers.ctrl1_xl.resume_val;
+
+		err = stat->tf->write(stat, device_registers.ctrl1_xl.address, 1, &buf);
+		if (err < 0)
+			goto error;
+
+		device_registers.ctrl1_xl.resume_val = buf;
+
+		/* Adjust Gyro ODR value */
+		if (atomic_read(&stat->enabled_gyr) &&
+		    (poll_interval_us < stat->gyr_current_ODR_interval_us))
+			asm330lxh_gyr_update_odr(stat, stat->pdata_gyr->poll_interval);
+
+		mutex_lock(&stat->lock);
+		stat->ktime_acc = ktime_set(0, US_TO_NS(poll_interval_us));
+		stat->pdata_acc->poll_interval = poll_interval_us;
+		mutex_unlock(&stat->lock);
+	} else {
+		mutex_lock(&stat->lock);
+		stat->pdata_acc->poll_interval = poll_interval_us;
+		mutex_unlock(&stat->lock);
+		err = 0;
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer odr failed: %d\n", err);
+
+	return err;
+}
+
+static int32_t asm330lxh_gyr_update_odr(struct asm330lxh_status *stat,
+					uint32_t poll_interval_us)
+{
+	uint8_t buf;
+	uint32_t val, i;
+	int32_t err = -1;
+
+	if (atomic_read(&stat->enabled_gyr)) {
+		// min poll rate from axl and gyro
+		if (atomic_read(&stat->enabled_acc))
+			val = min(poll_interval_us, stat->pdata_acc->poll_interval);
+		else
+			val = poll_interval_us;
+
+		for (i = ARRAY_SIZE(asm330lxh_gyr_odr_table) - 1; i >= 0; i--) {
+			if ((asm330lxh_gyr_odr_table[i].odr_us <= val)
+			    || (i == 0))
+				break;
+		}
+
+		/* Set ODR value */
+		buf = ASM330LXH_GYR_ODR_MASK & asm330lxh_gyr_odr_table[i].value;
+		buf |= (~ASM330LXH_GYR_ODR_MASK) & device_registers.ctrl2_g.resume_val;
+
+		err = stat->tf->write(stat, device_registers.ctrl2_g.address, 1, &buf);
+		if (err < 0)
+			goto error;
+
+		device_registers.ctrl2_g.resume_val = buf;
+
+		/* Enable all axes */
+		buf = CTRL10_C_ALLAXIS_EN | device_registers.ctrl10_c.resume_val;
+
+		err = stat->tf->write(stat, device_registers.ctrl10_c.address, 1, &buf);
+		if (err < 0)
+			goto error;
+
+		device_registers.ctrl10_c.resume_val = buf;
+
+		mutex_lock(&stat->lock);
+		stat->ktime_gyr = ktime_set(0, US_TO_NS(poll_interval_us));
+		stat->pdata_gyr->poll_interval = poll_interval_us;
+		stat->gyr_current_ODR_interval_us = val;
+		mutex_unlock(&stat->lock);
+	} else {
+		mutex_lock(&stat->lock);
+		stat->pdata_gyr->poll_interval = poll_interval_us;
+		mutex_unlock(&stat->lock);
+		err = 0;
+	}
+
+	return err;
+
+error:	
+	dev_err(stat->dev, "update accelerometer odr failed: %d\n", err);
+
+	return err;
+}
+
+static int32_t _asm330lxh_acc_enable(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t j;
+
+	err = asm330lxh_acc_device_power_on(stat);
+	if (err < 0) {
+		atomic_set(&stat->enabled_acc, 0);
+		dev_err(stat->dev, "enable accelerometer failed");
+		return err;
+	}
+
+	for (j = ARRAY_SIZE(asm330lxh_axl_turn_on_time) - 1; j >= 0; j--) {
+		if ((asm330lxh_axl_turn_on_time[j].odr_us <=
+		     stat->pdata_acc->poll_interval) || (j == 0))
+			break;
+	}
+
+	stat->acc_discard_samples =
+	    asm330lxh_axl_turn_on_time[j].samples_to_discard;
+
+	err = asm330lxh_acc_update_odr(stat, stat->pdata_acc->poll_interval);
+	if (err < 0)
+		return err;
+
+	hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+
+	return 0;
+}
+
+static int32_t asm330lxh_acc_enable(struct asm330lxh_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled_acc, 0, 1))
+		return _asm330lxh_acc_enable(stat);
+
+	return 0;
+}
+
+static int32_t _asm330lxh_gyr_enable(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+	uint8_t j;
+
+	err = asm330lxh_gyr_device_power_on(stat);
+	if (err < 0) {
+		atomic_set(&stat->enabled_gyr, 0);
+		return err;
+	}
+
+	for (j = ARRAY_SIZE(asm330lxh_gyr_turn_on_time) - 1; j >= 0; j--) {
+		if ((asm330lxh_gyr_turn_on_time[j].odr_us <=
+		     stat->pdata_gyr->poll_interval) || (j == 0))
+			break;
+	}
+
+	stat->gyr_discard_samples =
+	    asm330lxh_gyr_turn_on_time[j].samples_to_discard;
+
+	err = asm330lxh_gyr_update_odr(stat, stat->pdata_gyr->poll_interval);
+	if (err < 0)
+		return err;
+
+	hrtimer_start(&(stat->hr_timer_gyr), stat->ktime_gyr, HRTIMER_MODE_REL);
+
+	return 0;
+}
+
+static int32_t asm330lxh_gyr_enable(struct asm330lxh_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled_gyr, 0, 1))
+		return _asm330lxh_gyr_enable(stat);
+
+	return 0;
+}
+
+#ifdef ASM330LXH_EN_ON_OPEN
+int32_t asm330lxh_acc_input_open(struct input_dev * input)
+{
+	struct asm330lxh_status *stat = input_get_drvdata(input);
+
+	return asm330lxh_acc_enable(stat);
+}
+
+void asm330lxh_acc_input_close(struct input_dev *dev)
+{
+	struct asm330lxh_status *stat = input_get_drvdata(dev);
+
+	asm330lxh_acc_disable(stat);
+}
+
+int32_t asm330lxh_gyr_input_open(struct input_dev *input)
+{
+	struct asm330lxh_status *stat = input_get_drvdata(input);
+
+	return asm330lxh_gyr_enable(stat);
+}
+
+void asm330lxh_gyr_input_close(struct input_dev *dev)
+{
+	struct asm330lxh_status *stat = input_get_drvdata(dev);
+
+	asm330lxh_gyr_disable(stat);
+}
+#endif
+
+static int32_t asm330lxh_acc_get_data(struct asm330lxh_status *stat,
+				      int32_t * xyz)
+{
+	int32_t i, err = -1, hw_d[3] = { 0 };
+	uint8_t acc_data[6];
+
+	err = stat->tf->read(stat, OUT_X_L_XL, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((int32_t)((int16_t)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((int32_t)((int16_t)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((int32_t)((int16_t)((acc_data[5] << 8) | (acc_data[4]))));
+
+	mutex_lock(&stat->lock);
+	hw_d[0] = hw_d[0] * stat->sensitivity_acc;
+	hw_d[1] = hw_d[1] * stat->sensitivity_acc;
+	hw_d[2] = hw_d[2] * stat->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_main->rot_matrix[0][i] * hw_d[0] +
+			 stat->pdata_main->rot_matrix[1][i] * hw_d[1] +
+			 stat->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int32_t asm330lxh_gyr_get_data(struct asm330lxh_status *stat,
+				      int32_t * xyz)
+{
+	int32_t i, err = 1, hw_d[3] = { 0 };
+	uint8_t gyro_data[6];
+
+	err = stat->tf->read(stat, OUT_X_L_G, 6, gyro_data);
+
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (int32_t)((int16_t)((gyro_data[1]) << 8) | gyro_data[0]);
+	hw_d[1] = (int32_t)((int16_t)((gyro_data[3]) << 8) | gyro_data[2]);
+	hw_d[2] = (int32_t)((int16_t)((gyro_data[5]) << 8) | gyro_data[4]);
+
+	mutex_lock(&stat->lock);
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_gyr;
+	hw_d[1] = hw_d[1] * stat->sensitivity_gyr;
+	hw_d[2] = hw_d[2] * stat->sensitivity_gyr;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_main->rot_matrix[0][i] * hw_d[0] +
+			 stat->pdata_main->rot_matrix[1][i] * hw_d[1] +
+			 stat->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+	mutex_unlock(&stat->lock);
+	return err;
+}
+
+static void asm330lxh_acc_report_values(struct asm330lxh_status *stat,
+					int32_t * xyz)
+{
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    stat->acc_ts >> 32);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    stat->acc_ts & 0xffffffff);
+	input_sync(stat->input_dev_acc);
+}
+
+static void asm330lxh_gyr_report_values(struct asm330lxh_status *stat,
+					int32_t * xyz)
+{
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    stat->gyr_ts >> 32);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    stat->gyr_ts & 0xffffffff);
+	input_sync(stat->input_dev_gyr);
+}
+
+static int32_t asm330lxh_acc_input_init(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+
+	mutex_lock(&stat->lock);
+	stat->input_dev_acc = input_allocate_device();
+	if (!stat->input_dev_acc) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"accelerometer input device allocation failed\n");
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+#ifdef ASM330LXH_EN_ON_OPEN
+	stat->input_dev_acc->open = asm330lxh_acc_input_open;
+	stat->input_dev_acc->close = asm330lxh_acc_input_close;
+#endif
+	stat->input_dev_acc->name = ASM330LXH_ACC_DEV_NAME;
+	stat->input_dev_acc->id.bustype = stat->bustype;
+	stat->input_dev_acc->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev_acc, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev_acc->evbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev_acc->mscbit);
+
+	err = input_register_device(stat->input_dev_acc);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev_acc->name);
+		input_free_device(stat->input_dev_acc);
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int32_t asm330lxh_gyr_input_init(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	mutex_lock(&stat->lock);
+	stat->input_dev_gyr = input_allocate_device();
+	if (!stat->input_dev_gyr) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "input device allocation failed\n");
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+#ifdef ASM330LXH_EN_ON_OPEN
+	stat->input_dev_gyr->open = asm330lxh_gyr_input_open;
+	stat->input_dev_gyr->close = asm330lxh_gyr_input_close;
+#endif
+	stat->input_dev_gyr->name = ASM330LXH_GYR_DEV_NAME;
+	stat->input_dev_gyr->id.bustype = stat->bustype;
+	stat->input_dev_gyr->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev_gyr, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev_gyr->evbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, stat->input_dev_gyr->mscbit);
+
+	err = input_register_device(stat->input_dev_gyr);
+	if (err) {
+		dev_err(stat->dev, "unable to register input device %s\n",
+			stat->input_dev_gyr->name);
+		input_free_device(stat->input_dev_gyr);
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static void asm330lxh_input_cleanup(struct asm330lxh_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+
+	input_unregister_device(stat->input_dev_gyr);
+	input_free_device(stat->input_dev_gyr);
+}
+
+static ssize_t attr_set_polling_rate_acc(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 const char *buf, size_t size)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_us, interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_us = (unsigned long)max((unsigned int)MS_TO_US(interval_ms),
+					 stat->pdata_acc->min_interval);
+
+	asm330lxh_acc_update_odr(stat, interval_us);
+
+	return size;
+}
+
+static ssize_t attr_get_polling_rate_acc(struct kobject *kobj,
+					 struct kobj_attribute *attr, char *buf)
+{
+	uint32_t val = 0;
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%u\n", US_TO_MS(val));
+}
+
+static ssize_t attr_get_enable_acc(struct kobject *kobj,
+				   struct kobj_attribute *attr, char *buf)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+
+	int32_t val = (int)atomic_read(&stat->enabled_acc);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_acc(struct kobject *kobj,
+				   struct kobj_attribute *attr, const char *buf,
+				   size_t size)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		asm330lxh_acc_enable(stat);
+	else
+		asm330lxh_acc_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_get_range_acc(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	uint8_t val;
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	int32_t range = 2;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata_acc->fs_range;
+	mutex_unlock(&stat->lock);
+
+	switch (val) {
+	case ASM330LXH_ACC_FS_2G:
+		range = RANGE_2G;
+		break;
+	case ASM330LXH_ACC_FS_4G:
+		range = RANGE_4G;
+		break;
+	case ASM330LXH_ACC_FS_8G:
+		range = RANGE_8G;
+		break;
+	case ASM330LXH_ACC_FS_16G:
+		range = RANGE_16G;
+		break;
+	}
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_acc(struct kobject *kobj,
+				  struct kobj_attribute *attr, const char *buf,
+				  size_t size)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t range;
+	int32_t err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case RANGE_2G:
+		range = ASM330LXH_ACC_FS_2G;
+		break;
+	case RANGE_4G:
+		range = ASM330LXH_ACC_FS_4G;
+		break;
+	case RANGE_8G:
+		range = ASM330LXH_ACC_FS_8G;
+		break;
+	case RANGE_16G:
+		range = ASM330LXH_ACC_FS_16G;
+		break;
+	default:
+		dev_err(stat->dev, "accelerometer invalid range "
+			"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = asm330lxh_acc_update_fs_range(stat, range);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&stat->lock);
+	stat->pdata_acc->fs_range = range;
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "accelerometer range set to: %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_polling_rate_gyr(struct kobject *kobj,
+					 struct kobj_attribute *attr, char *buf)
+{
+	uint32_t val;
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata_gyr->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", US_TO_MS(val));
+}
+
+static ssize_t attr_set_polling_rate_gyr(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 const char *buf, size_t size)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_us, interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_us = (unsigned int)max((unsigned int)MS_TO_US(interval_ms),
+					stat->pdata_gyr->min_interval);
+
+	asm330lxh_gyr_update_odr(stat, interval_us);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_gyr(struct kobject *kobj,
+				   struct kobj_attribute *attr, char *buf)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	int32_t val = atomic_read(&stat->enabled_gyr);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_gyr(struct kobject *kobj,
+				   struct kobj_attribute *attr, const char *buf,
+				   size_t size)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		asm330lxh_gyr_enable(stat);
+	else
+		asm330lxh_gyr_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_get_range_gyr(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	int32_t range = 0;
+	uint8_t val;
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata_gyr->fs_range;
+	switch (val) {
+	case ASM330LXH_GYR_FS_245DPS:
+		range = RANGE_245DPS;
+		break;
+	case ASM330LXH_GYR_FS_500DPS:
+		range = RANGE_500DPS;
+		break;
+	case ASM330LXH_GYR_FS_1000DPS:
+		range = RANGE_1000DPS;
+		break;
+	case ASM330LXH_GYR_FS_2000DPS:
+		range = RANGE_2000DPS;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_gyr(struct kobject *kobj,
+				  struct kobj_attribute *attr, const char *buf,
+				  size_t size)
+{
+	struct device
+	*dev = to_dev(kobj->parent);
+	struct asm330lxh_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t range;
+	int32_t err = -1;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 245:
+		range = ASM330LXH_GYR_FS_245DPS;
+		break;
+	case 500:
+		range = ASM330LXH_GYR_FS_500DPS;
+		break;
+	case 1000:
+		range = ASM330LXH_GYR_FS_1000DPS;
+		break;
+	case 2000:
+		range = ASM330LXH_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = asm330lxh_gyr_update_fs_range(stat, range);
+	if (err >= 0) {
+		mutex_lock(&stat->lock);
+		stat->pdata_gyr->fs_range = range;
+		mutex_unlock(&stat->lock);
+	}
+
+	dev_info(stat->dev, "range set to: %lu dps\n", val);
+
+	return size;
+}
+
+static struct kobj_attribute poll_attr_acc =
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate_acc,
+	       attr_set_polling_rate_acc);
+static struct kobj_attribute enable_attr_acc =
+	__ATTR(enable_device, 0666, attr_get_enable_acc, attr_set_enable_acc);
+static struct kobj_attribute fs_attr_acc =
+	__ATTR(range, 0666, attr_get_range_acc, attr_set_range_acc);
+static struct kobj_attribute poll_attr_gyr =
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate_gyr,
+	       attr_set_polling_rate_gyr);
+static struct kobj_attribute enable_attr_gyr =
+	__ATTR(enable_device, 0666, attr_get_enable_gyr, attr_set_enable_gyr);
+static struct kobj_attribute range_attr_gyr =
+	__ATTR(range, 0666, attr_get_range_gyr, attr_set_range_gyr);
+
+static struct attribute *attributes_acc[] = { &poll_attr_acc.attr,
+	&enable_attr_acc.attr, &fs_attr_acc.attr,
+	NULL,
+};
+
+static struct attribute *attributes_gyr[] = { &poll_attr_gyr.attr,
+	&enable_attr_gyr.attr, &range_attr_gyr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_gyr = {
+	.attrs = attributes_gyr,
+};
+
+static int32_t create_sysfs_interfaces(struct device *dev)
+{
+	int32_t err = -1;
+
+	acc_kobj = kobject_create_and_add("accelerometer", &dev->kobj);
+	if (!acc_kobj)
+		return -ENOMEM;
+
+	gyr_kobj = kobject_create_and_add("gyroscope", &dev->kobj);
+	if (!gyr_kobj)
+		return -ENOMEM;
+
+	err = sysfs_create_group(acc_kobj, &attr_group_acc);
+	if (err)
+		kobject_put(acc_kobj);
+
+	err = sysfs_create_group(gyr_kobj, &attr_group_gyr);
+	if (err)
+		kobject_put(gyr_kobj);
+
+	return 0;
+}
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	kobject_put(acc_kobj);
+	kobject_put(gyr_kobj);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct asm330lxh_status *stat;
+	int32_t xyz[3] = { 0 }, err = -1;
+
+	stat = container_of((struct work_struct *)input_work_acc,
+			    struct asm330lxh_status, input_work_acc);
+
+	err = asm330lxh_acc_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get accelerometer data failed\n");
+	else {
+		mutex_lock(&stat->lock);
+		if (stat->acc_discard_samples > 0) {
+			stat->acc_discard_samples--;
+			mutex_unlock(&stat->lock);
+		} else {
+			mutex_unlock(&stat->lock);
+			asm330lxh_acc_report_values(stat, xyz);
+		}
+	}
+
+	hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+}
+
+static void poll_function_work_gyr(struct work_struct *input_work_gyr)
+{
+	struct asm330lxh_status *stat;
+	int32_t xyz[3] = { 0 }, err = -1;
+
+	stat = container_of((struct work_struct *)input_work_gyr,
+			    struct asm330lxh_status, input_work_gyr);
+
+	err = asm330lxh_gyr_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get gyroscope data failed.\n");
+	else
+		asm330lxh_gyr_report_values(stat, xyz);
+
+	hrtimer_start(&stat->hr_timer_gyr, stat->ktime_gyr, HRTIMER_MODE_REL);
+}
+
+#ifdef CONFIG_OF
+static int32_t asm330lxh_acc_gyr_parse_dt(struct asm330lxh_status *stat,
+					  struct device *dev)
+{
+	struct device_node *dn;
+	uint8_t i, j;
+	uint32_t val;
+	uint8_t range;
+	short vect[9] = { 0 };
+
+	mutex_lock(&stat->lock);
+	dn = dev->of_node;
+	stat->pdata_main->of_node = dn;
+
+	stat->pdata_main->gpio_int1 = of_get_gpio(dn, 0);
+	if (!gpio_is_valid(stat->pdata_main->gpio_int1)) {
+		dev_err(dev, "INT1 gpio not supported\n");
+		stat->pdata_main->gpio_int1 = ASM330LXH_INT1_GPIO_DEF;
+	}
+
+	stat->pdata_main->gpio_int2 = of_get_gpio(dn, 1);
+	if (!gpio_is_valid(stat->pdata_main->gpio_int2)) {
+		dev_err(dev, "INT2 gpio not supported\n");
+		stat->pdata_main->gpio_int2 = ASM330LXH_INT2_GPIO_DEF;
+	}
+
+	if (of_property_read_u16_array(dn, "rot-matrix", vect,
+				       ARRAY_SIZE(vect)) >= 0) {
+		for (j = 0; j < 3; j++) {
+			for (i = 0; i < 3; i++) {
+				stat->pdata_main->rot_matrix[i][j] =
+				    (short)vect[3 * j + i];
+			}
+		}
+	} else {
+		for (j = 0; j < 3; j++) {
+			for (i = 0; i < 3; i++) {
+				stat->pdata_main->rot_matrix[i][j] =
+				    default_asm330lxh_main_platform_data.rot_matrix[i][j];
+			}
+		}
+	}
+
+	if (!of_property_read_u32(dn, "g-poll-interval-ms", &val))
+		stat->pdata_gyr->poll_interval = MS_TO_US(val);
+	else
+		stat->pdata_gyr->poll_interval = ASM330LXH_GYR_POLL_INTERVAL_DEF;
+
+	if (!of_property_read_u32(dn, "g-min-interval-ms", &val))
+		stat->pdata_gyr->min_interval = MS_TO_US(val);
+	else
+		stat->pdata_gyr->min_interval = ASM330LXH_GYR_MIN_POLL_PERIOD_US;
+
+	if (!of_property_read_u32(dn, "g-fs-range-dps", &val)) {
+		switch (val) {
+		case RANGE_245DPS:
+			range = ASM330LXH_GYR_FS_245DPS;
+			break;
+		case RANGE_500DPS:
+			range = ASM330LXH_GYR_FS_500DPS;
+			break;
+		case RANGE_1000DPS:
+			range = ASM330LXH_GYR_FS_1000DPS;
+			break;
+		case RANGE_2000DPS:
+			range = ASM330LXH_GYR_FS_2000DPS;
+			break;
+		default:
+			range = ASM330LXH_GYR_FS_2000DPS;
+			break;
+		}
+
+		stat->pdata_gyr->fs_range = range;
+	} else
+		stat->pdata_gyr->fs_range = ASM330LXH_GYR_FS_2000DPS;
+
+	if (!of_property_read_u32(dn, "x-poll-interval-ms", &val))
+		stat->pdata_acc->poll_interval =  MS_TO_US(val);
+	else
+		stat->pdata_acc->poll_interval = ASM330LXH_ACC_POLL_INTERVAL_DEF;
+
+	if (!of_property_read_u32(dn, "x-min-interval-ms", &val))
+		stat->pdata_acc->min_interval =  MS_TO_US(val);
+	else
+		stat->pdata_acc->min_interval = ASM330LXH_ACC_MIN_POLL_PERIOD_US;
+
+	if (!of_property_read_u32(dn, "x-fs-range-g", &val)) {
+		switch (val) {
+		case RANGE_2G:
+			range = ASM330LXH_ACC_FS_2G;
+			break;
+		case RANGE_4G:
+			range = ASM330LXH_ACC_FS_4G;
+			break;
+		case RANGE_8G:
+			range = ASM330LXH_ACC_FS_8G;
+			break;
+		case RANGE_16G:
+			range = ASM330LXH_ACC_FS_16G;
+			break;
+		default:
+			range = ASM330LXH_ACC_FS_4G;
+			break;
+		}
+
+		stat->pdata_acc->fs_range = range;
+	} else
+		stat->pdata_acc->fs_range = ASM330LXH_ACC_FS_4G;
+
+	mutex_unlock(&stat->lock);
+
+	return 0;
+}
+#endif
+
+int32_t asm330lxh_common_probe(struct asm330lxh_status *stat)
+{
+	int32_t err = -1;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	if (!asm330lxh_workqueue)
+		asm330lxh_workqueue = create_workqueue("asm330lxh_workqueue");
+
+	hrtimer_init(&stat->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_acc.function = &poll_function_read_acc;
+	hrtimer_init(&stat->hr_timer_gyr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_gyr.function = &poll_function_read_gyr;
+
+	mutex_init(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+
+	stat->pdata_main = kzalloc(sizeof(*stat->pdata_main), GFP_KERNEL);
+	stat->pdata_acc = kzalloc(sizeof(*stat->pdata_acc), GFP_KERNEL);
+	stat->pdata_gyr = kzalloc(sizeof(*stat->pdata_gyr), GFP_KERNEL);
+
+	if ((stat->pdata_main == NULL) || (stat->pdata_acc == NULL)
+	    || (stat->pdata_gyr == NULL)) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "failed to allocate memory for pdata: %d\n",
+			err);
+		goto err_memory_alloc;
+	}
+
+	stat->pdata_main->pdata_acc = stat->pdata_acc;
+	stat->pdata_main->pdata_gyr = stat->pdata_gyr;
+
+#ifdef CONFIG_OF
+	/* Device Tree */
+	asm330lxh_acc_gyr_parse_dt(stat, stat->dev);
+#else
+	/* Board File */
+	if (client->dev.platform_data == NULL) {
+		memcpy(stat->pdata_main, &default_asm330lxh_main_platform_data,
+		       sizeof(*stat->pdata_main));
+		memcpy(stat->pdata_acc, &default_asm330lxh_acc_pdata,
+		       sizeof(*stat->pdata_acc));
+		memcpy(stat->pdata_gyr, &default_asm330lxh_gyr_pdata,
+		       sizeof(*stat->pdata_gyr));
+		dev_info(stat->dev, "using default plaform_data for "
+			 "accelerometer and gyroscope\n");
+	} else {
+		struct asm330lxh_main_platform_data *platform_data;
+		platform_data = client->dev.platform_data;
+
+		if (platform_data == NULL) {
+			memcpy(stat->pdata_main,fv
+			       &default_asm330lxh_main_platform_data,
+			       sizeof(*stat->pdata_main));
+			dev_info(stat->dev,
+				 "using default plaform_data for "
+				 "accelerometer\n");
+		} else {
+			memcpy(stat->pdata_main, platform_data,
+			       sizeof(*stat->pdata_acc));
+		}
+
+		if (platform_data->pdata_acc == NULL) {
+			memcpy(stat->pdata_acc, &default_asm330lxh_acc_pdata,
+			       sizeof(*stat->pdata_acc));
+			dev_info(stat->dev, "using default plaform_data for "
+				 "accelerometer\n");
+		} else {
+			memcpy(stat->pdata_acc, platform_data->pdata_acc,
+			       sizeof(*stat->pdata_acc));
+		}
+
+		if (platform_data->pdata_gyr == NULL) {
+			memcpy(stat->pdata_gyr, &default_asm330lxh_gyr_pdata,
+			       sizeof(*stat->pdata_gyr));
+			dev_info(stat->dev, "using default plaform_data for "
+				 "gyroscope\n");
+		} else {
+			memcpy(stat->pdata_gyr, platform_data->pdata_gyr,
+			       sizeof(*stat->pdata_gyr));
+		}
+	}
+#endif // Board File
+
+	err = asm330lxh_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data for "
+			"accelerometer \n");
+		goto exit_kfree_pdata;
+	}
+
+	err = asm330lxh_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data for "
+			"gyroscope\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata_acc->init) {
+		err = stat->pdata_acc->init();
+		if (err < 0) {
+			dev_err(stat->dev, "accelerometer init failed: "
+				"%d\n", err);
+			goto err_pdata_acc_init;
+		}
+	}
+	if (stat->pdata_gyr->init) {
+		err = stat->pdata_gyr->init();
+		if (err < 0) {
+			dev_err(stat->dev, "gyroscope init failed: "
+				"%d\n", err);
+			goto err_pdata_gyr_init;
+		}
+	}
+
+	err = asm330lxh_acc_gyr_hw_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = asm330lxh_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "accelerometer power on failed: "
+			"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = asm330lxh_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "gyroscope power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = asm330lxh_acc_update_fs_range(stat, stat->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"update accelerometer full scale range failed\n");
+		goto err_power_off_acc;
+	}
+
+	err = asm330lxh_gyr_update_fs_range(stat, stat->pdata_gyr->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"update gyroscope full scale range failed\n");
+		goto err_power_off_gyr;
+	}
+
+	err = asm330lxh_acc_update_odr(stat, stat->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer ODR failed\n");
+		goto err_power_off;
+	}
+
+	err = asm330lxh_gyr_update_odr(stat, stat->pdata_gyr->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update gyroscope ODR failed\n");
+		goto err_power_off;
+	}
+
+	err = asm330lxh_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = asm330lxh_gyr_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "gyroscope input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev, "device %s sysfs register failed\n",
+			ASM330LXH_ACC_GYR_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	asm330lxh_acc_device_power_off(stat);
+	asm330lxh_gyr_device_power_off(stat);
+
+	INIT_WORK(&stat->input_work_acc, poll_function_work_acc);
+	INIT_WORK(&stat->input_work_gyr, poll_function_work_gyr);
+
+	dev_info(stat->dev, "%s: probed\n", ASM330LXH_ACC_GYR_DEV_NAME);
+
+	return 0;
+
+err_input_cleanup:
+	asm330lxh_input_cleanup(stat);
+err_power_off:
+err_power_off_gyr:
+	asm330lxh_gyr_device_power_off(stat);
+err_power_off_acc:
+	asm330lxh_acc_device_power_off(stat);
+err_hw_init:
+err_pdata_init:
+err_pdata_gyr_init:
+	if (stat->pdata_gyr->exit)
+		stat->pdata_gyr->exit();
+err_pdata_acc_init:
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+exit_kfree_pdata:
+	mutex_lock(&stat->lock);
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_gyr);
+	kfree(stat->pdata_main);
+	mutex_unlock(&stat->lock);
+err_memory_alloc:
+	if (!asm330lxh_workqueue) {
+		flush_workqueue(asm330lxh_workqueue);
+		destroy_workqueue(asm330lxh_workqueue);
+	}
+	dev_err(stat->dev, "%s: Driver Init failed\n", ASM330LXH_ACC_GYR_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(asm330lxh_common_probe);
+
+int32_t asm330lxh_common_remove(struct asm330lxh_status *stat)
+{
+	if (atomic_read(&stat->enabled_gyr)) {
+		asm330lxh_gyr_disable(stat);
+		asm330lxh_gyr_input_cleanup(stat);
+
+		if (stat->pdata_gyr->exit)
+			stat->pdata_gyr->exit();
+	}
+
+	asm330lxh_acc_disable(stat);
+	asm330lxh_acc_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+	if (!asm330lxh_workqueue) {
+		flush_workqueue(asm330lxh_workqueue);
+		destroy_workqueue(asm330lxh_workqueue);
+		asm330lxh_workqueue = NULL;
+	}
+
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_gyr);
+	kfree(stat->pdata_main);
+
+	return 0;
+}
+EXPORT_SYMBOL(asm330lxh_common_remove);
+
+#ifdef CONFIG_PM
+int32_t asm330lxh_common_suspend(struct asm330lxh_status *stat)
+{
+	atomic_set(&stat->on_before_suspend, 1);
+	if (atomic_read(&stat->enabled_gyr) > 0)
+		_asm330lxh_gyr_disable(stat);
+
+	if (atomic_read(&stat->enabled_acc) > 0) {
+		_asm330lxh_acc_disable(stat);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(asm330lxh_common_suspend);
+
+int32_t asm330lxh_common_resume(struct asm330lxh_status *stat)
+{
+	if (atomic_read(&stat->enabled_acc) > 0) {
+		_asm330lxh_acc_enable(stat);
+	}
+
+	if (atomic_read(&stat->enabled_gyr) > 0) {
+		_asm330lxh_gyr_enable(stat);
+	}
+	atomic_set(&stat->on_before_suspend, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(asm330lxh_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("asm330lxh driver");
+MODULE_AUTHOR("Giuseppe Barba, Alberto Marinoni, Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/asm330lxh/asm330lxh.h b/drivers/input/misc/st/imu/asm330lxh/asm330lxh.h
--- a/drivers/input/misc/st/imu/asm330lxh/asm330lxh.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/asm330lxh/asm330lxh.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,204 @@
+/******************** (C) COPYRIGHT 2014 STMicroelectronics ******************
+*
+* File Name		: asm330lxh.h
+* Author		: AMS - Motion Mems Division - Application Team
+*			: Giuseppe Barba (giuseppe.barba@st.com)
+*			: Alberto MARINONI (alberto.marinoni@st.com)
+*			: Mario Tesi (mario.tesi@st.com)
+* Version		: V.1.0.1
+* Date			: 2016/Jul/07
+*
+******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*****************************************************************************/
+
+#ifndef	__ASM330LXH_H__
+#define	__ASM330LXH_H__
+
+/* Enable open/close input function
+#define ASM330LXH_EN_ON_OPEN
+*/
+/**********************************************/
+/* 	Acc Gyro section define		      */
+/**********************************************/
+#define ASM330LXH_ACC_GYR_DEV_NAME	"asm330lxh"
+#define ASM330LXH_ACC_DEV_NAME		"asm330lxh_acc"
+#define ASM330LXH_GYR_DEV_NAME		"asm330lxh_gyr"
+
+/** ODR periods in usec */
+#define ASM330LXH_ODR_PERIOD_US_12_5_HZ	80000
+#define ASM330LXH_ODR_PERIOD_US_50_HZ	20000
+#define ASM330LXH_ODR_PERIOD_US_100_HZ	10000
+#define ASM330LXH_ODR_PERIOD_US_200_HZ	5000
+#define ASM330LXH_ODR_PERIOD_US_400_HZ	2500
+#define ASM330LXH_ODR_PERIOD_US_800_HZ	1250
+
+#define ASM330LXH_GYR_MIN_POLL_PERIOD_US	(ASM330LXH_ODR_PERIOD_US_800_HZ)
+#define ASM330LXH_ACC_MIN_POLL_PERIOD_US	(ASM330LXH_ODR_PERIOD_US_800_HZ)
+#define ASM330LXH_GYR_POLL_INTERVAL_DEF	(ASM330LXH_ODR_PERIOD_US_12_5_HZ)
+#define ASM330LXH_ACC_POLL_INTERVAL_DEF	(ASM330LXH_ODR_PERIOD_US_12_5_HZ)
+
+#define ASM330LXH_ACC_ODR_OFF		0x00
+#define ASM330LXH_ACC_ODR_MASK		0xE0
+
+#define ASM330LXH_GYR_ODR_OFF		0x00
+#define ASM330LXH_GYR_ODR_MASK		0xE0
+#define ASM330LXH_GYR_ODR_MASK_SHIFT	5
+#define ASM330LXH_GYR_ODR_001		(1 << ASM330LXH_GYR_ODR_MASK_SHIFT)
+#define ASM330LXH_GYR_ODR_010		(2 << ASM330LXH_GYR_ODR_MASK_SHIFT)
+#define ASM330LXH_GYR_ODR_011		(3 << ASM330LXH_GYR_ODR_MASK_SHIFT)
+#define ASM330LXH_GYR_ODR_100		(4 << ASM330LXH_GYR_ODR_MASK_SHIFT)
+#define ASM330LXH_GYR_ODR_101		(5 << ASM330LXH_GYR_ODR_MASK_SHIFT)
+#define ASM330LXH_GYR_ODR_110		(6 << ASM330LXH_GYR_ODR_MASK_SHIFT)
+
+/* Accelerometer Sensor Full Scale */
+#define ASM330LXH_ACC_FS_MASK		0x18
+#define ASM330LXH_ACC_FS_2G 		0x00	/* Full scale 2g */
+#define ASM330LXH_ACC_FS_4G 		0x10	/* Full scale 4g */
+#define ASM330LXH_ACC_FS_8G 		0x18	/* Full scale 8g */
+#define ASM330LXH_ACC_FS_16G 		0x08	/* Full scale 16g */
+
+#define RANGE_2G			2
+#define RANGE_4G			4
+#define RANGE_8G			8
+#define RANGE_16G			16
+
+#define ASM330LXH_INT1_GPIO_DEF		(-EINVAL)
+#define ASM330LXH_INT2_GPIO_DEF		(-EINVAL)
+
+#define ASM330LXH_GYR_FS_MASK		0x18
+#define ASM330LXH_GYR_FS_245DPS		0x00
+#define ASM330LXH_GYR_FS_500DPS		0x08
+#define ASM330LXH_GYR_FS_1000DPS	0x10
+#define ASM330LXH_GYR_FS_2000DPS	0x18
+
+#define RANGE_245DPS			245
+#define RANGE_500DPS			500
+#define RANGE_1000DPS			1000
+#define RANGE_2000DPS			2000
+
+#define ASM330LXH_GYR_BW_00		0x00
+#define ASM330LXH_GYR_BW_01		0x01
+#define ASM330LXH_GYR_BW_10		0x02
+#define ASM330LXH_GYR_BW_11		0x03
+
+#define ASM330LXH_RX_MAX_LENGTH		500
+#define ASM330LXH_TX_MAX_LENGTH		500
+
+struct asm330lxh_status;
+
+struct asm330lxh_acc_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct asm330lxh_gyr_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct asm330lxh_main_platform_data {
+	int32_t gpio_int1;
+	int32_t gpio_int2;
+	short rot_matrix[3][3];
+	struct asm330lxh_acc_platform_data *pdata_acc;
+	struct asm330lxh_gyr_platform_data *pdata_gyr;
+#ifdef CONFIG_OF
+	struct device_node *of_node;
+#endif
+};
+
+struct asm330lxh_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[ASM330LXH_RX_MAX_LENGTH];
+	u8 tx_buf[ASM330LXH_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct asm330lxh_transfer_function {
+	int (*write)(struct asm330lxh_status *cdata, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct asm330lxh_status *cdata, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct asm330lxh_status {
+	struct asm330lxh_main_platform_data *pdata_main;
+	struct asm330lxh_acc_platform_data *pdata_acc;
+	struct asm330lxh_gyr_platform_data *pdata_gyr;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct work_struct input_work_gyr;
+
+	struct hrtimer hr_timer_acc;
+	ktime_t ktime_acc;
+	struct hrtimer hr_timer_gyr;
+	ktime_t ktime_gyr;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_gyr;
+	struct device *dev;
+
+	u16 bustype;
+	atomic_t enabled_acc;
+	atomic_t enabled_gyr;
+	int32_t irq;
+
+	atomic_t on_before_suspend;
+
+	uint32_t sensitivity_acc;
+	uint32_t sensitivity_gyr;
+
+	s64 acc_ts, gyr_ts;
+
+	/** acc_discard_samples count the number of samples to be discarded
+	 after switching between power-down mode and normal mode */
+	uint8_t acc_discard_samples;
+	uint8_t gyr_discard_samples;
+	uint32_t gyr_current_ODR_interval_us;
+
+	/* Serial BUS */
+	const struct asm330lxh_transfer_function *tf;
+	struct asm330lxh_transfer_buffer tb;
+};
+
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int32_t asm330lxh_common_probe(struct asm330lxh_status *stat);
+int32_t asm330lxh_common_remove(struct asm330lxh_status *stat);
+
+#ifdef CONFIG_PM
+int32_t asm330lxh_common_suspend(struct asm330lxh_status *stat);
+int32_t asm330lxh_common_resume(struct asm330lxh_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __ASM330LXH_H__ */
diff -uNr a/drivers/input/misc/st/imu/asm330lxh/asm330lxh_i2c.c b/drivers/input/misc/st/imu/asm330lxh/asm330lxh_i2c.c
--- a/drivers/input/misc/st/imu/asm330lxh/asm330lxh_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/asm330lxh/asm330lxh_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,170 @@
+/*
+ * STMicroelectronics asm330lxh i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "asm330lxh.h"
+
+static int asm330lxh_i2c_read(struct asm330lxh_status *cdata, u8 reg_addr, int len,
+			      u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	return (err == 2) ? 0 : 1;
+}
+
+static int asm330lxh_i2c_write(struct asm330lxh_status *cdata, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return (err == 1) ? 0 : 1;
+}
+
+static const struct asm330lxh_transfer_function asm330lxh_tf_i2c = {
+	.write = asm330lxh_i2c_write,
+	.read = asm330lxh_i2c_read,
+};
+
+static int asm330lxh_i2c_probe(struct i2c_client *client,
+			       const struct i2c_device_id *id)
+{
+	int err;
+	struct asm330lxh_status *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->irq = client->irq;
+	cdata->tf = &asm330lxh_tf_i2c;
+	cdata->bustype = BUS_I2C;
+	i2c_set_clientdata(client, cdata);
+
+	err = asm330lxh_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int asm330lxh_i2c_remove(struct i2c_client *client)
+{
+	struct asm330lxh_status *cdata = i2c_get_clientdata(client);
+
+	asm330lxh_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", ASM330LXH_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int asm330lxh_suspend(struct device *dev)
+{
+	struct asm330lxh_status *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return asm330lxh_common_suspend(cdata);
+}
+
+static int asm330lxh_resume(struct device *dev)
+{
+	struct asm330lxh_status *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return asm330lxh_common_resume(cdata);
+}
+
+static const struct dev_pm_ops asm330lxh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(asm330lxh_suspend, asm330lxh_resume)
+};
+
+#define ASM330LXH_PM_OPS	(&asm330lxh_pm_ops)
+#else /* CONFIG_PM */
+#define ASM330LXH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id asm330lxh_ids[] = {
+	{ ASM330LXH_ACC_GYR_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, asm330lxh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id asm330lxh_id_table[] = {
+	{ .compatible = "st,asm330lxh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, asm330lxh_id_table);
+#endif
+
+static struct i2c_driver asm330lxh_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = ASM330LXH_ACC_GYR_DEV_NAME,
+		.pm = ASM330LXH_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(asm330lxh_id_table),
+#endif
+	},
+	.probe    = asm330lxh_i2c_probe,
+	.remove   = asm330lxh_i2c_remove,
+	.id_table = asm330lxh_ids,
+};
+
+module_i2c_driver(asm330lxh_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics asm330lxh i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/asm330lxh/asm330lxh_spi.c b/drivers/input/misc/st/imu/asm330lxh/asm330lxh_spi.c
--- a/drivers/input/misc/st/imu/asm330lxh/asm330lxh_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/asm330lxh/asm330lxh_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,190 @@
+/*
+ * STMicroelectronics asm330lxh spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "asm330lxh.h"
+
+#define SENSORS_SPI_READ 0x80
+
+static int asm330lxh_spi_read(struct asm330lxh_status *cdata, u8 reg_addr, int len,
+			      u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (!err)
+		memcpy(data, cdata->tb.rx_buf, len);
+		
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int asm330lxh_spi_write(struct asm330lxh_status *cdata, u8 reg_addr, int len,
+			       u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= ASM330LXH_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static const struct asm330lxh_transfer_function asm330lxh_tf_spi = {
+	.write = asm330lxh_spi_write,
+	.read = asm330lxh_spi_read,
+};
+
+static int asm330lxh_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct asm330lxh_status *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->irq = spi->irq;
+	cdata->tf = &asm330lxh_tf_spi;
+	cdata->bustype = BUS_SPI;
+	spi_set_drvdata(spi, cdata);
+
+	err = asm330lxh_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int asm330lxh_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct asm330lxh_status *cdata = spi_get_drvdata(spi);
+
+	asm330lxh_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", ASM330LXH_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int asm330lxh_suspend(struct device *dev)
+{
+	struct asm330lxh_status *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return asm330lxh_common_suspend(cdata);
+}
+
+static int asm330lxh_resume(struct device *dev)
+{
+	struct asm330lxh_status *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return asm330lxh_common_resume(cdata);
+}
+
+static const struct dev_pm_ops asm330lxh_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(asm330lxh_suspend, asm330lxh_resume)
+};
+
+#define ASM330LXH_PM_OPS	(&asm330lxh_pm_ops)
+#else /* CONFIG_PM */
+#define ASM330LXH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id asm330lxh_ids[] = {
+	{ ASM330LXH_ACC_GYR_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, asm330lxh_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id asm330lxh_id_table[] = {
+	{ .compatible = "st,asm330lxh", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, asm330lxh_id_table);
+#endif
+
+static struct spi_driver asm330lxh_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = ASM330LXH_ACC_GYR_DEV_NAME,
+		.pm = ASM330LXH_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(asm330lxh_id_table),
+#endif
+	},
+	.probe    = asm330lxh_spi_probe,
+	.remove   = asm330lxh_spi_remove,
+	.id_table = asm330lxh_ids,
+};
+
+module_spi_driver(asm330lxh_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics asm330lxh spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/asm330lxh/Kconfig b/drivers/input/misc/st/imu/asm330lxh/Kconfig
--- a/drivers/input/misc/st/imu/asm330lxh/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/asm330lxh/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_ASM330LXH
+	tristate "STMicroelectronics ASM330LXH sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_ASM330LXH_I2C if (I2C)
+	select INPUT_ASM330LXH_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics ASM330LXH sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called asm330lxh.
+
+config INPUT_ASM330LXH_I2C
+	tristate
+	depends on INPUT_ASM330LXH
+	depends on I2C
+
+config INPUT_ASM330LXH_SPI
+	tristate
+	depends on INPUT_ASM330LXH
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/asm330lxh/Makefile b/drivers/input/misc/st/imu/asm330lxh/Makefile
--- a/drivers/input/misc/st/imu/asm330lxh/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/asm330lxh/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for the input misc STM imu asm330lxh driver
+#
+obj-$(CONFIG_INPUT_ASM330LXH) += asm330lxh.o
+obj-$(CONFIG_INPUT_ASM330LXH_I2C) += asm330lxh_i2c.o
+obj-$(CONFIG_INPUT_ASM330LXH_SPI) += asm330lxh_spi.o
diff -uNr a/drivers/input/misc/st/imu/Kconfig b/drivers/input/misc/st/imu/Kconfig
--- a/drivers/input/misc/st/imu/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,18 @@
+
+menuconfig INPUT_IMU
+	tristate "Inertial motion unit"
+
+if INPUT_IMU
+
+source "drivers/input/misc/st/imu/lsm6ds3/Kconfig"
+source "drivers/input/misc/st/imu/lsm6dsm/Kconfig"
+source "drivers/input/misc/st/imu/lsm6dsl/Kconfig"
+source "drivers/input/misc/st/imu/lsm9ds0/Kconfig"
+source "drivers/input/misc/st/imu/lsm9ds1/Kconfig"
+source "drivers/input/misc/st/imu/lsm330dlc/Kconfig"
+source "drivers/input/misc/st/imu/lsm6ds0/Kconfig"
+source "drivers/input/misc/st/imu/lsm6dl0/Kconfig"
+source "drivers/input/misc/st/imu/lsm330/Kconfig"
+source "drivers/input/misc/st/imu/asm330lxh/Kconfig"
+
+endif # INPUT_IMU
diff -uNr a/drivers/input/misc/st/imu/lsm330/Kconfig b/drivers/input/misc/st/imu/lsm330/Kconfig
--- a/drivers/input/misc/st/imu/lsm330/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,21 @@
+
+config INPUT_LSM330
+	tristate "STMicroelectronics LSM330 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM330_I2C if (I2C)
+	select INPUT_LSM330_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM330 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm330.
+
+config INPUT_LSM330_I2C
+	tristate
+	depends on INPUT_LSM330
+	depends on I2C
+
+config INPUT_LSM330_SPI
+	tristate
+	depends on INPUT_LSM330
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330_acc.c b/drivers/input/misc/st/imu/lsm330/lsm330_acc.c
--- a/drivers/input/misc/st/imu/lsm330/lsm330_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330_acc.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,1840 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name		: lsm330_acc.c
+ * Authors		: MSH - Motion Mems BU - Application Team
+ *			: Matteo Dameno (matteo.dameno@st.com)
+ *			: Denis Ciocca (denis.ciocca@st.com)
+ *			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+ *			: Author is willing to be considered the contact
+ *			: and update point for the driver.
+ * Version		: V.1.2.6.1
+ * Date			: 2016/May/24
+ * Description		: LSM330 accelerometer driver
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * THIS SOFTWARE IS SPECIFICALLY DESIGNED FOR EXCLUSIVE USE WITH ST PARTS.
+ *
+ ******************************************************************************
+Version History.
+	V 1.0.0		First Release
+	V 1.0.2		I2C address bugfix
+	V 1.2.0		Registers names compliant to correct datasheet
+	V.1.2.1		Removed enable_interrupt_output sysfs file, manages int1
+			and int2, implements int1 isr.
+	V.1.2.2		Added HR_Timer and custom sysfs path
+	V.1.2.3		Ch state program codes and state prog parameters defines
+	V.1.2.5		Changes create_sysfs_interfaces
+	V.1.2.6		Changes resume and suspend functions
+	V.1.2.6.1	Introduce SignMotion feat implementation and solves
+			acc suspend/resume issue;
+ ******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include "lsm330.h"
+
+//#define LSM330_DEBUG			1
+
+#define LOAD_SM1_PROGRAM	0
+#define LOAD_SM1_PARAMETERS	0
+#define LOAD_SM2_PROGRAM	1
+#define LOAD_SM2_PARAMETERS	1
+
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+/* customized thresholds for significant motion program*/
+#define THRS1_2_02G 0x09
+#define THRS1_2_04G 0x05
+#define THRS1_2_06G 0x03
+#define THRS1_2_08G 0x02
+#define THRS1_2_16G 0x01
+#endif
+
+#define G_MAX			23920640	/* ug */
+#define MS_TO_NS(x)		(x*1000000L)
+
+#define SENSITIVITY_2G		60		/* ug/LSB	*/
+#define SENSITIVITY_4G		120		/* ug/LSB	*/
+#define SENSITIVITY_6G		180		/* ug/LSB	*/
+#define SENSITIVITY_8G		240		/* ug/LSB	*/
+#define SENSITIVITY_16G		730		/* ug/LSB	*/
+
+#define	LSM330_ACC_FS_MASK	(0x38)
+
+/* Output Data Rates ODR */
+#define LSM330_ODR_MASK		(0xF0)
+#define LSM330_PM_OFF		(0x00)		/* OFF */
+#define LSM330_ODR3_125		(0x10)		/*    3.125 Hz */
+#define LSM330_ODR6_25		(0x20)		/*    6.25  Hz */
+#define LSM330_ODR12_5		(0x30)		/*   12.5   Hz */
+#define LSM330_ODR25		(0x40)		/*   25     Hz */
+#define LSM330_ODR50		(0x50)		/*   50     Hz */
+#define LSM330_ODR100		(0x60)		/*  100     Hz */
+#define LSM330_ODR400		(0x70)		/*  400     Hz */
+#define LSM330_ODR800		(0x80)		/*  800     Hz */
+#define LSM330_ODR1600		(0x90)		/* 1600     Hz */
+
+/* Registers configuration Mask and settings */
+/* CTRLREGx */
+#define LSM330_INTEN_MASK		(0x01)
+#define LSM330_INTEN_OFF		(0x00)
+#define LSM330_INTEN_ON			(0x01)
+
+/* CTRLREG1 */
+#define LSM330_HIST1_MASK		(0xE0)
+#define LSM330_SM1INT_PIN_MASK		(0x08)
+#define LSM330_SM1INT_PININT2		(0x08)
+#define LSM330_SM1INT_PININT1		(0x00)
+#define LSM330_SM1_EN_MASK		(0x01)
+#define LSM330_SM1_EN_ON		(0x01)
+#define LSM330_SM1_EN_OFF		(0x00)
+/* */
+
+/* CTRLREG2 */
+#define LSM330_HIST2_MASK		(0xE0)
+#define LSM330_SM2INT_PIN_MASK		(0x08)
+#define LSM330_SM2INT_PININT2		(0x08)
+#define LSM330_SM2INT_PININT1		(0x00)
+#define LSM330_SM2_EN_MASK		(0x01)
+#define LSM330_SM2_EN_ON		(0x01)
+#define LSM330_SM2_EN_OFF		(0x00)
+/* */
+
+/* CTRLREG3 */
+#define LSM330_INT_ACT_MASK		(0x01 << 6)
+#define LSM330_INT_ACT_H		(0x01 << 6)
+#define LSM330_INT_ACT_L		(0x00)
+
+#define LSM330_INT2_EN_MASK		(0x01 << 4)
+#define LSM330_INT2_EN_ON		(0x01 << 4)
+#define LSM330_INT2_EN_OFF		(0x00)
+
+#define LSM330_INT1_EN_MASK		(0x01 << 3)
+#define LSM330_INT1_EN_ON		(0x01 << 3)
+#define LSM330_INT1_EN_OFF		(0x00)
+/* */
+
+/* CTRLREG4 */
+#define LSM330_BDU_EN			(0x08)
+#define LSM330_ALL_AXES			(0x07)
+/* */
+
+/* STATUS REG BITS */
+#define LSM330_STAT_INTSM1_BIT		(0x01 << 3)
+#define LSM330_STAT_INTSM2_BIT		(0x01 << 2)
+
+#define OUT_AXISDATA_REG		LSM330_OUTX_L
+#define WHOAMI_LSM330_ACC		(0x40)	/* Expected content for WAI */
+
+/*	CONTROL REGISTERS	*/
+#define LSM330_WHO_AM_I			(0x0F)	/* WhoAmI register Address */
+
+#define LSM330_OUTX_L			(0x28)	/* Output X LSByte */
+#define LSM330_OUTX_H			(0x29)	/* Output X MSByte */
+#define LSM330_OUTY_L			(0x2A)	/* Output Y LSByte */
+#define LSM330_OUTY_H			(0x2B)	/* Output Y MSByte */
+#define LSM330_OUTZ_L			(0x2C)	/* Output Z LSByte */
+#define LSM330_OUTZ_H			(0x2D)	/* Output Z MSByte */
+#define LSM330_LC_L			(0x16)	/* LSByte Long Counter Status */
+#define LSM330_LC_H			(0x17)	/* MSByte Long Counter Status */
+
+#define LSM330_INTERR_STAT		(0x18)	/* Interrupt Status */
+
+#define LSM330_STATUS_REG		(0x27)	/* Status */
+
+#define LSM330_CTRL_REG1		(0x21)	/* control reg 1 */
+#define LSM330_CTRL_REG2		(0x22)	/* control reg 2 */
+#define LSM330_CTRL_REG3		(0x23)	/* control reg 3 */
+#define LSM330_CTRL_REG4		(0x20)	/* control reg 4 */
+#define LSM330_CTRL_REG5		(0x24)	/* control reg 5 */
+#define LSM330_CTRL_REG6		(0x25)	/* control reg 6 */
+
+#define LSM330_OFF_X			(0x10)	/* Offset X Corr */
+#define LSM330_OFF_Y			(0x11)	/* Offset Y Corr */
+#define LSM330_OFF_Z			(0x12)	/* Offset Z Corr */
+
+#define LSM330_CS_X			(0x13)	/* Const Shift X */
+#define LSM330_CS_Y			(0x14)	/* Const Shift Y */
+#define LSM330_CS_Z			(0x15)	/* Const Shift Z */
+
+#define LSM330_VFC_1			(0x1B)	/* Vect Filter Coeff 1 */
+#define LSM330_VFC_2			(0x1C)	/* Vect Filter Coeff 2 */
+#define LSM330_VFC_3			(0x1D)	/* Vect Filter Coeff 3 */
+#define LSM330_VFC_4			(0x1E)	/* Vect Filter Coeff 4 */
+
+
+	/* state machine 1 program */
+#define LSM330_STATEPR1		(0x40)	/*	State Program 1 16 bytes */
+	/* state machine 1 params */
+#define LSM330_TIM4_1		(0x50)	/*	SPr1 Timer4		*/
+#define LSM330_TIM3_1		(0x51)	/*	SPr1 Timer3		*/
+#define LSM330_TIM2_1		(0x52)	/*	SPr1 Timer2	2bytes	*/
+//
+#define LSM330_TIM1_1		(0x54)	/*	SPr1 Timer1	2bytes	*/
+//
+#define LSM330_THRS2_1		(0x56)	/*	SPr1 Threshold2		*/
+#define LSM330_THRS1_1		(0x57)	/*	SPr1 Threshold1		*/
+#define LSM330_SA_1		(0x59)	/*	SPr1 Swap Axis Sign Msk	*/
+#define LSM330_MA_1		(0x5A)	/*	SPr1 Axis Sign Msk	*/
+#define LSM330_SETT_1		(0x5B)	/*	SPr1 			*/
+#define LSM330_PPRP_1		(0x5C)	/*	SPr1 ProgPointer ResetPointer */
+#define LSM330_TC_1		(0x5D)	/*	SPr1 		2bytes	*/
+#define LSM330_OUTS_1		(0x5F)	/*	SPr1 			*/
+
+	/* state machine 2 program */
+#define LSM330_STATEPR2	(0x60)	/*	State Program 2 16 bytes */
+	/* state machine 2 params */
+#define LSM330_TIM4_2		(0x70)	/*	SPr2 Timer4		*/
+#define LSM330_TIM3_2		(0x71)	/*	SPr2 Timer3		*/
+#define LSM330_TIM2_2		(0x72)	/*	SPr2 Timer2	2bytes	*/
+//
+#define LSM330_TIM1_2		(0x74)	/*	SPr2 Timer1	2bytes	*/
+//
+#define LSM330_THRS2_2		(0x76)	/*	SPr2 Threshold2		*/
+#define LSM330_THRS1_2		(0x77)	/*	SPr2 Threshold1		*/
+#define LSM330_DES_2		(0x78)	/*	SPr2 Decimation		*/
+#define LSM330_SA_2		(0x79)	/*	SPr2 Swap Axis Sign Msk	*/
+#define LSM330_MA_2		(0x7A)	/*	SPr2 Axis Sign Msk	*/
+#define LSM330_SETT_2		(0x7B)	/*	SPr2 			*/
+#define LSM330_PPRP_2		(0x7C)	/*	SPr2 ProgPointer ResetPointer */
+#define LSM330_TC_2		(0x7D)	/*	SPr2 		2bytes	*/
+//
+#define LSM330_OUTS_2		(0x7F)	/*	SPr2 			*/
+/*	end CONTROL REGISTRES	*/
+
+
+/* RESUME STATE INDICES */
+#define RES_LSM330_LC_L				0
+#define RES_LSM330_LC_H				1
+
+#define RES_LSM330_CTRL_REG4			2
+#define RES_LSM330_CTRL_REG1			3
+#define RES_LSM330_CTRL_REG2			4
+#define RES_LSM330_CTRL_REG3			5
+#define RES_LSM330_CTRL_REG5			6
+#define RES_LSM330_CTRL_REG6			7
+
+#define RES_LSM330_OFF_X			8
+#define RES_LSM330_OFF_Y			9
+#define RES_LSM330_OFF_Z			10
+
+#define RES_LSM330_CS_X				11
+#define RES_LSM330_CS_Y				12
+#define RES_LSM330_CS_Z				13
+
+#define RES_LSM330_VFC_1			14
+#define RES_LSM330_VFC_2			15
+#define RES_LSM330_VFC_3			16
+#define RES_LSM330_VFC_4			17
+
+#define RES_LSM330_THRS3			18
+
+#define RES_LSM330_TIM4_1			20
+#define RES_LSM330_TIM3_1			21
+#define RES_LSM330_TIM2_1_L			22
+#define RES_LSM330_TIM2_1_H			23
+#define RES_LSM330_TIM1_1_L			24
+#define RES_LSM330_TIM1_1_H			25
+
+#define RES_LSM330_THRS2_1			26
+#define RES_LSM330_THRS1_1			27
+#define RES_LSM330_SA_1				28
+#define RES_LSM330_MA_1				29
+#define RES_LSM330_SETT_1			30
+
+#define RES_LSM330_TIM4_2			31
+#define RES_LSM330_TIM3_2			32
+#define RES_LSM330_TIM2_2_L			33
+#define RES_LSM330_TIM2_2_H			34
+#define RES_LSM330_TIM1_2_L			35
+#define RES_LSM330_TIM1_2_H			36
+
+#define RES_LSM330_THRS2_2			37
+#define RES_LSM330_THRS1_2			38
+#define RES_LSM330_DES_2			39
+#define RES_LSM330_SA_2				40
+#define RES_LSM330_MA_2				41
+#define RES_LSM330_SETT_2			42
+
+/* end RESUME STATE INDICES */
+
+/* STATE PROGRAMS ENABLE CONTROLS */
+#define LSM330_SM1_DIS_SM2_DIS			(0x00)
+#define LSM330_SM1_EN_SM2_DIS			(0x01)
+#define LSM330_SM1_DIS_SM2_EN			(0x02)
+#define LSM330_SM1_EN_SM2_EN			(0x03)
+
+/* INTERRUPTS ENABLE CONTROLS */
+#define LSM330_INT1_DIS_INT2_DIS		(0x00)
+#define LSM330_INT1_EN_INT2_DIS			(0x01)
+#define LSM330_INT1_DIS_INT2_EN			(0x02)
+#define LSM330_INT1_EN_INT2_EN			(0x03)
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lsm330_acc_odr_table[] = {
+		{    1, LSM330_ODR1600 },
+		{    3, LSM330_ODR400  },
+		{   10, LSM330_ODR100  },
+		{   20, LSM330_ODR50   },
+		{   40, LSM330_ODR25   },
+		{   80, LSM330_ODR12_5 },
+		{  160, LSM330_ODR6_25 },
+		{  320, LSM330_ODR3_125},
+};
+
+static struct lsm330_acc_platform_data default_lsm330_acc_pdata = {
+	.fs_range = LSM330_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 10,
+	.min_interval = LSM330_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LSM330_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LSM330_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int int1_gpio = LSM330_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LSM330_ACC_DEFAULT_INT2_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+module_param(int2_gpio, int, S_IRUGO);
+MODULE_PARM_DESC(int1_gpio, "integer: gpio number being assined to interrupt PIN1");
+MODULE_PARM_DESC(int2_gpio, "integer: gpio number being assined to interrupt PIN2");
+
+/* sets default init values to be written in registers at probe stage */
+static void lsm330_acc_set_init_register_values(struct lsm330_acc_data *acc)
+{
+	acc->resume_state[RES_LSM330_LC_L] = 0x00;
+	acc->resume_state[RES_LSM330_LC_H] = 0x00;
+
+	acc->resume_state[RES_LSM330_CTRL_REG1] = (0x00 | LSM330_SM1INT_PININT1);
+	acc->resume_state[RES_LSM330_CTRL_REG2] = (0x00 | LSM330_SM2INT_PININT1);
+	acc->resume_state[RES_LSM330_CTRL_REG3] = LSM330_INT_ACT_H;
+	if(acc->pdata->gpio_int1 >= 0)
+		acc->resume_state[RES_LSM330_CTRL_REG3] =
+				acc->resume_state[RES_LSM330_CTRL_REG3] | \
+					LSM330_INT1_EN_ON;
+	if(acc->pdata->gpio_int2 >= 0)
+		acc->resume_state[RES_LSM330_CTRL_REG3] =
+				acc->resume_state[RES_LSM330_CTRL_REG3] | \
+					LSM330_INT2_EN_ON;
+
+	acc->resume_state[RES_LSM330_CTRL_REG4] = (LSM330_BDU_EN |
+							LSM330_ALL_AXES);
+	acc->resume_state[RES_LSM330_CTRL_REG5] = 0x00;
+	acc->resume_state[RES_LSM330_CTRL_REG6] = 0x10;
+
+	acc->resume_state[RES_LSM330_THRS3] = 0x00;
+	acc->resume_state[RES_LSM330_OFF_X] = 0x00;
+	acc->resume_state[RES_LSM330_OFF_Y] = 0x00;
+	acc->resume_state[RES_LSM330_OFF_Z] = 0x00;
+
+	acc->resume_state[RES_LSM330_CS_X] = 0x00;
+	acc->resume_state[RES_LSM330_CS_Y] = 0x00;
+	acc->resume_state[RES_LSM330_CS_Z] = 0x00;
+
+	acc->resume_state[RES_LSM330_VFC_1] = 0x00;
+	acc->resume_state[RES_LSM330_VFC_2] = 0x00;
+	acc->resume_state[RES_LSM330_VFC_3] = 0x00;
+	acc->resume_state[RES_LSM330_VFC_4] = 0x00;
+}
+
+static void lsm330_acc_set_init_statepr1_inst(struct lsm330_acc_data *acc)
+{
+/* loads custom state program1 */
+#if LOAD_SM1_PROGRAM > 0
+	acc->resume_stmach_program1[0] = 0x00;
+	acc->resume_stmach_program1[1] = 0x00;
+	acc->resume_stmach_program1[2] = 0x00;
+	acc->resume_stmach_program1[3] = 0x00;
+	acc->resume_stmach_program1[4] = 0x00;
+	acc->resume_stmach_program1[5] = 0x00;
+	acc->resume_stmach_program1[6] = 0x00;
+	acc->resume_stmach_program1[7] = 0x00;
+	acc->resume_stmach_program1[8] = 0x00;
+	acc->resume_stmach_program1[9] = 0x00;
+	acc->resume_stmach_program1[10] = 0x00;
+	acc->resume_stmach_program1[11] = 0x00;
+	acc->resume_stmach_program1[12] = 0x00;
+	acc->resume_stmach_program1[13] = 0x00;
+	acc->resume_stmach_program1[14] = 0x00;
+	acc->resume_stmach_program1[15] = 0x00;
+#else /* loads default state program1 */
+	acc->resume_stmach_program1[0] = 0x00;
+	acc->resume_stmach_program1[1] = 0x00;
+	acc->resume_stmach_program1[2] = 0x00;
+	acc->resume_stmach_program1[3] = 0x00;
+	acc->resume_stmach_program1[4] = 0x00;
+	acc->resume_stmach_program1[5] = 0x00;
+	acc->resume_stmach_program1[6] = 0x00;
+	acc->resume_stmach_program1[7] = 0x00;
+	acc->resume_stmach_program1[8] = 0x00;
+	acc->resume_stmach_program1[9] = 0x00;
+	acc->resume_stmach_program1[10] = 0x00;
+	acc->resume_stmach_program1[11] = 0x00;
+	acc->resume_stmach_program1[12] = 0x00;
+	acc->resume_stmach_program1[13] = 0x00;
+	acc->resume_stmach_program1[14] = 0x00;
+	acc->resume_stmach_program1[15] = 0x00;
+#endif /* LOAD_SM1_PROGRAM */
+}
+
+static void lsm330_acc_set_init_statepr2_inst(struct lsm330_acc_data *acc)
+{
+/* loads custom state program2 */
+#if LOAD_SM2_PROGRAM > 0
+#if ENABLE_SIGNIFICANT_MOTION > 0
+	acc->resume_stmach_program2[0] = 0x05;
+	acc->resume_stmach_program2[1] = 0x03;
+	acc->resume_stmach_program2[2] = 0x04;
+	acc->resume_stmach_program2[3] = 0x45;
+	acc->resume_stmach_program2[4] = 0x00;
+	acc->resume_stmach_program2[5] = 0x00;
+	acc->resume_stmach_program2[6] = 0x00;
+	acc->resume_stmach_program2[7] = 0x00;
+	acc->resume_stmach_program2[8] = 0x00;
+	acc->resume_stmach_program2[9] = 0x00;
+	acc->resume_stmach_program2[10] = 0x00;
+	acc->resume_stmach_program2[11] = 0x00;
+	acc->resume_stmach_program2[12] = 0x00;
+	acc->resume_stmach_program2[13] = 0x00;
+	acc->resume_stmach_program2[14] = 0x00;
+	acc->resume_stmach_program2[15] = 0x00;
+#else
+	acc->resume_stmach_program2[0] = 0x00;
+	acc->resume_stmach_program2[1] = 0x00;
+	acc->resume_stmach_program2[2] = 0x00;
+	acc->resume_stmach_program2[3] = 0x00;
+	acc->resume_stmach_program2[4] = 0x00;
+	acc->resume_stmach_program2[5] = 0x00;
+	acc->resume_stmach_program2[6] = 0x00;
+	acc->resume_stmach_program2[7] = 0x00;
+	acc->resume_stmach_program2[8] = 0x00;
+	acc->resume_stmach_program2[9] = 0x00;
+	acc->resume_stmach_program2[10] = 0x00;
+	acc->resume_stmach_program2[11] = 0x00;
+	acc->resume_stmach_program2[12] = 0x00;
+	acc->resume_stmach_program2[13] = 0x00;
+	acc->resume_stmach_program2[14] = 0x00;
+	acc->resume_stmach_program2[15] = 0x00;
+#endif /* ENABLE_SIGNIFICANT_MOTION */
+#else /* loads default state program2 */
+	acc->resume_stmach_program2[0] = 0x00;
+	acc->resume_stmach_program2[1] = 0x00;
+	acc->resume_stmach_program2[2] = 0x00;
+	acc->resume_stmach_program2[3] = 0x00;
+	acc->resume_stmach_program2[4] = 0x00;
+	acc->resume_stmach_program2[5] = 0x00;
+	acc->resume_stmach_program2[6] = 0x00;
+	acc->resume_stmach_program2[7] = 0x00;
+	acc->resume_stmach_program2[8] = 0x00;
+	acc->resume_stmach_program2[9] = 0x00;
+	acc->resume_stmach_program2[10] = 0x00;
+	acc->resume_stmach_program2[11] = 0x00;
+	acc->resume_stmach_program2[12] = 0x00;
+	acc->resume_stmach_program2[13] = 0x00;
+	acc->resume_stmach_program2[14] = 0x00;
+	acc->resume_stmach_program2[15] = 0x00;
+#endif /* LOAD_SM2_PROGRAM */
+}
+
+static void lsm330_acc_set_init_statepr1_param(struct lsm330_acc_data *acc)
+{
+/* loads custom state prog1 parameters */
+#if LOAD_SM1_PARAMETERS > 0
+	acc->resume_state[RES_LSM330_TIM4_1] = 0x00;
+	acc->resume_state[RES_LSM330_TIM3_1] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_1_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_1_H] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_1_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_1_H] = 0x00;
+	acc->resume_state[RES_LSM330_THRS2_1] = 0x00;
+	acc->resume_state[RES_LSM330_THRS1_1] = 0x00;
+	/* DES1 not available*/
+	acc->resume_state[RES_LSM330_SA_1] = 0x00;
+	acc->resume_state[RES_LSM330_MA_1] = 0x00;
+	acc->resume_state[RES_LSM330_SETT_1] = 0x00;
+#else 	/* loads default state prog1 parameters */
+	acc->resume_state[RES_LSM330_TIM4_1] = 0x00;
+	acc->resume_state[RES_LSM330_TIM3_1] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_1_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_1_H] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_1_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_1_H] = 0x00;
+	acc->resume_state[RES_LSM330_THRS2_1] = 0x00;
+	acc->resume_state[RES_LSM330_THRS1_1] = 0x00;
+	/* DES1 not available*/
+	acc->resume_state[RES_LSM330_SA_1] = 0x00;
+	acc->resume_state[RES_LSM330_MA_1] = 0x00;
+	acc->resume_state[RES_LSM330_SETT_1] = 0x00;
+#endif
+}
+
+static void lsm330_acc_set_init_statepr2_param(struct lsm330_acc_data *acc)
+{
+/* loads custom state prog2 parameters */
+#if LOAD_SM2_PARAMETERS > 0
+#if ENABLE_SIGNIFICANT_MOTION > 0
+	acc->resume_state[RES_LSM330_TIM4_2] = 0x64;
+	acc->resume_state[RES_LSM330_TIM3_2] = 0xC8;
+	acc->resume_state[RES_LSM330_TIM2_2_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_2_H] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_2_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_2_H] = 0x00;
+	acc->resume_state[RES_LSM330_THRS2_2] = 0x00;
+	acc->resume_state[RES_LSM330_THRS1_2] = THRS1_2_02G;
+	acc->resume_state[RES_LSM330_DES_2] = 0x00;
+	acc->resume_state[RES_LSM330_SA_2] = 0xA8;
+	acc->resume_state[RES_LSM330_MA_2] = 0xA8;
+	acc->resume_state[RES_LSM330_SETT_2] = 0x13;
+#else
+	acc->resume_state[RES_LSM330_TIM4_2] = 0x00;
+	acc->resume_state[RES_LSM330_TIM3_2] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_2_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_2_H] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_2_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_2_H] = 0x00;
+	acc->resume_state[RES_LSM330_THRS2_2] = 0x00;
+	acc->resume_state[RES_LSM330_THRS1_2] = 0x00;
+	acc->resume_state[RES_LSM330_DES_2] = 0x00;
+	acc->resume_state[RES_LSM330_SA_2] = 0x00;
+	acc->resume_state[RES_LSM330_MA_2] = 0x00;
+	acc->resume_state[RES_LSM330_SETT_2] = 0x00;
+#endif  /* ENABLE_SIGNIFICANT_MOTION */
+#else	/* loads default state prog2 parameters */
+	acc->resume_state[RES_LSM330_TIM4_2] = 0x00;
+	acc->resume_state[RES_LSM330_TIM3_2] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_2_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM2_2_H] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_2_L] = 0x00;
+	acc->resume_state[RES_LSM330_TIM1_2_H] = 0x00;
+	acc->resume_state[RES_LSM330_THRS2_2] = 0x00;
+	acc->resume_state[RES_LSM330_THRS1_2] = 0x00;
+	acc->resume_state[RES_LSM330_DES_2] = 0x00;
+	acc->resume_state[RES_LSM330_SA_2] = 0x00;
+	acc->resume_state[RES_LSM330_MA_2] = 0x00;
+	acc->resume_state[RES_LSM330_SETT_2] = 0x00;
+#endif
+}
+
+static int lsm330_acc_update(struct lsm330_acc_data *acc,
+			     u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 rdbuf[1];
+	u8 wrbuf[1];
+
+	u8 init_val;
+	u8 updated_val;
+	err = acc->tf->read(acc->dev, reg_address, 1, rdbuf);
+	if (!(err < 0)) {
+		init_val = rdbuf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		wrbuf[0] = updated_val;
+		err = acc->tf->write(acc->dev, reg_address, 1, wrbuf);
+	}
+	return err;
+}
+
+static int lsm330_acc_hw_init(struct lsm330_acc_data *acc)
+{
+	int i;
+	int err = -1;
+	u8 buf[17];
+
+	pr_info("%s: hw init start\n", LSM330_ACC_DEV_NAME);
+
+	err = acc->tf->read(acc->dev, LSM330_WHO_AM_I, 1, buf);
+	if (err < 0) {
+	dev_warn(acc->dev, "Error reading WHO_AM_I: is device "
+		"available/working?\n");
+		goto err_firstread;
+	} else
+		acc->hw_working = 1;
+
+	if (buf[0] != WHOAMI_LSM330_ACC) {
+	dev_err(acc->dev,
+		"device unknown. Expected: 0x%02x,"
+		" Replies: 0x%02x\n", WHOAMI_LSM330_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+
+	buf[0] = acc->resume_state[RES_LSM330_LC_L];
+	buf[1] = acc->resume_state[RES_LSM330_LC_H];
+	err = acc->tf->write(acc->dev, LSM330_LC_L, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LSM330_TIM4_1];
+	buf[1] = acc->resume_state[RES_LSM330_TIM3_1];
+	buf[2] = acc->resume_state[RES_LSM330_TIM2_1_L];
+	buf[3] = acc->resume_state[RES_LSM330_TIM2_1_H];
+	buf[4] = acc->resume_state[RES_LSM330_TIM1_1_L];
+	buf[5] = acc->resume_state[RES_LSM330_TIM1_1_H];
+	buf[6] = acc->resume_state[RES_LSM330_THRS2_1];
+	buf[7] = acc->resume_state[RES_LSM330_THRS1_1];
+	err = acc->tf->write(acc->dev, LSM330_TIM4_1, 8, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LSM330_SA_1];
+	buf[1] = acc->resume_state[RES_LSM330_MA_1];
+	buf[2] = acc->resume_state[RES_LSM330_SETT_1];
+	err = acc->tf->write(acc->dev, LSM330_SA_1, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LSM330_TIM4_2];
+	buf[1] = acc->resume_state[RES_LSM330_TIM3_2];
+	buf[2] = acc->resume_state[RES_LSM330_TIM2_2_L];
+	buf[3] = acc->resume_state[RES_LSM330_TIM2_2_H];
+	buf[4] = acc->resume_state[RES_LSM330_TIM1_2_L];
+	buf[5] = acc->resume_state[RES_LSM330_TIM1_2_H];
+	buf[6] = acc->resume_state[RES_LSM330_THRS2_2];
+	buf[7] = acc->resume_state[RES_LSM330_THRS1_2];
+	buf[8] = acc->resume_state[RES_LSM330_DES_2];
+	buf[9] = acc->resume_state[RES_LSM330_SA_2];
+	buf[10] = acc->resume_state[RES_LSM330_MA_2];
+	buf[11] = acc->resume_state[RES_LSM330_SETT_2];
+	err = acc->tf->write(acc->dev, LSM330_TIM4_2, 12, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	/*	state program 1 */
+	for (i = 0; i < LSM330_STATE_PR_SIZE; i++) {
+		buf[i] = acc->resume_stmach_program1[i];
+		pr_debug("i=%d,sm pr1 buf[%d]=0x%02x\n", i, i, buf[i]);
+	};
+	err = acc->tf->write(acc->dev, LSM330_STATEPR1, LSM330_STATE_PR_SIZE,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	/*	state program 2 */
+	for(i = 0; i < LSM330_STATE_PR_SIZE; i++){
+		buf[i] = acc->resume_stmach_program2[i];
+		pr_debug("i=%d,sm pr2 buf[%d]=0x%02x\n", i, i, buf[i]);
+	};
+	err = acc->tf->write(acc->dev, LSM330_STATEPR2, LSM330_STATE_PR_SIZE,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LSM330_CTRL_REG5];
+	buf[1] = acc->resume_state[RES_LSM330_CTRL_REG6];
+	err = acc->tf->write(acc->dev, LSM330_CTRL_REG5, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LSM330_CTRL_REG1];
+	buf[1] = acc->resume_state[RES_LSM330_CTRL_REG2];
+	buf[2] = acc->resume_state[RES_LSM330_CTRL_REG3];
+	err = acc->tf->write(acc->dev, LSM330_CTRL_REG1, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = acc->resume_state[RES_LSM330_CTRL_REG4];
+	err = acc->tf->write(acc->dev, LSM330_CTRL_REG4, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	acc->hw_initialized = 1;
+	pr_info("%s: hw init done\n", LSM330_ACC_DEV_NAME);
+	return 0;
+
+err_firstread:
+	acc->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	acc->hw_initialized = 0;
+	dev_err(acc->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+			buf[1], err);
+	return err;
+}
+
+static void lsm330_acc_device_power_off(struct lsm330_acc_data *acc)
+{
+	int err;
+
+	err = lsm330_acc_update(acc, LSM330_CTRL_REG4,
+				LSM330_ODR_MASK, LSM330_PM_OFF);
+	if (err < 0)
+		dev_err(acc->dev, "soft power off failed: %d\n", err);
+
+	if (acc->pdata->power_off) {
+		if(acc->pdata->gpio_int1)
+			disable_irq_nosync(acc->irq1);
+		if(acc->pdata->gpio_int2)
+			disable_irq_nosync(acc->irq2);
+		acc->pdata->power_off();
+		acc->hw_initialized = 0;
+	}
+	if (acc->hw_initialized) {
+		if(acc->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(acc->irq2);
+		acc->hw_initialized = 0;
+	}
+}
+
+static int lsm330_acc_device_power_on(struct lsm330_acc_data *acc)
+{
+	int err = -1;
+
+	if (acc->pdata->power_on) {
+		err = acc->pdata->power_on();
+		if (err < 0) {
+			dev_err(acc->dev,
+					"power_on failed: %d\n", err);
+			return err;
+		}
+		if(acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+
+	if (!acc->hw_initialized) {
+		err = lsm330_acc_hw_init(acc);
+		if (acc->hw_working == 1 && err < 0) {
+			lsm330_acc_device_power_off(acc);
+			return err;
+		}
+	}
+
+	if (acc->hw_initialized) {
+		if(acc->pdata->gpio_int1 >= 0)
+			enable_irq(acc->irq1);
+		if(acc->pdata->gpio_int2 >= 0)
+			enable_irq(acc->irq2);
+	}
+	return 0;
+}
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+static void lsm330_acc_signMotion_interrupt_action(struct lsm330_acc_data *status)
+{
+	input_event(status->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_SM, 1);
+	input_sync(status->input_dev);
+	input_event(status->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_SM, 0);
+	input_sync(status->input_dev);
+
+	pr_debug("%s: sign Motion event\n", LSM330_ACC_DEV_NAME);
+	atomic_set(&status->sign_mot_enabled, 0);
+}
+#endif
+
+static irqreturn_t lsm330_acc_isr1(int irq, void *dev)
+{
+	struct lsm330_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+	pr_debug("%s: isr1 queued\n", LSM330_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lsm330_acc_isr2(int irq, void *dev)
+{
+	struct lsm330_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+	pr_debug("%s: isr2 queued\n", LSM330_ACC_DEV_NAME);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm330_acc_irq1_work_func(struct work_struct *work)
+{
+
+	int err = -1;
+	u8 rbuf[2], status;
+	struct lsm330_acc_data *acc;
+
+	acc = container_of(work, struct lsm330_acc_data, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm330_acc_get_int_source(acc); */
+	pr_debug("%s: IRQ1 triggered\n", LSM330_ACC_DEV_NAME);
+	/*  */
+
+	mutex_lock(&acc->lock);
+	err = acc->tf->read(acc->dev, LSM330_INTERR_STAT, 1, rbuf);
+	pr_debug("%s: INTERR_STAT_REG: 0x%02x\n",
+					LSM330_ACC_DEV_NAME, rbuf[0]);
+	status = rbuf[0];
+	if(status & LSM330_STAT_INTSM1_BIT) {
+		pr_debug("%s: SM1 interrupt \n", LSM330_ACC_DEV_NAME);
+
+		/* mandatory to unlatch SM2 interrupt */
+		err = acc->tf->read(acc->dev, LSM330_OUTS_1, 1, rbuf);
+		pr_debug("%s: OUTS_1: 0x%02x\n",
+					LSM330_ACC_DEV_NAME, rbuf[0]);
+
+	}
+	if(status & LSM330_STAT_INTSM2_BIT) {
+		pr_debug("%s: SM2 interrupt \n", LSM330_ACC_DEV_NAME);
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+		lsm330_acc_signMotion_interrupt_action(acc);
+#endif
+		/* mandatory to unlatch SM2 interrupt */
+		err = acc->tf->read(acc->dev, LSM330_OUTS_2, 1, rbuf);
+		pr_debug("%s: OUTS_2: 0x%02x\n",
+					LSM330_ACC_DEV_NAME, rbuf[0]);
+	}
+	pr_debug("%s: IRQ1 served\n", LSM330_ACC_DEV_NAME);
+	mutex_unlock(&acc->lock);
+
+	enable_irq(acc->irq1);
+	pr_debug("%s: IRQ1 re-enabled\n", LSM330_ACC_DEV_NAME);
+}
+
+static void lsm330_acc_irq2_work_func(struct work_struct *work)
+{
+	struct lsm330_acc_data *acc;
+
+	acc = container_of(work, struct lsm330_acc_data, irq2_work);
+	pr_debug("%s: IRQ2 triggered\n", LSM330_ACC_DEV_NAME);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm330_acc_get_stat_source(acc); */
+	/* ; */
+	pr_debug("%s: IRQ2 served\n", LSM330_ACC_DEV_NAME);
+
+	enable_irq(acc->irq2);
+	pr_debug("%s: IRQ2 re-enabled\n", LSM330_ACC_DEV_NAME);
+}
+
+static int lsm330_acc_register_masked_update(struct lsm330_acc_data *acc,
+		u8 reg_address, u8 mask, u8 new_bit_values, int resume_index)
+{
+	u8 config[0];
+	u8 init_val, updated_val;
+	int err;
+	int step = 0;
+
+	err = acc->tf->read(acc->dev, reg_address, 1, config);
+	if (err < 0)
+		goto error;
+	init_val = config[0];
+	acc->resume_state[resume_index] = init_val;
+	step = 1;
+	updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+	config[0] = updated_val;
+	err = acc->tf->write(acc->dev, reg_address, 1, config);
+	if (err < 0)
+		goto error;
+	acc->resume_state[resume_index] = updated_val;
+
+	return err;
+	error:
+		dev_err(acc->dev,
+			"register 0x%02x update failed at step %d, error: %d\n",
+				config[0], step, err);
+	return err;
+}
+
+static int lsm330_acc_update_fs_range(struct lsm330_acc_data *acc,
+								u8 new_fs_range)
+{
+	int err=-1;
+	u16 sensitivity;
+	u8 sigmot_threshold;
+	u8 init_val, updated_val;
+
+	switch (new_fs_range) {
+	case LSM330_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		sigmot_threshold = THRS1_2_02G;
+		break;
+	case LSM330_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		sigmot_threshold = THRS1_2_04G;
+		break;
+	case LSM330_ACC_G_6G:
+		sensitivity = SENSITIVITY_6G;
+		sigmot_threshold = THRS1_2_06G;
+		break;
+	case LSM330_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		sigmot_threshold = THRS1_2_08G;
+		break;
+	case LSM330_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		sigmot_threshold = THRS1_2_16G;
+		break;
+	default:
+		dev_err(acc->dev, "invalid g range requested: %u\n",
+				new_fs_range);
+		return -EINVAL;
+	}
+	/* Updates configuration register 5,
+	* which contains odr range setting if device is enabled,
+	* otherwise updates just RES_CTRL5 for when it will */
+	if (atomic_read(&acc->enabled)) {
+		/* Updates configuration register 1,
+		* which contains g range setting */
+		err = lsm330_acc_register_masked_update(acc, LSM330_CTRL_REG5,
+			LSM330_ACC_FS_MASK, new_fs_range, RES_LSM330_CTRL_REG5);
+		if(err < 0) {
+			dev_err(acc->dev, "update g range failed\n");
+			return err;
+		} else
+			acc->sensitivity = sensitivity;
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+		err = lsm330_acc_register_masked_update(acc, LSM330_THRS1_2,
+			0xFF, sigmot_threshold, RES_LSM330_THRS1_2);
+		if(err < 0)
+			dev_err(acc->dev, "update sign motion theshold"
+								" failed\n");
+		return err;
+#endif
+	} else {
+		init_val = acc->resume_state[RES_LSM330_CTRL_REG5];
+		updated_val = ((LSM330_ACC_FS_MASK & new_fs_range) | ((~LSM330_ACC_FS_MASK) & init_val));
+		acc->resume_state[RES_LSM330_CTRL_REG5] = updated_val;
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+		acc->resume_state[RES_LSM330_THRS1_2] = sigmot_threshold;
+#endif
+		return 0;
+	}
+
+	return err;
+}
+
+
+static int lsm330_acc_update_odr(struct lsm330_acc_data *acc,
+							int poll_interval_ms)
+{
+	int err = -1;
+	int i;
+	u8 new_odr;
+	u8 updated_val;
+	u8 init_val;
+	u8 mask = LSM330_ODR_MASK;
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+	if (poll_interval_ms == 0)
+		poll_interval_ms = 10;
+#endif
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lsm330_acc_odr_table) - 1; i >= 0; i--) {
+		if (lsm330_acc_odr_table[i].cutoff_ms <= poll_interval_ms)
+			break;
+	}
+	new_odr = lsm330_acc_odr_table[i].mask;
+
+	/* Updates configuration register 4,
+	* which contains odr range setting if device is enabled,
+	* otherwise updates just RES_CTRL4 for when it will */
+	if (atomic_read(&acc->enabled)) {
+		err = lsm330_acc_register_masked_update(acc,
+			LSM330_CTRL_REG4, LSM330_ODR_MASK, new_odr,
+							RES_LSM330_CTRL_REG4);
+		if(err < 0){
+			dev_err(acc->dev, "update odr failed\n");
+			return err;
+		}
+		acc->ktime_acc = ktime_set(poll_interval_ms / 1000,
+					MS_TO_NS(poll_interval_ms % 1000));
+	} else {
+		init_val = acc->resume_state[RES_LSM330_CTRL_REG4];
+		updated_val = ((mask & new_odr) | ((~mask) & init_val));
+		acc->resume_state[RES_LSM330_CTRL_REG4] = updated_val;
+		return 0;
+	}
+
+	return err;
+}
+
+
+#ifdef LSM330_DEBUG
+static int lsm330_acc_register_write(struct lsm330_acc_data *acc, u8 *buf,
+		u8 reg_address, u8 new_value)
+{
+	int err = -1;
+
+	mutex_lock(&acc->lock);
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	err = acc->tf->write(acc->dev, reg_address, 1, &new_value);
+	mutex_unlock(&acc->lock);
+	return err;
+}
+
+static int lsm330_acc_register_read(struct lsm330_acc_data *acc, u8 *buf,
+		u8 reg_address)
+{
+
+	int err;
+
+	mutex_lock(&acc->lock);
+	err = acc->tf->read(acc->dev, reg_address, 1, buf);
+	mutex_unlock(&acc->lock);
+
+	return err;
+}
+
+static int lsm330_acc_register_update(struct lsm330_acc_data *acc, u8 *buf,
+		u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+	err = lsm330_acc_register_read(acc, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = lsm330_acc_register_write(acc, buf, reg_address,
+				updated_val);
+	}
+	return err;
+}
+#endif
+
+
+static int lsm330_acc_get_data(struct lsm330_acc_data *acc, int *xyz)
+{
+	int err = -1;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = acc->tf->read(acc->dev, OUT_AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s16) ((acc_data[1] << 8) | acc_data[0]));
+	hw_d[1] = ((s16) ((acc_data[3] << 8) | acc_data[2]));
+	hw_d[2] = ((s16) ((acc_data[5] << 8) | acc_data[4]));
+
+	hw_d[0] = hw_d[0] * acc->sensitivity;
+	hw_d[1] = hw_d[1] * acc->sensitivity;
+	hw_d[2] = hw_d[2] * acc->sensitivity;
+
+
+	xyz[0] = ((acc->pdata->negate_x) ? (-hw_d[acc->pdata->axis_map_x])
+		   : (hw_d[acc->pdata->axis_map_x]));
+	xyz[1] = ((acc->pdata->negate_y) ? (-hw_d[acc->pdata->axis_map_y])
+		   : (hw_d[acc->pdata->axis_map_y]));
+	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
+		   : (hw_d[acc->pdata->axis_map_z]));
+
+	pr_debug("%s read x=%d, y=%d, z=%d\n",
+			LSM330_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+
+	return err;
+}
+
+static void lsm330_acc_report_values(struct lsm330_acc_data *acc,
+					int *xyz)
+{
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(acc->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(acc->input_dev);
+}
+
+static void lsm330_acc_polling_manage(struct lsm330_acc_data *acc)
+{
+	if((acc->enable_polling) & (atomic_read(&acc->enabled))) {
+			hrtimer_start(&acc->hr_timer_acc,
+				acc->ktime_acc, HRTIMER_MODE_REL);
+	} else
+		hrtimer_cancel(&acc->hr_timer_acc);
+}
+
+int lsm330_acc_enable(struct lsm330_acc_data *acc)
+{
+	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&acc->lock);
+		err = lsm330_acc_device_power_on(acc);
+		if (err < 0) {
+			atomic_set(&acc->enabled, 0);
+			mutex_unlock(&acc->lock);
+			return err;
+		}
+		mutex_unlock(&acc->lock);
+		lsm330_acc_polling_manage(acc);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330_acc_enable);
+
+int lsm330_acc_disable(struct lsm330_acc_data *acc)
+{
+	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
+		cancel_work_sync(&acc->input_work_acc);
+		lsm330_acc_polling_manage(acc);
+
+		mutex_lock(&acc->lock);
+		lsm330_acc_device_power_off(acc);
+		mutex_unlock(&acc->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330_acc_disable);
+
+static ssize_t attr_get_enable_polling(struct device *dev,
+					struct device_attribute *attr,
+								char *buf)
+{
+	int val;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	mutex_lock(&acc->lock);
+	val = acc->enable_polling;
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_polling(struct device *dev,
+				struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	if (enable)
+		acc->enable_polling = 1;
+	else
+		acc->enable_polling = 0;
+	mutex_unlock(&acc->lock);
+	lsm330_acc_polling_manage(acc);
+	return size;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+					struct device_attribute *attr,
+								char *buf)
+{
+	int val;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	mutex_lock(&acc->lock);
+	val = acc->pdata->poll_interval;
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+					struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	err = lsm330_acc_update_odr(acc, interval_ms);
+	if(err >= 0)
+	{
+		acc->pdata->poll_interval = interval_ms;
+	}
+	mutex_unlock(&acc->lock);
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	u8 val;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	int range = 2;
+	mutex_lock(&acc->lock);
+	val = acc->pdata->fs_range ;
+	switch(val) {
+	case LSM330_ACC_G_2G:
+		range = 2;
+		break;
+	case LSM330_ACC_G_4G:
+		range = 4;
+		break;
+	case LSM330_ACC_G_6G:
+		range = 6;
+		break;
+	case LSM330_ACC_G_8G:
+		range = 8;
+		break;
+	case LSM330_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&acc->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *dev,
+				struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch(val) {
+		case 2:
+			range = LSM330_ACC_G_2G;
+			break;
+		case 4:
+			range = LSM330_ACC_G_4G;
+			break;
+		case 6:
+			range = LSM330_ACC_G_6G;
+			break;
+		case 8:
+			range = LSM330_ACC_G_8G;
+			break;
+		case 16:
+			range = LSM330_ACC_G_16G;
+			break;
+		default:
+			return -1;
+	}
+
+	mutex_lock(&acc->lock);
+	err = lsm330_acc_update_fs_range(acc, range);
+	if(err >= 0)
+	{
+		acc->pdata->fs_range = range;
+	}
+	mutex_unlock(&acc->lock);
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	int val = atomic_read(&acc->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+				struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm330_acc_enable(acc);
+	else
+		lsm330_acc_disable(acc);
+
+	return size;
+}
+
+static int lsm330_acc_state_progrs_enable_control(
+				struct lsm330_acc_data *acc, u8 settings)
+{
+	u8 val1, val2;
+	int err = -1;
+	settings = settings & 0x03;
+
+	switch ( settings ) {
+	case LSM330_SM1_DIS_SM2_DIS:
+		val1 = LSM330_SM1_EN_OFF;
+		val2 = LSM330_SM2_EN_OFF;
+		break;
+	case LSM330_SM1_DIS_SM2_EN:
+		val1 = LSM330_SM1_EN_OFF;
+		val2 = LSM330_SM2_EN_ON;
+		break;
+	case LSM330_SM1_EN_SM2_DIS:
+		val1 = LSM330_SM1_EN_ON;
+		val2 = LSM330_SM2_EN_OFF;
+		break;
+	case LSM330_SM1_EN_SM2_EN:
+		val1 = LSM330_SM1_EN_ON;
+		val2 = LSM330_SM2_EN_ON;
+		break;
+	default :
+		pr_err("invalid state program setting : 0x%02x\n",settings);
+		return err;
+	}
+	err = lsm330_acc_register_masked_update(acc,
+		LSM330_CTRL_REG1, LSM330_SM1_EN_MASK, val1,
+							RES_LSM330_CTRL_REG1);
+	if (err < 0 )
+		return err;
+
+	err = lsm330_acc_register_masked_update(acc,
+		LSM330_CTRL_REG2, LSM330_SM2_EN_MASK, val2,
+							RES_LSM330_CTRL_REG2);
+	if (err < 0 )
+			return err;
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+	if (val2 == LSM330_SM2_EN_ON)
+		atomic_set(&acc->sign_mot_enabled, 1);
+#endif
+
+	pr_debug("state program setting : 0x%02x\n", settings);
+
+
+	return err;
+}
+
+static ssize_t attr_set_enable_state_prog(struct device *dev,
+		struct device_attribute *attr,	const char *buf, size_t size)
+{
+	int err = -1;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	long val=0;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+
+	if ( val < 0x00 || val > LSM330_SM1_EN_SM2_EN){
+		pr_warn("invalid state program setting, val: %ld\n",val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&acc->lock);
+	err = lsm330_acc_state_progrs_enable_control(acc, val);
+	mutex_unlock(&acc->lock);
+	if (err < 0)
+		return err;
+	return size;
+}
+
+static ssize_t attr_get_enable_state_prog(struct device *dev,
+		struct device_attribute *attr,	char *buf)
+{
+	int err;
+	u8 val, val1 = 0, val2 = 0, config[2];
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+
+	mutex_lock(&acc->lock);
+	err = acc->tf->read(acc->dev, LSM330_CTRL_REG1, 1, config);
+	if (err < 0) {
+		mutex_unlock(&acc->lock);
+		return err;
+	}
+	val1 = (config[0] & LSM330_SM1_EN_MASK);
+
+	err = acc->tf->read(acc->dev, LSM330_CTRL_REG2, 1, config);
+	val2 = ((config[0] & LSM330_SM2_EN_MASK) << 1);
+
+	val = (val1 | val2);
+	mutex_unlock(&acc->lock);
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+
+#ifdef LSM330_DEBUG
+/* PAY ATTENTION: These LSM330_DEBUG funtions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	u8 x[1];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	x[0] = val;
+	rc = acc->tf->write(acc->dev, acc->reg_addr, 1, x);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t ret;
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&acc->lock);
+	rc = acc->tf->read(acc->dev, acc->reg_addr, 1, &data);
+	mutex_unlock(&acc->lock);
+
+	/*TODO: error need to be managed */
+	ret = sprintf(buf, "0x%02x\n", data);
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm330_acc_data *acc = dev_get_drvdata(dev);
+	unsigned long val;
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&acc->lock);
+	acc->reg_addr = val;
+	mutex_unlock(&acc->lock);
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate,
+							attr_set_polling_rate),
+	__ATTR(range, 0666, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0666, attr_get_enable, attr_set_enable),
+	__ATTR(enable_polling, 0666, attr_get_enable_polling, attr_set_enable_polling),
+	__ATTR(enable_state_prog, 0666, attr_get_enable_state_prog,
+						attr_set_enable_state_prog),
+#ifdef LSM330_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct lsm330_acc_data *acc)
+{
+	int i;
+
+#ifdef CUSTOM_SYSFS_PATH
+	acc->acc_class = class_create(THIS_MODULE, CUSTOM_SYSFS_CLASS_NAME_ACC);
+	if (acc->acc_class == NULL)
+		goto custom_class_error;
+
+	acc->acc_dev = device_create(acc->acc_class, NULL, 0, "%s", "acc");
+	if (acc->acc_dev == NULL)
+		goto custom_class_error;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(acc->acc_dev, attributes + i))
+			goto error;
+#else
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(acc->dev, attributes + i))
+			goto error;
+#endif
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+#ifdef CUSTOM_SYSFS_PATH
+		device_remove_file(acc->acc_dev, attributes + i);
+#else
+		device_remove_file(acc->dev, attributes + i);
+#endif
+
+#ifdef CUSTOM_SYSFS_PATH
+custom_class_error:
+#endif
+	dev_err(acc->dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static int lsm330_acc_validate_pdata(struct lsm330_acc_data *acc)
+{
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
+			acc->pdata->min_interval);
+
+	if (acc->pdata->axis_map_x > 2 ||
+		acc->pdata->axis_map_y > 2 ||
+		 acc->pdata->axis_map_z > 2) {
+		dev_err(acc->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", acc->pdata->axis_map_x,
+				acc->pdata->axis_map_y, acc->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (acc->pdata->negate_x > 1 || acc->pdata->negate_y > 1
+			|| acc->pdata->negate_z > 1) {
+		dev_err(acc->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", acc->pdata->negate_x,
+				acc->pdata->negate_y, acc->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
+		dev_err(acc->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lsm330_acc_input_init(struct lsm330_acc_data *acc)
+{
+	int err;
+
+	acc->input_dev = input_allocate_device();
+	if (!acc->input_dev) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "input device allocation failed\n");
+		goto err0;
+	}
+
+	acc->input_dev->name = LSM330_ACC_DEV_NAME;
+	acc->input_dev->id.bustype = acc->bus_type;
+	acc->input_dev->dev.parent = acc->dev;
+
+	input_set_drvdata(acc->input_dev, acc);
+
+	set_bit(INPUT_EVENT_TYPE, acc->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, acc->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, acc->input_dev->mscbit);
+
+	/*	next is used for interruptB sources data if the case */
+#if ENABLE_SIGNIFICANT_MOTION > 0
+	set_bit(INPUT_EVENT_SM, acc->input_dev->mscbit);
+#endif
+
+	err = input_register_device(acc->input_dev);
+	if (err) {
+		dev_err(acc->dev, "unable to register input device %s\n",
+			acc->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(acc->input_dev);
+err0:
+	return err;
+}
+
+static void lsm330_acc_input_cleanup(struct lsm330_acc_data *acc)
+{
+	input_unregister_device(acc->input_dev);
+	input_free_device(acc->input_dev);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct lsm330_acc_data *acc;
+	int xyz[3] = { 0 };
+	int err;
+
+	acc = container_of((struct work_struct *)input_work_acc,
+					struct lsm330_acc_data, input_work_acc);
+
+	mutex_lock(&acc->lock);
+	err = lsm330_acc_get_data(acc, xyz);
+	if (err < 0)
+		dev_err(acc->dev, "get_accelerometer_data failed\n");
+	else
+		lsm330_acc_report_values(acc, xyz);
+
+	mutex_unlock(&acc->lock);
+
+	lsm330_acc_polling_manage(acc);
+}
+
+static enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct lsm330_acc_data *acc;
+
+	acc = container_of((struct hrtimer *)timer,
+					struct lsm330_acc_data, hr_timer_acc);
+
+	queue_work(acc->acc_workqueue, &acc->input_work_acc);
+	return HRTIMER_NORESTART;
+}
+
+int lsm330_acc_probe(struct lsm330_acc_data *acc)
+{
+	int err = -1;
+
+	mutex_lock(&acc->lock);
+
+	acc->pdata = kmalloc(sizeof(*acc->pdata), GFP_KERNEL);
+	if (acc->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(acc->dev, "failed to allocate memory for pdata: %d\n",
+			err);
+		goto err_mutexunlock;
+	}
+
+	if(acc->dev->platform_data == NULL) {
+		default_lsm330_acc_pdata.gpio_int1 = int1_gpio;
+		default_lsm330_acc_pdata.gpio_int2 = int2_gpio;
+		memcpy(acc->pdata, &default_lsm330_acc_pdata,
+							sizeof(*acc->pdata));
+		dev_info(acc->dev, "using default platform_data\n");
+	} else {
+		memcpy(acc->pdata, acc->dev->platform_data,
+		       sizeof(*acc->pdata));
+	}
+
+	err = lsm330_acc_validate_pdata(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (acc->pdata->init) {
+		err = acc->pdata->init();
+		if (err < 0) {
+			dev_err(acc->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if(acc->pdata->gpio_int1 >= 0){
+		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d "
+							"mapped on gpio:%d\n",
+			LSM330_ACC_DEV_NAME, __func__, acc->irq1,
+							acc->pdata->gpio_int1);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d "
+							"mapped on gpio:%d\n",
+			LSM330_ACC_DEV_NAME, __func__, acc->irq2,
+							acc->pdata->gpio_int2);
+	}
+
+	/* resume state init config */
+	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
+	lsm330_acc_set_init_register_values(acc);
+	//init state program1 and params
+	lsm330_acc_set_init_statepr1_param(acc);
+	lsm330_acc_set_init_statepr1_inst(acc);
+	//init state program2  and params
+	lsm330_acc_set_init_statepr2_param(acc);
+	lsm330_acc_set_init_statepr2_inst(acc);
+
+	err = lsm330_acc_device_power_on(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	acc->enable_polling = 1;
+	atomic_set(&acc->enabled, 1);
+
+	err = lsm330_acc_update_fs_range(acc, acc->pdata->fs_range);
+	if (err < 0) {
+		dev_err(acc->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm330_acc_update_odr(acc, acc->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(acc->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm330_acc_input_init(acc);
+	if (err < 0) {
+		dev_err(acc->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+
+	err = create_sysfs_interfaces(acc);
+	if (err < 0) {
+		dev_err(acc->dev,
+		   "device LSM330_ACC_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+#ifdef CUSTOM_SYSFS_PATH
+	dev_set_drvdata(acc->acc_dev, acc);
+#endif
+	lsm330_acc_device_power_off(acc);
+
+	/* As default, do not report information */
+	atomic_set(&acc->enabled, 0);
+
+#if ENABLE_SIGNIFICANT_MOTION > 0
+	atomic_set(&acc->sign_mot_enabled, 0);
+#endif
+	if(acc->pdata->gpio_int1 >= 0){
+		INIT_WORK(&acc->irq1_work, lsm330_acc_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("lsm330_acc_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(acc->irq1, lsm330_acc_isr1,
+				IRQF_TRIGGER_RISING, "lsm330_acc_irq1", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(acc->irq1);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		INIT_WORK(&acc->irq2_work, lsm330_acc_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("lsm330_acc_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(acc->dev,
+					"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, lsm330_acc_isr2,
+				IRQF_TRIGGER_RISING, "lsm330_acc_irq2", acc);
+		if (err < 0) {
+			dev_err(acc->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(acc->irq2);
+	}
+
+	acc->acc_workqueue = create_workqueue("lsm330_workqueue");
+	if (!acc->acc_workqueue)
+		goto err_destoyworkqueue2;
+
+	hrtimer_init(&acc->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	acc->hr_timer_acc.function = &poll_function_read_acc;
+	INIT_WORK(&acc->input_work_acc, poll_function_work_acc);
+
+	mutex_unlock(&acc->lock);
+
+	dev_info(acc->dev, "%s: probed\n", LSM330_ACC_DEV_NAME);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if(acc->pdata->gpio_int2 >= 0)
+		destroy_workqueue(acc->irq2_work_queue);
+err_free_irq1:
+	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if(acc->pdata->gpio_int1 >= 0)
+		destroy_workqueue(acc->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(acc->dev);
+err_input_cleanup:
+	lsm330_acc_input_cleanup(acc);
+err_power_off:
+	lsm330_acc_device_power_off(acc);
+err_pdata_init:
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+exit_kfree_pdata:
+	kfree(acc->pdata);
+err_mutexunlock:
+	mutex_unlock(&acc->lock);
+	if(acc->acc_workqueue) {
+		destroy_workqueue(acc->acc_workqueue);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(lsm330_acc_probe);
+
+int lsm330_acc_remove(struct lsm330_acc_data *acc)
+{
+	if(acc->pdata->gpio_int1 >= 0){
+		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
+
+	if(acc->pdata->gpio_int2 >= 0){
+		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
+
+	lsm330_acc_device_power_off(acc);
+	lsm330_acc_input_cleanup(acc);
+	remove_sysfs_interfaces(acc->dev);
+
+	if (acc->pdata->exit)
+		acc->pdata->exit();
+
+	if(acc->acc_workqueue) {
+		destroy_workqueue(acc->acc_workqueue);
+	}
+
+	kfree(acc->pdata);
+	kfree(acc);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330_acc_remove);
+
+MODULE_DESCRIPTION("lsm330 accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330_acc_i2c.c b/drivers/input/misc/st/imu/lsm330/lsm330_acc_i2c.c
--- a/drivers/input/misc/st/imu/lsm330/lsm330_acc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330_acc_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,195 @@
+/*
+ * STMicroelectronics lsm330_acc_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm330.h"
+#define I2C_RETRY_DELAY		5
+#define I2C_RETRIES		5
+
+/* XXX: caller must hold acc->lock */
+static int lsm330_acc_i2c_read(struct device *dev, u8 addr,
+			       int len, u8 *data)
+{
+	int i = 0, err;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags & I2C_M_TEN;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = (client->flags & I2C_M_TEN) | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while (err != 2 && ++i < I2C_RETRIES);
+
+	return (err != 2) ? -EIO : 0;
+}
+
+/* XXX: caller must hold acc->lock */
+static int lsm330_acc_i2c_write(struct device *dev, u8 addr,
+				int len, u8 *data)
+{
+	int i = 0, err;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while (err != 1 && ++i < I2C_RETRIES);
+
+	return (err != 1) ? -EIO : 0;
+}
+
+static struct lsm330_transfer_function lsm330_acc_i2c_tf = {
+	.write = lsm330_acc_i2c_write,
+	.read = lsm330_acc_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330_acc_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330_acc_data *acc = i2c_get_clientdata(client);
+
+	return lsm330_acc_enable(acc);
+}
+
+static int lsm330_acc_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330_acc_data *acc = i2c_get_clientdata(client);
+
+	return lsm330_acc_disable(acc);
+}
+
+static const struct dev_pm_ops lsm330_acc_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330_acc_i2c_suspend,
+				lsm330_acc_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330_acc_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm330_acc_data *acc;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	acc = kzalloc(sizeof(struct lsm330_acc_data), GFP_KERNEL);
+	if (!acc) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	acc->dev = &client->dev;
+	acc->name = client->name;
+	acc->bus_type = BUS_I2C;
+	acc->tf = &lsm330_acc_i2c_tf;
+
+	i2c_set_clientdata(client, acc);
+
+	mutex_init(&acc->lock);
+
+	err = lsm330_acc_probe(acc);
+	if (err < 0) {
+		kfree(acc);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lsm330_acc_data *acc = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(acc->dev, "driver removing\n");
+#endif
+
+	lsm330_acc_remove(acc);
+	kfree(acc);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm330_acc_i2c_id[] = {
+	{ "lsm330_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm330_acc_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330_acc_i2c_id_table[] = {
+	{ .compatible = "st,lsm330_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330_acc_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm330_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330_acc_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm330_acc_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330_acc_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330_acc_i2c_probe,
+	.remove = lsm330_acc_i2c_remove,
+	.id_table = lsm330_acc_i2c_id,
+};
+
+module_i2c_driver(lsm330_acc_i2c_driver);
+
+MODULE_DESCRIPTION("lsm330 acc i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330_acc_spi.c b/drivers/input/misc/st/imu/lsm330/lsm330_acc_spi.c
--- a/drivers/input/misc/st/imu/lsm330/lsm330_acc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330_acc_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,192 @@
+/*
+ * STMicroelectronics lsm330_acc_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm330.h"
+
+#define SENSORS_SPI_READ	0x80
+
+/* XXX: caller must hold stat->lock */
+static int lsm330_acc_spi_read(struct device *device, u8 addr,
+			       int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_acc_data *acc = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = acc->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = acc->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	acc->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, acc->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold stat->lock */
+static int lsm330_acc_spi_write(struct device *device, u8 addr,
+				     int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_acc_data *acc = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = acc->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM330_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	acc->tb.tx_buf[0] = addr;
+
+	memcpy(&acc->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm330_transfer_function lsm330_acc_spi_tf = {
+	.write = lsm330_acc_spi_write,
+	.read = lsm330_acc_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330_acc_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_acc_data *acc = spi_get_drvdata(spi);
+
+	return lsm330_acc_enable(acc);
+}
+
+static int lsm330_acc_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_acc_data *acc = spi_get_drvdata(spi);
+
+	return lsm330_acc_disable(acc);
+}
+
+static const struct dev_pm_ops lsm330_acc_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330_acc_spi_suspend,
+				lsm330_acc_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm330_acc_data *acc;
+
+#ifdef LSM330_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	acc = kzalloc(sizeof(struct lsm330_acc_data), GFP_KERNEL);
+	if (!acc) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	acc->name = spi->modalias;
+	acc->bus_type = BUS_SPI;
+	acc->tf = &lsm330_acc_spi_tf;
+	acc->dev = &spi->dev;
+	spi_set_drvdata(spi, acc);
+
+	mutex_init(&acc->lock);
+
+	err = lsm330_acc_probe(acc);
+	if (err < 0) {
+		kfree(acc);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330_acc_spi_remove(struct spi_device *spi)
+{
+	struct lsm330_acc_data *acc = spi_get_drvdata(spi);
+
+#ifdef LSM330_DEBUG
+	dev_info(acc->dev, "driver removing\n");
+#endif
+
+	lsm330_acc_remove(acc);
+	kfree(acc);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm330_acc_spi_id[] = {
+	{ "lsm330_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm330_acc_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330_acc_spi_id_table[] = {
+	{ .compatible = "st,lsm330_acc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330_acc_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm330_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330_acc_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm330_acc_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330_acc_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330_acc_spi_probe,
+	.remove = lsm330_acc_spi_remove,
+	.id_table = lsm330_acc_spi_id,
+};
+
+module_spi_driver(lsm330_acc_spi_driver);
+
+MODULE_DESCRIPTION("lsm330 acc-mag spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330_gyr.c b/drivers/input/misc/st/imu/lsm330/lsm330_gyr.c
--- a/drivers/input/misc/st/imu/lsm330/lsm330_gyr.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330_gyr.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,1496 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lsm330_gyr.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Lorenzo Bianocni (lorenzo.bianconi@st.com)
+*			: Authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2.6.1
+* Date			: 2016/May/24
+* Description		: LSM330 gyroscope driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca	  | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+* 1.2.2		| 2012/Dec/18	| Denis Ciocca	  | custom sysfs path
+* 1.2.3		| 2013/Jan/28	| Matteo Dameno	  | corrects remove and
+*		|		|		  | poll_function_work
+* 1.2.5		| 2013/Mar/04	| Matteo Dameno	  | Ch. create_sysfs_interfaces
+* 1.2.6		| 2013/Apr/09	| Denis Ciocca	  | Changes resume and suspend
+* 		|		|		  |  functions
+* 1.2.6.1	| 2013/Oct/03	| Matteo Dameno	  | Add SignMotion feat implem.
+* 		|		|		  | solve acc susp/resume issue;
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/stat.h>
+
+#include "lsm330.h" 
+/* Maximum polled-device-reported rot speed value value in dps */
+#define MS_TO_NS(x)			(x*1000000L)
+
+/* lsm330 gyroscope registers */
+#define WHO_AM_I	(0x0F)
+
+#define SENSITIVITY_250			8750		/*	udps/LSB */
+#define SENSITIVITY_500			17500		/*	udps/LSB */
+#define SENSITIVITY_2000		70000		/*	udps/LSB */
+
+#define CTRL_REG1	(0x20)    /* CTRL REG1 */
+#define CTRL_REG2	(0x21)    /* CTRL REG2 */
+#define CTRL_REG3	(0x22)    /* CTRL_REG3 */
+#define CTRL_REG4	(0x23)    /* CTRL_REG4 */
+#define CTRL_REG5	(0x24)    /* CTRL_REG5 */
+#define	REFERENCE	(0x25)    /* REFERENCE REG */
+#define	FIFO_CTRL_REG	(0x2E)    /* FIFO CONTROL REGISTER */
+#define FIFO_SRC_REG	(0x2F)    /* FIFO SOURCE REGISTER */
+#define	OUT_X_L		(0x28)    /* 1st AXIS OUT REG of 6 */
+
+#define AXISDATA_REG	OUT_X_L
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	(0x00)
+#define PM_OFF		(0x00)
+#define PM_NORMAL	(0x08)
+#define ENABLE_ALL_AXES	(0x07)
+#define ENABLE_NO_AXES	(0x00)
+#define BW00		(0x00)
+#define BW01		(0x10)
+#define BW10		(0x20)
+#define BW11		(0x30)
+#define ODR095		(0x00)  /* ODR =  95Hz */
+#define ODR190		(0x40)  /* ODR = 190Hz */
+#define ODR380		(0x80)  /* ODR = 380Hz */
+#define ODR760		(0xC0)  /* ODR = 760Hz */
+
+/* CTRL_REG3 bits */
+#define	I2_DRDY		(0x08)
+#define	I2_WTM		(0x04)
+#define	I2_OVRUN	(0x02)
+#define	I2_EMPTY	(0x01)
+#define	I2_NONE		(0x00)
+#define	I2_MASK		(0x0F)
+
+/* CTRL_REG4 bits */
+#define	FS_MASK		(0x30)
+#define	BDU_ENABLE	(0x80)
+
+/* CTRL_REG5 bits */
+#define	FIFO_ENABLE	(0x40)
+#define HPF_ENALBE	(0x11)
+
+/* FIFO_CTRL_REG bits */
+#define	FIFO_MODE_MASK		(0xE0)
+#define	FIFO_MODE_BYPASS	(0x00)
+#define	FIFO_MODE_FIFO		(0x20)
+#define	FIFO_MODE_STREAM	(0x40)
+#define	FIFO_MODE_STR2FIFO	(0x60)
+#define	FIFO_MODE_BYPASS2STR	(0x80)
+#define	FIFO_WATERMARK_MASK	(0x1F)
+
+#define FIFO_STORED_DATA_MASK	(0x1F)
+
+#define I2C_AUTO_INCREMENT	(0x80)
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_FIFO_CTRL_REG	5
+
+
+/* #define LSM330_DEBUG 1 */
+
+/** Registers Contents */
+#define WHOAMI_LSM330_GYR	(0xD4)  /* Expected content for WAI register*/
+
+
+
+static int int1_gpio = LSM330_GYR_DEFAULT_INT1_GPIO;
+static int int2_gpio = LSM330_GYR_DEFAULT_INT2_GPIO;
+/* module_param(int1_gpio, int, S_IRUGO); */
+module_param(int2_gpio, int, S_IRUGO);
+
+/*
+ * LSM330 gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * s32
+ */
+
+struct lsm330_gyr_triple {
+	s32	x,	/* x-axis angular rate data. */
+		y,	/* y-axis angluar rate data. */
+		z;	/* z-axis angular rate data. */
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+
+	{	2,	ODR760|BW10},
+	{	3,	ODR380|BW01},
+	{	6,	ODR190|BW00},
+	{	11,	ODR095|BW00},
+};
+
+static struct lsm330_gyr_platform_data default_lsm330_gyr_pdata = {
+	.fs_range = LSM330_GYR_FS_250DPS,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+
+	.poll_interval = 100,
+	.min_interval = LSM330_GYR_MIN_POLL_PERIOD_MS, /* 2ms */
+
+	.gpio_int1 = LSM330_GYR_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LSM330_GYR_DEFAULT_INT2_GPIO,	/* int for fifo */
+
+};
+
+static int lsm330_gyr_register_write(struct lsm330_gyr_status *stat,
+		u8 *buf, u8 reg_address, u8 new_value)
+{
+	return stat->tf->write(stat->dev, reg_address, 1, &new_value);
+}
+
+static int lsm330_gyr_register_read(struct lsm330_gyr_status *stat,
+							u8 *buf, u8 reg_address)
+{
+	return stat->tf->read(stat->dev, reg_address, 1, buf);
+}
+
+static int lsm330_gyr_register_update(struct lsm330_gyr_status *stat,
+			u8 *buf, u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err = -1;
+	u8 init_val;
+	u8 updated_val;
+
+	err = lsm330_gyr_register_read(stat, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = lsm330_gyr_register_write(stat, buf, reg_address,
+				updated_val);
+	}
+
+	return err;
+}
+
+
+static int lsm330_gyr_update_watermark(struct lsm330_gyr_status *stat,
+								u8 watermark)
+{
+	int res = 0;
+	u8 buf[2];
+	u8 new_value;
+
+	mutex_lock(&stat->lock);
+	new_value = (watermark % 0x20);
+	res = lsm330_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+			 FIFO_WATERMARK_MASK, new_value);
+	if (res < 0) {
+		dev_err(stat->dev, "failed to update watermark\n");
+		return res;
+	}
+	dev_dbg(stat->dev, "%s new_value:0x%02x,watermark:0x%02x\n",
+						__func__, new_value, watermark);
+
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_WATERMARK_MASK & new_value) |
+		(~FIFO_WATERMARK_MASK &
+				stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->watermark = new_value;
+	mutex_unlock(&stat->lock);
+	return res;
+}
+
+static int lsm330_gyr_update_fifomode(struct lsm330_gyr_status *stat,
+								u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	u8 new_value;
+
+	new_value = fifomode;
+	res = lsm330_gyr_register_update(stat, buf, FIFO_CTRL_REG,
+					FIFO_MODE_MASK, new_value);
+	if (res < 0) {
+		dev_err(stat->dev, "failed to update fifoMode\n");
+		return res;
+	}
+	/*
+	dev_dbg(stat->dev, "new_value:0x%02x,prev fifomode:0x%02x\n",
+				__func__, new_value, stat->fifomode);
+	 */
+	stat->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_MODE_MASK & new_value) |
+		(~FIFO_MODE_MASK &
+				stat->resume_state[RES_FIFO_CTRL_REG]));
+	stat->fifomode = new_value;
+
+	return res;
+}
+
+static int lsm330_gyr_fifo_reset(struct lsm330_gyr_status *stat)
+{
+	u8 oldmode;
+	int res;
+
+	oldmode = stat->fifomode;
+	res = lsm330_gyr_update_fifomode(stat, FIFO_MODE_BYPASS);
+	if (res < 0)
+		return res;
+	res = lsm330_gyr_update_fifomode(stat, oldmode);
+	if (res >= 0)
+		dev_dbg(stat->dev, "%s fifo reset to: 0x%02x\n",
+							__func__, oldmode);
+
+	return res;
+}
+
+static int lsm330_gyr_fifo_hwenable(struct lsm330_gyr_status *stat,
+								u8 enable)
+{
+	int res;
+	u8 buf[2];
+	u8 set = 0x00;
+	if (enable)
+		set = FIFO_ENABLE;
+
+	res = lsm330_gyr_register_update(stat, buf, CTRL_REG5,
+			FIFO_ENABLE, set);
+	if (res < 0) {
+		dev_err(stat->dev, "fifo_hw switch to:0x%02x failed\n",
+									set);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG5] =
+		((FIFO_ENABLE & set) |
+		(~FIFO_ENABLE & stat->resume_state[RES_CTRL_REG5]));
+	dev_dbg(stat->dev, "%s set to:0x%02x\n", __func__, set);
+	return res;
+}
+
+static int lsm330_gyr_manage_int2settings(struct lsm330_gyr_status *stat,
+								u8 fifomode)
+{
+	int res;
+	u8 buf[2];
+	bool enable_fifo_hw;
+	bool recognized_mode = false;
+	u8 int2bits = I2_NONE;
+/*
+	if (stat->polling_enabled) {
+		fifomode = FIFO_MODE_BYPASS;
+		dbg_warn(stat->dev, "in polling mode, fifo mode forced"
+							" to BYPASS mode\n");
+	}
+*/
+
+
+	switch (fifomode) {
+	case FIFO_MODE_FIFO:
+		recognized_mode = true;
+
+		if (stat->polling_enabled) {
+			int2bits = I2_NONE;
+			enable_fifo_hw = false;
+		} else {
+			int2bits = (I2_WTM | I2_OVRUN);
+			enable_fifo_hw = true;
+		}
+		res = lsm330_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update "
+							"CTRL_REG3:0x%02x\n",
+							__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~(I2_MASK) & stat->resume_state[RES_CTRL_REG3]));
+		/* enable_fifo_hw = true; */
+		break;
+
+	case FIFO_MODE_BYPASS:
+		recognized_mode = true;
+
+		if (stat->polling_enabled)
+			int2bits = I2_NONE;
+		else
+			int2bits = I2_DRDY;
+
+		res = lsm330_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update"
+						" to CTRL_REG3:0x%02x\n",
+							__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		enable_fifo_hw = false;
+		break;
+
+	default:
+		recognized_mode = false;
+		res = lsm330_gyr_register_update(stat, buf, CTRL_REG3,
+					I2_MASK, I2_NONE);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to update "
+						"CTRL_REG3:0x%02x\n",
+						__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		enable_fifo_hw = false;
+		stat->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & 0x00) |
+			(~I2_MASK & stat->resume_state[RES_CTRL_REG3]));
+		break;
+
+	}
+	if (recognized_mode) {
+		res = lsm330_gyr_update_fifomode(stat, fifomode);
+		if (res < 0) {
+			dev_err(stat->dev, "%s : failed to "
+						"set fifoMode\n", __func__);
+			goto err_mutex_unlock;
+		}
+	}
+	res = lsm330_gyr_fifo_hwenable(stat, enable_fifo_hw);
+
+err_mutex_unlock:
+
+	return res;
+}
+
+
+static int lsm330_gyr_update_fs_range(struct lsm330_gyr_status *stat,
+							u8 new_fs)
+{
+	int res ;
+	u8 buf[2];
+
+	u32 sensitivity;
+
+	switch(new_fs) {
+		case LSM330_GYR_FS_250DPS:
+			sensitivity = SENSITIVITY_250;
+			break;
+		case LSM330_GYR_FS_500DPS:
+			sensitivity = SENSITIVITY_500;
+			break;
+		case LSM330_GYR_FS_2000DPS:
+			sensitivity = SENSITIVITY_2000;
+			break;
+		default:
+			dev_err(stat->dev, "invalid g range "
+						"requested: %u\n", new_fs);
+			return -EINVAL;
+	}
+
+
+	buf[0] = CTRL_REG4;
+
+	res = lsm330_gyr_register_update(stat, buf, CTRL_REG4,
+							FS_MASK, new_fs);
+
+	if (res < 0) {
+		dev_err(stat->dev, "%s : failed to update fs:0x%02x\n",
+							__func__, new_fs);
+		return res;
+	}
+	stat->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs) |
+		(~FS_MASK & stat->resume_state[RES_CTRL_REG4]));
+
+	stat->sensitivity = sensitivity;
+	return res;
+}
+
+
+static int lsm330_gyr_update_odr(struct lsm330_gyr_status *stat,
+			unsigned int poll_interval_ms)
+{
+	int err = 0;
+	int i;
+	u8 config[1];
+
+	for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+		if ((odr_table[i].poll_rate_ms <= poll_interval_ms) || (i == 0))
+			break;
+	}
+
+	config[0] = odr_table[i].mask;
+	config[0] |= (ENABLE_ALL_AXES + PM_NORMAL);
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&stat->enabled)) {
+		err = stat->tf->write(stat->dev, CTRL_REG1, 1, config);
+		if (err < 0)
+			return err;
+	}
+	stat->resume_state[RES_CTRL_REG1] = config[0];
+
+	return err;
+}
+
+/* gyroscope data readout */
+static int lsm330_gyr_get_data(struct lsm330_gyr_status *stat,
+			     struct lsm330_gyr_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s32 hw_d[3] = { 0 };
+
+	err = stat->tf->read(stat->dev, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s32) ((s16)((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s32) ((s16)((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s32) ((s16)((gyro_out[5]) << 8) | gyro_out[4]);
+
+	//hw_d[0] = hw_d[0] * stat->sensitivity;
+	//hw_d[1] = hw_d[1] * stat->sensitivity;
+	//hw_d[2] = hw_d[2] * stat->sensitivity;
+
+	data->x = ((stat->pdata->negate_x) ? (-hw_d[stat->pdata->axis_map_x])
+		   : (hw_d[stat->pdata->axis_map_x]));
+	data->y = ((stat->pdata->negate_y) ? (-hw_d[stat->pdata->axis_map_y])
+		   : (hw_d[stat->pdata->axis_map_y]));
+	data->z = ((stat->pdata->negate_z) ? (-hw_d[stat->pdata->axis_map_z])
+		   : (hw_d[stat->pdata->axis_map_z]));
+
+#ifdef LSM330_DEBUG
+	/* dev_dbg(stat->dev, "gyro_out: x = %d, y = %d, z = %d\n",
+		data->x, data->y, data->z); */
+#endif
+
+	return err;
+}
+
+static void lsm330_gyr_report_values(struct lsm330_gyr_status *stat,
+					struct lsm330_gyr_triple *data)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, data->x);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, data->y);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, data->z);
+	input_sync(stat->input_dev);
+}
+
+
+static int lsm330_gyr_check_whoami(struct lsm330_gyr_status *stat)
+{
+	u8 whoami;
+	int err;
+
+	err = stat->tf->read(stat->dev, WHO_AM_I, 1, &whoami);
+	if (err < 0) {
+		dev_err(stat->dev, "error reading whoami register\n");
+		return err;
+	}
+
+	if (whoami != WHOAMI_LSM330_GYR) {
+		dev_err(stat->dev, "wrong whoami %02x-%02x\n",
+			whoami, WHOAMI_LSM330_GYR);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int lsm330_gyr_hw_init(struct lsm330_gyr_status *stat)
+{
+	int err;
+	u8 buf[5];
+
+	dev_info(stat->dev, "hw init\n");
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	buf[1] = stat->resume_state[RES_CTRL_REG2];
+	buf[2] = stat->resume_state[RES_CTRL_REG3];
+	buf[3] = stat->resume_state[RES_CTRL_REG4];
+	buf[4] = stat->resume_state[RES_CTRL_REG5];
+
+	err = stat->tf->write(stat->dev, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	buf[0] = stat->resume_state[RES_FIFO_CTRL_REG];
+	err = stat->tf->write(stat->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+			return err;
+
+	stat->hw_initialized = 1;
+
+	return err;
+}
+
+static void lsm330_gyr_device_power_off(struct lsm330_gyr_status *stat)
+{
+	int err;
+	u8 buf[1];
+
+	dev_info(stat->dev, "power off\n");
+
+	buf[0] = PM_OFF;
+	err = stat->tf->write(stat->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed\n");
+
+	if (stat->pdata->power_off) {
+		/* disable_irq_nosync(acc->irq1); */
+		disable_irq_nosync(stat->irq2);
+		stat->pdata->power_off();
+		stat->hw_initialized = 0;
+	}
+
+	if (stat->hw_initialized) {
+		/*
+		if (stat->pdata->gpio_int1 >= 0) {
+			disable_irq_nosync(stat->irq1);
+			dev_info(stat->dev,
+					"power off: irq1 disabled\n");
+		}
+		*/
+		if (stat->pdata->gpio_int2 >= 0) {
+			disable_irq_nosync(stat->irq2);
+			dev_info(stat->dev,
+					"power off: irq2 disabled\n");
+		}
+		stat->hw_initialized = 0;
+	}
+}
+
+static int lsm330_gyr_device_power_on(struct lsm330_gyr_status *stat)
+{
+	int err;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0)
+			return err;
+		if (stat->pdata->gpio_int2 >= 0)
+			enable_irq(stat->irq2);
+	}
+
+
+	if (!stat->hw_initialized) {
+		err = lsm330_gyr_hw_init(stat);
+		if (err < 0) {
+			lsm330_gyr_device_power_off(stat);
+			return err;
+		}
+	}
+
+	if (stat->hw_initialized) {
+		/* if (stat->pdata->gpio_int1) {
+			enable_irq(stat->irq1);
+			dev_info(stat->dev,
+						"power on: irq1 enabled\n");
+		} */
+		dev_dbg(stat->dev, "stat->pdata->gpio_int2 = %d\n",
+						stat->pdata->gpio_int2);
+		if (stat->pdata->gpio_int2 >= 0) {
+			enable_irq(stat->irq2);
+			dev_info(stat->dev,
+					"power on: irq2 enabled\n");
+		}
+	}
+
+	return 0;
+}
+
+int lsm330_gyr_enable(struct lsm330_gyr_status *stat)
+{
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&stat->lock);
+		err = lsm330_gyr_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			mutex_unlock(&stat->lock);
+			return err;
+		}
+
+		if (stat->polling_enabled) {
+			stat->ktime = ktime_set(stat->pdata->poll_interval / 1000,
+					MS_TO_NS(stat->pdata->poll_interval % 1000));
+			hrtimer_start(&stat->hr_timer, stat->ktime, HRTIMER_MODE_REL);
+		}
+		mutex_unlock(&stat->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330_gyr_enable);
+
+int lsm330_gyr_disable(struct lsm330_gyr_status *stat)
+{
+	dev_dbg(stat->dev, "%s: stat->enabled = %d\n", __func__,
+						atomic_read(&stat->enabled));
+
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+
+		mutex_lock(&stat->lock);
+		lsm330_gyr_device_power_off(stat);
+		mutex_unlock(&stat->lock);
+
+		hrtimer_cancel(&stat->hr_timer);
+		dev_dbg(stat->dev, "%s: cancel_hrtimer ", __func__);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lsm330_gyr_disable);
+
+static ssize_t attr_polling_rate_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int err;
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	err = lsm330_gyr_update_odr(stat, interval_ms);
+	if(err >= 0) {
+		stat->pdata->poll_interval = interval_ms;
+		stat->ktime = ktime_set(stat->pdata->poll_interval / 1000,
+				MS_TO_NS(stat->pdata->poll_interval % 1000));
+	}
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	int range = 0;
+	u8 val;
+	mutex_lock(&stat->lock);
+	val = stat->pdata->fs_range;
+
+	switch (val) {
+	case LSM330_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case LSM330_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case LSM330_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&stat->lock);
+	/* return sprintf(buf, "0x%02x\n", val); */
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 250:
+		range = LSM330_GYR_FS_250DPS;
+		break;
+	case 500:
+		range = LSM330_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = LSM330_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(stat->dev, "invalid range request: %lu,"
+				" discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&stat->lock);
+	err = lsm330_gyr_update_fs_range(stat, range);
+	if (err >= 0)
+		stat->pdata->fs_range = range;
+	mutex_unlock(&stat->lock);
+	dev_info(stat->dev, "range set to: %lu dps\n", val);
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm330_gyr_enable(stat);
+	else
+		lsm330_gyr_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_polling_mode_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int val = 0;
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	if (stat->polling_enabled)
+		val = 1;
+	mutex_unlock(&stat->lock);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_mode_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	if (val) {
+		stat->polling_enabled = true;
+		lsm330_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_info(dev, "polling mode enabled\n");
+		if (atomic_read(&stat->enabled)) {
+			hrtimer_start(&(stat->hr_timer), stat->ktime, HRTIMER_MODE_REL);
+		}
+	} else {
+		if (stat->polling_enabled) {
+			hrtimer_cancel(&stat->hr_timer);
+		}
+		stat->polling_enabled = false;
+		lsm330_gyr_manage_int2settings(stat, stat->fifomode);
+		dev_info(dev, "polling mode disabled\n");
+	}
+	mutex_unlock(&stat->lock);
+	return size;
+}
+
+static ssize_t attr_watermark_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long watermark;
+	int res;
+
+	if (strict_strtoul(buf, 16, &watermark))
+		return -EINVAL;
+
+	res = lsm330_gyr_update_watermark(stat, watermark);
+	if (res < 0)
+		return res;
+
+	return size;
+}
+
+static ssize_t attr_watermark_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	int val = stat->watermark;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_fifomode_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long fifomode;
+	int res;
+
+	if (strict_strtoul(buf, 16, &fifomode))
+		return -EINVAL;
+	/* if (!fifomode)
+		return -EINVAL; */
+
+	dev_dbg(dev, "%s, got value:0x%02x\n", __func__, (u8)fifomode);
+
+	mutex_lock(&stat->lock);
+	res = lsm330_gyr_manage_int2settings(stat, (u8) fifomode);
+	mutex_unlock(&stat->lock);
+
+	if (res < 0)
+		return res;
+	return size;
+}
+
+static ssize_t attr_fifomode_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	u8 val = stat->fifomode;
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+
+
+#ifdef LSM330_DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int rc;
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	u8 x[1];
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&stat->lock);
+	x[0] = val;
+	err = stat->tf->write(stat->dev, stat->reg_addr, 1, x);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	ssize_t ret;
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 data;
+
+	mutex_lock(&stat->lock);
+	err = stat->tf->read(stat->dev, stat->reg_addr, 1, &data);
+	mutex_unlock(&stat->lock);
+
+	ret = sprintf(buf, "0x%02x\n", data);
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm330_gyr_status *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+
+	stat->reg_addr = val;
+
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif /* LSM330_DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_polling_rate_show,
+						attr_polling_rate_store),
+	__ATTR(range, 0666, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0666, attr_enable_show, attr_enable_store),
+	__ATTR(enable_polling, 0666, attr_polling_mode_show,
+						attr_polling_mode_store),
+	__ATTR(fifo_samples, 0666, attr_watermark_show, attr_watermark_store),
+	__ATTR(fifo_mode, 0666, attr_fifomode_show, attr_fifomode_store),
+
+#ifdef LSM330_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct lsm330_gyr_status *gyr)
+{
+	int i;
+
+#ifdef CUSTOM_SYSFS_PATH
+	gyr->gyr_class = class_create(THIS_MODULE, CUSTOM_SYSFS_CLASS_NAME_GYR);
+	if (gyr->gyr_class == NULL)
+		goto custom_class_error;
+
+	gyr->gyr_dev = device_create(gyr->gyr_class, NULL, 0, "%s", "gyr");
+	if (gyr->gyr_dev == NULL)
+		goto custom_class_error;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(gyr->gyr_dev, attributes + i))
+			goto error;
+#else
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(gyr->dev, attributes + i))
+			goto error;
+#endif
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+#ifdef CUSTOM_SYSFS_PATH
+		device_remove_file(gyr->gyr_dev, attributes + i);
+#else
+		device_remove_file(gyr->dev, attributes + i);
+#endif
+
+#ifdef CUSTOM_SYSFS_PATH
+custom_class_error:
+#endif
+	dev_err(gyr->dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void lsm330_gyr_report_triple(struct lsm330_gyr_status *stat)
+{
+	int err;
+	struct lsm330_gyr_triple data_out;
+
+	err = lsm330_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(stat->dev, "get_gyroscope_data failed\n");
+	else
+		lsm330_gyr_report_values(stat, &data_out);
+}
+
+
+static void lsm330_gyr_irq2_fifo(struct lsm330_gyr_status *stat)
+{
+	int err;
+	u8 buf[2];
+	u8 int_source;
+	u8 samples;
+	u8 workingmode;
+	u8 stored_samples;
+
+	mutex_lock(&stat->lock);
+
+	workingmode = stat->fifomode;
+
+
+	dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+								workingmode);
+
+
+	switch (workingmode) {
+	case FIFO_MODE_BYPASS:
+	{
+		dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+							stat->fifomode);
+		lsm330_gyr_report_triple(stat);
+		break;
+	}
+	case FIFO_MODE_FIFO:
+		samples = (stat->watermark)+1;
+		dev_dbg(stat->dev,
+			"%s : FIFO_SRC_REG init samples:%d\n",
+							__func__, samples);
+		err = lsm330_gyr_register_read(stat, buf, FIFO_SRC_REG);
+		if (err < 0)
+			dev_err(stat->dev,
+					"error reading fifo source reg\n");
+
+		int_source = buf[0];
+		dev_dbg(stat->dev, "%s :FIFO_SRC_REG content:0x%02x\n",
+							__func__, int_source);
+
+		stored_samples = int_source & FIFO_STORED_DATA_MASK;
+		dev_dbg(stat->dev, "%s : fifomode:0x%02x\n", __func__,
+						stat->fifomode);
+
+		dev_dbg(stat->dev, "%s : samples:%d stored:%d\n",
+				__func__, samples, stored_samples);
+
+		for (; samples > 0; samples--) {
+#ifdef LSM330_DEBUG
+			input_event(stat->input_dev, INPUT_EVENT_TYPE,
+				    INPUT_EVENT_SM, 1);
+			input_sync(stat->input_dev);
+#endif
+			dev_dbg(stat->dev, "%s : current sample:%d\n",
+							__func__, samples);
+
+			lsm330_gyr_report_triple(stat);
+
+#ifdef LSM330_DEBUG
+			input_event(stat->input_dev, INPUT_EVENT_TYPE,
+				    INPUT_EVENT_SM, 0);
+			input_sync(stat->input_dev);
+#endif
+		}
+		lsm330_gyr_fifo_reset(stat);
+		break;
+	}
+#ifdef LSM330_DEBUG
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_SM, 3);
+	input_sync(stat->input_dev);
+#endif
+
+	mutex_unlock(&stat->lock);
+}
+
+static irqreturn_t lsm330_gyr_isr2(int irq, void *dev)
+{
+	struct lsm330_gyr_status *stat = dev;
+
+	disable_irq_nosync(irq);
+#ifdef LSM330_DEBUG
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_SM, 2);
+	input_sync(stat->input_dev->input);
+#endif
+	queue_work(stat->irq2_work_queue, &stat->irq2_work);
+	pr_debug("%s %s: isr2 queued\n", LSM330_GYR_DEV_NAME, __func__);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm330_gyr_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm330_gyr_status *stat =
+		container_of(work, struct lsm330_gyr_status, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm330_gyr_irq2_XXX(stat); */
+	lsm330_gyr_irq2_fifo(stat);
+	/*  */
+	pr_debug("%s %s: IRQ2 served\n", LSM330_GYR_DEV_NAME, __func__);
+/* exit: */
+	enable_irq(stat->irq2);
+}
+
+static int lsm330_gyr_validate_pdata(struct lsm330_gyr_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval =
+		max((unsigned int) LSM330_GYR_MIN_POLL_PERIOD_MS,
+						stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+			stat->pdata->min_interval);
+
+	if (stat->pdata->axis_map_x > 2 ||
+	    stat->pdata->axis_map_y > 2 ||
+	    stat->pdata->axis_map_z > 2) {
+		dev_err(stat->dev,
+			"invalid axis_map value x:%u y:%u z%u\n",
+			stat->pdata->axis_map_x,
+			stat->pdata->axis_map_y,
+			stat->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (stat->pdata->negate_x > 1 ||
+	    stat->pdata->negate_y > 1 ||
+	    stat->pdata->negate_z > 1) {
+		dev_err(stat->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			stat->pdata->negate_x,
+			stat->pdata->negate_y,
+			stat->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int lsm330_gyr_input_init(struct lsm330_gyr_status *stat)
+{
+	int err = -1;
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"input device allocation failed\n");
+		goto err0;
+	}
+
+	stat->input_dev->name = LSM330_GYR_DEV_NAME;
+	stat->input_dev->id.bustype = stat->bus_type;
+	stat->input_dev->dev.parent = stat->dev;
+
+	input_set_drvdata(stat->input_dev, stat);
+
+	set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, stat->input_dev->mscbit);
+
+	/*	next is used for interruptB sources data if the case */
+#ifdef LSM330_DEBUG
+	set_bit(INPUT_EVENT_SM, stat->input_dev->mscbit);
+#endif
+
+#ifdef LSM330_DEBUG
+	set_bit(INPUT_EVENT_SM, stat->input_dev->mscbit);
+#endif
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	input_free_device(stat->input_dev);
+err0:
+	return err;
+}
+
+static void lsm330_gyr_input_cleanup(struct lsm330_gyr_status *stat)
+{
+	input_unregister_device(stat->input_dev);
+	input_free_device(stat->input_dev);
+}
+
+static void poll_function_work(struct work_struct *polling_task)
+{
+	struct lsm330_gyr_status *stat;
+	struct lsm330_gyr_triple data_out;
+	int err;
+
+	stat = container_of((struct work_struct *)polling_task,
+					struct lsm330_gyr_status, polling_task);
+
+	mutex_lock(&stat->lock);
+	err = lsm330_gyr_get_data(stat, &data_out);
+	if (err < 0)
+		dev_err(stat->dev, "get_rotation_data failed.\n");
+	else
+		lsm330_gyr_report_values(stat, &data_out);
+
+	if (atomic_read(&stat->enabled))
+		hrtimer_start(&stat->hr_timer, stat->ktime, HRTIMER_MODE_REL);
+	mutex_unlock(&stat->lock);
+}
+
+static enum hrtimer_restart poll_function_read(struct hrtimer *timer)
+{
+	struct lsm330_gyr_status *stat;
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm330_gyr_status, hr_timer);
+
+	queue_work(stat->gyr_workqueue, &stat->polling_task);
+	return HRTIMER_NORESTART;
+}
+
+int lsm330_gyr_probe(struct lsm330_gyr_status *stat)
+{
+	int err;
+
+	mutex_lock(&stat->lock);
+
+	err = lsm330_gyr_check_whoami(stat);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+	stat->pdata = kmalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err1;
+	}
+
+	if (stat->dev->platform_data == NULL) {
+		default_lsm330_gyr_pdata.gpio_int1 = int1_gpio;
+		default_lsm330_gyr_pdata.gpio_int2 = int2_gpio;
+		memcpy(stat->pdata, &default_lsm330_gyr_pdata,
+							sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default plaform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = lsm330_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	stat->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES |
+					    PM_NORMAL;
+	stat->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	stat->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	stat->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	stat->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+
+	stat->polling_enabled = true;
+	dev_info(stat->dev, "polling mode enabled\n");
+
+	err = lsm330_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lsm330_gyr_update_fs_range(stat, stat->pdata->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = lsm330_gyr_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = lsm330_gyr_input_init(stat);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(stat);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"%s device register failed\n", LSM330_GYR_DEV_NAME);
+		goto err4;
+	}
+
+#ifdef CUSTOM_SYSFS_PATH
+	dev_set_drvdata(stat->gyr_dev, stat);
+#endif
+
+	lsm330_gyr_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	if (stat->pdata->gpio_int2 >= 0) {
+		stat->irq2 = gpio_to_irq(stat->pdata->gpio_int2);
+		dev_info(stat->dev, "%s: %s has set irq2 to irq:"
+						" %d mapped on gpio:%d\n",
+			LSM330_GYR_DEV_NAME, __func__, stat->irq2,
+							stat->pdata->gpio_int2);
+
+		INIT_WORK(&stat->irq2_work, lsm330_gyr_irq2_work_func);
+		stat->irq2_work_queue =
+			create_singlethread_workqueue("lsm330_gyr_irq2_wq");
+		if (!stat->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(stat->dev, "cannot create "
+						"work queue2: %d\n", err);
+			goto err5;
+		}
+
+		err = request_irq(stat->irq2, lsm330_gyr_isr2,
+				IRQF_TRIGGER_HIGH, "lsm330_gyr_irq2", stat);
+
+		if (err < 0) {
+			dev_err(stat->dev, "request irq2 failed: %d\n", err);
+			goto err6;
+		}
+		disable_irq_nosync(stat->irq2);
+	}
+
+	stat->gyr_workqueue = create_workqueue("lsm330_gyr_workqueue");
+	if (!stat->gyr_workqueue)
+		goto err6;
+
+	hrtimer_init(&stat->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer.function = &poll_function_read;
+
+	mutex_unlock(&stat->lock);
+
+	INIT_WORK(&stat->polling_task, poll_function_work);
+	dev_info(stat->dev, "%s probed: device created successfully\n",
+							LSM330_GYR_DEV_NAME);
+
+	return 0;
+
+/*err7:
+	free_irq(stat->irq2, stat);
+*/
+err6:
+	destroy_workqueue(stat->irq2_work_queue);
+err5:
+	lsm330_gyr_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+err4:
+	lsm330_gyr_input_cleanup(stat);
+err3:
+	lsm330_gyr_device_power_off(stat);
+err2:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+err1_1:
+	mutex_unlock(&stat->lock);
+	kfree(stat->pdata);
+err1:
+	if (stat->gyr_workqueue)
+		destroy_workqueue(stat->gyr_workqueue);
+	
+	return err;
+}
+EXPORT_SYMBOL(lsm330_gyr_probe);
+
+int lsm330_gyr_remove(struct lsm330_gyr_status *stat)
+{
+	lsm330_gyr_disable(stat);
+
+	if (stat->gyr_workqueue) {
+		destroy_workqueue(stat->gyr_workqueue);
+	}
+	/*
+	if (stat->pdata->gpio_int1 >= 0)
+	{
+		free_irq(stat->irq1, stat);
+		gpio_free(stat->pdata->gpio_int1);
+		destroy_workqueue(stat->irq1_work_queue);
+	}
+	*/
+	if (stat->pdata->gpio_int2 >= 0) {
+		free_irq(stat->irq2, stat);
+		gpio_free(stat->pdata->gpio_int2);
+		destroy_workqueue(stat->irq2_work_queue);
+	}
+
+	lsm330_gyr_input_cleanup(stat);
+
+	remove_sysfs_interfaces(stat->dev);
+
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330_gyr_remove);
+
+MODULE_DESCRIPTION("lsm330 gyroscope driver");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Denis Ciocca, STMicroelectronics");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330_gyr_i2c.c b/drivers/input/misc/st/imu/lsm330/lsm330_gyr_i2c.c
--- a/drivers/input/misc/st/imu/lsm330/lsm330_gyr_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330_gyr_i2c.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm330_gyr_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm330.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold stat->lock */
+static int lsm330_gyr_i2c_read(struct device *dev, u8 addr, int len,
+			       u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold stat->lock */
+static int lsm330_gyr_i2c_write(struct device *dev, u8 addr, int len,
+				u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm330_transfer_function lsm330_gyr_i2c_tf = {
+	.write = lsm330_gyr_i2c_write,
+	.read = lsm330_gyr_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330_gyr_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330_gyr_status *stat = i2c_get_clientdata(client);
+
+	return lsm330_gyr_enable(stat);
+}
+
+static int lsm330_gyr_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330_gyr_status *stat = i2c_get_clientdata(client);
+
+	return lsm330_gyr_disable(stat);
+}
+
+static const struct dev_pm_ops lsm330_gyr_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330_gyr_i2c_suspend,
+				lsm330_gyr_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330_gyr_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm330_gyr_status *stat;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct lsm330_gyr_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bus_type = BUS_I2C;
+	stat->tf = &lsm330_gyr_i2c_tf;
+
+	i2c_set_clientdata(client, stat);
+
+	mutex_init(&stat->lock);
+
+	err = lsm330_gyr_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330_gyr_i2c_remove(struct i2c_client *client)
+{
+	struct lsm330_gyr_status *stat = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(stat->dev, "driver removing\n");
+#endif
+
+	lsm330_gyr_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm330_gyr_i2c_id[] = {
+	{ "lsm330_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm330_gyr_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330_gyr_i2c_id_table[] = {
+	{ .compatible = "st,lsm330_gyr", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330_gyr_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm330_gyr_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330_gyr_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm330_gyr_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330_gyr_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330_gyr_i2c_probe,
+	.remove = lsm330_gyr_i2c_remove,
+	.id_table = lsm330_gyr_i2c_id,
+};
+
+module_i2c_driver(lsm330_gyr_i2c_driver);
+
+MODULE_DESCRIPTION("lsm330 gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330_gyr_spi.c b/drivers/input/misc/st/imu/lsm330/lsm330_gyr_spi.c
--- a/drivers/input/misc/st/imu/lsm330/lsm330_gyr_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330_gyr_spi.c	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm330_gyr_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm330.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold stat->lock */
+static int lsm330_gyr_spi_read(struct device *device, u8 addr, int len,
+				u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_gyr_status *stat = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	stat->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold stat->lock */
+static int lsm330_gyr_spi_write(struct device *device, u8 addr, int len,
+				u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_gyr_status *stat = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM330_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	stat->tb.tx_buf[0] = addr;
+
+	memcpy(&stat->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm330_transfer_function lsm330_gyr_spi_tf = {
+	.write = lsm330_gyr_spi_write,
+	.read = lsm330_gyr_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330_gyr_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_gyr_status *stat = spi_get_drvdata(spi);
+
+	return lsm330_gyr_enable(stat);
+}
+
+static int lsm330_gyr_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330_gyr_status *stat = spi_get_drvdata(spi);
+
+	return lsm330_gyr_disable(stat);
+}
+
+static const struct dev_pm_ops lsm330_gyr_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330_gyr_spi_suspend,
+				lsm330_gyr_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330_gyr_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm330_gyr_status *stat;
+
+#ifdef LSM330_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	stat = kzalloc(sizeof(struct lsm330_gyr_status), GFP_KERNEL);
+	if (!stat) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	stat->name = spi->modalias;
+	stat->bus_type = BUS_SPI;
+	stat->tf = &lsm330_gyr_spi_tf;
+	stat->dev = &spi->dev;
+	spi_set_drvdata(spi, stat);
+
+	mutex_init(&stat->lock);
+
+	err = lsm330_gyr_probe(stat);
+	if (err < 0) {
+		kfree(stat);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330_gyr_spi_remove(struct spi_device *spi)
+{
+	struct lsm330_gyr_status *stat = spi_get_drvdata(spi);
+
+#ifdef LSM330_DEBUG
+	dev_info(stat->dev, "driver removing\n");
+#endif
+
+	lsm330_gyr_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm330_gyr_spi_id[] = {
+	{ "lsm330_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm330_gyr_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330_gyr_spi_id_table[] = {
+	{ .compatible = "st,lsm330_gyr" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330_gyr_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm330_gyr_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330_gyr_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm330_gyr_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330_gyr_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330_gyr_spi_probe,
+	.remove = lsm330_gyr_spi_remove,
+	.id_table = lsm330_gyr_spi_id,
+};
+
+module_spi_driver(lsm330_gyr_spi_driver);
+
+MODULE_DESCRIPTION("lsm330 gyr spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330/lsm330.h b/drivers/input/misc/st/imu/lsm330/lsm330.h
--- a/drivers/input/misc/st/imu/lsm330/lsm330.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/lsm330.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,312 @@
+/*
+********************* (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lsm330.h
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+* Version		: V.1.2.6.1
+* Date			: 2016/May/24
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+
+********************************************************************************
+Version History.
+	V 1.0.0		First Release
+	V 1.0.2		I2C address bugfix
+	V 1.2.0		Registers names compliant to correct datasheet
+	V.1.2.1		Removed enable_interrupt_output sysfs file, manage int1
+			and int2, implements int1 isr.
+	V.1.2.2		Added HR_Timer and custom sysfs path
+	V.1.2.3		Ch state program codes and state prog parameters define,
+			gyro: corrects remove and poll_function_work
+	V.1.2.5		Changes create_sysfs_interfaces
+	V.1.2.6		Changes resume and suspend functions
+	V.1.2.6.1	Introduce SignMotion feat implementation and solves
+			acc suspend/resume issue;
+
+********************************************************************************
+SYSFS interface
+- range: set full scale
+	-> accelerometer: 	2,4,6,8,16 				[g]
+	-> gyroscope:		250,500,2000				[dps]
+- poll_period_ms: set 1/ODR
+	-> accelerometer:	LSM330_ACC_MIN_POLL_PERIOD_MS < t	[ms]
+	-> gyroscope:		LSM330_GYR_MIN_POLL_PERIOD_MS < t	[ms]
+- enable_device: enable/disable sensor					[1/0]
+- enable_polling: enable data polling/enable interrupt driven data acq	[1/0]
+
+INPUT subsystem: NOTE-> output data INCLUDE the sensitivity in accelerometer,
+			but NOT INCLUDE the sensitivity in gyroscope.
+*******************************************************************************/
+
+#ifndef __LSM330_H__
+#define __LSM330_H__
+
+
+#define LSM330_ACC_DEV_NAME		"lsm330_acc"
+#define LSM330_GYR_DEV_NAME		"lsm330_gyr"
+
+//#define CUSTOM_SYSFS_PATH
+#define CUSTOM_SYSFS_CLASS_NAME_GYR	"ST_gyr"
+#define CUSTOM_SYSFS_CLASS_NAME_ACC	"ST_acc"
+
+#define LSM330_GYR_SAD0L		(0x00)
+#define LSM330_ACC_SAD0L		(0x02)
+#define LSM330_SAD0H			(0x01)
+#define LSM330_ACC_I2C_SADROOT		(0x07)
+#define LSM330_ACC_I2C_SAD_L		((LSM330_ACC_I2C_SADROOT<<2) | \
+							LSM330_ACC_SAD0L)
+#define LSM330_ACC_I2C_SAD_H		((LSM330_ACC_I2C_SADROOT<<2) | \
+							LSM330_SAD0H)
+
+#define LSM330_GYR_I2C_SADROOT		(0x35)
+#define LSM330_GYR_I2C_SAD_L		((LSM330_GYR_I2C_SADROOT<<1)| \
+							LSM330_GYR_SAD0L)
+#define LSM330_GYR_I2C_SAD_H		((LSM330_GYR_I2C_SADROOT<<1)| \
+							LSM330_SAD0H)
+
+/* Poll Interval */
+#define LSM330_ACC_MIN_POLL_PERIOD_MS		1
+
+#define LSM330_GYR_MIN_POLL_PERIOD_MS		2
+
+
+#ifdef __KERNEL__
+/* enable significan motion program options
+ * and configurations on INT2
+ * */
+#define ENABLE_SIGNIFICANT_MOTION	1
+
+/* Interrupt */
+#define LSM330_ACC_DEFAULT_INT1_GPIO		(-EINVAL)
+#define LSM330_ACC_DEFAULT_INT2_GPIO		(-EINVAL)
+
+/* replace previous defines with something like following
+ * if you like to have default platform_data to
+ * have gpios for interrupt pins defined.
+#define LSM330_ACC_DEFAULT_INT1_GPIO		134
+#define LSM330_ACC_DEFAULT_INT2_GPIO		39
+*/
+
+#define LSM330_GYR_DEFAULT_INT1_GPIO		(-EINVAL)
+#define LSM330_GYR_DEFAULT_INT2_GPIO		(-EINVAL)
+
+
+/* Accelerometer Sensor Full Scale */
+#define LSM330_ACC_G_2G				(0x00)
+#define LSM330_ACC_G_4G				(0x08)
+#define LSM330_ACC_G_6G				(0x10)
+#define LSM330_ACC_G_8G				(0x18)
+#define LSM330_ACC_G_16G			(0x20)
+
+/* Gyroscope Sensor Full Scale */
+#define LSM330_GYR_FS_250DPS			(0x00)
+#define LSM330_GYR_FS_500DPS			(0x10)
+#define LSM330_GYR_FS_2000DPS			(0x30)
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_SM			MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+struct lsm330_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LSM330_SPI) || \
+    defined(CONFIG_INPUT_LSM330_SPI_MODULE)
+#define LSM330_RX_MAX_LENGTH		500
+#define LSM330_TX_MAX_LENGTH		500
+
+struct lsm330_transfer_buffer {
+	u8 rx_buf[LSM330_RX_MAX_LENGTH];
+	u8 tx_buf[LSM330_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LSM330_SPI */
+
+struct lsm330_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+#define LSM330_ACC_RESUME_ENTRIES		43
+#define LSM330_STATE_PR_SIZE			16
+
+struct lsm330_acc_data {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	struct lsm330_acc_platform_data *pdata;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct hrtimer hr_timer_acc;
+	struct workqueue_struct *acc_workqueue;
+	ktime_t ktime_acc;
+
+	struct input_dev *input_dev;
+
+#ifdef CUSTOM_SYSFS_PATH
+	struct class *acc_class;
+	struct device *acc_dev;
+#endif
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+	atomic_t sign_mot_enabled;
+	int enable_polling;
+
+	u16 sensitivity;
+
+	u8 resume_state[LSM330_ACC_RESUME_ENTRIES];
+	u8 resume_stmach_program1[LSM330_STATE_PR_SIZE];
+	u8 resume_stmach_program2[LSM330_STATE_PR_SIZE];
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef LSM330_DEBUG
+	u8 reg_addr;
+#endif
+	struct lsm330_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM330_SPI) || \
+    defined(CONFIG_INPUT_LSM330_SPI_MODULE)
+	struct lsm330_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM330_SPI */
+};
+
+struct lsm330_gyr_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	/* gpio ports for interrupt pads */
+	int gpio_int1;
+	int gpio_int2;		/* int for fifo */
+
+	/* axis mapping */
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+#define LSM330_GYR_RESUME_ENTRIES		6
+
+struct lsm330_gyr_status {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	struct lsm330_gyr_platform_data *pdata;
+
+	struct mutex lock;
+	struct workqueue_struct *gyr_workqueue;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	atomic_t enabled;
+
+	u8 reg_addr;
+	u8 resume_state[LSM330_GYR_RESUME_ENTRIES];
+
+	u32 sensitivity;
+
+#ifdef CUSTOM_SYSFS_PATH
+	struct class *gyr_class;
+	struct device *gyr_dev;
+#endif
+
+	/* interrupt related */
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	bool polling_enabled;
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+	struct work_struct polling_task;
+
+	struct lsm330_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM330_SPI) || \
+    defined(CONFIG_INPUT_LSM330_SPI_MODULE)
+	struct lsm330_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM330_SPI */
+};
+
+int lsm330_acc_probe(struct lsm330_acc_data *acc);
+int lsm330_acc_remove(struct lsm330_acc_data *acc);
+int lsm330_acc_enable(struct lsm330_acc_data *acc);
+int lsm330_acc_disable(struct lsm330_acc_data *acc);
+
+int lsm330_gyr_probe(struct lsm330_gyr_status *stat);
+int lsm330_gyr_remove(struct lsm330_gyr_status *stat);
+int lsm330_gyr_enable(struct lsm330_gyr_status *stat);
+int lsm330_gyr_disable(struct lsm330_gyr_status *stat);
+
+#endif	/* __KERNEL__ */
+
+#endif	/* __LSM330_H__ */
diff -uNr a/drivers/input/misc/st/imu/lsm330/Makefile b/drivers/input/misc/st/imu/lsm330/Makefile
--- a/drivers/input/misc/st/imu/lsm330/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for the input misc STM imu lsm330 driver
+#
+obj-$(CONFIG_INPUT_LSM330) += lsm330_acc.o lsm330_gyr.o
+obj-$(CONFIG_INPUT_LSM330_I2C) += lsm330_acc_i2c.o lsm330_gyr_i2c.o
+obj-$(CONFIG_INPUT_LSM330_SPI) += lsm330_acc_spi.o lsm330_gyr_spi.o
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/Kconfig b/drivers/input/misc/st/imu/lsm330dlc/Kconfig
--- a/drivers/input/misc/st/imu/lsm330dlc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/Kconfig	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,21 @@
+
+config INPUT_LSM330DLC
+	tristate "STMicroelectronics LSM330DLC sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM330DLC_I2C if (I2C)
+	select INPUT_LSM330DLC_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM330DLC sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm330dlc.
+
+config INPUT_LSM330DLC_I2C
+	tristate
+	depends on INPUT_LSM330DLC
+	depends on I2C
+
+config INPUT_LSM330DLC_SPI
+	tristate
+	depends on INPUT_LSM330DLC
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc.c b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc.c
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1265 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+ *
+ * File Name          : lsm330dlc_acc.c
+ * Authors            : MSH - Motion Mems BU - Application Team
+ *		      : Matteo Dameno (matteo.dameno@st.com)
+ *		      : Carmine Iascone (carmine.iascone@st.com)
+ *		      : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+ *		      : Authors are willing to be considered the contact
+ *		      : and update points for the driver.
+ * Version            : V.1.0.12
+ * Date               : 2016/May/6
+ * Description        : LSM330DLC accelerometer sensor API
+ *
+ *******************************************************************************
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+ * OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+ * PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+ * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+ * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+ * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ ******************************************************************************
+ Revision 1.0.6 15/11/2010
+  first revision
+  supports sysfs;
+  no more support for ioctl;
+ Revision 1.0.7 26/11/2010
+  checks for availability of interrupts pins
+  correction on FUZZ and FLAT values;
+ Revision 1.0.8 2010/Apr/01
+  corrects a bug in interrupt pin management in 1.0.7
+ Revision 1.0.9: 2011/May/23
+  update_odr func correction;
+ Revision 1.0.10: 2011/Aug/16
+  introduces default_platform_data, i2c_read and i2c_write function rewritten,
+  manages smbus beside i2c
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  moved use_smbus inside status struct; modified:-update_fs_range;-set_range
+  input format; allows gpio_intX to be passed as parameter at insmod time;
+ ******************************************************************************/
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "lsm330dlc.h"
+
+/* mg/LSB */
+#define SENSITIVITY_2G		1
+#define SENSITIVITY_4G		2
+#define SENSITIVITY_8G		4
+#define SENSITIVITY_16G		12
+
+/* Accelerometer Sensor Operating Mode */
+#define LSM330DLC_ACC_ENABLE	0x01
+#define LSM330DLC_ACC_DISABLE	0x00
+
+#define	HIGH_RESOLUTION		0x08
+
+#define	AXISDATA_REG		0x28
+#define WHOAMI_LSM330DLC_ACC	0x33
+
+/* CONTROL REGISTERS */
+#define WHO_AM_I		0x0F
+#define TEMP_CFG_REG		0x1F
+#define CTRL_REG1		0x20
+#define CTRL_REG2		0x21
+#define CTRL_REG3		0x22
+#define CTRL_REG4		0x23
+#define CTRL_REG5		0x24
+#define CTRL_REG6		0x25
+
+#define FIFO_CTRL_REG		0x2E
+
+#define INT_CFG1		0x30
+#define INT_SRC1		0x31
+#define INT_THS1		0x32
+#define INT_DUR1		0x33
+
+#define TT_CFG			0x38
+#define TT_SRC			0x39
+#define TT_THS			0x3A
+#define TT_LIM			0x3B
+#define TT_TLAT			0x3C
+#define TT_TW			0x3D
+
+#define ENABLE_HIGH_RESOLUTION	1
+
+#define LSM330DLC_ACC_PM_OFF		0x00
+#define LSM330DLC_ACC_ENABLE_ALL_AXES	0x07
+
+#define PMODE_MASK		0x08
+#define ODR_MASK		0XF0
+
+#define LSM330DLC_ACC_ODR1	0x10
+#define LSM330DLC_ACC_ODR10	0x20
+#define LSM330DLC_ACC_ODR25	0x30
+#define LSM330DLC_ACC_ODR50	0x40
+#define LSM330DLC_ACC_ODR100	0x50
+#define LSM330DLC_ACC_ODR200	0x60
+#define LSM330DLC_ACC_ODR400	0x70
+#define LSM330DLC_ACC_ODR1250	0x90
+
+#define IA			0x40
+#define ZH			0x20
+#define ZL			0x10
+#define YH			0x08
+#define YL			0x04
+#define XH			0x02
+#define XL			0x01
+
+/* CTRL REG BITS*/
+#define CTRL_REG3_I1_AOI1	0x40
+#define CTRL_REG4_BDU_ENABLE	0x80
+#define CTRL_REG4_BDU_MASK	0x80
+#define CTRL_REG6_I2_TAPEN	0x80
+#define CTRL_REG6_HLACTIVE	0x02
+
+#define NO_MASK			0xFF
+#define INT1_DURATION_MASK	0x7F
+#define INT1_THRESHOLD_MASK	0x7F
+#define TAP_CFG_MASK		0x3F
+#define TAP_THS_MASK		0x7F
+#define TAP_TLIM_MASK		0x7F
+#define TAP_TLAT_MASK		NO_MASK
+#define TAP_TW_MASK		NO_MASK
+
+/* TAP_SOURCE_REG BIT */
+#define DTAP			0x20
+#define STAP			0x10
+#define SIGNTAP			0x08
+#define ZTAP			0x04
+#define YTAP			0x02
+#define XTAZ			0x01
+
+#define FUZZ			0
+#define FLAT			0
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1		0
+#define	RES_CTRL_REG2		1
+#define	RES_CTRL_REG3		2
+#define	RES_CTRL_REG4		3
+#define	RES_CTRL_REG5		4
+#define	RES_CTRL_REG6		5
+
+#define	RES_INT_CFG1		6
+#define	RES_INT_THS1		7
+#define	RES_INT_DUR1		8
+
+#define	RES_TT_CFG		9
+#define	RES_TT_THS		10
+#define	RES_TT_LIM		11
+#define	RES_TT_TLAT		12
+#define	RES_TT_TW		13
+
+#define	RES_TEMP_CFG_REG	14
+#define	RES_REFERENCE_REG	15
+#define	RES_FIFO_CTRL_REG	16
+
+#define LSM330DLC_ACC_MIN_POLL_PERIOD_MS	1
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones havew to be set to -EINVAL
+ */
+#define LSM330DLC_ACC_DEFAULT_INT1_GPIO		-EINVAL
+#define LSM330DLC_ACC_DEFAULT_INT2_GPIO		-EINVAL
+
+/* Accelerometer Sensor Full Scale */
+#define LSM330DLC_ACC_FS_MASK		0x30
+#define LSM330DLC_ACC_G_2G		0x00
+#define LSM330DLC_ACC_G_4G		0x10
+#define LSM330DLC_ACC_G_8G		0x20
+#define LSM330DLC_ACC_G_16G		0x30
+
+struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lsm330dlc_acc_odr_table[] = {
+	{    1, LSM330DLC_ACC_ODR1250 },
+	{    3, LSM330DLC_ACC_ODR400  },
+	{    5, LSM330DLC_ACC_ODR200  },
+	{   10, LSM330DLC_ACC_ODR100  },
+	{   20, LSM330DLC_ACC_ODR50   },
+	{   40, LSM330DLC_ACC_ODR25   },
+	{  100, LSM330DLC_ACC_ODR10   },
+	{ 1000, LSM330DLC_ACC_ODR1    },
+};
+
+static int int1_gpio = LSM330DLC_ACC_DEFAULT_INT1_GPIO;
+static int int2_gpio = LSM330DLC_ACC_DEFAULT_INT2_GPIO;
+module_param(int1_gpio, int, S_IRUGO);
+module_param(int2_gpio, int, S_IRUGO);
+
+static struct lsm330dlc_acc_platform_data default_lsm330dlc_acc_pdata = {
+	.fs_range = LSM330DLC_ACC_G_2G,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+	.poll_interval = 100,
+	.min_interval = LSM330DLC_ACC_MIN_POLL_PERIOD_MS,
+	.gpio_int1 = LSM330DLC_ACC_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LSM330DLC_ACC_DEFAULT_INT2_GPIO,
+};
+
+static int lsm330dlc_acc_hw_init(struct lsm330dlc_acc_dev *dev)
+{
+	int err;
+	u8 buf[7];
+
+	err = dev->tf->read(dev->dev, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(dev->dev, "Error reading WHO_AM_I\n");
+		goto err_firstread;
+	} else {
+		dev->hw_working = 1;
+	}
+
+	if (buf[0] != WHOAMI_LSM330DLC_ACC) {
+		dev_err(dev->dev, "device unknown. [0x%02x 0x%02x]\n",
+			WHOAMI_LSM330DLC_ACC, buf[0]);
+		err = -1; /* choose the right coded error */
+		goto err_unknown_device;
+	}
+
+	buf[0] = dev->resume_state[RES_CTRL_REG1];
+	err = dev->tf->write(dev->dev, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_TEMP_CFG_REG];
+	err = dev->tf->write(dev->dev, TEMP_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_FIFO_CTRL_REG];
+	err = dev->tf->write(dev->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_TT_THS];
+	buf[1] = dev->resume_state[RES_TT_LIM];
+	buf[2] = dev->resume_state[RES_TT_TLAT];
+	buf[3] = dev->resume_state[RES_TT_TW];
+	err = dev->tf->write(dev->dev, TT_THS, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_TT_CFG];
+	err = dev->tf->write(dev->dev, TT_CFG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_INT_THS1];
+	buf[1] = dev->resume_state[RES_INT_DUR1];
+	err = dev->tf->write(dev->dev, INT_THS1, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_INT_CFG1];
+	err = dev->tf->write(dev->dev, INT_CFG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = dev->resume_state[RES_CTRL_REG2];
+	buf[1] = dev->resume_state[RES_CTRL_REG3];
+	buf[2] = dev->resume_state[RES_CTRL_REG4];
+	buf[3] = dev->resume_state[RES_CTRL_REG5];
+	buf[4] = dev->resume_state[RES_CTRL_REG6];
+	err = dev->tf->write(dev->dev, CTRL_REG2, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	dev->hw_initialized = 1;
+
+	return 0;
+
+err_firstread:
+	dev->hw_working = 0;
+err_unknown_device:
+err_resume_state:
+	dev->hw_initialized = 0;
+
+	return err;
+}
+
+static void lsm330dlc_acc_device_power_off(struct lsm330dlc_acc_dev *dev)
+{
+	int err;
+	u8 data = LSM330DLC_ACC_PM_OFF;
+
+	err = dev->tf->write(dev->dev, CTRL_REG1, 1, &data);
+	if (err < 0)
+		dev_err(dev->dev, "soft power off failed: %d\n", err);
+
+	if (dev->pdata->power_off) {
+		if (dev->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(dev->irq1);
+		if (dev->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(dev->irq2);
+		dev->pdata->power_off();
+		dev->hw_initialized = 0;
+	}
+
+	if (dev->hw_initialized) {
+		if (dev->pdata->gpio_int1 >= 0)
+			disable_irq_nosync(dev->irq1);
+		if (dev->pdata->gpio_int2 >= 0)
+			disable_irq_nosync(dev->irq2);
+		dev->hw_initialized = 0;
+	}
+
+}
+
+static int lsm330dlc_acc_device_power_on(struct lsm330dlc_acc_dev *dev)
+{
+	if (dev->pdata->power_on) {
+		int err = dev->pdata->power_on();
+		if (err < 0) {
+			dev_err(dev->dev, "power_on failed: %d\n", err);
+			return err;
+		}
+
+		if (dev->pdata->gpio_int1 >= 0)
+			enable_irq(dev->irq1);
+		if (dev->pdata->gpio_int2 >= 0)
+			enable_irq(dev->irq2);
+	}
+
+	if (!dev->hw_initialized) {
+		int err = lsm330dlc_acc_hw_init(dev);
+		if (dev->hw_working == 1 && err < 0) {
+			lsm330dlc_acc_device_power_off(dev);
+			return err;
+		}
+	}
+
+	if (dev->hw_initialized) {
+		if (dev->pdata->gpio_int1 >= 0)
+			enable_irq(dev->irq1);
+		if (dev->pdata->gpio_int2 >= 0)
+			enable_irq(dev->irq2);
+	}
+
+	return 0;
+}
+
+static irqreturn_t lsm330dlc_acc_isr1(int irq, void *data)
+{
+	struct lsm330dlc_acc_dev *dev = data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq1_work_queue, &dev->irq1_work);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lsm330dlc_acc_isr2(int irq, void *data)
+{
+	struct lsm330dlc_acc_dev *dev = data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq2_work_queue, &dev->irq2_work);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm330dlc_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct lsm330dlc_acc_dev *dev;
+	
+	dev = container_of(work, struct lsm330dlc_acc_dev, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm330dlc_acc_get_int1_source(dev); */
+
+	enable_irq(dev->irq1);
+}
+
+static void lsm330dlc_acc_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm330dlc_acc_dev *dev;
+	
+	dev = container_of(work, struct lsm330dlc_acc_dev, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm330dlc_acc_get_tap_source(dev); */
+
+	enable_irq(dev->irq2);
+}
+
+static int lsm330dlc_acc_update_fs_range(struct lsm330dlc_acc_dev *dev,
+					 u8 new_fs_range)
+{
+	int err;
+	u8 data, sensitivity, updated_val;
+	u8 mask = LSM330DLC_ACC_FS_MASK | HIGH_RESOLUTION;
+
+	switch (new_fs_range) {
+	case LSM330DLC_ACC_G_2G:
+		sensitivity = SENSITIVITY_2G;
+		break;
+	case LSM330DLC_ACC_G_4G:
+		sensitivity = SENSITIVITY_4G;
+		break;
+	case LSM330DLC_ACC_G_8G:
+		sensitivity = SENSITIVITY_8G;
+		break;
+	case LSM330DLC_ACC_G_16G:
+		sensitivity = SENSITIVITY_16G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	/* Updates configuration register 4,
+	 * which contains fs range setting */
+	err = dev->tf->read(dev->dev, CTRL_REG4, 1, &data);
+	if (err < 0)
+		return err;
+
+	dev->resume_state[RES_CTRL_REG4] = data;
+	updated_val = ((mask & (new_fs_range | HIGH_RESOLUTION)) |
+		       (~mask & data));
+	err = dev->tf->write(dev->dev, CTRL_REG4, 1, &updated_val);
+	if (err < 0)
+		return err;
+
+	dev->resume_state[RES_CTRL_REG4] = updated_val;
+	dev->sensitivity = sensitivity;
+
+	return 0;
+}
+
+static int lsm330dlc_acc_update_odr(struct lsm330dlc_acc_dev *dev,
+				    int poll_ms)
+{
+	if (atomic_read(&dev->enabled)) {
+		int i, err;
+		u8 data = LSM330DLC_ACC_ENABLE_ALL_AXES;
+
+		/* Following, looks for the longest possible odr interval
+		 * scrolling the odr_table vector from the end
+		 * (shortest interval) backward (longest interval), to support
+		 * the poll_interval requested by the system.
+		 * It must be the longest interval lower then the poll interval
+		 */
+		for (i = ARRAY_SIZE(lsm330dlc_acc_odr_table) - 1; i >= 0; i--) {
+			if ((lsm330dlc_acc_odr_table[i].cutoff_ms <= poll_ms) ||
+			    (i == 0))
+				break;
+		}
+		data |= lsm330dlc_acc_odr_table[i].mask;
+
+		/* If device is currently enabled, we need to write new
+		 * configuration out to it */
+		err = dev->tf->write(dev->dev, CTRL_REG1, 1, &data);
+		if (err < 0)
+			return err;
+		dev->resume_state[RES_CTRL_REG1] = data;
+	}
+
+	return 0;
+}
+
+static int lsm330dlc_acc_get_acceleration_data(struct lsm330dlc_acc_dev *dev,
+					       int *xyz)
+{
+	int err;
+	/* Data bytes from hardware xL, xH, yL, yH, zL, zH */
+	u8 acc_data[6];
+	/* x,y,z hardware data */
+	s16 hw_d[3];
+
+	err = dev->tf->read(dev->dev, AXISDATA_REG, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (((s16) ((acc_data[1] << 8) | acc_data[0])) >> 4);
+	hw_d[1] = (((s16) ((acc_data[3] << 8) | acc_data[2])) >> 4);
+	hw_d[2] = (((s16) ((acc_data[5] << 8) | acc_data[4])) >> 4);
+
+	hw_d[0] *= dev->sensitivity;
+	hw_d[1] *= dev->sensitivity;
+	hw_d[2] *= dev->sensitivity;
+
+	xyz[0] = ((dev->pdata->negate_x) ? (-hw_d[dev->pdata->axis_map_x])
+		   : (hw_d[dev->pdata->axis_map_x]));
+	xyz[1] = ((dev->pdata->negate_y) ? (-hw_d[dev->pdata->axis_map_y])
+		   : (hw_d[dev->pdata->axis_map_y]));
+	xyz[2] = ((dev->pdata->negate_z) ? (-hw_d[dev->pdata->axis_map_z])
+		   : (hw_d[dev->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void lsm330dlc_acc_report_values(struct lsm330dlc_acc_dev *dev,
+					int *xyz)
+{
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(dev->input_dev);
+}
+
+int lsm330dlc_acc_enable(struct lsm330dlc_acc_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&dev->lock);
+		err = lsm330dlc_acc_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		schedule_delayed_work(&dev->input_work,
+			msecs_to_jiffies(dev->pdata->poll_interval));
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330dlc_acc_enable);
+
+int lsm330dlc_acc_disable(struct lsm330dlc_acc_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&dev->input_work);
+
+		mutex_lock(&dev->lock);
+		lsm330dlc_acc_device_power_off(dev);
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330dlc_acc_disable);
+
+static ssize_t read_single_reg(struct device *device, char *buf, u8 reg)
+{
+	u8 data;
+	ssize_t ret;
+	int err;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(device, reg, 1, &data);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	mutex_unlock(&dev->lock);
+
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static int write_reg(struct device *device, const char *buf, u8 reg, u8 mask,
+		     int resumeIndex)
+{
+	int err;
+	u8 data;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_unlock(&dev->lock);
+	data = ((u8)val & mask);
+	err = dev->tf->write(device, reg, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	if (err < 0)
+		return err;
+
+	dev->resume_state[resumeIndex] = data;
+
+	return err;
+}
+
+static ssize_t attr_get_polling_rate(struct device *device,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata->poll_interval;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *device,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	unsigned long interval_ms;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, dev->pdata->min_interval);
+
+	mutex_lock(&dev->lock);
+	dev->pdata->poll_interval = interval_ms;
+	lsm330dlc_acc_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_range(struct device *device,
+			      struct device_attribute *attr, char *buf)
+{
+	char range = 2;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	switch (dev->pdata->fs_range) {
+	case LSM330DLC_ACC_G_2G:
+		range = 2;
+		break;
+	case LSM330DLC_ACC_G_4G:
+		range = 4;
+		break;
+	case LSM330DLC_ACC_G_8G:
+		range = 8;
+		break;
+	case LSM330DLC_ACC_G_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	unsigned long val;
+	int err;
+	u8 range;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LSM330DLC_ACC_G_2G;
+		break;
+	case 4:
+		range = LSM330DLC_ACC_G_4G;
+		break;
+	case 8:
+		range = LSM330DLC_ACC_G_8G;
+		break;
+	case 16:
+		range = LSM330DLC_ACC_G_16G;
+		break;
+	default:
+		dev_err(device, "invalid range request: %lu\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lsm330dlc_acc_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", atomic_read(&dev->enabled));
+}
+
+static ssize_t attr_set_enable(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm330dlc_acc_enable(dev);
+	else
+		lsm330dlc_acc_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_set_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_CFG1, NO_MASK, RES_INT_CFG1);
+}
+
+static ssize_t attr_get_intconfig1(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	return read_single_reg(dev, buf, INT_CFG1);
+}
+
+static ssize_t attr_set_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_DUR1, INT1_DURATION_MASK, RES_INT_DUR1);
+}
+
+static ssize_t attr_get_duration1(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	return read_single_reg(dev, buf, INT_DUR1);
+}
+
+static ssize_t attr_set_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	return write_reg(dev, buf, INT_THS1, INT1_THRESHOLD_MASK, RES_INT_THS1);
+}
+
+static ssize_t attr_get_thresh1(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	return read_single_reg(dev, buf, INT_THS1);
+}
+
+static ssize_t attr_get_source1(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return read_single_reg(dev, buf, INT_SRC1);
+}
+
+static ssize_t attr_set_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_CFG, TAP_CFG_MASK, RES_TT_CFG);
+}
+
+static ssize_t attr_get_click_cfg(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	return read_single_reg(dev, buf, TT_CFG);
+}
+
+static ssize_t attr_get_click_source(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	return read_single_reg(dev, buf, TT_SRC);
+}
+
+static ssize_t attr_set_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_THS, TAP_THS_MASK, RES_TT_THS);
+}
+
+static ssize_t attr_get_click_ths(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	return read_single_reg(dev, buf, TT_THS);
+}
+
+static ssize_t attr_set_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_LIM, TAP_TLIM_MASK, RES_TT_LIM);
+}
+
+static ssize_t attr_get_click_tlim(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	return read_single_reg(dev, buf, TT_LIM);
+}
+
+static ssize_t attr_set_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TLAT_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tlat(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+static ssize_t attr_set_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	return write_reg(dev, buf, TT_TLAT, TAP_TW_MASK, RES_TT_TLAT);
+}
+
+static ssize_t attr_get_click_tw(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	return read_single_reg(dev, buf, TT_TLAT);
+}
+
+#ifdef LSM330DLC_DEBUG
+/* PAY ATTENTION: These DEBUG functions don't manage resume_state */
+static ssize_t attr_reg_set(struct device *device,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	u8 data;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	/*TODO: error need to be managed */
+	mutex_lock(&dev->lock);
+	data = val;
+	err = dev->tf->write(device, dev->reg_addr, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	int err;
+	u8 data;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	/*TODO: error need to be managed */
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(device, dev->reg_addr, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *device,
+			     struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm330dlc_acc_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	dev->reg_addr = val;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate,
+	       attr_set_polling_rate),
+	__ATTR(range, 0664, attr_get_range, attr_set_range),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(int1_config, 0664, attr_get_intconfig1, attr_set_intconfig1),
+	__ATTR(int1_duration, 0664, attr_get_duration1, attr_set_duration1),
+	__ATTR(int1_threshold, 0664, attr_get_thresh1, attr_set_thresh1),
+	__ATTR(int1_source, 0444, attr_get_source1, NULL),
+	__ATTR(click_config, 0664, attr_get_click_cfg, attr_set_click_cfg),
+	__ATTR(click_source, 0444, attr_get_click_source, NULL),
+	__ATTR(click_threshold, 0664, attr_get_click_ths, attr_set_click_ths),
+	__ATTR(click_timelimit, 0664, attr_get_click_tlim, attr_set_click_tlim),
+	__ATTR(click_timelatency, 0664, attr_get_click_tlat,
+	       attr_set_click_tlat),
+	__ATTR(click_timewindow, 0664, attr_get_click_tw, attr_set_click_tw),
+
+#ifdef LSM330DLC_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lsm330dlc_acc_input_work_func(struct work_struct *work)
+{
+	struct lsm330dlc_acc_dev *dev;
+	int err, xyz[3] = {};
+
+	dev = container_of((struct delayed_work *)work,
+			   struct lsm330dlc_acc_dev, input_work);
+
+	mutex_lock(&dev->lock);
+	err = lsm330dlc_acc_get_acceleration_data(dev, xyz);
+	if (err < 0)
+		dev_err(dev->dev, "get_acceleration_data failed\n");
+	else
+		lsm330dlc_acc_report_values(dev, xyz);
+
+	schedule_delayed_work(&dev->input_work,
+			      msecs_to_jiffies(dev->pdata->poll_interval));
+
+	mutex_unlock(&dev->lock);
+}
+
+static int lsm330dlc_acc_validate_pdata(struct lsm330dlc_acc_dev *dev)
+{
+	/* checks for correctness of minimal polling period */
+	dev->pdata->min_interval = max((u32)LSM330DLC_ACC_MIN_POLL_PERIOD_MS,
+				       dev->pdata->min_interval);
+
+	dev->pdata->poll_interval = max(dev->pdata->poll_interval,
+					dev->pdata->min_interval);
+
+	if (dev->pdata->axis_map_x > 2 || dev->pdata->axis_map_y > 2 ||
+	    dev->pdata->axis_map_z > 2) {
+		dev_err(dev->dev, "invalid axis_map value "
+			"x:%u y:%u z%u\n", dev->pdata->axis_map_x,
+			dev->pdata->axis_map_y, dev->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (dev->pdata->negate_x > 1 || dev->pdata->negate_y > 1 ||
+	    dev->pdata->negate_z > 1) {
+		dev_err(dev->dev, "invalid negate value "
+			"x:%u y:%u z:%u\n", dev->pdata->negate_x,
+			dev->pdata->negate_y, dev->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (dev->pdata->poll_interval < dev->pdata->min_interval) {
+		dev_err(dev->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lsm330dlc_acc_input_init(struct lsm330dlc_acc_dev *dev)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&dev->input_work, lsm330dlc_acc_input_work_func);
+
+	dev->input_dev = input_allocate_device();
+	if (!dev->input_dev) {
+		dev_err(dev->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev->name = LSM330DLC_ACC_DEV_NAME;
+	dev->input_dev->id.bustype = dev->bus_type;
+	dev->input_dev->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev, dev);
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev->mscbit);
+
+	err = input_register_device(dev->input_dev);
+	if (err) {
+		dev_err(dev->dev, "unable to register input device %s\n",
+			dev->input_dev->name);
+		input_free_device(dev->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lsm330dlc_acc_input_cleanup(struct lsm330dlc_acc_dev *dev)
+{
+	input_unregister_device(dev->input_dev);
+	input_free_device(dev->input_dev);
+}
+
+int lsm330dlc_acc_probe(struct lsm330dlc_acc_dev *dev)
+{
+	int err;
+
+	mutex_lock(&dev->lock);
+
+	dev->pdata = kmalloc(sizeof(*dev->pdata), GFP_KERNEL);
+	if (dev->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(dev->dev, "failed to allocate memory for pdata: %d\n",
+			err);
+		goto err_mutexunlock;
+	}
+
+	if (dev->dev->platform_data == NULL) {
+		default_lsm330dlc_acc_pdata.gpio_int1 = int1_gpio;
+		default_lsm330dlc_acc_pdata.gpio_int2 = int2_gpio;
+		memcpy(dev->pdata, &default_lsm330dlc_acc_pdata,
+		       sizeof(*dev->pdata));
+		dev_info(dev->dev, "using default plaform_data\n");
+	} else {
+		memcpy(dev->pdata, dev->dev->platform_data,
+		       sizeof(*dev->pdata));
+	}
+
+	err = lsm330dlc_acc_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (dev->pdata->init) {
+		err = dev->pdata->init();
+		if (err < 0) {
+			dev_err(dev->dev, "init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	if (dev->pdata->gpio_int1 >= 0) {
+		dev->irq1 = gpio_to_irq(dev->pdata->gpio_int1);
+		pr_info("%s: %s has set irq1 to irq: %d, mapped on gpio:%d\n",
+			LSM330DLC_ACC_DEV_NAME, __func__, dev->irq1,
+			dev->pdata->gpio_int1);
+	}
+
+	if (dev->pdata->gpio_int2 >= 0) {
+		dev->irq2 = gpio_to_irq(dev->pdata->gpio_int2);
+		pr_info("%s: %s has set irq2 to irq: %d, mapped on gpio:%d\n",
+			LSM330DLC_ACC_DEV_NAME, __func__, dev->irq2,
+			dev->pdata->gpio_int2);
+	}
+
+	dev->resume_state[RES_CTRL_REG1] = LSM330DLC_ACC_ENABLE_ALL_AXES;
+	dev->resume_state[RES_CTRL_REG4] = CTRL_REG4_BDU_ENABLE;
+
+	err = lsm330dlc_acc_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	atomic_set(&dev->enabled, 1);
+
+	err = lsm330dlc_acc_update_fs_range(dev, dev->pdata->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm330dlc_acc_update_odr(dev, dev->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm330dlc_acc_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "device sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm330dlc_acc_device_power_off(dev);
+
+	/* As default, do not report information */
+	atomic_set(&dev->enabled, 0);
+
+	if (dev->pdata->gpio_int1 >= 0) {
+		INIT_WORK(&dev->irq1_work, lsm330dlc_acc_irq1_work_func);
+		dev->irq1_work_queue =
+			create_singlethread_workqueue("lsm330dlc_acc_wq1");
+		if (!dev->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev, "cannot create work queue1: %d\n",
+				err);
+			goto err_remove_sysfs_int;
+		}
+
+		err = request_irq(dev->irq1, lsm330dlc_acc_isr1,
+				  IRQF_TRIGGER_RISING, "lsm330dlc_acc_irq1",
+				  dev);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(dev->irq1);
+	}
+
+	if (dev->pdata->gpio_int2 >= 0) {
+		INIT_WORK(&dev->irq2_work, lsm330dlc_acc_irq2_work_func);
+		dev->irq2_work_queue =
+			create_singlethread_workqueue("lsm330dlc_acc_wq2");
+		if (!dev->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev, "cannot create work queue2: %d\n",
+				err);
+			goto err_free_irq1;
+		}
+		err = request_irq(dev->irq2, lsm330dlc_acc_isr2,
+				  IRQF_TRIGGER_RISING, "lsm330dlc_acc_irq2",
+				  dev);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(dev->irq2);
+	}
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err_destoyworkqueue2:
+	if (dev->pdata->gpio_int2 >= 0)
+		destroy_workqueue(dev->irq2_work_queue);
+err_free_irq1:
+	free_irq(dev->irq1, dev);
+err_destoyworkqueue1:
+	if (dev->pdata->gpio_int1 >= 0)
+		destroy_workqueue(dev->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(dev->dev);
+err_input_cleanup:
+	lsm330dlc_acc_input_cleanup(dev);
+err_power_off:
+	lsm330dlc_acc_device_power_off(dev);
+err_pdata_init:
+	if (dev->pdata->exit)
+		dev->pdata->exit();
+exit_kfree_pdata:
+	kfree(dev->pdata);
+err_mutexunlock:
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm330dlc_acc_probe);
+
+int lsm330dlc_acc_remove(struct lsm330dlc_acc_dev *dev)
+{
+	if (dev->pdata->gpio_int1 >= 0) {
+		free_irq(dev->irq1, dev);
+		gpio_free(dev->pdata->gpio_int1);
+		destroy_workqueue(dev->irq1_work_queue);
+	}
+
+	if (dev->pdata->gpio_int2 >= 0) {
+		free_irq(dev->irq2, dev);
+		gpio_free(dev->pdata->gpio_int2);
+		destroy_workqueue(dev->irq2_work_queue);
+	}
+
+	lsm330dlc_acc_input_cleanup(dev);
+	lsm330dlc_acc_device_power_off(dev);
+	remove_sysfs_interfaces(dev->dev);
+
+	if (dev->pdata->exit)
+		dev->pdata->exit();
+	kfree(dev->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330dlc_acc_remove);
+
+MODULE_DESCRIPTION("lsm330dlc accelerometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Carmine Iascone, STMicroelectronics");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_i2c.c b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_i2c.c
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm330dlc_acc_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm330dlc.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm330dlc_acc_i2c_read(struct device *dev, u8 addr, int len,
+				  u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm330dlc_acc_i2c_write(struct device *dev, u8 addr, int len,
+				   u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm330dlc_transfer_function lsm330dlc_acc_i2c_tf = {
+	.write = lsm330dlc_acc_i2c_write,
+	.read = lsm330dlc_acc_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330dlc_acc_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330dlc_acc_dev *dev = i2c_get_clientdata(client);
+
+	return lsm330dlc_acc_enable(dev);
+}
+
+static int lsm330dlc_acc_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330dlc_acc_dev *dev = i2c_get_clientdata(client);
+
+	return lsm330dlc_acc_disable(dev);
+}
+
+static const struct dev_pm_ops lsm330dlc_acc_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330dlc_acc_i2c_suspend,
+				lsm330dlc_acc_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330dlc_acc_i2c_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm330dlc_acc_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm330dlc_acc_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm330dlc_acc_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm330dlc_acc_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330dlc_acc_i2c_remove(struct i2c_client *client)
+{
+	struct lsm330dlc_acc_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm330dlc_acc_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm330dlc_acc_i2c_id[] = {
+	{ "lsm330dlc_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm330dlc_acc_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330dlc_acc_i2c_id_table[] = {
+	{ .compatible = "st,lsm330dlc_acc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330dlc_acc_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm330dlc_acc_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330dlc_acc_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm330dlc_acc_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330dlc_acc_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330dlc_acc_i2c_probe,
+	.remove = lsm330dlc_acc_i2c_remove,
+	.id_table = lsm330dlc_acc_i2c_id,
+};
+
+module_i2c_driver(lsm330dlc_acc_i2c_driver);
+
+MODULE_DESCRIPTION("lsm330dlc acc i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_spi.c b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_spi.c
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_acc_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm330dlc_acc_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm330dlc.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm330dlc_acc_spi_read(struct device *device, u8 addr, int len,
+				  u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_acc_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm330dlc_acc_spi_write(struct device *device, u8 addr, int len,
+				   u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_acc_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM330DLC_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static const struct lsm330dlc_transfer_function lsm330dlc_acc_spi_tf = {
+	.write = lsm330dlc_acc_spi_write,
+	.read = lsm330dlc_acc_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330dlc_acc_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_acc_dev *dev = spi_get_drvdata(spi);
+
+	return lsm330dlc_acc_enable(dev);
+}
+
+static int lsm330dlc_acc_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_acc_dev *dev = spi_get_drvdata(spi);
+
+	return lsm330dlc_acc_disable(dev);
+}
+
+static const struct dev_pm_ops lsm330dlc_acc_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330dlc_acc_spi_suspend,
+				lsm330dlc_acc_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330dlc_acc_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm330dlc_acc_dev *dev;
+
+#ifdef LSM330DLC_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm330dlc_acc_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm330dlc_acc_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm330dlc_acc_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330dlc_acc_spi_remove(struct spi_device *spi)
+{
+	struct lsm330dlc_acc_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LSM330DLC_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm330dlc_acc_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm330dlc_acc_spi_id[] = {
+	{ "lsm330dlc_acc", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm330dlc_acc_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330dlc_acc_spi_id_table[] = {
+	{ .compatible = "st,lsm330dlc_acc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330dlc_acc_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm330dlc_acc_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330dlc_acc_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm330dlc_acc_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330dlc_acc_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330dlc_acc_spi_probe,
+	.remove = lsm330dlc_acc_spi_remove,
+	.id_table = lsm330dlc_acc_spi_id,
+};
+
+module_spi_driver(lsm330dlc_acc_spi_driver);
+
+MODULE_DESCRIPTION("lsm330dlc acc spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr.c b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr.c
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1185 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lsm330dlc_gyr.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Carmine Iascone (carmine.iascone@st.com)
+*			: Both authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.1.5.5 sysfs
+* Date			: 2016/May/10
+* Description		: LSM330DLC digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+*******************************************************************************/
+
+#include <linux/mutex.h>
+#include <linux/input-polldev.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+
+#include "lsm330dlc.h"
+
+#define WHO_AM_I	0x0F
+
+#define CTRL_REG1	0x20 /* CTRL REG1 */
+#define CTRL_REG2	0x21 /* CTRL REG2 */
+#define CTRL_REG3	0x22 /* CTRL_REG3 */
+#define CTRL_REG4	0x23 /* CTRL_REG4 */
+#define CTRL_REG5	0x24 /* CTRL_REG5 */
+#define REFERENCE	0x25 /* REFERENCE REG */
+#define FIFO_CTRL_REG	0x2E /* FIFO CONTROL REGISTER */
+#define FIFO_SRC_REG	0x2F /* FIFO SOURCE REGISTER */
+#define OUT_X_L		0x28 /* 1st AXIS OUT REG of 6 */
+
+#define AXISDATA_REG	OUT_X_L
+
+/* CTRL_REG1 */
+#define ALL_ZEROES		0x00
+#define PM_OFF			0x00
+#define PM_NORMAL		0x08
+#define ENABLE_ALL_AXES		0x07
+#define ENABLE_NO_AXES		0x00
+#define BW00			0x00
+#define BW01			0x10
+#define BW10			0x20
+#define BW11			0x30
+#define ODR095			0x00 /* ODR =  95Hz */
+#define ODR190			0x40 /* ODR = 190Hz */
+#define ODR380			0x80 /* ODR = 380Hz */
+#define ODR760			0xC0 /* ODR = 760Hz */
+
+/* CTRL_REG3 bits */
+#define I2_DRDY		0x08
+#define I2_WTM		0x04
+#define I2_OVRUN	0x02
+#define I2_EMPTY	0x01
+#define I2_NONE		0x00
+#define I2_MASK		0x0F
+
+/* CTRL_REG4 bits */
+#define FS_MASK		0x30
+#define BDU_ENABLE	0x80
+
+/* CTRL_REG5 bits */
+#define FIFO_ENABLE	0x40
+#define HPF_ENALBE	0x11
+
+/* FIFO_CTRL_REG bits */
+#define FIFO_MODE_MASK		0xE0
+#define FIFO_MODE_BYPASS	0x00
+#define FIFO_MODE_FIFO		0x20
+#define FIFO_MODE_STREAM	0x40
+#define FIFO_MODE_STR2FIFO	0x60
+#define FIFO_MODE_BYPASS2STR	0x80
+#define FIFO_WATERMARK_MASK	0x1F
+
+#define FIFO_STORED_DATA_MASK	0x1F
+
+#define FUZZ			0
+#define FLAT			0
+
+/* RESUME STATE INDICES */
+#define RES_CTRL_REG1		0
+#define RES_CTRL_REG2		1
+#define RES_CTRL_REG3		2
+#define RES_CTRL_REG4		3
+#define RES_CTRL_REG5		4
+#define RES_FIFO_CTRL_REG	5
+
+#define LSM330DLC_GYR_MIN_POLL_PERIOD_MS	2
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones have to be set to -EINVAL
+ */
+#define LSM330DLC_GYR_DEFAULT_INT1_GPIO		-EINVAL
+#define LSM330DLC_GYR_DEFAULT_INT2_GPIO		-EINVAL
+
+/* Gyroscope Sensor Full Scale */
+#define LSM330DLC_GYR_FS_250DPS		0x00
+#define LSM330DLC_GYR_FS_500DPS		0x10
+#define LSM330DLC_GYR_FS_2000DPS	0x30
+
+/** Registers Contents */
+#define WHOAMI_LSM330DLC_GYR		0x00D4
+
+static int int1_gpio = LSM330DLC_GYR_DEFAULT_INT1_GPIO;
+static int int2_gpio = LSM330DLC_GYR_DEFAULT_INT2_GPIO;
+/* module_param(int1_gpio, int, S_IRUGO); */
+module_param(int2_gpio, int, S_IRUGO);
+
+/*
+ * LSM330DLC gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * signed short
+ */
+struct lsm330dlc_gyr_triple {
+	short x;
+	short y;
+	short z;
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+	{ 2,	ODR760 | BW10 },
+	{ 3,	ODR380 | BW01 },
+	{ 6,	ODR190 | BW00 },
+	{ 11,	ODR095 | BW00 },
+};
+
+static struct lsm330dlc_gyr_platform_data default_lsm330dlc_gyr_pdata = {
+	.fs_range = LSM330DLC_GYR_FS_250DPS,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+
+	.poll_interval = 100,
+	.min_interval = LSM330DLC_GYR_MIN_POLL_PERIOD_MS, /* 2ms */
+
+	.gpio_int1 = LSM330DLC_GYR_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LSM330DLC_GYR_DEFAULT_INT2_GPIO,	/* int for fifo */
+};
+
+static int lsm330dlc_gyr_register_update(struct lsm330dlc_gyr_dev *dev,
+					 u8 reg_address, u8 mask,
+					 u8 new_bit_values)
+{
+	int err;
+	u8 data, updated_val;
+
+	err = dev->tf->read(dev->dev, reg_address, 1, &data);
+	if (err < 0)
+		return err;
+	
+	updated_val = ((mask & new_bit_values) | (~mask & data));
+	err = dev->tf->write(dev->dev, reg_address, 1, &updated_val);
+
+	return err;
+}
+
+static int lsm330dlc_gyr_update_watermark(struct lsm330dlc_gyr_dev *dev,
+					  u8 watermark)
+{
+	int res;
+	u8 new_value;
+
+	mutex_lock(&dev->lock);
+	new_value = (watermark % 0x20);
+	res = lsm330dlc_gyr_register_update(dev, FIFO_CTRL_REG,
+					    FIFO_WATERMARK_MASK,
+					    new_value);
+	if (res < 0) {
+		dev_err(dev->dev, "failed to update watermark\n");
+		mutex_unlock(&dev->lock);
+		return res;
+	}
+
+#ifdef LSM303D_DEBUG
+	dev_dbg(dev->dev, "%s new_value: 0x%02x, watermark: 0x%02x\n",
+		__func__, new_value, watermark);
+#endif
+
+	dev->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_WATERMARK_MASK & new_value) |
+		 (~FIFO_WATERMARK_MASK & dev->resume_state[RES_FIFO_CTRL_REG]));
+	dev->watermark = new_value;
+	mutex_unlock(&dev->lock);
+
+	return res;
+}
+
+static int lsm330dlc_gyr_update_fifomode(struct lsm330dlc_gyr_dev *dev,
+					 u8 fifomode)
+{
+	int res;
+
+	res = lsm330dlc_gyr_register_update(dev, FIFO_CTRL_REG, FIFO_MODE_MASK,
+					    fifomode);
+	if (res < 0) {
+		dev_err(dev->dev, "failed to update fifoMode\n");
+		return res;
+	}
+
+	dev->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_MODE_MASK & fifomode) |
+		 (~FIFO_MODE_MASK & dev->resume_state[RES_FIFO_CTRL_REG]));
+	dev->fifomode = fifomode;
+
+	return res;
+}
+
+static int lsm330dlc_gyr_fifo_reset(struct lsm330dlc_gyr_dev *dev)
+{
+	int res;
+	u8 oldmode = dev->fifomode;
+
+	res = lsm330dlc_gyr_update_fifomode(dev, FIFO_MODE_BYPASS);
+	if (res < 0)
+		return res;
+
+	res = lsm330dlc_gyr_update_fifomode(dev, oldmode);
+	if (res >= 0)
+		dev_dbg(dev->dev, "%s fifo reset to: 0x%02x\n",
+			__func__, oldmode);
+
+	return res;
+}
+
+static int lsm330dlc_gyr_fifo_hwenable(struct lsm330dlc_gyr_dev *dev,
+				       u8 enable)
+{
+	int res;
+	u8 set = (enable) ? FIFO_ENABLE : 0;
+
+	res = lsm330dlc_gyr_register_update(dev, CTRL_REG5, FIFO_ENABLE, set);
+	if (res < 0) {
+		dev_err(dev->dev, "fifo_hw switch to:0x%02x failed\n", set);
+		return res;
+	}
+
+	dev->resume_state[RES_CTRL_REG5] =
+		((FIFO_ENABLE & set) |
+		 (~FIFO_ENABLE & dev->resume_state[RES_CTRL_REG5]));
+
+#ifdef LSM330DLC_DEBUG
+	dev_dbg(dev->dev, "%s set to:0x%02x\n", __func__, set);
+#endif
+
+	return res;
+}
+
+static int lsm330dlc_gyr_manage_int2settings(struct lsm330dlc_gyr_dev *dev,
+					     u8 fifomode)
+{
+	int res;
+	bool enable_fifo_hw, recognized_mode;
+	u8 int2bits = I2_NONE;
+
+	switch (fifomode) {
+	case FIFO_MODE_FIFO:
+	case FIFO_MODE_BYPASS:
+		recognized_mode = true;
+
+		int2bits = I2_NONE;
+
+		res = lsm330dlc_gyr_register_update(dev, CTRL_REG3, I2_MASK,
+						    int2bits);
+		if (res < 0) {
+			dev_err(dev->dev,
+				"%s : failed to update to CTRL_REG3: 0x%02x\n",
+				__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		dev->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			 (~I2_MASK & dev->resume_state[RES_CTRL_REG3]));
+		enable_fifo_hw = false;
+		break;
+
+	default:
+		recognized_mode = false;
+		res = lsm330dlc_gyr_register_update(dev, CTRL_REG3, I2_MASK,
+						    I2_NONE);
+		if (res < 0) {
+			dev_err(dev->dev,
+				"%s : failed to update CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			goto err_mutex_unlock;
+		}
+		enable_fifo_hw = false;
+		dev->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & 0x00) |
+			 (~I2_MASK & dev->resume_state[RES_CTRL_REG3]));
+		break;
+
+	}
+
+	if (recognized_mode) {
+		res = lsm330dlc_gyr_update_fifomode(dev, fifomode);
+		if (res < 0) {
+			dev_err(dev->dev,
+				"%s : failed to set fifoMode\n", __func__);
+			goto err_mutex_unlock;
+		}
+	}
+	res = lsm330dlc_gyr_fifo_hwenable(dev, enable_fifo_hw);
+
+err_mutex_unlock:
+
+	return res;
+}
+
+static int lsm330dlc_gyr_update_fs_range(struct lsm330dlc_gyr_dev *dev,
+					 u8 new_fs)
+{
+	int res ;
+
+	res = lsm330dlc_gyr_register_update(dev, CTRL_REG4, FS_MASK, new_fs);
+	if (res < 0) {
+		dev_err(dev->dev, "%s : failed to update fs:0x%02x\n",
+			__func__, new_fs);
+		return res;
+	}
+
+	dev->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs) |
+		 (~FS_MASK & dev->resume_state[RES_CTRL_REG4]));
+
+	return res;
+}
+
+static int lsm330dlc_gyr_update_odr(struct lsm330dlc_gyr_dev *dev,
+				    u32 poll_interval_ms)
+{
+	if (atomic_read(&dev->enabled)) {
+		int err, i;
+		u8 data;
+
+		for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+			if ((odr_table[i].poll_rate_ms <= poll_interval_ms) ||
+			    (i == 0))
+				break;
+		}
+
+		data = odr_table[i].mask | (ENABLE_ALL_AXES + PM_NORMAL);
+
+		err = dev->tf->write(dev->dev, CTRL_REG1, 1, &data);
+		if (err < 0)
+			return err;
+
+		dev->resume_state[RES_CTRL_REG1] = data;
+	}
+
+
+	return 0;
+}
+
+/* gyroscope data readout */
+static int lsm330dlc_gyr_get_data(struct lsm330dlc_gyr_dev *dev,
+				  struct lsm330dlc_gyr_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6];
+	/* y,p,r hardware data */
+	s16 hw_d[3];
+
+	err = dev->tf->read(dev->dev, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s16)(((gyro_out[1]) << 8) | gyro_out[0]);
+	hw_d[1] = (s16)(((gyro_out[3]) << 8) | gyro_out[2]);
+	hw_d[2] = (s16)(((gyro_out[5]) << 8) | gyro_out[4]);
+
+	data->x = ((dev->pdata->negate_x) ? (-hw_d[dev->pdata->axis_map_x])
+		   : (hw_d[dev->pdata->axis_map_x]));
+	data->y = ((dev->pdata->negate_y) ? (-hw_d[dev->pdata->axis_map_y])
+		   : (hw_d[dev->pdata->axis_map_y]));
+	data->z = ((dev->pdata->negate_z) ? (-hw_d[dev->pdata->axis_map_z])
+		   : (hw_d[dev->pdata->axis_map_z]));
+
+	return err;
+}
+
+static void lsm330dlc_gyr_report_values(struct lsm330dlc_gyr_dev *dev,
+					struct lsm330dlc_gyr_triple *data)
+{
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, data->x);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, data->y);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, data->z);
+	input_sync(dev->input_dev);
+}
+
+static int lsm330dlc_gyr_hw_init(struct lsm330dlc_gyr_dev *dev)
+{
+	int err;
+	u8 buf[5];
+
+	buf[0] = dev->resume_state[RES_CTRL_REG1];
+	buf[1] = dev->resume_state[RES_CTRL_REG2];
+	buf[2] = dev->resume_state[RES_CTRL_REG3];
+	buf[3] = dev->resume_state[RES_CTRL_REG4];
+	buf[4] = dev->resume_state[RES_CTRL_REG5];
+
+	err = dev->tf->write(dev->dev, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	buf[0] = dev->resume_state[RES_FIFO_CTRL_REG];
+	err = dev->tf->write(dev->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+			return err;
+
+	dev->hw_initialized = 1;
+
+	return err;
+}
+
+static void lsm330dlc_gyr_device_power_off(struct lsm330dlc_gyr_dev *dev)
+{
+	int err;
+	u8 data = PM_OFF;
+
+	err = dev->tf->write(dev->dev, CTRL_REG1, 1, &data);
+	if (err < 0)
+		dev_err(dev->dev, "soft power off failed\n");
+
+	if (dev->pdata->power_off) {
+		/* disable_irq_nosync(acc->irq1); */
+		disable_irq_nosync(dev->irq);
+		dev->pdata->power_off();
+		dev->hw_initialized = 0;
+	}
+
+	if (dev->hw_initialized) {
+		if (dev->pdata->gpio_int2 >= 0) {
+			disable_irq_nosync(dev->irq);
+			dev_info(dev->dev, "power off: irq disabled\n");
+		}
+		dev->hw_initialized = 0;
+	}
+}
+
+static int lsm330dlc_gyr_device_power_on(struct lsm330dlc_gyr_dev *dev)
+{
+	int err;
+
+	if (dev->pdata->power_on) {
+		err = dev->pdata->power_on();
+		if (err < 0)
+			return err;
+		if (dev->pdata->gpio_int2 >= 0)
+			enable_irq(dev->irq);
+	}
+
+	if (!dev->hw_initialized) {
+		err = lsm330dlc_gyr_hw_init(dev);
+		if (err < 0) {
+			lsm330dlc_gyr_device_power_off(dev);
+			return err;
+		}
+	}
+
+	if (dev->hw_initialized) {
+		dev_dbg(dev->dev, "dev->pdata->gpio_int2 = %d\n",
+			dev->pdata->gpio_int2);
+		if (dev->pdata->gpio_int2 >= 0) {
+			enable_irq(dev->irq);
+			dev_info(dev->dev, "power on: irq enabled\n");
+		}
+	}
+
+	return 0;
+}
+
+static int lsm330dlc_gyr_enable(struct lsm330dlc_gyr_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled, 0, 1)) {
+		int err;
+
+		err = lsm330dlc_gyr_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled, 0);
+			return err;
+		}
+		schedule_delayed_work(&dev->input_work,
+			msecs_to_jiffies(dev->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lsm330dlc_gyr_disable(struct lsm330dlc_gyr_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&dev->input_work);
+		lsm330dlc_gyr_device_power_off(dev);
+	}
+
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *device,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	int val;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata->poll_interval;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *device,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	unsigned long interval_ms;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, dev->pdata->min_interval);
+
+	mutex_lock(&dev->lock);
+	dev->pdata->poll_interval = interval_ms;
+	lsm330dlc_gyr_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+	int range = 0;
+
+	mutex_lock(&dev->lock);
+	switch (dev->pdata->fs_range) {
+	case LSM330DLC_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case LSM330DLC_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case LSM330DLC_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int err;
+	u8 range;
+	unsigned long val;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 250:
+		range = LSM330DLC_GYR_FS_250DPS;
+		break;
+	case 500:
+		range = LSM330DLC_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = LSM330DLC_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(dev->dev, "invalid range request: %lu\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lsm330dlc_gyr_update_fs_range(dev, range);
+	if (err >= 0)
+		dev->pdata->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *device,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+	int val = atomic_read(&dev->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm330dlc_gyr_enable(dev);
+	else
+		lsm330dlc_gyr_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_watermark_store(struct device *device,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	int res;
+	unsigned long watermark;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 16, &watermark))
+		return -EINVAL;
+
+	res = lsm330dlc_gyr_update_watermark(dev, watermark);
+	if (res < 0)
+		return res;
+
+	return size;
+}
+
+static ssize_t attr_watermark_show(struct device *device,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+	int val = dev->watermark;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_fifomode_store(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long fifomode;
+	int res;
+
+	if (strict_strtoul(buf, 16, &fifomode))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	res = lsm330dlc_gyr_manage_int2settings(dev, (u8)fifomode);
+	mutex_unlock(&dev->lock);
+
+	return (res < 0) ? res : size;
+}
+
+static ssize_t attr_fifomode_show(struct device *device,
+				  struct device_attribute *attr, char *buf)
+{
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+	u8 val = dev->fifomode;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+#ifdef LSM330DLC_DEBUG
+static ssize_t attr_reg_set(struct device *device,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->write(dev->dev, dev->reg_addr, 1, val);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *device,
+			    struct device_attribute *attr, char *buf)
+{
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+	int err;
+	u8 data;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, dev->reg_addr, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *device, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm330dlc_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	dev->reg_addr = val;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+#endif /* LSM330DLC_DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0644, attr_polling_rate_show,
+	       attr_polling_rate_store),
+	__ATTR(range, 0644, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0644, attr_enable_show, attr_enable_store),
+	__ATTR(fifo_samples, 0644, attr_watermark_show, attr_watermark_store),
+	__ATTR(fifo_mode, 0644, attr_fifomode_show, attr_fifomode_store),
+#ifdef LSM330DLC_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void lsm330dlc_gyr_report_triple(struct lsm330dlc_gyr_dev *dev)
+{
+	int err;
+	struct lsm330dlc_gyr_triple data_out;
+
+	err = lsm330dlc_gyr_get_data(dev, &data_out);
+	if (err < 0)
+		dev_err(dev->dev, "get_gyroscope_data failed\n");
+	else
+		lsm330dlc_gyr_report_values(dev, &data_out);
+}
+
+static void lsm330dlc_gyr_input_work_func(struct work_struct *work)
+{
+	struct lsm330dlc_gyr_dev *dev;
+
+	dev = container_of((struct delayed_work *)work,
+			    struct lsm330dlc_gyr_dev, input_work);
+
+	mutex_lock(&dev->lock);
+	lsm330dlc_gyr_report_triple(dev);
+	schedule_delayed_work(&dev->input_work,
+			      msecs_to_jiffies(dev->pdata->poll_interval));
+	mutex_unlock(&dev->lock);
+}
+
+static void lsm330dlc_gyr_irq_fifo(struct lsm330dlc_gyr_dev *dev)
+{
+	mutex_lock(&dev->lock);
+
+	switch (dev->fifomode) {
+	case FIFO_MODE_BYPASS: {
+		dev_dbg(dev->dev, "%s : fifomode:0x%02x\n", __func__,
+			dev->fifomode);
+		lsm330dlc_gyr_report_triple(dev);
+		break;
+	}
+	case FIFO_MODE_FIFO: {
+		int err;
+		u8 stored_samples, int_source, samples = (dev->watermark) + 1;
+
+		dev_dbg(dev->dev, "%s : FIFO_SRC_REG init samples:%d\n",
+			__func__, samples);
+
+		err = dev->tf->read(dev->dev, FIFO_SRC_REG, 1, &int_source);
+		if (err < 0) {
+			dev_err(dev->dev, "error reading fifo source reg\n");
+		}
+
+		dev_dbg(dev->dev, "%s :FIFO_SRC_REG content:0x%02x\n",
+			__func__, int_source);
+
+		stored_samples = int_source & FIFO_STORED_DATA_MASK;
+		dev_dbg(dev->dev, "%s : fifomode:0x%02x\n", __func__,
+			dev->fifomode);
+
+		dev_dbg(dev->dev, "%s : samples:%d stored:%d\n",
+			__func__, samples, stored_samples);
+
+		for (; samples > 0; samples--) {
+			dev_dbg(dev->dev, "%s : current sample:%d\n",
+				__func__, samples);
+			lsm330dlc_gyr_report_triple(dev);
+		}
+
+		lsm330dlc_gyr_fifo_reset(dev);
+		break;
+	}
+	}
+
+	mutex_unlock(&dev->lock);
+}
+
+static irqreturn_t lsm330dlc_gyr_isr(int irq, void *data)
+{
+	struct lsm330dlc_gyr_dev *dev = data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq_work_queue, &dev->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm330dlc_gyr_irq_work_func(struct work_struct *work)
+{
+
+	struct lsm330dlc_gyr_dev *dev;
+
+	dev = container_of(work, struct lsm330dlc_gyr_dev, irq_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm330dlc_gyr_irq_XXX(stat); */
+	lsm330dlc_gyr_irq_fifo(dev);
+	enable_irq(dev->irq);
+}
+
+static int lsm330dlc_gyr_validate_pdata(struct lsm330dlc_gyr_dev *dev)
+{
+	/* checks for correctness of minimal polling period */
+	dev->pdata->min_interval =
+		max((unsigned int)LSM330DLC_GYR_MIN_POLL_PERIOD_MS,
+		    dev->pdata->min_interval);
+
+	dev->pdata->poll_interval = max(dev->pdata->poll_interval,
+					dev->pdata->min_interval);
+
+	if (dev->pdata->axis_map_x > 2 || dev->pdata->axis_map_y > 2 ||
+	    dev->pdata->axis_map_z > 2) {
+		dev_err(dev->dev, "invalid axis_map value x:%u y:%u z%u\n",
+			dev->pdata->axis_map_x, dev->pdata->axis_map_y,
+			dev->pdata->axis_map_z);
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (dev->pdata->negate_x > 1 || dev->pdata->negate_y > 1 ||
+	    dev->pdata->negate_z > 1) {
+		dev_err(dev->dev,
+			"invalid negate value x:%u y:%u z:%u\n",
+			dev->pdata->negate_x,
+			dev->pdata->negate_y,
+			dev->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (dev->pdata->poll_interval < dev->pdata->min_interval) {
+		dev_err(dev->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int lsm330dlc_gyr_input_init(struct lsm330dlc_gyr_dev *dev)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&dev->input_work, lsm330dlc_gyr_input_work_func);
+
+	dev->input_dev = input_allocate_device();
+	if (!dev->input_dev) {
+		dev_err(dev->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev->id.bustype = dev->bus_type;
+	dev->input_dev->dev.parent = dev->dev;
+	dev->input_dev->name = LSM330DLC_GYR_DEV_NAME;
+
+	input_set_drvdata(dev->input_dev, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev->mscbit);
+
+	err = input_register_device(dev->input_dev);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register input polled device %s\n",
+			dev->input_dev->name);
+		input_free_device(dev->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lsm330dlc_gyr_input_cleanup(struct lsm330dlc_gyr_dev *dev)
+{
+	input_unregister_device(dev->input_dev);
+	input_free_device(dev->input_dev);
+}
+
+int lsm330dlc_gyr_probe(struct lsm330dlc_gyr_dev *dev)
+{
+	int err = -1;
+
+	mutex_lock(&dev->lock);
+
+	dev->pdata = kmalloc(sizeof(*dev->pdata), GFP_KERNEL);
+	if (dev->pdata == NULL) {
+		dev_err(dev->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+
+	if (dev->dev->platform_data == NULL) {
+		default_lsm330dlc_gyr_pdata.gpio_int1 = int1_gpio;
+		default_lsm330dlc_gyr_pdata.gpio_int2 = int2_gpio;
+		memcpy(dev->pdata, &default_lsm330dlc_gyr_pdata,
+		       sizeof(*dev->pdata));
+		dev_info(dev->dev, "using default plaform_data\n");
+	} else {
+		memcpy(dev->pdata, dev->dev->platform_data,
+		       sizeof(*dev->pdata));
+	}
+
+	err = lsm330dlc_gyr_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (dev->pdata->init) {
+		err = dev->pdata->init();
+		if (err < 0) {
+			dev_err(dev->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	dev->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES |
+					   PM_NORMAL;
+	dev->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	dev->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	dev->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	dev->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	dev->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+
+	err = lsm330dlc_gyr_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&dev->enabled, 1);
+
+	err = lsm330dlc_gyr_update_fs_range(dev, dev->pdata->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = lsm330dlc_gyr_update_odr(dev, dev->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = lsm330dlc_gyr_input_init(dev);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "%s device register failed\n",
+			LSM330DLC_GYR_DEV_NAME);
+		goto err4;
+	}
+
+	lsm330dlc_gyr_device_power_off(dev);
+
+	/* As default, do not report information */
+	atomic_set(&dev->enabled, 0);
+
+	if (dev->pdata->gpio_int2 >= 0) {
+		dev->irq = gpio_to_irq(dev->pdata->gpio_int2);
+		dev_info(dev->dev, "%s: %s has set irq: %d mapped on gpio:%d\n",
+			 LSM330DLC_GYR_DEV_NAME, __func__, dev->irq,
+			 dev->pdata->gpio_int2);
+
+		INIT_WORK(&dev->irq_work, lsm330dlc_gyr_irq_work_func);
+		dev->irq_work_queue =
+			create_singlethread_workqueue("lsm330dlc_gyr_irq_wq");
+		if (!dev->irq_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev, "cannot create work queue2: %d\n",
+				err);
+			goto err5;
+		}
+
+		err = request_irq(dev->irq, lsm330dlc_gyr_isr,
+				  IRQF_TRIGGER_HIGH, "lsm330dlc_gyr_irq", dev);
+
+		if (err < 0) {
+			dev_err(dev->dev, "request irq failed: %d\n", err);
+			goto err6;
+		}
+		disable_irq_nosync(dev->irq);
+	}
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err6:
+	destroy_workqueue(dev->irq_work_queue);
+err5:
+	lsm330dlc_gyr_device_power_off(dev);
+	remove_sysfs_interfaces(dev->dev);
+err4:
+	lsm330dlc_gyr_input_cleanup(dev);
+err3:
+	lsm330dlc_gyr_device_power_off(dev);
+err2:
+	if (dev->pdata->exit)
+		dev->pdata->exit();
+err1_1:
+	kfree(dev->pdata);
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm330dlc_gyr_probe);
+
+int lsm330dlc_gyr_remove(struct lsm330dlc_gyr_dev *dev)
+{
+	/* if (dev->pdata->gpio_int1 >= 0)
+	{
+		free_irq(dev->irq1, dev);
+		gpio_free(dev->pdata->gpio_int1);
+		destroy_workqueue(dev->irq1_work_queue);
+	}
+	*/
+	if (dev->pdata->gpio_int2 >= 0) {
+		free_irq(dev->irq, dev);
+		gpio_free(dev->pdata->gpio_int2);
+		destroy_workqueue(dev->irq_work_queue);
+	}
+
+	lsm330dlc_gyr_disable(dev);
+	lsm330dlc_gyr_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+	kfree(dev->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm330dlc_gyr_remove);
+
+int lsm330dlc_gyr_resume(struct lsm330dlc_gyr_dev *dev)
+{
+	if (atomic_read(&dev->enabled)) {
+		int err;
+		mutex_lock(&dev->lock);
+		err = lsm330dlc_gyr_register_update(dev, CTRL_REG1, 0x0F,
+					(ENABLE_ALL_AXES | PM_NORMAL));
+		if (err < 0) {
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		schedule_delayed_work(&dev->input_work,
+				msecs_to_jiffies(dev->pdata->poll_interval));
+		mutex_unlock(&dev->lock);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lsm330dlc_gyr_resume);
+
+int lsm330dlc_gyr_suspend(struct lsm330dlc_gyr_dev *dev)
+{
+	if (atomic_read(&dev->enabled)) {
+		int err;
+
+		cancel_delayed_work_sync(&dev->input_work);
+		mutex_lock(&dev->lock);
+		err = lsm330dlc_gyr_register_update(dev, CTRL_REG1, 0x0F,
+						    PM_OFF);
+		if (err >= 0)
+			err = 0;
+		mutex_unlock(&dev->lock);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lsm330dlc_gyr_suspend);
+
+MODULE_DESCRIPTION("lsm330dlc digital gyroscope section driver");
+MODULE_AUTHOR("Matteo Dameno, Carmine Iascone, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_i2c.c b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_i2c.c
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm330dlc_gyr_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm330dlc.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm330dlc_gyr_i2c_read(struct device *dev, u8 addr, int len,
+				  u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm330dlc_gyr_i2c_write(struct device *dev, u8 addr, int len,
+				   u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm330dlc_transfer_function lsm330dlc_gyr_i2c_tf = {
+	.write = lsm330dlc_gyr_i2c_write,
+	.read = lsm330dlc_gyr_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330dlc_gyr_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330dlc_gyr_dev *dev = i2c_get_clientdata(client);
+
+	return lsm330dlc_gyr_resume(dev);
+}
+
+static int lsm330dlc_gyr_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm330dlc_gyr_dev *dev = i2c_get_clientdata(client);
+
+	return lsm330dlc_gyr_suspend(dev);
+}
+
+static const struct dev_pm_ops lsm330dlc_gyr_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330dlc_gyr_i2c_suspend,
+				lsm330dlc_gyr_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330dlc_gyr_i2c_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm330dlc_gyr_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm330dlc_gyr_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm330dlc_gyr_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm330dlc_gyr_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330dlc_gyr_i2c_remove(struct i2c_client *client)
+{
+	struct lsm330dlc_gyr_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm330dlc_gyr_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm330dlc_gyr_i2c_id[] = {
+	{ "lsm330dlc_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm330dlc_gyr_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330dlc_gyr_i2c_id_table[] = {
+	{ .compatible = "st,lsm330dlc_gyr", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330dlc_gyr_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm330dlc_gyr_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330dlc_gyr_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm330dlc_gyr_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330dlc_gyr_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330dlc_gyr_i2c_probe,
+	.remove = lsm330dlc_gyr_i2c_remove,
+	.id_table = lsm330dlc_gyr_i2c_id,
+};
+
+module_i2c_driver(lsm330dlc_gyr_i2c_driver);
+
+MODULE_DESCRIPTION("lsm330dlc gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_spi.c b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_spi.c
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc_gyr_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm330dlc_gyr_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm330dlc.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm330dlc_gyr_spi_read(struct device *device, u8 addr, int len,
+				  u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm330dlc_gyr_spi_write(struct device *device, u8 addr, int len,
+				   u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM330DLC_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static const struct lsm330dlc_transfer_function lsm330dlc_gyr_spi_tf = {
+	.write = lsm330dlc_gyr_spi_write,
+	.read = lsm330dlc_gyr_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm330dlc_gyr_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	return lsm330dlc_gyr_resume(dev);
+}
+
+static int lsm330dlc_gyr_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm330dlc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	return lsm330dlc_gyr_suspend(dev);
+}
+
+static const struct dev_pm_ops lsm330dlc_gyr_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm330dlc_gyr_spi_suspend,
+				lsm330dlc_gyr_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm330dlc_gyr_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm330dlc_gyr_dev *dev;
+
+#ifdef LSM330DLC_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm330dlc_gyr_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm330dlc_gyr_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm330dlc_gyr_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm330dlc_gyr_spi_remove(struct spi_device *spi)
+{
+	struct lsm330dlc_gyr_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LSM330DLC_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm330dlc_gyr_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm330dlc_gyr_spi_id[] = {
+	{ "lsm330dlc_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm330dlc_gyr_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm330dlc_gyr_spi_id_table[] = {
+	{ .compatible = "st,lsm330dlc_gyr" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm330dlc_gyr_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm330dlc_gyr_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm330dlc_gyr_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm330dlc_gyr_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm330dlc_gyr_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm330dlc_gyr_spi_probe,
+	.remove = lsm330dlc_gyr_spi_remove,
+	.id_table = lsm330dlc_gyr_spi_id,
+};
+
+module_spi_driver(lsm330dlc_gyr_spi_driver);
+
+MODULE_DESCRIPTION("lsm330dlc gyr spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc.h b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc.h
--- a/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/lsm330dlc.h	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,211 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm330dlc_sysfs.h
+* Authors            : MH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Carmine Iascone (carmine.iascone@st.com)
+		     : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+* Version            : V.1.0.12
+* Date               : 2016/May/06
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+/*******************************************************************************
+Version History.
+
+ Revision 1.0.10: 2011/Aug/16
+  merges release 1.0.10 acc + 1.1.5.3 gyr
+ Revision 1.0.11: 2012/Jan/09
+  moved under input/misc
+ Revision 1.0.12: 2012/Feb/29
+  renamed field g_range to fs_range in lsm330dlc_acc_platform_data
+  replaced defines SA0L and SA0H with LSM330DLC_SAD0x
+*******************************************************************************/
+
+#ifndef	__LSM330DLC_H__
+#define	__LSM330DLC_H__
+
+
+#define	LSM330DLC_ACC_DEV_NAME	"lsm330dlc_acc"
+#define LSM330DLC_GYR_DEV_NAME	"lsm330dlc_gyr"
+
+#define LSM330DLC_ACC_RESUME_ENTRIES	17
+#define LSM330DLC_GYR_RESUME_ENTRIES	6
+
+/* Input events used by lsm303agr driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+struct lsm330dlc_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LSM330DLC_SPI) || \
+    defined(CONFIG_INPUT_LSM330DLC_SPI_MODULE)
+#define LSM330DLC_RX_MAX_LENGTH		500
+#define LSM330DLC_TX_MAX_LENGTH		500
+
+struct lsm330dlc_transfer_buffer {
+	u8 rx_buf[LSM330DLC_RX_MAX_LENGTH];
+	u8 tx_buf[LSM330DLC_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LSM330DLC_SPI */
+
+struct lsm330dlc_acc_dev {
+	struct device *dev;
+	const char *name;
+	u16 bus_type;
+
+	int hw_initialized;
+	/* hw_working = -1 means not tested yet */
+	int hw_working;
+	atomic_t enabled;
+
+	u8 resume_state[LSM330DLC_ACC_RESUME_ENTRIES];
+	u8 sensitivity;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+
+	struct input_dev *input_dev;
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	const struct lsm330dlc_transfer_function *tf;
+
+	struct lsm330dlc_acc_platform_data *pdata;
+#if defined(CONFIG_INPUT_LSM330DLC_SPI) || \
+    defined(CONFIG_INPUT_LSM330DLC_SPI_MODULE)
+	struct lsm330dlc_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM330DLC_SPI */
+
+#ifdef LSM330DLC_DEBUG
+	u8 reg_addr;
+#endif
+};
+
+struct lsm330dlc_gyr_dev {
+	struct device *dev;
+	const char *name;
+	u16 bus_type;
+
+	struct lsm330dlc_gyr_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	atomic_t enabled;
+
+	u8 reg_addr;
+	u8 resume_state[LSM330DLC_GYR_RESUME_ENTRIES];
+
+	/* interrupt related */
+	int irq;
+	struct work_struct irq_work;
+	struct workqueue_struct *irq_work_queue;
+
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	const struct lsm330dlc_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM330DLC_SPI) || \
+    defined(CONFIG_INPUT_LSM330DLC_SPI_MODULE)
+	struct lsm330dlc_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM330DLC_SPI */
+};
+
+struct lsm330dlc_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	/* set gpio_int[1,2] either to the choosen gpio pin number or to -EINVAL
+	 * if leaved unconnected
+	 */
+	int gpio_int1;
+	int gpio_int2;
+};
+
+struct lsm330dlc_gyr_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	/* gpio ports for interrupt pads */
+	int gpio_int1;
+	int gpio_int2;		/* int for fifo */
+
+	/* axis mapping */
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+int lsm330dlc_acc_probe(struct lsm330dlc_acc_dev *dev);
+int lsm330dlc_acc_remove(struct lsm330dlc_acc_dev *dev);
+int lsm330dlc_acc_enable(struct lsm330dlc_acc_dev *dev);
+int lsm330dlc_acc_disable(struct lsm330dlc_acc_dev *dev);
+
+int lsm330dlc_gyr_probe(struct lsm330dlc_gyr_dev *dev);
+int lsm330dlc_gyr_remove(struct lsm330dlc_gyr_dev *dev);
+int lsm330dlc_gyr_resume(struct lsm330dlc_gyr_dev *dev);
+int lsm330dlc_gyr_suspend(struct lsm330dlc_gyr_dev *dev);
+
+#endif	/* __LSM330DLC_H__ */
+
diff -uNr a/drivers/input/misc/st/imu/lsm330dlc/Makefile b/drivers/input/misc/st/imu/lsm330dlc/Makefile
--- a/drivers/input/misc/st/imu/lsm330dlc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm330dlc/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the input misc STM imu lsm330dlc driver
+#
+obj-$(CONFIG_INPUT_LSM330DLC) += lsm330dlc_acc.o lsm330dlc_gyr.o
+obj-$(CONFIG_INPUT_LSM330DLC_I2C) += lsm330dlc_acc_i2c.o lsm330dlc_gyr_i2c.o
+obj-$(CONFIG_INPUT_LSM330DLC_SPI) += lsm330dlc_acc_spi.o lsm330dlc_gyr_spi.o
+
+# ccflags-y += -DLSM330DLC_DEBUG
diff -uNr a/drivers/input/misc/st/imu/lsm6dl0/Kconfig b/drivers/input/misc/st/imu/lsm6dl0/Kconfig
--- a/drivers/input/misc/st/imu/lsm6dl0/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dl0/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LSM6DL0
+	tristate "STMicroelectronics LSM6DL0 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM6DL0_I2C if (I2C)
+	select INPUT_LSM6DL0_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM6DL0 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm6dl0.
+
+config INPUT_LSM6DL0_I2C
+	tristate
+	depends on INPUT_LSM6DL0
+	depends on I2C
+
+config INPUT_LSM6DL0_SPI
+	tristate
+	depends on INPUT_LSM6DL0
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_core.c b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_core.c
--- a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_core.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,2511 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ******************
+*
+* File Name		: lsm6dl0_core.c
+* Author		: MSH - C&I BU - Application Team
+*			: Giuseppe Barba (giuseppe.barba@st.com)
+*			: Author is willing to be considered the contact
+*			: and update point for the driver.
+* Version		: V.1.1.0
+* Date			: 2016/May/13
+* Description		: LSM6DL0 driver
+*
+******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*****************************************************************************/
+//#define DEBUG
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm6dl0.h"
+
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+#define COMP_X_FACTOR_ADDR		0x7F
+#define COMP_Y_FACTOR_ADDR		0xF0
+#define COMP_Z_FACTOR_ADDR		0xF1
+#define COMP_HW_DISABLE_MASK		0xC0
+#endif
+
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+#define LSM6DL0_GYR_LPF1		0
+#define LSM6DL0_GYR_LPF1_2		1
+#define LSM6DL0_GYR_LP_TH_US		(LSM6DL0_ODR_US_100)
+
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL
+#define CONFIG_INPUT_LSM6DL0_S_MODEL_LP
+#endif
+#endif
+
+#define MS_TO_US(x)			(x * 1000L)
+#define US_TO_NS(x)			(x * 1000L)
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define NS_TO_US(x)			(x / 1000)
+#define US_TO_MS(x)			(x / 1000)
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+#define REFERENCE_G			0x0B
+
+/* TODO: check the following values */
+/* Sensitivity */
+#define SENSITIVITY_ACC_2G		61	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		122	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		244	/** ug/LSB */
+#define SENSITIVITY_GYR_250		8750	/** udps/LSB */
+#define SENSITIVITY_GYR_500		17500	/** udps/LSB */
+#define SENSITIVITY_GYR_2000		70000	/** udps/LSB */
+#define SENSITIVITY_TEMP		16	/** LSB/C */
+#define OFFSET_TEMP			25	/** Offset temperature */
+
+#define ACC_G_MAX_POS			1495040	/** max positive value acc [ug] */
+#define ACC_G_MAX_NEG			1495770	/** max negative value acc [ug] */
+#define GYR_FS_MAX			32768
+
+#define FUZZ				0
+#define FLAT				0
+
+#define FILTER_50			50	/** Anti-Aliasing 50 Hz */
+#define FILTER_100			100	/** Anti-Aliasing 105 Hz */
+#define FILTER_200			200	/** Anti-Aliasing 211 Hz */
+#define FILTER_400			400	/** Anti-Aliasing 408 Hz */
+
+#define RANGE_245DPS			245
+#define RANGE_500DPS			500
+#define RANGE_2000DPS			2000
+
+#define ACT_THS				0x04
+#define ACT_DUR				0x05
+#define WHO_AM_I			0x0F
+#define WHO_AM_I_VAL			0x68
+
+/* Angular rate sensor Control Register 1 */
+#define CTRL_REG1_G			0x10
+
+#define BW_G_SHIFT			0
+#define BW_G_MASK			0x03
+
+#define FS_G_SHIFT			3
+#define FS_G_MASK			0x18
+
+/* Angular rate sensor Control Register 2 */
+#define CTRL_REG2_G			0x11
+
+#define OUT_SEL_SHIFT			0
+#define OUT_SEL_MASK			0x03
+
+#define INT_SEL_SHIFT			2
+#define INT_SEL_MASK			0x0C
+
+#define CTRL_REG3_G			0x12
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+#define CTRL_REG3_G_LP_MODE_MASK	0x80
+#endif
+
+/* Angular rate sensor sign and orientation register. */
+#define ORIENT_CFG_G			0x13
+#define ORIENT_CFG_G_SIGN_X_MASK	0x20
+#define ORIENT_CFG_G_SIGN_Y_MASK	0x10
+#define ORIENT_CFG_G_SIGN_Z_MASK	0x08
+#define ORIENT_CFG_G_SIGN_ORIENT_MASK	0x07
+#define OUT_TEMP_L			0x15
+#define OUT_TEMP_H			0x16
+#define STATUS_REG1			0x17
+#define	OUT_X_L_G			0x18 /* 1st AXIS OUT REG of 6 */
+#define CTRL_REG4			0x1E
+#define CTRL_REG4_DEF			0x38
+#define CTRL_REG4_X_EN			0x08
+#define CTRL_REG4_Y_EN			0x10
+#define CTRL_REG4_Z_EN			0x20
+#define CTRL_REG4_ALL_AXES_EN		0x38
+#define CTRL_REG4_AXES_EN_MASK		0x38
+#define CTRL_REG5_XL			0x1F
+#define CTRL_REG5_XL_DEF		0x38
+#define CTRL_REG6_XL			0x20
+#define LSM6DL0_ACC_FS_DEF		LSM6DL0_ACC_FS_2G
+#define BW_SCAL_ODR_SHIFT		2
+#define BW_SCAL_ODR_MASK		0x04
+#define BW_XL_50			0x0C
+#define BW_XL_105			0x08
+#define BW_XL_211			0x04
+#define BW_XL_408			0x00
+#define BW_XL_DEF			BW_XL_408
+#define CTRL_REG7_XL			0x21
+#define CTRL_REG8			0x22
+#define CTRL_REG8_DEF			0x44
+#define CTRL_REG9			0x23
+#define CTRL_REG10			0x24
+#define STATUS_REG2			0x27
+#define OUT_X_L_XL			0x28 /* 1st AXIS OUT REG of 6 */
+#define FIFO_CTRL			0x2E
+#define FIFO_SRC			0x2F
+/* INT1_A/G pin control register. */
+#define INT1_CTRL			0x0C
+#define INT1_CTRL_IG_G_MASK		0x80
+#define INT1_CTRL_IG_XL_MASK		0x40
+#define INT1_CTRL_FSS5_MASK		0x20
+#define INT1_CTRL_OVR_MASK		0x10
+#define INT1_CTRL_FTH_MASK		0x08
+#define INT1_CTRL_BOOT_MASK		0x04
+#define INT1_CTRL_DRDY_G_MASK		0x02
+#define INT1_CTRL_DRDY_XL_MASK		0x01
+
+/* INT2_A/G pin control register. */
+#define INT2_CTRL			0x0D
+#define INT2_CTRL_INACT_MASK		0x80
+#define INT2_CTRL_FSS5_MASK		0x20
+#define INT2_CTRL_OVR_MASK		0x10
+#define INT2_CTRL_FTH_MASK		0x08
+#define INT2_CTRL_DRDY_TEMP_MASK	0x04
+#define INT2_CTRL_DRDY_G_MASK		0x02
+#define INT2_CTRL_DRDY_XL_MASK		0x01
+
+/* Linear acceleration sensor interrupt source register. */
+#define INT_GEN_SRC_XL			0x26
+#define INT_GEN_SRC_XL_IA_MASK		0x40
+#define INT_GEN_SRC_XL_ZH_MASK		0x20
+#define INT_GEN_SRC_XL_ZL_MASK		0x10
+#define INT_GEN_SRC_XL_YH_MASK		0x08
+#define INT_GEN_SRC_XL_YL_MASK		0x04
+#define INT_GEN_SRC_XL_XH_MASK		0x02
+#define INT_GEN_SRC_XL_XL_MASK		0x01
+
+/* Linear acceleration sensor interrupt generator configuration register. */
+#define INT_GEN_CFG_XL			0x06
+#define INT_GEN_CFG_XL_AOI_MASK		0x80
+#define INT_GEN_CFG_XL_6D_MASK		0x40
+#define INT_GEN_CFG_XL_ZHIE_MASK	0x20
+#define INT_GEN_CFG_XL_ZLIE_MASK	0x10
+#define INT_GEN_CFG_XL_YHIE_MASK	0x08
+#define INT_GEN_CFG_XL_YLIE_MASK	0x04
+#define INT_GEN_CFG_XL_XHIE_MASK	0x02
+#define INT_GEN_CFG_XL_XLIE_MASK	0x01
+
+/* Linear acceleration sensor interrupt threshold registers. */
+#define INT_GEN_THS_X_XL		0x07
+#define INT_GEN_THS_Y_XL		0x08
+#define INT_GEN_THS_Z_XL		0x09
+
+/* Linear acceleration sensor interrupt duration register. */
+#define INT_GEN_DUR_XL			0x0A
+#define INT_GEN_DUR_XL_WAIT_MASK	0x80
+#define INT_GEN_DUR_XL_DUR_MASK		0x7F
+
+/* Angular rate sensor interrupt source register. */
+#define INT_GEN_SRC_G			0x14
+#define INT_GEN_SRC_G_IA_MASK		0x40
+#define INT_GEN_SRC_G_ZH_MASK		0x20
+#define INT_GEN_SRC_G_ZL_MASK		0x10
+#define INT_GEN_SRC_G_YH_MASK		0x08
+#define INT_GEN_SRC_G_YL_MASK		0x04
+#define INT_GEN_SRC_G_XH_MASK		0x02
+#define INT_GEN_SRC_G_XL_MASK		0x01
+
+/* Angular rate sensor interrupt generator configuration register. */
+#define INT_GEN_CFG_G			0x30
+#define INT_GEN_CFG_G_AOI_MASK		0x80
+#define INT_GEN_CFG_G_LIR_MASK		0x40
+#define INT_GEN_CFG_G_ZHIE_MASK		0x20
+#define INT_GEN_CFG_G_ZLIE_MASK		0x10
+#define INT_GEN_CFG_G_YHIE_MASK		0x08
+#define INT_GEN_CFG_G_YLIE_MASK		0x04
+#define INT_GEN_CFG_G_XHIE_MASK		0x02
+#define INT_GEN_CFG_G_XLIE_MASK		0x01
+
+/* Angular rate sensor interrupt generator threshold registers. */
+#define INT_GEN_THS_XH_G		0x31
+#define INT_GEN_THS_XL_G		0x32
+#define INT_GEN_THS_YH_G		0x33
+#define INT_GEN_THS_YL_G		0x34
+#define INT_GEN_THS_ZH_G		0x35
+#define INT_GEN_THS_ZL_G		0x36
+
+/* Angular rate sensor interrupt generator duration register. */
+#define INT_GEN_DUR_G			0x37
+#define INT_GEN_DUR_G_WAIT_MASK		0x80
+#define INT_GEN_DUR_G_DUR_MASK		0x7F
+
+#define DEF_ZERO			0x00
+#define UNDEF				0x00
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+#define LSM6DL0_ATTTR(_name, _leaf, _mode, _show, _store) \
+	struct device_attribute lsm6dl0_attr_##_name = __ATTR(_leaf, _mode, _show, _store)
+
+static struct workqueue_struct *lsm6dl0_workqueue;
+
+
+struct output_rate{
+	uint32_t cutoff_us;
+	uint8_t value;
+};
+
+static const struct output_rate lsm6dl0_gyr_odr_table[] = {
+	{ LSM6DL0_ODR_US_110, (LSM6DL0_GYR_ODR_110 | (LSM6DL0_GYR_BW_11)) },
+	{ LSM6DL0_ODR_US_101, (LSM6DL0_GYR_ODR_101 | (LSM6DL0_GYR_BW_11)) },
+	{ LSM6DL0_ODR_US_100, (LSM6DL0_GYR_ODR_100 | (LSM6DL0_GYR_BW_11)) },
+	{ LSM6DL0_ODR_US_011, (LSM6DL0_GYR_ODR_011 | (LSM6DL0_GYR_BW_11)) },
+	{ LSM6DL0_ODR_US_010, (LSM6DL0_GYR_ODR_010 | (LSM6DL0_GYR_BW_11)) },
+	{ LSM6DL0_ODR_US_001, (LSM6DL0_GYR_ODR_001) },
+};
+
+static const struct output_rate lsm6dl0_acc_odr_table[] = {
+        { LSM6DL0_ODR_US_110, (LSM6DL0_GYR_ODR_110) },
+        { LSM6DL0_ODR_US_101, (LSM6DL0_GYR_ODR_101) },
+        { LSM6DL0_ODR_US_100, (LSM6DL0_GYR_ODR_100) },
+        { LSM6DL0_ODR_US_011, (LSM6DL0_GYR_ODR_011) },
+        { LSM6DL0_ODR_US_010, (LSM6DL0_GYR_ODR_010) },
+        { LSM6DL0_ODR_US_001, (LSM6DL0_GYR_ODR_001) },
+};
+
+struct discard_list {
+	uint32_t param;
+	uint8_t count;
+};
+
+static const struct acc_turn_on_time {
+	uint32_t odr_us;
+	struct discard_list disc_list[4];
+} lsm6dl0_acc_turn_on_time [] = {
+	{ LSM6DL0_ODR_US_110,{	{ LSM6DL0_ACC_BW_400, 2},
+				{ LSM6DL0_ACC_BW_200, 4},
+				{ LSM6DL0_ACC_BW_100, 7},
+				{ LSM6DL0_ACC_BW_50,  14},},},
+	{ LSM6DL0_ODR_US_101,{	{ LSM6DL0_ACC_BW_400, 1},
+				{ LSM6DL0_ACC_BW_200, 2},
+				{ LSM6DL0_ACC_BW_100, 4},
+				{ LSM6DL0_ACC_BW_50,  7},},},
+	{ LSM6DL0_ODR_US_100,{	{ LSM6DL0_ACC_BW_400, 1},
+				{ LSM6DL0_ACC_BW_200, 1},
+				{ LSM6DL0_ACC_BW_100, 2},
+				{ LSM6DL0_ACC_BW_50,  4},},},
+	{ LSM6DL0_ODR_US_011,{	{ LSM6DL0_ACC_BW_400, 1},
+				{ LSM6DL0_ACC_BW_200, 1},
+				{ LSM6DL0_ACC_BW_100, 1},
+				{ LSM6DL0_ACC_BW_50,  2},},},
+	{ LSM6DL0_ODR_US_010,{	{ LSM6DL0_ACC_BW_400, 0},
+				{ LSM6DL0_ACC_BW_200, 0},
+				{ LSM6DL0_ACC_BW_100, 0},
+				{ LSM6DL0_ACC_BW_50,  0},},},
+	{ LSM6DL0_ODR_US_001,{	{ LSM6DL0_ACC_BW_400, 0},
+				{ LSM6DL0_ACC_BW_200, 0},
+				{ LSM6DL0_ACC_BW_100, 0},
+				{ LSM6DL0_ACC_BW_50,  0},},},
+};
+
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+static const struct gyr_turn_on_time {
+	uint32_t odr_us;
+	struct discard_list disc_list[2];
+} lsm6dl0_gyr_turn_on_time [] = {
+	{ LSM6DL0_ODR_US_110,{	{ LSM6DL0_GYR_LPF1,   8},
+				{ LSM6DL0_GYR_LPF1_2, 18},},},
+	{ LSM6DL0_ODR_US_101,{	{ LSM6DL0_GYR_LPF1,   5},
+				{ LSM6DL0_GYR_LPF1_2, 15},},},
+	{ LSM6DL0_ODR_US_100,{	{ LSM6DL0_GYR_LPF1,   4},
+				{ LSM6DL0_GYR_LPF1_2, 14},},},
+	{ LSM6DL0_ODR_US_011,{	{ LSM6DL0_GYR_LPF1,   3},
+				{ LSM6DL0_GYR_LPF1_2, 13},},},
+	{ LSM6DL0_ODR_US_010,{	{ LSM6DL0_GYR_LPF1,   3},
+				{ LSM6DL0_GYR_LPF1_2, 13},},},
+	{ LSM6DL0_ODR_US_001,{	{ LSM6DL0_GYR_LPF1,   2},
+				{ LSM6DL0_GYR_LPF1_2, 0},},},
+};
+#endif
+
+static const struct lsm6dl0_acc_platform_data default_lsm6dl0_acc_pdata = {
+	.fs_range = LSM6DL0_ACC_FS_2G,
+	.poll_interval = LSM6DL0_ACC_POLL_INTERVAL_DEF,
+	.min_interval = LSM6DL0_ACC_MIN_POLL_PERIOD_US,
+	.aa_filter_bandwidth = LSM6DL0_ACC_BW_400,
+};
+
+static const struct lsm6dl0_gyr_platform_data default_lsm6dl0_gyr_pdata = {
+	.fs_range = LSM6DL0_GYR_FS_245DPS,
+	.poll_interval = LSM6DL0_GYR_POLL_INTERVAL_DEF,
+	.min_interval = LSM6DL0_GYR_MIN_POLL_PERIOD_US,
+};
+
+struct lsm6dl0_main_platform_data default_lsm6dl0_main_platform_data = {
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+	.gpio_int1 = LSM6DL0_INT1_GPIO_DEF,
+	.gpio_int2 = LSM6DL0_INT2_GPIO_DEF,
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	uint8_t address;
+	uint8_t mask;
+};
+
+struct interrupt_value {
+	int32_t value;
+	uint8_t address;
+};
+
+
+struct reg_rw {
+	uint8_t address;
+	uint8_t default_val;
+	uint8_t resume_val;
+};
+
+struct reg_r {
+	uint8_t address;
+	uint8_t default_val;
+};
+
+static struct status_registers {
+	struct reg_rw act_ths;
+	struct reg_rw act_dur;
+	struct reg_rw int_gen_cfg_xl;
+	struct reg_rw int_gen_ths_x_xl;
+	struct reg_rw int_gen_ths_y_xl;
+	struct reg_rw int_gen_ths_z_xl;
+	struct reg_rw int_gen_dur_xl;
+	struct reg_rw reference_g;
+	struct reg_rw int1_ctrl;
+	struct reg_rw int2_ctrl;
+	struct reg_r who_am_i;
+	struct reg_rw ctrl_reg1_g;
+	struct reg_rw ctrl_reg2_g;
+	struct reg_rw ctrl_reg3_g;
+	struct reg_rw orient_cfg_g;
+	struct reg_r int_gen_src_g;
+	struct reg_r status_reg1;
+	struct reg_rw ctrl_reg4;
+	struct reg_rw ctrl_reg5_xl;
+	struct reg_rw ctrl_reg6_xl;
+	struct reg_rw ctrl_reg7_xl;
+	struct reg_rw ctrl_reg8;
+	struct reg_rw ctrl_reg9;
+	struct reg_rw ctrl_reg10;
+	struct reg_r int_gen_src_xl;
+	struct reg_r status_reg2;
+	struct reg_rw fifo_ctrl;
+	struct reg_r fifo_src;
+	struct reg_rw int_gen_cfg_g;
+	struct reg_rw int_gen_ths_xh_g;
+	struct reg_rw int_gen_ths_xl_g;
+	struct reg_rw int_gen_ths_yh_g;
+	struct reg_rw int_gen_ths_yl_g;
+	struct reg_rw int_gen_ths_zh_g;
+	struct reg_rw int_gen_ths_zl_g;
+	struct reg_rw int_gen_dur_g;
+} status_registers = {
+	.act_ths =
+		{.address = ACT_THS, 		.default_val = DEF_ZERO,},
+	.act_dur =
+		{.address = ACT_DUR, 		.default_val = DEF_ZERO,},
+	.int_gen_cfg_xl =
+		{.address = INT_GEN_CFG_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_x_xl =
+		{.address = INT_GEN_THS_X_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_y_xl =
+		{.address = INT_GEN_THS_Y_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_z_xl =
+		{.address = INT_GEN_THS_Z_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_dur_xl =
+		{.address = INT_GEN_DUR_XL, 	.default_val = DEF_ZERO,},
+	.reference_g =
+		{.address = REFERENCE_G, 	.default_val = DEF_ZERO,},
+	.int1_ctrl =
+		{.address = INT1_CTRL,		.default_val = DEF_ZERO,},
+	.int2_ctrl =
+		{.address = INT2_CTRL,		.default_val = DEF_ZERO,},
+	.who_am_i =
+		{.address = WHO_AM_I,		.default_val = WHO_AM_I_VAL,},
+	.ctrl_reg1_g =
+		{.address = CTRL_REG1_G,	.default_val = DEF_ZERO,},
+	.ctrl_reg2_g =
+		{.address = CTRL_REG2_G,	.default_val = DEF_ZERO,},
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL_LP
+		/** LSM6L0 require the LP bit to be set to 0 */
+	.ctrl_reg3_g =
+		{.address = CTRL_REG3_G,
+				.default_val = CTRL_REG3_G_LP_MODE_MASK,},
+#else
+	.ctrl_reg3_g =
+		{.address = CTRL_REG3_G,	.default_val = DEF_ZERO,},
+#endif
+	.orient_cfg_g =
+		{.address = ORIENT_CFG_G,	.default_val = DEF_ZERO,},
+	.int_gen_src_g =
+		{.address = INT_GEN_SRC_G,	.default_val = UNDEF,},
+	.status_reg1 =
+		{.address = STATUS_REG1,	.default_val = UNDEF,},
+	.ctrl_reg4 =
+		{.address = CTRL_REG4,		.default_val = CTRL_REG4_DEF,},
+	.ctrl_reg5_xl =
+		{.address = CTRL_REG5_XL,	.default_val = CTRL_REG5_XL_DEF,},
+	.ctrl_reg6_xl =
+		{.address = CTRL_REG6_XL,	.default_val = DEF_ZERO,},
+	.ctrl_reg7_xl =
+		{.address = CTRL_REG7_XL,	.default_val = DEF_ZERO,},
+	.ctrl_reg8 =
+		{.address = CTRL_REG8,		.default_val = CTRL_REG8_DEF,},
+	.ctrl_reg9 =
+		{.address = CTRL_REG9,		.default_val = DEF_ZERO,},
+	.ctrl_reg10 =
+		{.address = CTRL_REG10,	.default_val = DEF_ZERO,},
+	.int_gen_src_xl =
+		{.address = INT_GEN_SRC_XL,	.default_val = DEF_ZERO,},
+	.status_reg2 =
+		{.address = STATUS_REG2,	.default_val = UNDEF,},
+	.fifo_ctrl =
+		{.address = FIFO_CTRL,		.default_val = DEF_ZERO,},
+	.fifo_src =
+		{.address = FIFO_SRC,		.default_val = UNDEF,},
+	.int_gen_cfg_g =
+		{.address = INT_GEN_CFG_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_xh_g =
+		{.address = INT_GEN_THS_XH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_xl_g =
+		{.address = INT_GEN_THS_XL_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_yh_g =
+		{.address = INT_GEN_THS_YH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_yl_g =
+		{.address = INT_GEN_THS_YL_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_zh_g =
+		{.address = INT_GEN_THS_ZH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_zl_g =
+		{.address = INT_GEN_THS_ZL_G,	.default_val = DEF_ZERO,},
+	.int_gen_dur_g =
+		{.address = INT_GEN_DUR_G,	.default_val = DEF_ZERO,},
+};
+
+static int32_t _lsm6dl0_acc_device_power_off(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf = (LSM6DL0_ACC_ODR_MASK & LSM6DL0_ACC_ODR_OFF) |
+				   ((~LSM6DL0_ACC_ODR_MASK) &
+				   status_registers.ctrl_reg6_xl.resume_val);
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg6_xl.address, 1, &buf);
+
+	if (err < 0)
+		dev_err(stat->dev, "accelerometer soft power off "
+							"failed: %d\n", err);
+
+	if (stat->pdata_acc->power_off) {
+		stat->pdata_acc->power_off();
+	}
+
+	return 0;
+}
+
+static int32_t lsm6dl0_acc_device_power_off(struct lsm6dl0_status *stat)
+{
+	_lsm6dl0_acc_device_power_off(stat);
+
+	atomic_set(&stat->enabled_acc, 0);
+	dev_info(stat->dev, "accelerometer switched off.");
+
+	return 0;
+}
+
+static int32_t _lsm6dl0_gyr_device_power_off(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf = (LSM6DL0_GYR_ODR_MASK & LSM6DL0_GYR_ODR_OFF) |
+				   ((~LSM6DL0_GYR_ODR_MASK) &
+				   status_registers.ctrl_reg1_g.resume_val);
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 1, &buf);
+
+	if (err < 0)
+		dev_err(stat->dev, "gyroscope soft power off "
+							"failed: %d\n", err);
+
+	if (stat->pdata_gyr->power_off) {
+		stat->pdata_gyr->power_off();
+	}
+
+	return 0;
+}
+
+static int32_t lsm6dl0_gyr_device_power_off(struct lsm6dl0_status *stat)
+{
+	_lsm6dl0_gyr_device_power_off(stat);
+	atomic_set(&stat->enabled_gyr, 0);
+	dev_info(stat->dev, "gyroscope switched off.");
+
+	return 0;
+}
+
+static int32_t lsm6dl0_gyr_disable(struct lsm6dl0_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_gyr, 1, 0)) {
+		cancel_work_sync(&stat->input_work_gyr);
+		hrtimer_cancel(&stat->hr_timer_gyr);
+		lsm6dl0_gyr_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static int32_t lsm6dl0_acc_disable(struct lsm6dl0_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_acc, 1, 0)) {
+		if (atomic_read(&stat->enabled_gyr) > 0)
+			lsm6dl0_gyr_disable(stat);
+
+		cancel_work_sync(&stat->input_work_acc);
+		hrtimer_cancel(&stat->hr_timer_acc);
+		lsm6dl0_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static void lsm6dl0_acc_input_cleanup(struct lsm6dl0_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+}
+
+static void lsm6dl0_gyr_input_cleanup(struct lsm6dl0_status *stat)
+{
+	input_unregister_device(stat->input_dev_gyr);
+	input_free_device(stat->input_dev_gyr);
+}
+
+static enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct lsm6dl0_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm6dl0_status, hr_timer_acc);
+
+	queue_work(lsm6dl0_workqueue, &stat->input_work_acc);
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart poll_function_read_gyr(struct hrtimer *timer)
+{
+	struct lsm6dl0_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm6dl0_status, hr_timer_gyr);
+
+	queue_work(lsm6dl0_workqueue, &stat->input_work_gyr);
+	return HRTIMER_NORESTART;
+}
+
+static void lsm6dl0_validate_polling(uint32_t *min_interval,
+					uint32_t *poll_interval,
+					uint32_t min)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int32_t lsm6dl0_acc_validate_pdata(struct lsm6dl0_status *stat)
+{
+	int32_t res = -EINVAL;
+
+	lsm6dl0_validate_polling(&stat->pdata_acc->min_interval,
+				 &stat->pdata_acc->poll_interval,
+				(unsigned int)LSM6DL0_ACC_MIN_POLL_PERIOD_US);
+
+	switch (stat->pdata_acc->aa_filter_bandwidth) {
+	case LSM6DL0_ACC_BW_50:
+		res = 1;
+		break;
+	case LSM6DL0_ACC_BW_100:
+		res = 1;
+		break;
+	case LSM6DL0_ACC_BW_200:
+		res = 1;
+		break;
+	case LSM6DL0_ACC_BW_400:
+		res = 1;
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+			"bandwidth selected: %u\n",
+				stat->pdata_acc->aa_filter_bandwidth);
+	}
+
+	return res;
+}
+
+static int32_t lsm6dl0_gyr_validate_pdata(struct lsm6dl0_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	lsm6dl0_validate_polling(&stat->pdata_gyr->min_interval,
+				 &stat->pdata_gyr->poll_interval,
+				(unsigned int)LSM6DL0_GYR_MIN_POLL_PERIOD_US);
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata_gyr->poll_interval < stat->pdata_gyr->min_interval) {
+		dev_err(stat->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	stat->compensation_temp = 0;
+#endif
+	return 0;
+}
+
+
+static int32_t lsm6dl0_hw_init(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf;
+
+	dev_info(stat->dev, "%s: hw init start\n",
+						LSM6DL0_ACC_GYR_DEV_NAME);
+
+	err = stat->tf->read(stat, status_registers.who_am_i.address, 1, &buf);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I: is device"
+		" available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+
+	if (buf != status_registers.who_am_i.default_val) {
+	dev_err(stat->dev,
+		"device unknown. Expected: 0x%02x,"
+		" Replies: 0x%02x\n", status_registers.who_am_i.default_val,
+					buf);
+		err = -1;
+		goto err_unknown_device;
+	}
+
+	status_registers.act_ths.resume_val =
+				status_registers.act_ths.default_val;
+	status_registers.act_dur.resume_val =
+				status_registers.act_dur.default_val;
+	status_registers.int_gen_cfg_xl.resume_val =
+				status_registers.int_gen_cfg_xl.default_val;
+	status_registers.int_gen_ths_x_xl.resume_val =
+				status_registers.int_gen_ths_x_xl.default_val;
+	status_registers.int_gen_ths_y_xl.resume_val =
+				status_registers.int_gen_ths_y_xl.default_val;
+	status_registers.int_gen_ths_z_xl.resume_val =
+				status_registers.int_gen_ths_z_xl.default_val;
+	status_registers.int_gen_dur_xl.resume_val =
+				status_registers.int_gen_dur_xl.default_val;
+	status_registers.reference_g.resume_val =
+				status_registers.reference_g.default_val;
+	status_registers.int1_ctrl.resume_val =
+				status_registers.int1_ctrl.default_val;
+	status_registers.int2_ctrl.resume_val =
+				status_registers.int2_ctrl.default_val;
+	status_registers.ctrl_reg1_g.resume_val =
+				status_registers.ctrl_reg1_g.default_val;
+	status_registers.ctrl_reg2_g.resume_val =
+				status_registers.ctrl_reg2_g.default_val;
+	status_registers.ctrl_reg3_g.resume_val =
+				status_registers.ctrl_reg3_g.default_val;
+	status_registers.orient_cfg_g.resume_val =
+				status_registers.orient_cfg_g.default_val;
+	status_registers.ctrl_reg4.resume_val =
+				status_registers.ctrl_reg4.default_val;
+	status_registers.ctrl_reg5_xl.resume_val =
+				status_registers.ctrl_reg5_xl.default_val;
+	status_registers.ctrl_reg6_xl.resume_val =
+				status_registers.ctrl_reg6_xl.default_val;
+	status_registers.ctrl_reg7_xl.resume_val =
+				status_registers.ctrl_reg7_xl.default_val;
+	status_registers.ctrl_reg8.resume_val =
+				status_registers.ctrl_reg8.default_val;
+	status_registers.ctrl_reg9.resume_val =
+				status_registers.ctrl_reg9.default_val;
+	status_registers.ctrl_reg10.resume_val =
+				status_registers.ctrl_reg10.default_val;
+	status_registers.fifo_ctrl.resume_val =
+				status_registers.fifo_ctrl.default_val;
+	status_registers.int_gen_cfg_g.resume_val =
+				status_registers.int_gen_cfg_g.default_val;
+	status_registers.int_gen_ths_xh_g.resume_val =
+				status_registers.int_gen_ths_xh_g.default_val;
+	status_registers.int_gen_ths_xl_g.resume_val =
+				status_registers.int_gen_ths_xl_g.default_val;
+	status_registers.int_gen_ths_yh_g.resume_val =
+				status_registers.int_gen_ths_yh_g.default_val;
+	status_registers.int_gen_ths_yl_g.resume_val =
+				status_registers.int_gen_ths_yl_g.default_val;
+	status_registers.int_gen_ths_zh_g.resume_val =
+				status_registers.int_gen_ths_zh_g.default_val;
+	status_registers.int_gen_ths_zl_g.resume_val =
+				status_registers.int_gen_ths_zl_g.default_val;
+	status_registers.int_gen_dur_g.resume_val =
+				status_registers.int_gen_dur_g.default_val;
+
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+	atomic_set(&stat->low_power_state, 0);
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL
+	/** Disable Low Power mode at startup, device will be in normal mode */
+	atomic_set(&stat->enabled_lp_mode, 0);
+#else
+	atomic_set(&stat->enabled_lp_mode, 1);
+#endif
+	stat->gyr_discard_samples = 0;
+#endif
+	stat->acc_discard_samples = 0;
+
+	stat->hw_initialized = 1;
+	dev_info(stat->dev, "%s: hw init done\n",
+						LSM6DL0_ACC_GYR_DEV_NAME);
+
+	return 0;
+
+err_unknown_device:
+err_firstread:
+	stat->hw_working = 0;
+	stat->hw_initialized = 0;
+
+	return err;
+}
+
+static int32_t _lsm6dl0_acc_device_power_on(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf[9] = { 0 };
+
+	if (stat->pdata_acc->power_on) {
+		err = stat->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+ 	buf[0] = status_registers.ctrl_reg4.resume_val;
+ 	buf[1] = status_registers.ctrl_reg5_xl.resume_val;
+	buf[2] = status_registers.ctrl_reg6_xl.resume_val;
+	buf[3] = status_registers.ctrl_reg7_xl.resume_val;
+	buf[4] = status_registers.ctrl_reg8.resume_val;
+	buf[5] = status_registers.ctrl_reg9.resume_val;
+	buf[6] = status_registers.ctrl_reg10.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg4.address, 7, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen_cfg_xl.resume_val;
+	buf[1] = status_registers.int_gen_ths_x_xl.resume_val;
+	buf[2] = status_registers.int_gen_ths_y_xl.resume_val;
+	buf[3] = status_registers.int_gen_ths_z_xl.resume_val;
+	buf[4] = status_registers.int_gen_dur_xl.resume_val;
+	err = stat->tf->write(stat, status_registers.int_gen_cfg_xl.address, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int1_ctrl.resume_val;
+	buf[1] = status_registers.int2_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.int1_ctrl.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.fifo_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.fifo_ctrl.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg8.resume_val;
+	buf[1] = status_registers.ctrl_reg9.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg8.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	return 0;
+
+err_resume_state:
+	dev_err(stat->dev, "accelerometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int32_t lsm6dl0_acc_device_power_on(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+
+	err = _lsm6dl0_acc_device_power_on(stat);
+	if (err < 0)
+		atomic_set(&stat->enabled_acc, 0);
+	else
+		atomic_set(&stat->enabled_acc, 1);
+
+	return err;
+}
+
+static int32_t _lsm6dl0_gyr_device_power_on(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf[9] = { 0 };
+
+	if (stat->pdata_gyr->power_on) {
+		err = stat->pdata_gyr->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"gyroscope power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.act_ths.resume_val;
+	err = stat->tf->write(stat, status_registers.act_ths.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.reference_g.resume_val;
+	err = stat->tf->write(stat, status_registers.reference_g.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg1_g.resume_val;
+	buf[1] = status_registers.ctrl_reg2_g.resume_val;
+	buf[2] = status_registers.ctrl_reg3_g.resume_val;
+	buf[3] = status_registers.orient_cfg_g.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg4.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg4.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen_cfg_g.resume_val;
+	buf[1] = status_registers.int_gen_ths_xh_g.resume_val;
+	buf[2] = status_registers.int_gen_ths_xl_g.resume_val;
+	buf[3] = status_registers.int_gen_ths_yh_g.resume_val;
+	buf[4] = status_registers.int_gen_ths_yl_g.resume_val;
+	buf[5] = status_registers.int_gen_ths_zh_g.resume_val;
+	buf[6] = status_registers.int_gen_ths_zl_g.resume_val;
+	buf[7] = status_registers.int_gen_dur_g.resume_val;
+	err = stat->tf->write(stat, status_registers.int_gen_cfg_g.address, 8, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int1_ctrl.resume_val;
+	buf[1] = status_registers.int2_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.int1_ctrl.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.fifo_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.fifo_ctrl.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	return 0;
+
+err_resume_state:
+	dev_err(stat->dev, "gyroscope hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+
+	return err;
+}
+
+static int32_t lsm6dl0_gyr_device_power_on(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	
+	err = _lsm6dl0_gyr_device_power_on(stat);
+	if (err < 0)
+		atomic_set(&stat->enabled_gyr, 0);
+	else
+		atomic_set(&stat->enabled_gyr, 1);
+
+	return err;
+}
+
+static int32_t lsm6dl0_acc_update_fs_range(struct lsm6dl0_status *stat,
+							uint8_t new_fs_range)
+{
+	int32_t sensitivity, err = -1;
+	uint8_t val;
+
+	switch (new_fs_range) {
+	case LSM6DL0_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case LSM6DL0_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case LSM6DL0_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	val = ((LSM6DL0_ACC_FS_MASK & new_fs_range) | ((~LSM6DL0_ACC_FS_MASK) &
+				status_registers.ctrl_reg6_xl.resume_val));
+
+	err = stat->tf->write(stat,  status_registers.ctrl_reg6_xl.address, 1, &val);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = val;
+
+	mutex_lock(&stat->lock);
+	stat->sensitivity_acc = sensitivity;
+	mutex_unlock(&stat->lock);
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer fs range failed "
+			"0x%02x,0x%02x: %d\n", status_registers.ctrl_reg6_xl.address,
+			val, err);
+	return err;
+}
+
+static int32_t lsm6dl0_gyr_update_fs_range(struct lsm6dl0_status *stat,
+							uint8_t new_fs_range)
+{
+	int32_t err = -1;
+	uint8_t updated_val;
+	u32 sensitivity;
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	int8_t k_fs;
+#endif
+
+	switch(new_fs_range) {
+	case LSM6DL0_GYR_FS_245DPS:
+		sensitivity = SENSITIVITY_GYR_250;
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+		k_fs = 8;
+#endif
+		break;
+	case LSM6DL0_GYR_FS_500DPS:
+		sensitivity = SENSITIVITY_GYR_500;
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+		k_fs = 4;
+#endif
+		break;
+	case LSM6DL0_GYR_FS_2000DPS:
+		sensitivity = SENSITIVITY_GYR_2000;
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+		k_fs = 1;
+#endif
+		break;
+	default:
+		dev_err(stat->dev, "invalid g range "
+					"requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	err = stat->tf->read(stat, status_registers.ctrl_reg1_g.address, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	updated_val = ((LSM6DL0_GYR_FS_MASK & new_fs_range) |
+					((~LSM6DL0_GYR_FS_MASK) & updated_val));
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 1,
+							&updated_val);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg1_g.resume_val = updated_val;
+
+	mutex_lock(&stat->lock);
+	stat->sensitivity_gyr = sensitivity;
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	stat->k_fs = k_fs;
+#endif
+	mutex_unlock(&stat->lock);
+
+error:
+	return err;
+}
+
+static int32_t lsm6dl0_acc_update_odr(struct lsm6dl0_status *stat,
+					uint32_t poll_interval_us)
+{
+	int32_t err = -1;
+	uint8_t buf;
+	uint32_t i;
+
+	for (i = ARRAY_SIZE(lsm6dl0_acc_odr_table) - 1; i >= 0; i--) {
+		if (((uint32_t)lsm6dl0_acc_odr_table[i].cutoff_us <=
+			poll_interval_us) || (i == 0))
+			break;
+	}
+
+	if (atomic_read(&stat->enabled_acc)) {
+		buf = LSM6DL0_ACC_ODR_MASK & lsm6dl0_acc_odr_table[i].value;
+		buf |= (~LSM6DL0_ACC_ODR_MASK) &
+				status_registers.ctrl_reg6_xl.resume_val;
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg6_xl.address, 1,
+							  &buf);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg6_xl.resume_val = buf;
+		mutex_lock(&stat->lock);
+		stat->pdata_acc->poll_interval = poll_interval_us;
+		stat->ktime_acc = ktime_set(0, US_TO_NS(poll_interval_us));
+		mutex_unlock(&stat->lock);
+		dev_info(stat->dev, "Acc Polling Rate (us)%d\n", stat->pdata_acc->poll_interval);
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer odr failed : %d\n", err);
+
+	return err;
+}
+
+static int32_t lsm6dl0_gyr_update_odr(struct lsm6dl0_status *stat,
+					uint32_t poll_interval_us)
+{
+	uint8_t buf;
+	uint32_t val, i;
+	int32_t err = -1;
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+	uint8_t lp_mode;
+#endif
+
+	if (atomic_read(&stat->enabled_gyr)) {
+		if (atomic_read(&stat->enabled_acc)) {
+			val = min(poll_interval_us,
+					stat->pdata_acc->poll_interval);
+		} else {
+			val = poll_interval_us;
+		}
+
+		for (i = ARRAY_SIZE(lsm6dl0_gyr_odr_table) - 1; i >= 0; i--) {
+			if ((lsm6dl0_gyr_odr_table[i].cutoff_us <= val) ||
+				(i == 0))
+				break;
+		}
+
+		/* Set ODR value */
+		buf = LSM6DL0_GYR_ODR_MASK & lsm6dl0_gyr_odr_table[i].value;
+		buf |= (~LSM6DL0_GYR_ODR_MASK) &
+				status_registers.ctrl_reg1_g.resume_val;
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 1,
+							  &buf);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg1_g.resume_val = buf;
+
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+		if (lsm6dl0_gyr_odr_table[i].cutoff_us < LSM6DL0_GYR_LP_TH_US)
+			lp_mode = 1;
+		else
+			lp_mode = 0;
+
+		/* Discard samples only if switch between normal and low-power
+		 * mode
+		 */
+		if (lp_mode != (uint8_t)atomic_read(&stat->low_power_state) &&
+				atomic_read(&stat->enabled_lp_mode) == 1) {
+			atomic_set(&stat->low_power_state, lp_mode);
+
+			mutex_lock(&stat->lock);
+			stat->gyr_discard_samples =
+			lsm6dl0_gyr_turn_on_time[i].disc_list[LSM6DL0_GYR_LPF1].count;
+		} else {
+			mutex_lock(&stat->lock);
+			stat->gyr_discard_samples = 0;
+		}
+		mutex_unlock(&stat->lock);
+#endif
+		/* Enable all axes */
+		buf = CTRL_REG4_ALL_AXES_EN |
+			  status_registers.ctrl_reg4.resume_val;
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg4.address, 1, &buf);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg4.resume_val = buf;
+
+		mutex_lock(&stat->lock);
+		stat->ktime_gyr = ktime_set(0, US_TO_NS(val));
+		stat->pdata_gyr->poll_interval = val;
+		mutex_unlock(&stat->lock);
+	}
+	return err;
+error:
+	dev_err(stat->dev, "update accelerometer odr failed: %d\n", err);
+
+	return err;
+}
+
+static int32_t lsm6dl0_acc_update_filter(struct lsm6dl0_status *stat,
+							uint8_t new_bandwidth)
+{
+	int32_t err = -1;
+	uint8_t updated_val;
+
+	switch (new_bandwidth) {
+	case LSM6DL0_ACC_BW_50:
+		break;
+	case LSM6DL0_ACC_BW_100:
+		break;
+	case LSM6DL0_ACC_BW_200:
+		break;
+	case LSM6DL0_ACC_BW_400:
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+			"update bandwidth requested: %u\n", new_bandwidth);
+		return -EINVAL;
+	}
+
+	err = stat->tf->read(stat, status_registers.ctrl_reg6_xl.address, 1,
+						 &updated_val);
+	if (err < 0)
+		goto error;
+
+	updated_val = ((LSM6DL0_ACC_BW_MASK & new_bandwidth) |
+					((~LSM6DL0_ACC_BW_MASK) & updated_val));
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg6_xl.address, 1,
+						  &updated_val);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = updated_val;
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer fs range failed : %d\n", err);
+	return err;
+}
+
+
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL_LP
+static int32_t lsm6dl0_acc_change_pm_state(struct lsm6dl0_status *stat,
+							uint8_t new_pm_state)
+{
+	uint8_t val;
+	int32_t err = -1, new_state = (new_pm_state != 0) ? 1 : 0;
+
+	if (atomic_read(&stat->enabled_lp_mode) != new_state) {
+		val = ((CTRL_REG3_G_LP_MODE_MASK & new_state) |
+			((~CTRL_REG3_G_LP_MODE_MASK) &
+			status_registers.ctrl_reg3_g.resume_val));
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg3_g.address, 1,
+							  &val);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg3_g.resume_val = val;
+		atomic_set(&stat->enabled_lp_mode, new_state);
+	}
+	return err;
+error:
+	dev_err(stat->dev, "enable pm bit failed : %d\n", err);
+	return err;
+}
+#endif
+
+static int32_t lsm6dl0_acc_enable(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t j, bw;
+
+	if (!atomic_cmpxchg(&stat->enabled_acc, 0, 1)) {
+		err = lsm6dl0_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_acc, 0);
+			dev_err(stat->dev, "enable accelerometer "
+				      "failed");
+			return err;
+		}
+
+		for (j = ARRAY_SIZE(lsm6dl0_acc_turn_on_time) - 1; j >= 0; j--) {
+			if ((lsm6dl0_acc_turn_on_time[j].odr_us <=
+			  stat->pdata_acc->poll_interval) || (j == 0))
+				break;
+		}
+		bw = stat->pdata_acc->aa_filter_bandwidth;
+
+		stat->acc_discard_samples =
+			lsm6dl0_acc_turn_on_time[j].disc_list[bw].count;
+		
+		hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc,
+							HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+
+static int32_t lsm6dl0_gyr_enable(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+
+	if (!atomic_cmpxchg(&stat->enabled_gyr, 0, 1)) {
+
+		err = lsm6dl0_gyr_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_gyr, 0);
+			return err;
+		}
+
+		hrtimer_start(&(stat->hr_timer_gyr), stat->ktime_gyr,
+							HRTIMER_MODE_REL);
+	}
+	return 0;
+}
+
+#ifdef LSM6DL0_EN_ON_OPEN
+int32_t lsm6dl0_acc_input_open(struct input_dev *input)
+{
+	struct lsm6dl0_status *stat = input_get_drvdata(input);
+
+	return lsm6dl0_acc_enable(stat);
+}
+
+void lsm6dl0_acc_input_close(struct input_dev *dev)
+{
+	struct lsm6dl0_status *stat = input_get_drvdata(dev);
+
+	lsm6dl0_acc_disable(stat);
+}
+#endif
+
+int32_t lsm6dl0_gyr_input_open(struct input_dev *input)
+{
+	struct lsm6dl0_status *stat = input_get_drvdata(input);
+
+	return lsm6dl0_gyr_enable(stat);
+}
+
+void lsm6dl0_gyr_input_close(struct input_dev *dev)
+{
+	struct lsm6dl0_status *stat = input_get_drvdata(dev);
+
+	lsm6dl0_gyr_disable(stat);
+}
+
+static int32_t lsm6dl0_temp_get_data(struct lsm6dl0_status *stat, int32_t *data)
+{
+	int32_t err = -1;
+	uint8_t temp_data[2] = { 0 };
+
+	err = stat->tf->read(stat, OUT_TEMP_L, 2, temp_data);
+	if (err < 0)
+		return err;
+
+	(*data) = (int32_t)((int16_t)((temp_data[1] << 8) | (temp_data[0])));
+
+	return err;
+}
+
+static int32_t lsm6dl0_acc_get_data(struct lsm6dl0_status *stat, int32_t *xyz)
+{
+	int32_t i, err = -1, hw_d[3] = { 0 };
+	uint8_t acc_data[6];
+
+	err = stat->tf->read(stat, OUT_X_L_XL, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((int32_t)( (int16_t)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((int32_t)( (int16_t)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((int32_t)( (int16_t)((acc_data[5] << 8) | (acc_data[4]))));
+
+	mutex_lock(&stat->lock);
+	hw_d[0] = hw_d[0] * stat->sensitivity_acc;
+	hw_d[1] = hw_d[1] * stat->sensitivity_acc;
+	hw_d[2] = hw_d[2] * stat->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_main->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_main->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int32_t lsm6dl0_gyr_get_data(struct lsm6dl0_status *stat, int32_t *xyz)
+{
+	int32_t i, err = 1, hw_d[3] = { 0 };
+	uint8_t gyro_data[6];
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	int32_t temp, abs_temp;
+#endif
+
+	err = stat->tf->read(stat, OUT_X_L_G, 6, gyro_data);
+
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (int32_t) ((int16_t)((gyro_data[1]) << 8) | gyro_data[0]);
+	hw_d[1] = (int32_t) ((int16_t)((gyro_data[3]) << 8) | gyro_data[2]);
+	hw_d[2] = (int32_t) ((int16_t)((gyro_data[5]) << 8) | gyro_data[4]);
+
+	mutex_lock(&stat->lock);
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	err = lsm6dl0_temp_get_data(stat, &temp);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+	if (temp >= stat->compensation_temp) {
+		abs_temp = temp - stat->compensation_temp;
+	} else {
+		abs_temp = stat->compensation_temp - temp;
+	}
+
+	if (abs_temp > SENSITIVITY_TEMP)
+		stat->compensation_temp = temp;
+
+	hw_d[0] -= 10 * stat->compensation_temp *
+			((int32_t)(stat->k_fs * stat->k_coeff[1])) / 896;
+	hw_d[1] += 10 * stat->compensation_temp *
+			((int32_t)(stat->k_fs * stat->k_coeff[0])) / 896;
+	hw_d[2] -= 10 * stat->compensation_temp *
+			((int32_t)(stat->k_fs * stat->k_coeff[2])) / 896;
+#endif
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_gyr;
+	hw_d[1] = hw_d[1] * stat->sensitivity_gyr;
+	hw_d[2] = hw_d[2] * stat->sensitivity_gyr;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_main->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_main->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static void lsm6dl0_acc_report_values(struct lsm6dl0_status *stat,
+								int32_t *xyz)
+{
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(stat->input_dev_acc);
+}
+
+static void lsm6dl0_gyr_report_values(struct lsm6dl0_status *stat,
+								int32_t *xyz)
+{
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(stat->input_dev_gyr);
+}
+
+static int32_t lsm6dl0_acc_input_init(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+
+	mutex_lock(&stat->lock);
+	stat->input_dev_acc = input_allocate_device();
+	if (!stat->input_dev_acc) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "accelerometer "
+					"input device allocation failed\n");
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+#ifdef LSM6DL0_EN_ON_OPEN
+	stat->input_dev_acc->open = lsm6dl0_acc_input_open;
+	stat->input_dev_acc->close = lsm6dl0_acc_input_close;
+#endif
+	stat->input_dev_acc->name = LSM6DL0_ACC_DEV_NAME;
+	stat->input_dev_acc->id.bustype = stat->bustype;
+	stat->input_dev_acc->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev_acc, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev_acc->evbit );
+	__set_bit(INPUT_EVENT_X, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev_acc->mscbit);
+
+	err = input_register_device(stat->input_dev_acc);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register accelerometer input device %s\n",
+				stat->input_dev_acc->name);
+		input_free_device(stat->input_dev_acc);
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int32_t lsm6dl0_gyr_input_init(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	mutex_lock(&stat->lock);
+	stat->input_dev_gyr = input_allocate_device();
+	if (!stat->input_dev_gyr) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"input device allocation failed\n");
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+#ifdef LSM6DL0_EN_ON_OPEN
+	stat->input_dev_gyr->open = lsm6dl0_gyr_input_open;
+	stat->input_dev_gyr->close = lsm6dl0_gyr_input_close;
+#endif
+	stat->input_dev_gyr->name = LSM6DL0_GYR_DEV_NAME;
+	stat->input_dev_gyr->id.bustype = stat->bustype;
+	stat->input_dev_gyr->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev_gyr, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev_gyr->evbit );
+	__set_bit(INPUT_EVENT_X, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev_gyr->mscbit);
+
+	err = input_register_device(stat->input_dev_gyr);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input device %s\n",
+			stat->input_dev_gyr->name);
+		input_free_device(stat->input_dev_gyr);
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+static void lsm6dl0_input_cleanup(struct lsm6dl0_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+
+	input_unregister_device(stat->input_dev_gyr);
+	input_free_device(stat->input_dev_gyr);
+}
+
+static ssize_t set_polling_rate_acc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long interval_us, interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_us = (unsigned long)max((unsigned int)MS_TO_US(interval_ms),
+						sdata->pdata_acc->min_interval);
+
+	lsm6dl0_acc_update_odr(sdata, interval_us);
+
+	return count;
+}
+
+static ssize_t get_polling_rate_acc(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint32_t val = 0;
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_acc->poll_interval;
+	mutex_unlock(&sdata->lock);
+
+	return sprintf(buf, "%u\n", US_TO_MS(val));
+}
+
+static ssize_t get_enable_acc(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+
+	int32_t val = (int)atomic_read(&sdata->enabled_acc);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_enable_acc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm6dl0_acc_enable(sdata);
+	else
+		lsm6dl0_acc_disable(sdata);
+
+	return count;
+}
+
+static ssize_t get_range_acc(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint8_t val;
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	int32_t range = 2;
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_acc->fs_range;
+	mutex_unlock(&sdata->lock);
+
+	switch (val) {
+	case LSM6DL0_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM6DL0_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM6DL0_ACC_FS_8G:
+		range = 8;
+		break;
+	}
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t set_range_acc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t range;
+	int32_t err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LSM6DL0_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM6DL0_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM6DL0_ACC_FS_8G;
+		break;
+	default:
+		dev_err(sdata->dev, "accelerometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = lsm6dl0_acc_update_fs_range(sdata, range);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->lock);
+	sdata->pdata_acc->fs_range = range;
+	mutex_unlock(&sdata->lock);
+
+	dev_info(sdata->dev, "accelerometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t get_aa_filter(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint8_t val;
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	int32_t frequency = FILTER_400;
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_acc->aa_filter_bandwidth;
+	mutex_unlock(&sdata->lock);
+
+	switch (val) {
+	case LSM6DL0_ACC_BW_50:
+		frequency = FILTER_50;
+		break;
+	case LSM6DL0_ACC_BW_100:
+		frequency = FILTER_100;
+		break;
+	case LSM6DL0_ACC_BW_200:
+		frequency = FILTER_200;
+		break;
+	case LSM6DL0_ACC_BW_400:
+		frequency = FILTER_400;
+		break;
+	}
+
+	return sprintf(buf, "%d\n", frequency);
+}
+
+static ssize_t set_aa_filter(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t frequency;
+	int32_t err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case FILTER_50:
+		frequency = LSM6DL0_ACC_BW_50;
+		break;
+	case FILTER_100:
+		frequency = LSM6DL0_ACC_BW_100;
+		break;
+	case FILTER_200:
+		frequency = LSM6DL0_ACC_BW_200;
+		break;
+	case FILTER_400:
+		frequency = LSM6DL0_ACC_BW_400;
+		break;
+	default:
+		dev_err(sdata->dev, "accelerometer invalid filter "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = lsm6dl0_acc_update_filter(sdata, frequency);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->lock);
+	sdata->pdata_acc->aa_filter_bandwidth = frequency;
+	mutex_unlock(&sdata->lock);
+
+	dev_info(sdata->dev, "accelerometer anti-aliasing filter "
+					"set to: %lu Hz\n", val);
+
+	return size;
+}
+
+static ssize_t get_temp(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	int32_t temp_decimal, temp_hw = 0, err = -1;
+	uint32_t temp_float;
+
+	err = lsm6dl0_temp_get_data(sdata, &temp_hw);
+	if (err < 0)
+		return sprintf(buf, "null\n");
+
+	temp_decimal = (int32_t)(temp_hw / SENSITIVITY_TEMP) + OFFSET_TEMP;
+	temp_float = (((uint32_t)temp_hw) % SENSITIVITY_TEMP);
+
+	return sprintf(buf, "%d.%d\n", temp_decimal, temp_float);
+}
+
+static ssize_t get_polling_rate_gyr(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint32_t val;
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_gyr->poll_interval;
+	mutex_unlock(&sdata->lock);
+
+	return sprintf(buf, "%d\n", US_TO_MS(val));
+}
+
+static ssize_t set_polling_rate_gyr(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long interval_us, interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_us = (unsigned int)max((unsigned int)MS_TO_US(interval_ms),
+					sdata->pdata_gyr->min_interval);
+
+	lsm6dl0_gyr_update_odr(sdata, interval_us);
+
+	return count;
+}
+
+static ssize_t get_enable_gyr(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	int32_t val = atomic_read(&sdata->enabled_gyr);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_enable_gyr(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm6dl0_gyr_enable(sdata);
+	else
+		lsm6dl0_gyr_disable(sdata);
+
+	return count;
+}
+
+static ssize_t get_range_gyr(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	int32_t range = 0;
+	uint8_t val;
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_gyr->fs_range;
+	switch (val) {
+	case LSM6DL0_GYR_FS_245DPS:
+		range = RANGE_245DPS;
+		break;
+	case LSM6DL0_GYR_FS_500DPS:
+		range = RANGE_500DPS;
+		break;
+	case LSM6DL0_GYR_FS_2000DPS:
+		range = RANGE_2000DPS;
+		break;
+	}
+	mutex_unlock(&sdata->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t set_range_gyr(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t range;
+	int32_t err = -1;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 245:
+		range = LSM6DL0_GYR_FS_245DPS;
+		break;
+	case 500:
+		range = LSM6DL0_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = LSM6DL0_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(sdata->dev, "invalid range request: %lu,"
+				" discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = lsm6dl0_gyr_update_fs_range(sdata, range);
+	if (err >= 0) {
+		mutex_lock(&sdata->lock);
+		sdata->pdata_gyr->fs_range = range;
+		mutex_unlock(&sdata->lock);
+	}
+
+	dev_info(sdata->dev, "range set to: %lu dps\n", val);
+
+	return count;
+}
+
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL_LP
+static ssize_t get_pmode(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	uint8_t val;
+
+	val = atomic_read(&sdata->enabled_lp_mode);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_pmode(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6dl0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	lsm6dl0_acc_change_pm_state(sdata, val);
+
+	return count;
+}
+#endif
+
+LSM6DL0_ATTTR(enable_acc, enable_device, 0664, get_enable_acc, set_enable_acc);
+LSM6DL0_ATTTR(enable_gyr, enable_device, 0664, get_enable_gyr, set_enable_gyr);
+LSM6DL0_ATTTR(pollrate_acc, pollrate_ms, 0664, get_polling_rate_acc, set_polling_rate_acc);
+LSM6DL0_ATTTR(pollrate_gyr, pollrate_ms, 0664, get_polling_rate_gyr, set_polling_rate_gyr);
+LSM6DL0_ATTTR(range_acc, range, 0664, get_range_acc, set_range_acc);
+LSM6DL0_ATTTR(range_gyr, range, 0664, get_range_gyr, set_range_gyr);
+LSM6DL0_ATTTR(aa_freq, anti_aliasing_frequency, 0664, get_aa_filter, set_aa_filter);
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL_LP
+LSM6DL0_ATTTR(pmode, pmode, 0664, get_pmode, set_pmode);
+#endif
+LSM6DL0_ATTTR(temperature, temperature, 0444, get_temp, NULL);
+
+static struct attribute *attributes_acc[] = {
+	&lsm6dl0_attr_enable_acc.attr,
+	&lsm6dl0_attr_pollrate_acc.attr,
+	&lsm6dl0_attr_range_acc.attr,
+	&lsm6dl0_attr_aa_freq.attr,
+	&lsm6dl0_attr_temperature.attr,
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL_LP
+	&lsm6dl0_attr_pmode.attr,
+#endif
+	NULL,
+};
+
+static struct attribute *attributes_gyr[] = {
+	&lsm6dl0_attr_enable_gyr.attr,
+	&lsm6dl0_attr_pollrate_gyr.attr,
+	&lsm6dl0_attr_range_gyr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_gyr = {
+	.attrs = attributes_gyr,
+};
+
+static int32_t create_sysfs_interfaces(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+
+	err = sysfs_create_group(&stat->input_dev_acc->dev.kobj, &attr_group_acc);
+	if (err)
+		return err;
+
+	return sysfs_create_group(&stat->input_dev_gyr->dev.kobj, &attr_group_gyr);
+}
+
+static void remove_sysfs_interfaces(struct lsm6dl0_status *stat)
+{
+	sysfs_remove_group(&stat->input_dev_acc->dev.kobj, &attr_group_acc);
+	sysfs_remove_group(&stat->input_dev_gyr->dev.kobj, &attr_group_gyr);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct lsm6dl0_status *stat;
+	int32_t xyz[3] = { 0 }, err = -1;
+
+	stat = container_of((struct work_struct *)input_work_acc,
+			struct lsm6dl0_status, input_work_acc);
+
+	err = lsm6dl0_acc_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get accelerometer data failed\n");
+	else {
+		mutex_lock(&stat->lock);
+		if (stat->acc_discard_samples > 0) {
+			stat->acc_discard_samples--;
+			mutex_unlock(&stat->lock);
+		} else {
+			mutex_unlock(&stat->lock);
+			lsm6dl0_acc_report_values(stat, xyz);
+		}
+	}
+
+	hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+}
+
+static void poll_function_work_gyr(struct work_struct *input_work_gyr)
+{
+	struct lsm6dl0_status *stat;
+	int32_t xyz[3] = { 0 }, err = -1;
+
+	stat = container_of((struct work_struct *)input_work_gyr,
+			struct lsm6dl0_status, input_work_gyr);
+
+	err = lsm6dl0_gyr_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get gyroscope data failed.\n");
+	else {
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+		mutex_lock(&stat->lock);
+		if (stat->gyr_discard_samples > 0) {
+			stat->gyr_discard_samples--;
+			mutex_unlock(&stat->lock);
+		} else {
+			mutex_unlock(&stat->lock);
+			lsm6dl0_gyr_report_values(stat, xyz);
+		}
+#else
+		lsm6dl0_gyr_report_values(stat, xyz);
+#endif
+	}
+
+	hrtimer_start(&stat->hr_timer_gyr, stat->ktime_gyr, HRTIMER_MODE_REL);
+}
+
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+int32_t lsm6dl0_hw_comp_read_k(struct lsm6dl0_status *stat, uint8_t reg,
+								int8_t *val)
+{
+	int32_t err = -1;
+
+	/* Read hardcoded factor */
+	(*val) = reg;
+	err = stat->tf->read(stat, reg, 1, val);
+	if (err < 0) {
+		return err;
+	}
+
+	if ((*val) & (0x20)) {
+		(*val) |= (0xE0);
+		(*val) &= (0xFF);
+	} else {
+		(*val) &= (0x3F);
+	}
+	return err;
+}
+
+int32_t lsm6dl0_hw_compensation_disable(struct lsm6dl0_status *stat,
+								uint8_t reg)
+{
+	int32_t err = -1;
+	uint8_t tmp = 0;
+
+	switch(reg) {
+	case COMP_X_FACTOR_ADDR:
+		tmp = stat->k_coeff[0];
+		break;
+
+	case COMP_Y_FACTOR_ADDR:
+		tmp = stat->k_coeff[1];
+		break;
+
+	case COMP_Z_FACTOR_ADDR:
+		tmp = stat->k_coeff[2];
+		break;
+	}
+
+	/* Disable HW compensation */
+	err = stat->tf->write(stat, reg, 1, &tmp);
+
+	return err;
+}
+
+static int32_t lsm6dl0_gyr_temp_compensation_init(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+	int8_t k_coeff[3] = { 0 };
+
+	/* reset coefficients */
+	mutex_lock(&stat->lock);
+	stat->k_coeff[0] = 0;
+	stat->k_coeff[1] = 0;
+	stat->k_coeff[2] = 0;
+	mutex_unlock(&stat->lock);
+
+	err = lsm6dl0_hw_comp_read_k(stat, COMP_X_FACTOR_ADDR, &k_coeff[0]);
+	if (err < 0) {
+		return err;
+	}
+
+	err = lsm6dl0_hw_comp_read_k(stat, COMP_Y_FACTOR_ADDR, &k_coeff[1]);
+	if (err < 0) {
+		return err;
+	}
+
+	err = lsm6dl0_hw_comp_read_k(stat, COMP_Z_FACTOR_ADDR, &k_coeff[2]);
+	if (err < 0) {
+		return err;
+	}
+
+	mutex_lock(&stat->lock);
+	err = lsm6dl0_hw_compensation_disable(stat, COMP_X_FACTOR_ADDR);
+	if (err < 0) {
+		goto err_dis_comp;
+	}
+	stat->k_coeff[0] = k_coeff[0];
+
+	err = lsm6dl0_hw_compensation_disable(stat, COMP_Y_FACTOR_ADDR);
+	if (err < 0) {
+		goto err_dis_comp;
+	}
+	stat->k_coeff[1] = k_coeff[1];
+
+	err = lsm6dl0_hw_compensation_disable(stat, COMP_Z_FACTOR_ADDR);
+	if (err < 0) {
+		goto err_dis_comp;
+	}
+	stat->k_coeff[2] = k_coeff[2];
+
+err_dis_comp:
+	mutex_unlock(&stat->lock);
+	return err;
+}
+#endif
+
+#ifdef CONFIG_OF
+static int32_t lsm6dl0_parse_dt(struct lsm6dl0_status *stat,
+                                        struct device* dev)
+{
+	struct device_node *dn;
+	uint8_t i, j;
+	uint32_t val;
+	uint32_t vect[9] = { 0 };
+
+	mutex_lock(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+
+	dn = dev->of_node;
+	stat->pdata_main->of_node = dn;
+	stat->pdata_main->gpio_int1 = of_get_gpio(dn, 0);
+	if (!gpio_is_valid(stat->pdata_main->gpio_int1)) {
+		dev_err(dev, "failed to get gpio_int1\n");
+			stat->pdata_main->gpio_int1 = LSM6DL0_INT1_GPIO_DEF;
+	}
+
+	stat->pdata_main->gpio_int2 = of_get_gpio(dn, 1);
+	if (!gpio_is_valid(stat->pdata_main->gpio_int2)) {
+		dev_err(dev, "failed to get gpio_int2\n");
+			stat->pdata_main->gpio_int2 = LSM6DL0_INT2_GPIO_DEF;
+	}
+
+	if (of_property_read_u32_array(dn, "rot-matrix", vect,
+		      ARRAY_SIZE(vect)) >= 0) {
+		for (j = 0; j < 3; j++) {
+			for (i = 0; i < 3; i++) {
+				stat->pdata_main->rot_matrix[i][j] = vect[3 * j + i];
+			}
+		}
+	} else {
+		for (j = 0; j < 3; j++) {
+			for (i = 0; i < 3; i++) {
+				stat->pdata_main->rot_matrix[i][j] =
+		default_lsm6dl0_main_platform_data.rot_matrix[i][j];
+			}
+		}
+	}
+
+	if (!of_property_read_u32(dn, "g-poll-interval", &val)) {
+		stat->pdata_gyr->poll_interval = MS_TO_US(val);
+	} else {
+		stat->pdata_gyr->poll_interval =
+			LSM6DL0_GYR_POLL_INTERVAL_DEF;
+	}
+
+	if (!of_property_read_u32(dn, "g-min-interval", &val)) {
+		stat->pdata_gyr->min_interval = val;
+	} else {
+		stat->pdata_gyr->min_interval =
+			LSM6DL0_GYR_MIN_POLL_PERIOD_US;
+	}
+	
+	if (!of_property_read_u32(dn, "g-fs-range", &val)) {
+		stat->pdata_gyr->fs_range = val;
+	} else {
+	stat->pdata_gyr->fs_range = LSM6DL0_GYR_FS_245DPS;
+	}
+
+	if (!of_property_read_u32(dn, "x-poll-interval", &val)) {
+		stat->pdata_acc->poll_interval = MS_TO_US(val);
+	} else {
+		stat->pdata_acc->poll_interval =
+			LSM6DL0_ACC_MIN_POLL_PERIOD_US;
+	}
+
+	if (!of_property_read_u32(dn, "x-min-interval", &val)) {
+		stat->pdata_acc->min_interval = MS_TO_US(val);
+	} else {
+		stat->pdata_acc->min_interval =
+			LSM6DL0_ACC_MIN_POLL_PERIOD_US;
+	}
+
+	if (!of_property_read_u32(dn, "x-fs-range", &val)) {
+		stat->pdata_acc->fs_range = val;
+	} else {
+		stat->pdata_acc->fs_range = LSM6DL0_ACC_FS_2G;
+	}
+
+	if (!of_property_read_u32(dn, "aa-filter-bw", &val)) {
+		stat->pdata_acc->aa_filter_bandwidth = val;
+	} else {
+		stat->pdata_acc->aa_filter_bandwidth = LSM6DL0_ACC_BW_400;
+	}
+	mutex_unlock(&stat->lock);
+
+	return 0;
+}
+#endif
+
+int32_t lsm6dl0_common_probe(struct lsm6dl0_status *stat)
+{
+	int32_t err = -1;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	if (!lsm6dl0_workqueue)
+		lsm6dl0_workqueue = create_workqueue("lsm6dl0_workqueue");
+
+	hrtimer_init(&stat->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_acc.function = &poll_function_read_acc;
+	hrtimer_init(&stat->hr_timer_gyr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_gyr.function = &poll_function_read_gyr;
+
+	stat->pdata_main = kzalloc(sizeof(*stat->pdata_main), GFP_KERNEL);
+	stat->pdata_acc = kzalloc(sizeof(*stat->pdata_acc), GFP_KERNEL);
+	stat->pdata_gyr = kzalloc(sizeof(*stat->pdata_gyr), GFP_KERNEL);
+
+	if ((stat->pdata_main == NULL) || (stat->pdata_acc == NULL) ||
+						  (stat->pdata_gyr == NULL)){
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_memory_alloc;
+	}
+
+	stat->pdata_main->pdata_acc = stat->pdata_acc;
+	stat->pdata_main->pdata_gyr = stat->pdata_gyr;
+
+#ifdef CONFIG_OF
+	lsm6dl0_parse_dt(stat, stat->dev);
+#else
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata_main,
+				&default_lsm6dl0_main_platform_data,
+				sizeof(*stat->pdata_main));
+		memcpy(stat->pdata_acc, &default_lsm6dl0_acc_pdata,
+						sizeof(*stat->pdata_acc));
+		memcpy(stat->pdata_gyr, &default_lsm6dl0_gyr_pdata,
+						sizeof(*stat->pdata_gyr));
+		dev_info(stat->dev, "using default plaform_data for "
+					"accelerometer and gyroscope\n");
+	} else {
+		struct lsm6dl0_main_platform_data *platform_data;
+		platform_data = stat->dev->platform_data;
+
+		if (platform_data == NULL) {
+			memcpy(stat->pdata_main,
+				&default_lsm6dl0_main_platform_data,
+				sizeof(*stat->pdata_main));
+			dev_info(stat->dev, "using default plaform_data for "
+							"accelerometer\n");
+		} else {
+			memcpy(stat->pdata_main, platform_data,
+						sizeof(*stat->pdata_acc));
+		}
+
+		if (platform_data->pdata_acc == NULL) {
+			memcpy(stat->pdata_acc, &default_lsm6dl0_acc_pdata,
+						sizeof(*stat->pdata_acc));
+			dev_info(stat->dev, "using default plaform_data for "
+							"accelerometer\n");
+		} else {
+			memcpy(stat->pdata_acc, platform_data->pdata_acc,
+						sizeof(*stat->pdata_acc));
+		}
+
+		if (platform_data->pdata_gyr == NULL) {
+			memcpy(stat->pdata_gyr, &default_lsm6dl0_gyr_pdata,
+						sizeof(*stat->pdata_gyr));
+			dev_info(stat->dev, "using default plaform_data for "
+							"gyroscope\n");
+		} else {
+			memcpy(stat->pdata_gyr, platform_data->pdata_gyr,
+						sizeof(*stat->pdata_gyr));
+		}
+	}
+#endif
+
+	err = lsm6dl0_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data for "
+							"accelerometer \n");
+		goto exit_kfree_pdata;
+	}
+
+	err = lsm6dl0_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data for "
+							"gyroscope\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata_acc->init) {
+		err = stat->pdata_acc->init();
+		if (err < 0) {
+			dev_err(stat->dev, "accelerometer init failed: "
+								"%d\n", err);
+			goto err_pdata_acc_init;
+		}
+	}
+	if (stat->pdata_gyr->init) {
+		err = stat->pdata_gyr->init();
+		if (err < 0) {
+			dev_err(stat->dev, "gyroscope init failed: "
+								"%d\n", err);
+			goto err_pdata_gyr_init;
+		}
+	}
+
+	err = lsm6dl0_hw_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm6dl0_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "accelerometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm6dl0_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "gyroscope power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm6dl0_acc_update_fs_range(stat, stat->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer full scale range "
+								"failed\n");
+		goto  err_power_off_acc;
+	}
+
+	err = lsm6dl0_gyr_update_fs_range(stat, stat->pdata_gyr->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update gyroscope full scale range "
+								"failed\n");
+		goto  err_power_off_gyr;
+	}
+
+	err = lsm6dl0_acc_update_odr(stat, stat->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer ODR failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm6dl0_gyr_update_odr(stat, stat->pdata_gyr->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update gyroscope ODR failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm6dl0_acc_update_filter(stat,
+					stat->pdata_acc->aa_filter_bandwidth);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer filter "
+								"failed\n");
+		goto  err_power_off;
+	}
+
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	err = lsm6dl0_gyr_temp_compensation_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "sw temperature compensation init "
+								"failed\n");
+		goto  err_power_off;
+	}
+#endif
+
+	err = lsm6dl0_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = lsm6dl0_gyr_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "gyroscope input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "device %s sysfs register failed\n",
+			LSM6DL0_ACC_GYR_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lsm6dl0_acc_device_power_off(stat);
+	lsm6dl0_gyr_device_power_off(stat);
+	INIT_WORK(&stat->input_work_acc, poll_function_work_acc);
+	INIT_WORK(&stat->input_work_gyr, poll_function_work_gyr);
+	dev_info(stat->dev, "%s: probed\n", LSM6DL0_ACC_GYR_DEV_NAME);
+
+	return 0;
+
+err_input_cleanup:
+	lsm6dl0_input_cleanup(stat);
+
+err_power_off:
+err_power_off_gyr:
+	lsm6dl0_gyr_device_power_off(stat);
+
+err_power_off_acc:
+	lsm6dl0_acc_device_power_off(stat);
+
+err_hw_init:
+err_pdata_init:
+err_pdata_gyr_init:
+	if (stat->pdata_gyr->exit)
+		stat->pdata_gyr->exit();
+
+err_pdata_acc_init:
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+exit_kfree_pdata:
+	mutex_lock(&stat->lock);
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_gyr);
+	kfree(stat->pdata_main);
+	mutex_unlock(&stat->lock);
+
+err_memory_alloc:
+	if (lsm6dl0_workqueue) {
+		flush_workqueue(lsm6dl0_workqueue);
+		destroy_workqueue(lsm6dl0_workqueue);
+		lsm6dl0_workqueue = NULL;
+	}
+
+	dev_err(stat->dev,"%s: Driver Init failed\n",
+						LSM6DL0_ACC_GYR_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm6dl0_common_probe);
+
+int32_t lsm6dl0_common_remove(struct lsm6dl0_status *stat)
+{
+	remove_sysfs_interfaces(stat);
+	if (atomic_read(&stat->enabled_gyr)) {
+		lsm6dl0_gyr_disable(stat);
+		lsm6dl0_gyr_input_cleanup(stat);
+
+		if (stat->pdata_gyr->exit)
+			stat->pdata_gyr->exit();
+	}
+
+	lsm6dl0_acc_disable(stat);
+	lsm6dl0_acc_input_cleanup(stat);
+
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+	if(lsm6dl0_workqueue) {
+		flush_workqueue(lsm6dl0_workqueue);
+		destroy_workqueue(lsm6dl0_workqueue);
+		lsm6dl0_workqueue = NULL;
+	}
+
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_gyr);
+	kfree(stat->pdata_main);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dl0_common_remove);
+
+#ifdef CONFIG_PM
+int32_t lsm6dl0_common_suspend(struct lsm6dl0_status *stat)
+{
+	if (atomic_read(&stat->enabled_gyr) > 0) {
+		cancel_work_sync(&stat->input_work_gyr);
+		hrtimer_cancel(&stat->hr_timer_gyr);
+		_lsm6dl0_gyr_device_power_off(stat);
+	}
+
+	if (atomic_read(&stat->enabled_acc) > 0) {
+		cancel_work_sync(&stat->input_work_acc);
+		hrtimer_cancel(&stat->hr_timer_acc);
+		_lsm6dl0_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dl0_common_suspend);
+
+int32_t lsm6dl0_common_resume(struct lsm6dl0_status *stat)
+{
+	if (atomic_read(&stat->enabled_acc) > 0) {
+		_lsm6dl0_acc_device_power_on(stat);
+		hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc,
+							HRTIMER_MODE_REL);
+	}
+
+	if (atomic_read(&stat->enabled_gyr) > 0) {
+		_lsm6dl0_gyr_device_power_on(stat);
+		hrtimer_start(&(stat->hr_timer_gyr), stat->ktime_gyr,
+							HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dl0_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION(LSM6DL0_MOD_DESCRIPTION);
+MODULE_AUTHOR("Giuseppe Barba,STMicroelectronics");
+MODULE_LICENSE("GPL");
diff -uNr a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0.h b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0.h
--- a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,265 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ******************
+*
+* File Name		: lsm6dl0.h
+* Author		: AMS - Motion Mems Division - Application Team
+*			: Giuseppe Barba (giuseppe.barba@st.com)
+* Version		: V.1.1.0
+* Date			: 2016/May/13
+*
+******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*****************************************************************************/
+
+#ifndef	__LSM6DL0_H__
+#define	__LSM6DL0_H__
+
+/** LSM6DL0 model */
+#define LSM6DL0_ACC_GYR_DEV_NAME	"lsm6dl0"
+#define LSM6DL0_ACC_DEV_NAME		"lsm6dl0_acc"
+#define LSM6DL0_GYR_DEV_NAME    	"lsm6dl0_gyr"
+#define LSM6DL0_MOD_DESCRIPTION	"lsm6dl0 driver"
+
+/**********************************************/
+/* 	Accelerometer section defines	 	*/
+/**********************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define LSM6DL0_ACC_FS_MASK		0x18
+#define LSM6DL0_ACC_FS_2G 		0x00	/* Full scale 2g */
+#define LSM6DL0_ACC_FS_4G 		0x08	/* Full scale 4g */
+#define LSM6DL0_ACC_FS_8G 		0x10	/* Full scale 8g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define LSM6DL0_ACC_BW_400		0X00
+#define LSM6DL0_ACC_BW_200		0X01
+#define LSM6DL0_ACC_BW_100		0X02
+#define LSM6DL0_ACC_BW_50		0X03
+#define LSM6DL0_ACC_BW_MASK		0X03
+
+#define LSM6DL0_INT1_GPIO_DEF		(-EINVAL)
+#define LSM6DL0_INT2_GPIO_DEF		(-EINVAL)
+
+#define LSM6DL0_ACC_ODR_OFF		0x00
+#define LSM6DL0_ACC_ODR_MASK		0xE0
+#define LSM6DL0_ACC_ODR_14_9		0x20
+#define LSM6DL0_ACC_ODR_59_5		0x40
+#define LSM6DL0_ACC_ODR_119		0x60
+#define LSM6DL0_ACC_ODR_238		0x80
+#define LSM6DL0_ACC_ODR_476		0xA0
+#define LSM6DL0_ACC_ODR_952		0xC0
+
+#define LSM6DL0_ACC_ODR_20		0x20
+#define LSM6DL0_ACC_ODR_80		0x40
+#define LSM6DL0_ACC_ODR_160		0x60
+#define LSM6DL0_ACC_ODR_320		0x80
+#define LSM6DL0_ACC_ODR_640		0xA0
+#define LSM6DL0_ACC_ODR_1280		0xC0
+
+/**********************************************/
+/* 	Gyroscope section defines	 	*/
+/**********************************************/
+
+
+#define LSM6DL0_GYR_FS_MASK		0x18
+#define LSM6DL0_GYR_FS_245DPS		0x00
+#define LSM6DL0_GYR_FS_500DPS		0x08
+#define LSM6DL0_GYR_FS_2000DPS		0x18
+
+#define LSM6DL0_GYR_ODR_OFF		0x00
+#define LSM6DL0_GYR_ODR_MASK		0xE0
+#define LSM6DL0_GYR_ODR_MASK_SHIFT	5
+#define LSM6DL0_GYR_ODR_001		(1 << LSM6DL0_GYR_ODR_MASK_SHIFT)
+#define LSM6DL0_GYR_ODR_010		(2 << LSM6DL0_GYR_ODR_MASK_SHIFT)
+#define LSM6DL0_GYR_ODR_011		(3 << LSM6DL0_GYR_ODR_MASK_SHIFT)
+#define LSM6DL0_GYR_ODR_100		(4 << LSM6DL0_GYR_ODR_MASK_SHIFT)
+#define LSM6DL0_GYR_ODR_101		(5 << LSM6DL0_GYR_ODR_MASK_SHIFT)
+#define LSM6DL0_GYR_ODR_110		(6 << LSM6DL0_GYR_ODR_MASK_SHIFT)
+
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+#define LSM6DL0_GYR_MAX_LP_ODR_US	8
+#endif
+
+#define LSM6DL0_GYR_BW_00		0x00
+#define LSM6DL0_GYR_BW_01		0x01
+#define LSM6DL0_GYR_BW_10		0x02
+#define LSM6DL0_GYR_BW_11		0x03
+
+/** ODR periods in msec */
+#ifdef CONFIG_INPUT_LSM6DL0_S_MODEL
+/** LSM6DL0 model */
+#define LSM6DL0_ODR_14_9_US		67115
+#define LSM6DL0_ODR_59_5_US		16807
+#define LSM6DL0_ODR_119_US		 8404
+#define LSM6DL0_ODR_238_US		 4202
+#define LSM6DL0_ODR_476_US		 2101
+#define LSM6DL0_ODR_952_US		 1051
+
+#define LSM6DL0_ODR_US_001		LSM6DL0_ODR_14_9_US
+#define LSM6DL0_ODR_US_010		LSM6DL0_ODR_59_5_US
+#define LSM6DL0_ODR_US_011		LSM6DL0_ODR_119_US
+#define LSM6DL0_ODR_US_100		LSM6DL0_ODR_238_US
+#define LSM6DL0_ODR_US_101		LSM6DL0_ODR_476_US
+#define LSM6DL0_ODR_US_110		LSM6DL0_ODR_952_US
+#else
+/** LSM6DL0 model */
+#define LSM6DL0_ODR_20_US		50000
+#define LSM6DL0_ODR_80_US		12500
+#define LSM6DL0_ODR_160_US		 6250
+#define LSM6DL0_ODR_320_US		 3125
+#define LSM6DL0_ODR_640_US		 1563
+#define LSM6DL0_ODR_1280_US		  782
+
+#define LSM6DL0_ODR_US_001		LSM6DL0_ODR_20_US
+#define LSM6DL0_ODR_US_010		LSM6DL0_ODR_80_US
+#define LSM6DL0_ODR_US_011		LSM6DL0_ODR_160_US
+#define LSM6DL0_ODR_US_100		LSM6DL0_ODR_320_US
+#define LSM6DL0_ODR_US_101		LSM6DL0_ODR_640_US
+#define LSM6DL0_ODR_US_110		LSM6DL0_ODR_1280_US
+#endif
+
+#define LSM6DL0_GYR_MIN_POLL_PERIOD_US	LSM6DL0_ODR_US_110
+#define LSM6DL0_ACC_MIN_POLL_PERIOD_US	LSM6DL0_ODR_US_110
+#define LSM6DL0_GYR_POLL_INTERVAL_DEF	LSM6DL0_ODR_US_001
+#define LSM6DL0_ACC_POLL_INTERVAL_DEF	LSM6DL0_ODR_US_001
+
+#define LSM6DL0_RX_MAX_LENGTH		500
+#define LSM6DL0_TX_MAX_LENGTH		500
+
+struct lsm6dl0_status;
+
+struct lsm6dl0_acc_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+	uint8_t aa_filter_bandwidth;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct lsm6dl0_gyr_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct lsm6dl0_main_platform_data {
+	int32_t gpio_int1;
+	int32_t gpio_int2;
+	short rot_matrix[3][3];
+	struct lsm6dl0_acc_platform_data *pdata_acc;
+	struct lsm6dl0_gyr_platform_data *pdata_gyr;
+#ifdef CONFIG_OF
+	struct device_node	*of_node;
+#endif
+};
+
+struct lsm6dl0_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM6DL0_RX_MAX_LENGTH];
+	u8 tx_buf[LSM6DL0_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6dl0_transfer_function {
+	int (*write) (struct lsm6dl0_status *cdata, u8 reg_addr, int len, u8 *data);
+	int (*read) (struct lsm6dl0_status *cdata, u8 reg_addr, int len, u8 *data);
+};
+
+struct lsm6dl0_status {
+	struct lsm6dl0_main_platform_data *pdata_main;
+	struct lsm6dl0_acc_platform_data *pdata_acc;
+	struct lsm6dl0_gyr_platform_data *pdata_gyr;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct work_struct input_work_gyr;
+
+	struct hrtimer hr_timer_acc;
+	ktime_t ktime_acc;
+	struct hrtimer hr_timer_gyr;
+	ktime_t ktime_gyr;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_gyr;
+	struct device *dev;
+	u16 bustype;
+
+	int8_t hw_initialized;
+
+	/* hw_working=-1 means not tested yet */
+	int8_t hw_working;
+
+	atomic_t enabled_acc;
+	atomic_t enabled_gyr;
+	atomic_t enabled_temp;
+
+	int32_t on_before_suspend;
+
+	uint32_t sensitivity_acc;
+	uint32_t sensitivity_gyr;
+	int32_t irq;
+
+	int32_t irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+
+	int32_t irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef CONFIG_INPUT_LSM6DL0_SW_COMP
+	int8_t k_fs;
+	int8_t k_coeff[3];
+	int32_t compensation_temp;
+#endif
+#ifdef CONFIG_INPUT_LSM6DL0_LP
+	atomic_t low_power_state;
+	atomic_t enabled_lp_mode;
+
+	/** gyr_discard_samples count the number of samples to be discarded
+	    after switching between low-power and normal mode */
+	uint8_t gyr_discard_samples;
+#endif
+	/** acc_discard_samples count the number of samples to be discarded
+	    after switching between power-down mode and normal mode */
+	uint8_t acc_discard_samples;
+
+	const struct lsm6dl0_transfer_function *tf;
+	struct lsm6dl0_transfer_buffer tb;
+};
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int32_t lsm6dl0_common_probe(struct lsm6dl0_status *stat);
+int32_t lsm6dl0_common_remove(struct lsm6dl0_status *stat);
+
+#ifdef CONFIG_PM
+int32_t lsm6dl0_common_suspend(struct lsm6dl0_status *stat);
+int32_t lsm6dl0_common_resume(struct lsm6dl0_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __LSM6DL0_H__ */
diff -uNr a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_i2c.c b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_i2c.c
--- a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,170 @@
+/*
+ * STMicroelectronics lsm6dl0 i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "lsm6dl0.h"
+
+static int lsm6dl0_i2c_read(struct lsm6dl0_status *cdata, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	return (err == 2) ? 0 : 1;
+}
+
+static int lsm6dl0_i2c_write(struct lsm6dl0_status *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return (err == 1) ? 0 : 1;
+}
+
+
+static const struct lsm6dl0_transfer_function lsm6dl0_tf_i2c = {
+	.write = lsm6dl0_i2c_write,
+	.read = lsm6dl0_i2c_read,
+};
+
+static int lsm6dl0_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6dl0_status *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->irq = client->irq;
+	cdata->tf = &lsm6dl0_tf_i2c;
+	cdata->bustype = BUS_I2C;
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm6dl0_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lsm6dl0_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6dl0_status *cdata = i2c_get_clientdata(client);
+
+	lsm6dl0_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DL0_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6dl0_suspend(struct device *dev)
+{
+	struct lsm6dl0_status *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6dl0_common_suspend(cdata);
+}
+
+static int lsm6dl0_resume(struct device *dev)
+{
+	struct lsm6dl0_status *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6dl0_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6dl0_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6dl0_suspend, lsm6dl0_resume)
+};
+
+#define LSM6DL0_PM_OPS		(&lsm6dl0_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DL0_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lsm6dl0_ids[] = {
+	{ LSM6DL0_ACC_GYR_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lsm6dl0_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dl0_id_table[] = {
+	{ .compatible = "st,lsm6dl0", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6dl0_id_table);
+#endif
+
+static struct i2c_driver lsm6dl0_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DL0_ACC_GYR_DEV_NAME,
+		.pm = LSM6DL0_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lsm6dl0_id_table),
+#endif
+	},
+	.probe    = lsm6dl0_i2c_probe,
+	.remove   = lsm6dl0_i2c_remove,
+	.id_table = lsm6dl0_ids,
+};
+
+module_i2c_driver(lsm6dl0_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dl0 i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_spi.c b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_spi.c
--- a/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dl0/lsm6dl0_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,191 @@
+/*
+ * STMicroelectronics lsm6dl0 spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "lsm6dl0.h"
+
+#define SENSORS_SPI_READ 0x80
+
+static int lsm6dl0_spi_read(struct lsm6dl0_status *cdata, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (!err)
+		memcpy(data, cdata->tb.rx_buf, len);
+		
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int lsm6dl0_spi_write(struct lsm6dl0_status *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM6DL0_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static const struct lsm6dl0_transfer_function lsm6dl0_tf_spi = {
+	.write = lsm6dl0_spi_write,
+	.read = lsm6dl0_spi_read,
+};
+
+static int lsm6dl0_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6dl0_status *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->irq = spi->irq;
+	cdata->tf = &lsm6dl0_tf_spi;
+	cdata->bustype = BUS_SPI;
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm6dl0_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lsm6dl0_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lsm6dl0_status *cdata = spi_get_drvdata(spi);
+
+	lsm6dl0_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DL0_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6dl0_suspend(struct device *dev)
+{
+	struct lsm6dl0_status *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6dl0_common_suspend(cdata);
+}
+
+static int lsm6dl0_resume(struct device *dev)
+{
+	struct lsm6dl0_status *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6dl0_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6dl0_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6dl0_suspend, lsm6dl0_resume)
+};
+
+#define LSM6DL0_PM_OPS		(&lsm6dl0_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DL0_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lsm6dl0_ids[] = {
+	{ LSM6DL0_ACC_GYR_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm6dl0_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dl0_id_table[] = {
+	{ .compatible = "st,lsm6dl0", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6dl0_id_table);
+#endif
+
+static struct spi_driver lsm6dl0_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DL0_ACC_GYR_DEV_NAME,
+		.pm = LSM6DL0_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lsm6dl0_id_table),
+#endif
+	},
+	.probe    = lsm6dl0_spi_probe,
+	.remove   = lsm6dl0_spi_remove,
+	.id_table = lsm6dl0_ids,
+};
+
+module_spi_driver(lsm6dl0_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dl0 spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dl0/Makefile b/drivers/input/misc/st/imu/lsm6dl0/Makefile
--- a/drivers/input/misc/st/imu/lsm6dl0/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dl0/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM imu lsm6dl0 driver
+#
+lsm6dl0-core-y += lsm6dl0_core.o
+obj-$(CONFIG_INPUT_LSM6DL0) += lsm6dl0-core.o
+obj-$(CONFIG_INPUT_LSM6DL0_I2C) += lsm6dl0_i2c.o
+obj-$(CONFIG_INPUT_LSM6DL0_SPI) += lsm6dl0_spi.o
diff -uNr a/drivers/input/misc/st/imu/lsm6ds0/Kconfig b/drivers/input/misc/st/imu/lsm6ds0/Kconfig
--- a/drivers/input/misc/st/imu/lsm6ds0/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds0/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LSM6DS0
+	tristate "STMicroelectronics LSM6DS0 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM6DS0_I2C if (I2C)
+	select INPUT_LSM6DS0_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM6DS0 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm6ds0.
+
+config INPUT_LSM6DS0_I2C
+	tristate
+	depends on INPUT_LSM6DS0
+	depends on I2C
+
+config INPUT_LSM6DS0_SPI
+	tristate
+	depends on INPUT_LSM6DS0
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_core.c b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_core.c
--- a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_core.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,2510 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ******************
+*
+* File Name		: lsm6ds0_core.c
+* Author		: MSH - C&I BU - Application Team
+*			: Giuseppe Barba (giuseppe.barba@st.com)
+*			: Author is willing to be considered the contact
+*			: and update point for the driver.
+* Version		: V.1.1.0
+* Date			: 2016/May/13
+* Description		: LSM6DS0 driver
+*
+******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*****************************************************************************/
+//#define DEBUG
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm6ds0.h"
+
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+#define COMP_X_FACTOR_ADDR		0x7F
+#define COMP_Y_FACTOR_ADDR		0xF0
+#define COMP_Z_FACTOR_ADDR		0xF1
+#define COMP_HW_DISABLE_MASK		0xC0
+#endif
+
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+#define LSM6DS0_GYR_LPF1		0
+#define LSM6DS0_GYR_LPF1_2		1
+#define LSM6DS0_GYR_LP_TH_US		(LSM6DS0_ODR_US_100)
+
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL
+#define CONFIG_INPUT_LSM6DS0_S_MODEL_LP
+#endif
+#endif
+
+#define MS_TO_US(x)			(x * 1000L)
+#define US_TO_NS(x)			(x * 1000L)
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define NS_TO_US(x)			(x / 1000)
+#define US_TO_MS(x)			(x / 1000)
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+#define REFERENCE_G			0x0B
+
+/* TODO: check the following values */
+/* Sensitivity */
+#define SENSITIVITY_ACC_2G		61	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		122	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		244	/** ug/LSB */
+#define SENSITIVITY_GYR_250		8750	/** udps/LSB */
+#define SENSITIVITY_GYR_500		17500	/** udps/LSB */
+#define SENSITIVITY_GYR_2000		70000	/** udps/LSB */
+#define SENSITIVITY_TEMP		16	/** LSB/C */
+#define OFFSET_TEMP			25	/** Offset temperature */
+
+#define ACC_G_MAX_POS			1495040	/** max positive value acc [ug] */
+#define ACC_G_MAX_NEG			1495770	/** max negative value acc [ug] */
+#define GYR_FS_MAX			32768
+
+#define FUZZ				0
+#define FLAT				0
+
+#define FILTER_50			50	/** Anti-Aliasing 50 Hz */
+#define FILTER_100			100	/** Anti-Aliasing 105 Hz */
+#define FILTER_200			200	/** Anti-Aliasing 211 Hz */
+#define FILTER_400			400	/** Anti-Aliasing 408 Hz */
+
+#define RANGE_245DPS			245
+#define RANGE_500DPS			500
+#define RANGE_2000DPS			2000
+
+#define ACT_THS				0x04
+#define ACT_DUR				0x05
+#define WHO_AM_I			0x0F
+#define WHO_AM_I_VAL			0x68
+
+/* Angular rate sensor Control Register 1 */
+#define CTRL_REG1_G			0x10
+
+#define BW_G_SHIFT			0
+#define BW_G_MASK			0x03
+
+#define FS_G_SHIFT			3
+#define FS_G_MASK			0x18
+
+/* Angular rate sensor Control Register 2 */
+#define CTRL_REG2_G			0x11
+
+#define OUT_SEL_SHIFT			0
+#define OUT_SEL_MASK			0x03
+
+#define INT_SEL_SHIFT			2
+#define INT_SEL_MASK			0x0C
+
+#define CTRL_REG3_G			0x12
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+#define CTRL_REG3_G_LP_MODE_MASK	0x80
+#endif
+
+/* Angular rate sensor sign and orientation register. */
+#define ORIENT_CFG_G			0x13
+#define ORIENT_CFG_G_SIGN_X_MASK	0x20
+#define ORIENT_CFG_G_SIGN_Y_MASK	0x10
+#define ORIENT_CFG_G_SIGN_Z_MASK	0x08
+#define ORIENT_CFG_G_SIGN_ORIENT_MASK	0x07
+#define OUT_TEMP_L			0x15
+#define OUT_TEMP_H			0x16
+#define STATUS_REG1			0x17
+#define	OUT_X_L_G			0x18 /* 1st AXIS OUT REG of 6 */
+#define CTRL_REG4			0x1E
+#define CTRL_REG4_DEF			0x38
+#define CTRL_REG4_X_EN			0x08
+#define CTRL_REG4_Y_EN			0x10
+#define CTRL_REG4_Z_EN			0x20
+#define CTRL_REG4_ALL_AXES_EN		0x38
+#define CTRL_REG4_AXES_EN_MASK		0x38
+#define CTRL_REG5_XL			0x1F
+#define CTRL_REG5_XL_DEF		0x38
+#define CTRL_REG6_XL			0x20
+#define LSM6DS0_ACC_FS_DEF		LSM6DS0_ACC_FS_2G
+#define BW_SCAL_ODR_SHIFT		2
+#define BW_SCAL_ODR_MASK		0x04
+#define BW_XL_50			0x0C
+#define BW_XL_105			0x08
+#define BW_XL_211			0x04
+#define BW_XL_408			0x00
+#define BW_XL_DEF			BW_XL_408
+#define CTRL_REG7_XL			0x21
+#define CTRL_REG8			0x22
+#define CTRL_REG8_DEF			0x44
+#define CTRL_REG9			0x23
+#define CTRL_REG10			0x24
+#define STATUS_REG2			0x27
+#define OUT_X_L_XL			0x28 /* 1st AXIS OUT REG of 6 */
+#define FIFO_CTRL			0x2E
+#define FIFO_SRC			0x2F
+/* INT1_A/G pin control register. */
+#define INT1_CTRL			0x0C
+#define INT1_CTRL_IG_G_MASK		0x80
+#define INT1_CTRL_IG_XL_MASK		0x40
+#define INT1_CTRL_FSS5_MASK		0x20
+#define INT1_CTRL_OVR_MASK		0x10
+#define INT1_CTRL_FTH_MASK		0x08
+#define INT1_CTRL_BOOT_MASK		0x04
+#define INT1_CTRL_DRDY_G_MASK		0x02
+#define INT1_CTRL_DRDY_XL_MASK		0x01
+
+/* INT2_A/G pin control register. */
+#define INT2_CTRL			0x0D
+#define INT2_CTRL_INACT_MASK		0x80
+#define INT2_CTRL_FSS5_MASK		0x20
+#define INT2_CTRL_OVR_MASK		0x10
+#define INT2_CTRL_FTH_MASK		0x08
+#define INT2_CTRL_DRDY_TEMP_MASK	0x04
+#define INT2_CTRL_DRDY_G_MASK		0x02
+#define INT2_CTRL_DRDY_XL_MASK		0x01
+
+/* Linear acceleration sensor interrupt source register. */
+#define INT_GEN_SRC_XL			0x26
+#define INT_GEN_SRC_XL_IA_MASK		0x40
+#define INT_GEN_SRC_XL_ZH_MASK		0x20
+#define INT_GEN_SRC_XL_ZL_MASK		0x10
+#define INT_GEN_SRC_XL_YH_MASK		0x08
+#define INT_GEN_SRC_XL_YL_MASK		0x04
+#define INT_GEN_SRC_XL_XH_MASK		0x02
+#define INT_GEN_SRC_XL_XL_MASK		0x01
+
+/* Linear acceleration sensor interrupt generator configuration register. */
+#define INT_GEN_CFG_XL			0x06
+#define INT_GEN_CFG_XL_AOI_MASK		0x80
+#define INT_GEN_CFG_XL_6D_MASK		0x40
+#define INT_GEN_CFG_XL_ZHIE_MASK	0x20
+#define INT_GEN_CFG_XL_ZLIE_MASK	0x10
+#define INT_GEN_CFG_XL_YHIE_MASK	0x08
+#define INT_GEN_CFG_XL_YLIE_MASK	0x04
+#define INT_GEN_CFG_XL_XHIE_MASK	0x02
+#define INT_GEN_CFG_XL_XLIE_MASK	0x01
+
+/* Linear acceleration sensor interrupt threshold registers. */
+#define INT_GEN_THS_X_XL		0x07
+#define INT_GEN_THS_Y_XL		0x08
+#define INT_GEN_THS_Z_XL		0x09
+
+/* Linear acceleration sensor interrupt duration register. */
+#define INT_GEN_DUR_XL			0x0A
+#define INT_GEN_DUR_XL_WAIT_MASK	0x80
+#define INT_GEN_DUR_XL_DUR_MASK		0x7F
+
+/* Angular rate sensor interrupt source register. */
+#define INT_GEN_SRC_G			0x14
+#define INT_GEN_SRC_G_IA_MASK		0x40
+#define INT_GEN_SRC_G_ZH_MASK		0x20
+#define INT_GEN_SRC_G_ZL_MASK		0x10
+#define INT_GEN_SRC_G_YH_MASK		0x08
+#define INT_GEN_SRC_G_YL_MASK		0x04
+#define INT_GEN_SRC_G_XH_MASK		0x02
+#define INT_GEN_SRC_G_XL_MASK		0x01
+
+/* Angular rate sensor interrupt generator configuration register. */
+#define INT_GEN_CFG_G			0x30
+#define INT_GEN_CFG_G_AOI_MASK		0x80
+#define INT_GEN_CFG_G_LIR_MASK		0x40
+#define INT_GEN_CFG_G_ZHIE_MASK		0x20
+#define INT_GEN_CFG_G_ZLIE_MASK		0x10
+#define INT_GEN_CFG_G_YHIE_MASK		0x08
+#define INT_GEN_CFG_G_YLIE_MASK		0x04
+#define INT_GEN_CFG_G_XHIE_MASK		0x02
+#define INT_GEN_CFG_G_XLIE_MASK		0x01
+
+/* Angular rate sensor interrupt generator threshold registers. */
+#define INT_GEN_THS_XH_G		0x31
+#define INT_GEN_THS_XL_G		0x32
+#define INT_GEN_THS_YH_G		0x33
+#define INT_GEN_THS_YL_G		0x34
+#define INT_GEN_THS_ZH_G		0x35
+#define INT_GEN_THS_ZL_G		0x36
+
+/* Angular rate sensor interrupt generator duration register. */
+#define INT_GEN_DUR_G			0x37
+#define INT_GEN_DUR_G_WAIT_MASK		0x80
+#define INT_GEN_DUR_G_DUR_MASK		0x7F
+
+#define DEF_ZERO			0x00
+#define UNDEF				0x00
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+#define LSM6DS0_ATTTR(_name, _leaf, _mode, _show, _store) \
+	struct device_attribute lsm6ds0_attr_##_name = __ATTR(_leaf, _mode, _show, _store)
+
+static struct workqueue_struct *lsm6ds0_workqueue;
+
+
+struct output_rate{
+	uint32_t cutoff_us;
+	uint8_t value;
+};
+
+static const struct output_rate lsm6ds0_gyr_odr_table[] = {
+	{ LSM6DS0_ODR_US_110, (LSM6DS0_GYR_ODR_110 | (LSM6DS0_GYR_BW_11)) },
+	{ LSM6DS0_ODR_US_101, (LSM6DS0_GYR_ODR_101 | (LSM6DS0_GYR_BW_11)) },
+	{ LSM6DS0_ODR_US_100, (LSM6DS0_GYR_ODR_100 | (LSM6DS0_GYR_BW_11)) },
+	{ LSM6DS0_ODR_US_011, (LSM6DS0_GYR_ODR_011 | (LSM6DS0_GYR_BW_11)) },
+	{ LSM6DS0_ODR_US_010, (LSM6DS0_GYR_ODR_010 | (LSM6DS0_GYR_BW_11)) },
+	{ LSM6DS0_ODR_US_001, (LSM6DS0_GYR_ODR_001) },
+};
+
+static const struct output_rate lsm6ds0_acc_odr_table[] = {
+        { LSM6DS0_ODR_US_110, (LSM6DS0_GYR_ODR_110) },
+        { LSM6DS0_ODR_US_101, (LSM6DS0_GYR_ODR_101) },
+        { LSM6DS0_ODR_US_100, (LSM6DS0_GYR_ODR_100) },
+        { LSM6DS0_ODR_US_011, (LSM6DS0_GYR_ODR_011) },
+        { LSM6DS0_ODR_US_010, (LSM6DS0_GYR_ODR_010) },
+        { LSM6DS0_ODR_US_001, (LSM6DS0_GYR_ODR_001) },
+};
+
+struct discard_list {
+	uint32_t param;
+	uint8_t count;
+};
+
+static const struct acc_turn_on_time {
+	uint32_t odr_us;
+	struct discard_list disc_list[4];
+} lsm6ds0_acc_turn_on_time [] = {
+	{ LSM6DS0_ODR_US_110,{	{ LSM6DS0_ACC_BW_400, 2},
+				{ LSM6DS0_ACC_BW_200, 4},
+				{ LSM6DS0_ACC_BW_100, 7},
+				{ LSM6DS0_ACC_BW_50,  14},},},
+	{ LSM6DS0_ODR_US_101,{	{ LSM6DS0_ACC_BW_400, 1},
+				{ LSM6DS0_ACC_BW_200, 2},
+				{ LSM6DS0_ACC_BW_100, 4},
+				{ LSM6DS0_ACC_BW_50,  7},},},
+	{ LSM6DS0_ODR_US_100,{	{ LSM6DS0_ACC_BW_400, 1},
+				{ LSM6DS0_ACC_BW_200, 1},
+				{ LSM6DS0_ACC_BW_100, 2},
+				{ LSM6DS0_ACC_BW_50,  4},},},
+	{ LSM6DS0_ODR_US_011,{	{ LSM6DS0_ACC_BW_400, 1},
+				{ LSM6DS0_ACC_BW_200, 1},
+				{ LSM6DS0_ACC_BW_100, 1},
+				{ LSM6DS0_ACC_BW_50,  2},},},
+	{ LSM6DS0_ODR_US_010,{	{ LSM6DS0_ACC_BW_400, 0},
+				{ LSM6DS0_ACC_BW_200, 0},
+				{ LSM6DS0_ACC_BW_100, 0},
+				{ LSM6DS0_ACC_BW_50,  0},},},
+	{ LSM6DS0_ODR_US_001,{	{ LSM6DS0_ACC_BW_400, 0},
+				{ LSM6DS0_ACC_BW_200, 0},
+				{ LSM6DS0_ACC_BW_100, 0},
+				{ LSM6DS0_ACC_BW_50,  0},},},
+};
+
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+static const struct gyr_turn_on_time {
+	uint32_t odr_us;
+	struct discard_list disc_list[2];
+} lsm6ds0_gyr_turn_on_time [] = {
+	{ LSM6DS0_ODR_US_110,{	{ LSM6DS0_GYR_LPF1,   8},
+				{ LSM6DS0_GYR_LPF1_2, 18},},},
+	{ LSM6DS0_ODR_US_101,{	{ LSM6DS0_GYR_LPF1,   5},
+				{ LSM6DS0_GYR_LPF1_2, 15},},},
+	{ LSM6DS0_ODR_US_100,{	{ LSM6DS0_GYR_LPF1,   4},
+				{ LSM6DS0_GYR_LPF1_2, 14},},},
+	{ LSM6DS0_ODR_US_011,{	{ LSM6DS0_GYR_LPF1,   3},
+				{ LSM6DS0_GYR_LPF1_2, 13},},},
+	{ LSM6DS0_ODR_US_010,{	{ LSM6DS0_GYR_LPF1,   3},
+				{ LSM6DS0_GYR_LPF1_2, 13},},},
+	{ LSM6DS0_ODR_US_001,{	{ LSM6DS0_GYR_LPF1,   2},
+				{ LSM6DS0_GYR_LPF1_2, 0},},},
+};
+#endif
+
+static const struct lsm6ds0_acc_platform_data default_lsm6ds0_acc_pdata = {
+	.fs_range = LSM6DS0_ACC_FS_2G,
+	.poll_interval = LSM6DS0_ACC_POLL_INTERVAL_DEF,
+	.min_interval = LSM6DS0_ACC_MIN_POLL_PERIOD_US,
+	.aa_filter_bandwidth = LSM6DS0_ACC_BW_400,
+};
+
+static const struct lsm6ds0_gyr_platform_data default_lsm6ds0_gyr_pdata = {
+	.fs_range = LSM6DS0_GYR_FS_245DPS,
+	.poll_interval = LSM6DS0_GYR_POLL_INTERVAL_DEF,
+	.min_interval = LSM6DS0_GYR_MIN_POLL_PERIOD_US,
+};
+
+struct lsm6ds0_main_platform_data default_lsm6ds0_main_platform_data = {
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+	.gpio_int1 = LSM6DS0_INT1_GPIO_DEF,
+	.gpio_int2 = LSM6DS0_INT2_GPIO_DEF,
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	uint8_t address;
+	uint8_t mask;
+};
+
+struct interrupt_value {
+	int32_t value;
+	uint8_t address;
+};
+
+
+struct reg_rw {
+	uint8_t address;
+	uint8_t default_val;
+	uint8_t resume_val;
+};
+
+struct reg_r {
+	uint8_t address;
+	uint8_t default_val;
+};
+
+static struct status_registers {
+	struct reg_rw act_ths;
+	struct reg_rw act_dur;
+	struct reg_rw int_gen_cfg_xl;
+	struct reg_rw int_gen_ths_x_xl;
+	struct reg_rw int_gen_ths_y_xl;
+	struct reg_rw int_gen_ths_z_xl;
+	struct reg_rw int_gen_dur_xl;
+	struct reg_rw reference_g;
+	struct reg_rw int1_ctrl;
+	struct reg_rw int2_ctrl;
+	struct reg_r who_am_i;
+	struct reg_rw ctrl_reg1_g;
+	struct reg_rw ctrl_reg2_g;
+	struct reg_rw ctrl_reg3_g;
+	struct reg_rw orient_cfg_g;
+	struct reg_r int_gen_src_g;
+	struct reg_r status_reg1;
+	struct reg_rw ctrl_reg4;
+	struct reg_rw ctrl_reg5_xl;
+	struct reg_rw ctrl_reg6_xl;
+	struct reg_rw ctrl_reg7_xl;
+	struct reg_rw ctrl_reg8;
+	struct reg_rw ctrl_reg9;
+	struct reg_rw ctrl_reg10;
+	struct reg_r int_gen_src_xl;
+	struct reg_r status_reg2;
+	struct reg_rw fifo_ctrl;
+	struct reg_r fifo_src;
+	struct reg_rw int_gen_cfg_g;
+	struct reg_rw int_gen_ths_xh_g;
+	struct reg_rw int_gen_ths_xl_g;
+	struct reg_rw int_gen_ths_yh_g;
+	struct reg_rw int_gen_ths_yl_g;
+	struct reg_rw int_gen_ths_zh_g;
+	struct reg_rw int_gen_ths_zl_g;
+	struct reg_rw int_gen_dur_g;
+} status_registers = {
+	.act_ths =
+		{.address = ACT_THS, 		.default_val = DEF_ZERO,},
+	.act_dur =
+		{.address = ACT_DUR, 		.default_val = DEF_ZERO,},
+	.int_gen_cfg_xl =
+		{.address = INT_GEN_CFG_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_x_xl =
+		{.address = INT_GEN_THS_X_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_y_xl =
+		{.address = INT_GEN_THS_Y_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_z_xl =
+		{.address = INT_GEN_THS_Z_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_dur_xl =
+		{.address = INT_GEN_DUR_XL, 	.default_val = DEF_ZERO,},
+	.reference_g =
+		{.address = REFERENCE_G, 	.default_val = DEF_ZERO,},
+	.int1_ctrl =
+		{.address = INT1_CTRL,		.default_val = DEF_ZERO,},
+	.int2_ctrl =
+		{.address = INT2_CTRL,		.default_val = DEF_ZERO,},
+	.who_am_i =
+		{.address = WHO_AM_I,		.default_val = WHO_AM_I_VAL,},
+	.ctrl_reg1_g =
+		{.address = CTRL_REG1_G,	.default_val = DEF_ZERO,},
+	.ctrl_reg2_g =
+		{.address = CTRL_REG2_G,	.default_val = DEF_ZERO,},
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL_LP
+		/** LSM6L0 require the LP bit to be set to 0 */
+	.ctrl_reg3_g =
+		{.address = CTRL_REG3_G,
+				.default_val = CTRL_REG3_G_LP_MODE_MASK,},
+#else
+	.ctrl_reg3_g =
+		{.address = CTRL_REG3_G,	.default_val = DEF_ZERO,},
+#endif
+	.orient_cfg_g =
+		{.address = ORIENT_CFG_G,	.default_val = DEF_ZERO,},
+	.int_gen_src_g =
+		{.address = INT_GEN_SRC_G,	.default_val = UNDEF,},
+	.status_reg1 =
+		{.address = STATUS_REG1,	.default_val = UNDEF,},
+	.ctrl_reg4 =
+		{.address = CTRL_REG4,		.default_val = CTRL_REG4_DEF,},
+	.ctrl_reg5_xl =
+		{.address = CTRL_REG5_XL,	.default_val = CTRL_REG5_XL_DEF,},
+	.ctrl_reg6_xl =
+		{.address = CTRL_REG6_XL,	.default_val = DEF_ZERO,},
+	.ctrl_reg7_xl =
+		{.address = CTRL_REG7_XL,	.default_val = DEF_ZERO,},
+	.ctrl_reg8 =
+		{.address = CTRL_REG8,		.default_val = CTRL_REG8_DEF,},
+	.ctrl_reg9 =
+		{.address = CTRL_REG9,		.default_val = DEF_ZERO,},
+	.ctrl_reg10 =
+		{.address = CTRL_REG10,	.default_val = DEF_ZERO,},
+	.int_gen_src_xl =
+		{.address = INT_GEN_SRC_XL,	.default_val = DEF_ZERO,},
+	.status_reg2 =
+		{.address = STATUS_REG2,	.default_val = UNDEF,},
+	.fifo_ctrl =
+		{.address = FIFO_CTRL,		.default_val = DEF_ZERO,},
+	.fifo_src =
+		{.address = FIFO_SRC,		.default_val = UNDEF,},
+	.int_gen_cfg_g =
+		{.address = INT_GEN_CFG_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_xh_g =
+		{.address = INT_GEN_THS_XH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_xl_g =
+		{.address = INT_GEN_THS_XL_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_yh_g =
+		{.address = INT_GEN_THS_YH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_yl_g =
+		{.address = INT_GEN_THS_YL_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_zh_g =
+		{.address = INT_GEN_THS_ZH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_zl_g =
+		{.address = INT_GEN_THS_ZL_G,	.default_val = DEF_ZERO,},
+	.int_gen_dur_g =
+		{.address = INT_GEN_DUR_G,	.default_val = DEF_ZERO,},
+};
+
+static int32_t _lsm6ds0_acc_device_power_off(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf = (LSM6DS0_ACC_ODR_MASK & LSM6DS0_ACC_ODR_OFF) |
+				   ((~LSM6DS0_ACC_ODR_MASK) &
+				   status_registers.ctrl_reg6_xl.resume_val);
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg6_xl.address, 1, &buf);
+
+	if (err < 0)
+		dev_err(stat->dev, "accelerometer soft power off "
+							"failed: %d\n", err);
+
+	if (stat->pdata_acc->power_off) {
+		stat->pdata_acc->power_off();
+	}
+
+	return 0;
+}
+
+static int32_t lsm6ds0_acc_device_power_off(struct lsm6ds0_status *stat)
+{
+	_lsm6ds0_acc_device_power_off(stat);
+
+	atomic_set(&stat->enabled_acc, 0);
+	dev_info(stat->dev, "accelerometer switched off.");
+
+	return 0;
+}
+
+static int32_t _lsm6ds0_gyr_device_power_off(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf = (LSM6DS0_GYR_ODR_MASK & LSM6DS0_GYR_ODR_OFF) |
+				   ((~LSM6DS0_GYR_ODR_MASK) &
+				   status_registers.ctrl_reg1_g.resume_val);
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 1, &buf);
+
+	if (err < 0)
+		dev_err(stat->dev, "gyroscope soft power off "
+							"failed: %d\n", err);
+
+	if (stat->pdata_gyr->power_off) {
+		stat->pdata_gyr->power_off();
+	}
+
+	return 0;
+}
+
+static int32_t lsm6ds0_gyr_device_power_off(struct lsm6ds0_status *stat)
+{
+	_lsm6ds0_gyr_device_power_off(stat);
+	atomic_set(&stat->enabled_gyr, 0);
+	dev_info(stat->dev, "gyroscope switched off.");
+
+	return 0;
+}
+
+static int32_t lsm6ds0_gyr_disable(struct lsm6ds0_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_gyr, 1, 0)) {
+		cancel_work_sync(&stat->input_work_gyr);
+		hrtimer_cancel(&stat->hr_timer_gyr);
+		lsm6ds0_gyr_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static int32_t lsm6ds0_acc_disable(struct lsm6ds0_status *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled_acc, 1, 0)) {
+		if (atomic_read(&stat->enabled_gyr) > 0)
+			lsm6ds0_gyr_disable(stat);
+
+		cancel_work_sync(&stat->input_work_acc);
+		hrtimer_cancel(&stat->hr_timer_acc);
+		lsm6ds0_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static void lsm6ds0_acc_input_cleanup(struct lsm6ds0_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+}
+
+static void lsm6ds0_gyr_input_cleanup(struct lsm6ds0_status *stat)
+{
+	input_unregister_device(stat->input_dev_gyr);
+	input_free_device(stat->input_dev_gyr);
+}
+
+static enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct lsm6ds0_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm6ds0_status, hr_timer_acc);
+
+	queue_work(lsm6ds0_workqueue, &stat->input_work_acc);
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart poll_function_read_gyr(struct hrtimer *timer)
+{
+	struct lsm6ds0_status *stat;
+
+
+	stat = container_of((struct hrtimer *)timer,
+				struct lsm6ds0_status, hr_timer_gyr);
+
+	queue_work(lsm6ds0_workqueue, &stat->input_work_gyr);
+	return HRTIMER_NORESTART;
+}
+
+static void lsm6ds0_validate_polling(uint32_t *min_interval,
+					uint32_t *poll_interval,
+					uint32_t min)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int32_t lsm6ds0_acc_validate_pdata(struct lsm6ds0_status *stat)
+{
+	int32_t res = -EINVAL;
+
+	lsm6ds0_validate_polling(&stat->pdata_acc->min_interval,
+				 &stat->pdata_acc->poll_interval,
+				(unsigned int)LSM6DS0_ACC_MIN_POLL_PERIOD_US);
+
+	switch (stat->pdata_acc->aa_filter_bandwidth) {
+	case LSM6DS0_ACC_BW_50:
+		res = 1;
+		break;
+	case LSM6DS0_ACC_BW_100:
+		res = 1;
+		break;
+	case LSM6DS0_ACC_BW_200:
+		res = 1;
+		break;
+	case LSM6DS0_ACC_BW_400:
+		res = 1;
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+			"bandwidth selected: %u\n",
+				stat->pdata_acc->aa_filter_bandwidth);
+	}
+
+	return res;
+}
+
+static int32_t lsm6ds0_gyr_validate_pdata(struct lsm6ds0_status *stat)
+{
+	/* checks for correctness of minimal polling period */
+	lsm6ds0_validate_polling(&stat->pdata_gyr->min_interval,
+				 &stat->pdata_gyr->poll_interval,
+				(unsigned int)LSM6DS0_GYR_MIN_POLL_PERIOD_US);
+
+	/* Enforce minimum polling interval */
+	if (stat->pdata_gyr->poll_interval < stat->pdata_gyr->min_interval) {
+		dev_err(stat->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	stat->compensation_temp = 0;
+#endif
+	return 0;
+}
+
+
+static int32_t lsm6ds0_hw_init(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf;
+
+	dev_info(stat->dev, "%s: hw init start\n",
+						LSM6DS0_ACC_GYR_DEV_NAME);
+
+	err = stat->tf->read(stat, status_registers.who_am_i.address, 1, &buf);
+	if (err < 0) {
+		dev_warn(stat->dev, "Error reading WHO_AM_I: is device"
+		" available/working?\n");
+		goto err_firstread;
+	} else
+		stat->hw_working = 1;
+
+	if (buf != status_registers.who_am_i.default_val) {
+	dev_err(stat->dev,
+		"device unknown. Expected: 0x%02x,"
+		" Replies: 0x%02x\n", status_registers.who_am_i.default_val,
+					buf);
+		err = -1;
+		goto err_unknown_device;
+	}
+
+	status_registers.act_ths.resume_val =
+				status_registers.act_ths.default_val;
+	status_registers.act_dur.resume_val =
+				status_registers.act_dur.default_val;
+	status_registers.int_gen_cfg_xl.resume_val =
+				status_registers.int_gen_cfg_xl.default_val;
+	status_registers.int_gen_ths_x_xl.resume_val =
+				status_registers.int_gen_ths_x_xl.default_val;
+	status_registers.int_gen_ths_y_xl.resume_val =
+				status_registers.int_gen_ths_y_xl.default_val;
+	status_registers.int_gen_ths_z_xl.resume_val =
+				status_registers.int_gen_ths_z_xl.default_val;
+	status_registers.int_gen_dur_xl.resume_val =
+				status_registers.int_gen_dur_xl.default_val;
+	status_registers.reference_g.resume_val =
+				status_registers.reference_g.default_val;
+	status_registers.int1_ctrl.resume_val =
+				status_registers.int1_ctrl.default_val;
+	status_registers.int2_ctrl.resume_val =
+				status_registers.int2_ctrl.default_val;
+	status_registers.ctrl_reg1_g.resume_val =
+				status_registers.ctrl_reg1_g.default_val;
+	status_registers.ctrl_reg2_g.resume_val =
+				status_registers.ctrl_reg2_g.default_val;
+	status_registers.ctrl_reg3_g.resume_val =
+				status_registers.ctrl_reg3_g.default_val;
+	status_registers.orient_cfg_g.resume_val =
+				status_registers.orient_cfg_g.default_val;
+	status_registers.ctrl_reg4.resume_val =
+				status_registers.ctrl_reg4.default_val;
+	status_registers.ctrl_reg5_xl.resume_val =
+				status_registers.ctrl_reg5_xl.default_val;
+	status_registers.ctrl_reg6_xl.resume_val =
+				status_registers.ctrl_reg6_xl.default_val;
+	status_registers.ctrl_reg7_xl.resume_val =
+				status_registers.ctrl_reg7_xl.default_val;
+	status_registers.ctrl_reg8.resume_val =
+				status_registers.ctrl_reg8.default_val;
+	status_registers.ctrl_reg9.resume_val =
+				status_registers.ctrl_reg9.default_val;
+	status_registers.ctrl_reg10.resume_val =
+				status_registers.ctrl_reg10.default_val;
+	status_registers.fifo_ctrl.resume_val =
+				status_registers.fifo_ctrl.default_val;
+	status_registers.int_gen_cfg_g.resume_val =
+				status_registers.int_gen_cfg_g.default_val;
+	status_registers.int_gen_ths_xh_g.resume_val =
+				status_registers.int_gen_ths_xh_g.default_val;
+	status_registers.int_gen_ths_xl_g.resume_val =
+				status_registers.int_gen_ths_xl_g.default_val;
+	status_registers.int_gen_ths_yh_g.resume_val =
+				status_registers.int_gen_ths_yh_g.default_val;
+	status_registers.int_gen_ths_yl_g.resume_val =
+				status_registers.int_gen_ths_yl_g.default_val;
+	status_registers.int_gen_ths_zh_g.resume_val =
+				status_registers.int_gen_ths_zh_g.default_val;
+	status_registers.int_gen_ths_zl_g.resume_val =
+				status_registers.int_gen_ths_zl_g.default_val;
+	status_registers.int_gen_dur_g.resume_val =
+				status_registers.int_gen_dur_g.default_val;
+
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+	atomic_set(&stat->low_power_state, 0);
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL
+	/** Disable Low Power mode at startup, device will be in normal mode */
+	atomic_set(&stat->enabled_lp_mode, 0);
+#else
+	atomic_set(&stat->enabled_lp_mode, 1);
+#endif
+	stat->gyr_discard_samples = 0;
+#endif
+	stat->acc_discard_samples = 0;
+
+	stat->hw_initialized = 1;
+	dev_info(stat->dev, "%s: hw init done\n",
+						LSM6DS0_ACC_GYR_DEV_NAME);
+
+	return 0;
+
+err_unknown_device:
+err_firstread:
+	stat->hw_working = 0;
+	stat->hw_initialized = 0;
+
+	return err;
+}
+
+static int32_t _lsm6ds0_acc_device_power_on(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf[9] = { 0 };
+
+	if (stat->pdata_acc->power_on) {
+		err = stat->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+ 	buf[0] = status_registers.ctrl_reg4.resume_val;
+ 	buf[1] = status_registers.ctrl_reg5_xl.resume_val;
+	buf[2] = status_registers.ctrl_reg6_xl.resume_val;
+	buf[3] = status_registers.ctrl_reg7_xl.resume_val;
+	buf[4] = status_registers.ctrl_reg8.resume_val;
+	buf[5] = status_registers.ctrl_reg9.resume_val;
+	buf[6] = status_registers.ctrl_reg10.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg4.address, 7, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen_cfg_xl.resume_val;
+	buf[1] = status_registers.int_gen_ths_x_xl.resume_val;
+	buf[2] = status_registers.int_gen_ths_y_xl.resume_val;
+	buf[3] = status_registers.int_gen_ths_z_xl.resume_val;
+	buf[4] = status_registers.int_gen_dur_xl.resume_val;
+	err = stat->tf->write(stat, status_registers.int_gen_cfg_xl.address, 5, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int1_ctrl.resume_val;
+	buf[1] = status_registers.int2_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.int1_ctrl.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.fifo_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.fifo_ctrl.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg8.resume_val;
+	buf[1] = status_registers.ctrl_reg9.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg8.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	return 0;
+
+err_resume_state:
+	dev_err(stat->dev, "accelerometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int32_t lsm6ds0_acc_device_power_on(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+
+	err = _lsm6ds0_acc_device_power_on(stat);
+	if (err < 0)
+		atomic_set(&stat->enabled_acc, 0);
+	else
+		atomic_set(&stat->enabled_acc, 1);
+
+	return err;
+}
+
+static int32_t _lsm6ds0_gyr_device_power_on(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t buf[9] = { 0 };
+
+	if (stat->pdata_gyr->power_on) {
+		err = stat->pdata_gyr->power_on();
+		if (err < 0) {
+			dev_err(stat->dev,
+				"gyroscope power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.act_ths.resume_val;
+	err = stat->tf->write(stat, status_registers.act_ths.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.reference_g.resume_val;
+	err = stat->tf->write(stat, status_registers.reference_g.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg1_g.resume_val;
+	buf[1] = status_registers.ctrl_reg2_g.resume_val;
+	buf[2] = status_registers.ctrl_reg3_g.resume_val;
+	buf[3] = status_registers.orient_cfg_g.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg4.resume_val;
+	err = stat->tf->write(stat, status_registers.ctrl_reg4.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen_cfg_g.resume_val;
+	buf[1] = status_registers.int_gen_ths_xh_g.resume_val;
+	buf[2] = status_registers.int_gen_ths_xl_g.resume_val;
+	buf[3] = status_registers.int_gen_ths_yh_g.resume_val;
+	buf[4] = status_registers.int_gen_ths_yl_g.resume_val;
+	buf[5] = status_registers.int_gen_ths_zh_g.resume_val;
+	buf[6] = status_registers.int_gen_ths_zl_g.resume_val;
+	buf[7] = status_registers.int_gen_dur_g.resume_val;
+	err = stat->tf->write(stat, status_registers.int_gen_cfg_g.address, 8, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int1_ctrl.resume_val;
+	buf[1] = status_registers.int2_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.int1_ctrl.address, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.fifo_ctrl.resume_val;
+	err = stat->tf->write(stat, status_registers.fifo_ctrl.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	return 0;
+
+err_resume_state:
+	dev_err(stat->dev, "gyroscope hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+
+	return err;
+}
+
+static int32_t lsm6ds0_gyr_device_power_on(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	
+	err = _lsm6ds0_gyr_device_power_on(stat);
+	if (err < 0)
+		atomic_set(&stat->enabled_gyr, 0);
+	else
+		atomic_set(&stat->enabled_gyr, 1);
+
+	return err;
+}
+
+static int32_t lsm6ds0_acc_update_fs_range(struct lsm6ds0_status *stat,
+							uint8_t new_fs_range)
+{
+	int32_t sensitivity, err = -1;
+	uint8_t val;
+
+	switch (new_fs_range) {
+	case LSM6DS0_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case LSM6DS0_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case LSM6DS0_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	val = ((LSM6DS0_ACC_FS_MASK & new_fs_range) | ((~LSM6DS0_ACC_FS_MASK) &
+				status_registers.ctrl_reg6_xl.resume_val));
+
+	err = stat->tf->write(stat,  status_registers.ctrl_reg6_xl.address, 1, &val);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = val;
+
+	mutex_lock(&stat->lock);
+	stat->sensitivity_acc = sensitivity;
+	mutex_unlock(&stat->lock);
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer fs range failed "
+			"0x%02x,0x%02x: %d\n", status_registers.ctrl_reg6_xl.address,
+			val, err);
+	return err;
+}
+
+static int32_t lsm6ds0_gyr_update_fs_range(struct lsm6ds0_status *stat,
+							uint8_t new_fs_range)
+{
+	int32_t err = -1;
+	uint8_t updated_val;
+	u32 sensitivity;
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	int8_t k_fs;
+#endif
+
+	switch(new_fs_range) {
+	case LSM6DS0_GYR_FS_245DPS:
+		sensitivity = SENSITIVITY_GYR_250;
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+		k_fs = 8;
+#endif
+		break;
+	case LSM6DS0_GYR_FS_500DPS:
+		sensitivity = SENSITIVITY_GYR_500;
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+		k_fs = 4;
+#endif
+		break;
+	case LSM6DS0_GYR_FS_2000DPS:
+		sensitivity = SENSITIVITY_GYR_2000;
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+		k_fs = 1;
+#endif
+		break;
+	default:
+		dev_err(stat->dev, "invalid g range "
+					"requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	err = stat->tf->read(stat, status_registers.ctrl_reg1_g.address, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	updated_val = ((LSM6DS0_GYR_FS_MASK & new_fs_range) |
+					((~LSM6DS0_GYR_FS_MASK) & updated_val));
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 1,
+							&updated_val);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg1_g.resume_val = updated_val;
+
+	mutex_lock(&stat->lock);
+	stat->sensitivity_gyr = sensitivity;
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	stat->k_fs = k_fs;
+#endif
+	mutex_unlock(&stat->lock);
+
+error:
+	return err;
+}
+
+static int32_t lsm6ds0_acc_update_odr(struct lsm6ds0_status *stat,
+					uint32_t poll_interval_us)
+{
+	int32_t err = -1;
+	uint8_t buf;
+	uint32_t i;
+
+	for (i = ARRAY_SIZE(lsm6ds0_acc_odr_table) - 1; i >= 0; i--) {
+		if (((uint32_t)lsm6ds0_acc_odr_table[i].cutoff_us <=
+			poll_interval_us) || (i == 0))
+			break;
+	}
+
+	if (atomic_read(&stat->enabled_acc)) {
+		buf = LSM6DS0_ACC_ODR_MASK & lsm6ds0_acc_odr_table[i].value;
+		buf |= (~LSM6DS0_ACC_ODR_MASK) &
+				status_registers.ctrl_reg6_xl.resume_val;
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg6_xl.address, 1,
+							  &buf);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg6_xl.resume_val = buf;
+		mutex_lock(&stat->lock);
+		stat->pdata_acc->poll_interval = poll_interval_us;
+		stat->ktime_acc = ktime_set(0, US_TO_NS(poll_interval_us));
+		mutex_unlock(&stat->lock);
+		dev_info(stat->dev, "Acc Polling Rate (us)%d\n", stat->pdata_acc->poll_interval);
+	}
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer odr failed : %d\n", err);
+
+	return err;
+}
+
+static int32_t lsm6ds0_gyr_update_odr(struct lsm6ds0_status *stat,
+					uint32_t poll_interval_us)
+{
+	uint8_t buf;
+	uint32_t val, i;
+	int32_t err = -1;
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+	uint8_t lp_mode;
+#endif
+
+	if (atomic_read(&stat->enabled_gyr)) {
+		if (atomic_read(&stat->enabled_acc)) {
+			val = min(poll_interval_us,
+					stat->pdata_acc->poll_interval);
+		} else {
+			val = poll_interval_us;
+		}
+
+		for (i = ARRAY_SIZE(lsm6ds0_gyr_odr_table) - 1; i >= 0; i--) {
+			if ((lsm6ds0_gyr_odr_table[i].cutoff_us <= val) ||
+				(i == 0))
+				break;
+		}
+
+		/* Set ODR value */
+		buf = LSM6DS0_GYR_ODR_MASK & lsm6ds0_gyr_odr_table[i].value;
+		buf |= (~LSM6DS0_GYR_ODR_MASK) &
+				status_registers.ctrl_reg1_g.resume_val;
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg1_g.address, 1,
+							  &buf);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg1_g.resume_val = buf;
+
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+		if (lsm6ds0_gyr_odr_table[i].cutoff_us < LSM6DS0_GYR_LP_TH_US)
+			lp_mode = 1;
+		else
+			lp_mode = 0;
+
+		/* Discard samples only if switch between normal and low-power
+		 * mode
+		 */
+		if (lp_mode != (uint8_t)atomic_read(&stat->low_power_state) &&
+				atomic_read(&stat->enabled_lp_mode) == 1) {
+			atomic_set(&stat->low_power_state, lp_mode);
+
+			mutex_lock(&stat->lock);
+			stat->gyr_discard_samples =
+			lsm6ds0_gyr_turn_on_time[i].disc_list[LSM6DS0_GYR_LPF1].count;
+		} else {
+			mutex_lock(&stat->lock);
+			stat->gyr_discard_samples = 0;
+		}
+		mutex_unlock(&stat->lock);
+#endif
+		/* Enable all axes */
+		buf = CTRL_REG4_ALL_AXES_EN |
+			  status_registers.ctrl_reg4.resume_val;
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg4.address, 1, &buf);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg4.resume_val = buf;
+
+		mutex_lock(&stat->lock);
+		stat->ktime_gyr = ktime_set(0, US_TO_NS(val));
+		stat->pdata_gyr->poll_interval = val;
+		mutex_unlock(&stat->lock);
+	}
+	return err;
+error:
+	dev_err(stat->dev, "update accelerometer odr failed: %d\n", err);
+
+	return err;
+}
+
+static int32_t lsm6ds0_acc_update_filter(struct lsm6ds0_status *stat,
+							uint8_t new_bandwidth)
+{
+	int32_t err = -1;
+	uint8_t updated_val;
+
+	switch (new_bandwidth) {
+	case LSM6DS0_ACC_BW_50:
+		break;
+	case LSM6DS0_ACC_BW_100:
+		break;
+	case LSM6DS0_ACC_BW_200:
+		break;
+	case LSM6DS0_ACC_BW_400:
+		break;
+	default:
+		dev_err(stat->dev, "invalid accelerometer "
+			"update bandwidth requested: %u\n", new_bandwidth);
+		return -EINVAL;
+	}
+
+	err = stat->tf->read(stat, status_registers.ctrl_reg6_xl.address, 1,
+						 &updated_val);
+	if (err < 0)
+		goto error;
+
+	updated_val = ((LSM6DS0_ACC_BW_MASK & new_bandwidth) |
+					((~LSM6DS0_ACC_BW_MASK) & updated_val));
+
+	err = stat->tf->write(stat, status_registers.ctrl_reg6_xl.address, 1,
+						  &updated_val);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = updated_val;
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update accelerometer fs range failed : %d\n", err);
+	return err;
+}
+
+
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL_LP
+static int32_t lsm6ds0_acc_change_pm_state(struct lsm6ds0_status *stat,
+							uint8_t new_pm_state)
+{
+	uint8_t val;
+	int32_t err = -1, new_state = (new_pm_state != 0) ? 1 : 0;
+
+	if (atomic_read(&stat->enabled_lp_mode) != new_state) {
+		val = ((CTRL_REG3_G_LP_MODE_MASK & new_state) |
+			((~CTRL_REG3_G_LP_MODE_MASK) &
+			status_registers.ctrl_reg3_g.resume_val));
+
+		err = stat->tf->write(stat, status_registers.ctrl_reg3_g.address, 1,
+							  &val);
+		if (err < 0)
+			goto error;
+
+		status_registers.ctrl_reg3_g.resume_val = val;
+		atomic_set(&stat->enabled_lp_mode, new_state);
+	}
+	return err;
+error:
+	dev_err(stat->dev, "enable pm bit failed : %d\n", err);
+	return err;
+}
+#endif
+
+static int32_t lsm6ds0_acc_enable(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	uint8_t j, bw;
+
+	if (!atomic_cmpxchg(&stat->enabled_acc, 0, 1)) {
+		err = lsm6ds0_acc_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_acc, 0);
+			dev_err(stat->dev, "enable accelerometer "
+				      "failed");
+			return err;
+		}
+
+		for (j = ARRAY_SIZE(lsm6ds0_acc_turn_on_time) - 1; j >= 0; j--) {
+			if ((lsm6ds0_acc_turn_on_time[j].odr_us <=
+			  stat->pdata_acc->poll_interval) || (j == 0))
+				break;
+		}
+		bw = stat->pdata_acc->aa_filter_bandwidth;
+
+		stat->acc_discard_samples =
+			lsm6ds0_acc_turn_on_time[j].disc_list[bw].count;
+		
+		hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc,
+							HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+
+static int32_t lsm6ds0_gyr_enable(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+
+	if (!atomic_cmpxchg(&stat->enabled_gyr, 0, 1)) {
+
+		err = lsm6ds0_gyr_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled_gyr, 0);
+			return err;
+		}
+
+		hrtimer_start(&(stat->hr_timer_gyr), stat->ktime_gyr,
+							HRTIMER_MODE_REL);
+	}
+	return 0;
+}
+
+#ifdef LSM6DS0_EN_ON_OPEN
+int32_t lsm6ds0_acc_input_open(struct input_dev *input)
+{
+	struct lsm6ds0_status *stat = input_get_drvdata(input);
+
+	return lsm6ds0_acc_enable(stat);
+}
+
+void lsm6ds0_acc_input_close(struct input_dev *dev)
+{
+	struct lsm6ds0_status *stat = input_get_drvdata(dev);
+
+	lsm6ds0_acc_disable(stat);
+}
+#endif
+
+int32_t lsm6ds0_gyr_input_open(struct input_dev *input)
+{
+	struct lsm6ds0_status *stat = input_get_drvdata(input);
+
+	return lsm6ds0_gyr_enable(stat);
+}
+
+void lsm6ds0_gyr_input_close(struct input_dev *dev)
+{
+	struct lsm6ds0_status *stat = input_get_drvdata(dev);
+
+	lsm6ds0_gyr_disable(stat);
+}
+
+static int32_t lsm6ds0_temp_get_data(struct lsm6ds0_status *stat, int32_t *data)
+{
+	int32_t err = -1;
+	uint8_t temp_data[2] = { 0 };
+
+	err = stat->tf->read(stat, OUT_TEMP_L, 2, temp_data);
+	if (err < 0)
+		return err;
+
+	(*data) = (int32_t)((int16_t)((temp_data[1] << 8) | (temp_data[0])));
+
+	return err;
+}
+
+static int32_t lsm6ds0_acc_get_data(struct lsm6ds0_status *stat, int32_t *xyz)
+{
+	int32_t i, err = -1, hw_d[3] = { 0 };
+	uint8_t acc_data[6];
+
+	err = stat->tf->read(stat, OUT_X_L_XL, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((int32_t)( (int16_t)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((int32_t)( (int16_t)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((int32_t)( (int16_t)((acc_data[5] << 8) | (acc_data[4]))));
+
+	mutex_lock(&stat->lock);
+	hw_d[0] = hw_d[0] * stat->sensitivity_acc;
+	hw_d[1] = hw_d[1] * stat->sensitivity_acc;
+	hw_d[2] = hw_d[2] * stat->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_main->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_main->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int32_t lsm6ds0_gyr_get_data(struct lsm6ds0_status *stat, int32_t *xyz)
+{
+	int32_t i, err = 1, hw_d[3] = { 0 };
+	uint8_t gyro_data[6];
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	int32_t temp, abs_temp;
+#endif
+
+	err = stat->tf->read(stat, OUT_X_L_G, 6, gyro_data);
+
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (int32_t) ((int16_t)((gyro_data[1]) << 8) | gyro_data[0]);
+	hw_d[1] = (int32_t) ((int16_t)((gyro_data[3]) << 8) | gyro_data[2]);
+	hw_d[2] = (int32_t) ((int16_t)((gyro_data[5]) << 8) | gyro_data[4]);
+
+	mutex_lock(&stat->lock);
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	err = lsm6ds0_temp_get_data(stat, &temp);
+	if (err < 0) {
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+	if (temp >= stat->compensation_temp) {
+		abs_temp = temp - stat->compensation_temp;
+	} else {
+		abs_temp = stat->compensation_temp - temp;
+	}
+
+	if (abs_temp > SENSITIVITY_TEMP)
+		stat->compensation_temp = temp;
+
+	hw_d[0] -= 10 * stat->compensation_temp *
+			((int32_t)(stat->k_fs * stat->k_coeff[1])) / 896;
+	hw_d[1] += 10 * stat->compensation_temp *
+			((int32_t)(stat->k_fs * stat->k_coeff[0])) / 896;
+	hw_d[2] -= 10 * stat->compensation_temp *
+			((int32_t)(stat->k_fs * stat->k_coeff[2])) / 896;
+#endif
+
+	hw_d[0] = hw_d[0] * stat->sensitivity_gyr;
+	hw_d[1] = hw_d[1] * stat->sensitivity_gyr;
+	hw_d[2] = hw_d[2] * stat->sensitivity_gyr;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = stat->pdata_main->rot_matrix[0][i] * hw_d[0] +
+				stat->pdata_main->rot_matrix[1][i] * hw_d[1] +
+				stat->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static void lsm6ds0_acc_report_values(struct lsm6ds0_status *stat,
+								int32_t *xyz)
+{
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(stat->input_dev_acc);
+}
+
+static void lsm6ds0_gyr_report_values(struct lsm6ds0_status *stat,
+								int32_t *xyz)
+{
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(stat->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_sync(stat->input_dev_gyr);
+}
+
+static int32_t lsm6ds0_acc_input_init(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+
+	mutex_lock(&stat->lock);
+	stat->input_dev_acc = input_allocate_device();
+	if (!stat->input_dev_acc) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "accelerometer "
+					"input device allocation failed\n");
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+#ifdef LSM6DS0_EN_ON_OPEN
+	stat->input_dev_acc->open = lsm6ds0_acc_input_open;
+	stat->input_dev_acc->close = lsm6ds0_acc_input_close;
+#endif
+	stat->input_dev_acc->name = LSM6DS0_ACC_DEV_NAME;
+	stat->input_dev_acc->id.bustype = stat->bustype;
+	stat->input_dev_acc->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev_acc, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev_acc->evbit );
+	__set_bit(INPUT_EVENT_X, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev_acc->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev_acc->mscbit);
+
+	err = input_register_device(stat->input_dev_acc);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register accelerometer input device %s\n",
+				stat->input_dev_acc->name);
+		input_free_device(stat->input_dev_acc);
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+
+static int32_t lsm6ds0_gyr_input_init(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+
+	dev_dbg(stat->dev, "%s\n", __func__);
+
+	mutex_lock(&stat->lock);
+	stat->input_dev_gyr = input_allocate_device();
+	if (!stat->input_dev_gyr) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"input device allocation failed\n");
+		mutex_unlock(&stat->lock);
+		return err;
+	}
+
+#ifdef LSM6DS0_EN_ON_OPEN
+	stat->input_dev_gyr->open = lsm6ds0_gyr_input_open;
+	stat->input_dev_gyr->close = lsm6ds0_gyr_input_close;
+#endif
+	stat->input_dev_gyr->name = LSM6DS0_GYR_DEV_NAME;
+	stat->input_dev_gyr->id.bustype = stat->bustype;
+	stat->input_dev_gyr->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev_gyr, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev_gyr->evbit );
+	__set_bit(INPUT_EVENT_X, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev_gyr->mscbit);
+	__set_bit(INPUT_EVENT_Z, stat->input_dev_gyr->mscbit);
+
+	err = input_register_device(stat->input_dev_gyr);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input device %s\n",
+			stat->input_dev_gyr->name);
+		input_free_device(stat->input_dev_gyr);
+	}
+	mutex_unlock(&stat->lock);
+
+	return err;
+}
+static void lsm6ds0_input_cleanup(struct lsm6ds0_status *stat)
+{
+	input_unregister_device(stat->input_dev_acc);
+	input_free_device(stat->input_dev_acc);
+
+	input_unregister_device(stat->input_dev_gyr);
+	input_free_device(stat->input_dev_gyr);
+}
+
+static ssize_t set_polling_rate_acc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long interval_us, interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_us = (unsigned long)max((unsigned int)MS_TO_US(interval_ms),
+						sdata->pdata_acc->min_interval);
+
+	lsm6ds0_acc_update_odr(sdata, interval_us);
+
+	return count;
+}
+
+static ssize_t get_polling_rate_acc(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint32_t val = 0;
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_acc->poll_interval;
+	mutex_unlock(&sdata->lock);
+
+	return sprintf(buf, "%u\n", US_TO_MS(val));
+}
+
+static ssize_t get_enable_acc(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+
+	int32_t val = (int)atomic_read(&sdata->enabled_acc);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_enable_acc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm6ds0_acc_enable(sdata);
+	else
+		lsm6ds0_acc_disable(sdata);
+
+	return count;
+}
+
+static ssize_t get_range_acc(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint8_t val;
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	int32_t range = 2;
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_acc->fs_range;
+	mutex_unlock(&sdata->lock);
+
+	switch (val) {
+	case LSM6DS0_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM6DS0_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM6DS0_ACC_FS_8G:
+		range = 8;
+		break;
+	}
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t set_range_acc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t range;
+	int32_t err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LSM6DS0_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM6DS0_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM6DS0_ACC_FS_8G;
+		break;
+	default:
+		dev_err(sdata->dev, "accelerometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = lsm6ds0_acc_update_fs_range(sdata, range);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->lock);
+	sdata->pdata_acc->fs_range = range;
+	mutex_unlock(&sdata->lock);
+
+	dev_info(sdata->dev, "accelerometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t get_aa_filter(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint8_t val;
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	int32_t frequency = FILTER_400;
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_acc->aa_filter_bandwidth;
+	mutex_unlock(&sdata->lock);
+
+	switch (val) {
+	case LSM6DS0_ACC_BW_50:
+		frequency = FILTER_50;
+		break;
+	case LSM6DS0_ACC_BW_100:
+		frequency = FILTER_100;
+		break;
+	case LSM6DS0_ACC_BW_200:
+		frequency = FILTER_200;
+		break;
+	case LSM6DS0_ACC_BW_400:
+		frequency = FILTER_400;
+		break;
+	}
+
+	return sprintf(buf, "%d\n", frequency);
+}
+
+static ssize_t set_aa_filter(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t frequency;
+	int32_t err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case FILTER_50:
+		frequency = LSM6DS0_ACC_BW_50;
+		break;
+	case FILTER_100:
+		frequency = LSM6DS0_ACC_BW_100;
+		break;
+	case FILTER_200:
+		frequency = LSM6DS0_ACC_BW_200;
+		break;
+	case FILTER_400:
+		frequency = LSM6DS0_ACC_BW_400;
+		break;
+	default:
+		dev_err(sdata->dev, "accelerometer invalid filter "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = lsm6ds0_acc_update_filter(sdata, frequency);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->lock);
+	sdata->pdata_acc->aa_filter_bandwidth = frequency;
+	mutex_unlock(&sdata->lock);
+
+	dev_info(sdata->dev, "accelerometer anti-aliasing filter "
+					"set to: %lu Hz\n", val);
+
+	return size;
+}
+
+static ssize_t get_temp(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	int32_t temp_decimal, temp_hw = 0, err = -1;
+	uint32_t temp_float;
+
+	err = lsm6ds0_temp_get_data(sdata, &temp_hw);
+	if (err < 0)
+		return sprintf(buf, "null\n");
+
+	temp_decimal = (int32_t)(temp_hw / SENSITIVITY_TEMP) + OFFSET_TEMP;
+	temp_float = (((uint32_t)temp_hw) % SENSITIVITY_TEMP);
+
+	return sprintf(buf, "%d.%d\n", temp_decimal, temp_float);
+}
+
+static ssize_t get_polling_rate_gyr(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	uint32_t val;
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_gyr->poll_interval;
+	mutex_unlock(&sdata->lock);
+
+	return sprintf(buf, "%d\n", US_TO_MS(val));
+}
+
+static ssize_t set_polling_rate_gyr(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long interval_us, interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_us = (unsigned int)max((unsigned int)MS_TO_US(interval_ms),
+					sdata->pdata_gyr->min_interval);
+
+	lsm6ds0_gyr_update_odr(sdata, interval_us);
+
+	return count;
+}
+
+static ssize_t get_enable_gyr(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	int32_t val = atomic_read(&sdata->enabled_gyr);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_enable_gyr(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm6ds0_gyr_enable(sdata);
+	else
+		lsm6ds0_gyr_disable(sdata);
+
+	return count;
+}
+
+static ssize_t get_range_gyr(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	int32_t range = 0;
+	uint8_t val;
+
+	mutex_lock(&sdata->lock);
+	val = sdata->pdata_gyr->fs_range;
+	switch (val) {
+	case LSM6DS0_GYR_FS_245DPS:
+		range = RANGE_245DPS;
+		break;
+	case LSM6DS0_GYR_FS_500DPS:
+		range = RANGE_500DPS;
+		break;
+	case LSM6DS0_GYR_FS_2000DPS:
+		range = RANGE_2000DPS;
+		break;
+	}
+	mutex_unlock(&sdata->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t set_range_gyr(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+	uint8_t range;
+	int32_t err = -1;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 245:
+		range = LSM6DS0_GYR_FS_245DPS;
+		break;
+	case 500:
+		range = LSM6DS0_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = LSM6DS0_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(sdata->dev, "invalid range request: %lu,"
+				" discarded\n", val);
+		return -EINVAL;
+	}
+
+	err = lsm6ds0_gyr_update_fs_range(sdata, range);
+	if (err >= 0) {
+		mutex_lock(&sdata->lock);
+		sdata->pdata_gyr->fs_range = range;
+		mutex_unlock(&sdata->lock);
+	}
+
+	dev_info(sdata->dev, "range set to: %lu dps\n", val);
+
+	return count;
+}
+
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL_LP
+static ssize_t get_pmode(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	uint8_t val;
+
+	val = atomic_read(&sdata->enabled_lp_mode);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_pmode(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct lsm6ds0_status *sdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	lsm6ds0_acc_change_pm_state(sdata, val);
+
+	return count;
+}
+#endif
+
+LSM6DS0_ATTTR(enable_acc, enable_device, 0664, get_enable_acc, set_enable_acc);
+LSM6DS0_ATTTR(enable_gyr, enable_device, 0664, get_enable_gyr, set_enable_gyr);
+LSM6DS0_ATTTR(pollrate_acc, pollrate_ms, 0664, get_polling_rate_acc, set_polling_rate_acc);
+LSM6DS0_ATTTR(pollrate_gyr, pollrate_ms, 0664, get_polling_rate_gyr, set_polling_rate_gyr);
+LSM6DS0_ATTTR(range_acc, range, 0664, get_range_acc, set_range_acc);
+LSM6DS0_ATTTR(range_gyr, range, 0664, get_range_gyr, set_range_gyr);
+LSM6DS0_ATTTR(aa_freq, anti_aliasing_frequency, 0664, get_aa_filter, set_aa_filter);
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL_LP
+LSM6DS0_ATTTR(pmode, pmode, 0664, get_pmode, set_pmode);
+#endif
+LSM6DS0_ATTTR(temperature, temperature, 0444, get_temp, NULL);
+
+static struct attribute *attributes_acc[] = {
+	&lsm6ds0_attr_enable_acc.attr,
+	&lsm6ds0_attr_pollrate_acc.attr,
+	&lsm6ds0_attr_range_acc.attr,
+	&lsm6ds0_attr_aa_freq.attr,
+	&lsm6ds0_attr_temperature.attr,
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL_LP
+	&lsm6ds0_attr_pmode.attr,
+#endif
+	NULL,
+};
+
+static struct attribute *attributes_gyr[] = {
+	&lsm6ds0_attr_enable_gyr.attr,
+	&lsm6ds0_attr_pollrate_gyr.attr,
+	&lsm6ds0_attr_range_gyr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_gyr = {
+	.attrs = attributes_gyr,
+};
+
+static int32_t create_sysfs_interfaces(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+
+	err = sysfs_create_group(&stat->input_dev_acc->dev.kobj, &attr_group_acc);
+	if (err)
+		return err;
+
+	return sysfs_create_group(&stat->input_dev_gyr->dev.kobj, &attr_group_gyr);
+}
+
+static void remove_sysfs_interfaces(struct lsm6ds0_status *stat)
+{
+	sysfs_remove_group(&stat->input_dev_acc->dev.kobj, &attr_group_acc);
+	sysfs_remove_group(&stat->input_dev_gyr->dev.kobj, &attr_group_gyr);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct lsm6ds0_status *stat;
+	int32_t xyz[3] = { 0 }, err = -1;
+
+	stat = container_of((struct work_struct *)input_work_acc,
+			struct lsm6ds0_status, input_work_acc);
+
+	err = lsm6ds0_acc_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get accelerometer data failed\n");
+	else {
+		mutex_lock(&stat->lock);
+		if (stat->acc_discard_samples > 0) {
+			stat->acc_discard_samples--;
+			mutex_unlock(&stat->lock);
+		} else {
+			mutex_unlock(&stat->lock);
+			lsm6ds0_acc_report_values(stat, xyz);
+		}
+	}
+
+	hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc, HRTIMER_MODE_REL);
+}
+
+static void poll_function_work_gyr(struct work_struct *input_work_gyr)
+{
+	struct lsm6ds0_status *stat;
+	int32_t xyz[3] = { 0 }, err = -1;
+
+	stat = container_of((struct work_struct *)input_work_gyr,
+			struct lsm6ds0_status, input_work_gyr);
+
+	err = lsm6ds0_gyr_get_data(stat, xyz);
+	if (err < 0)
+		dev_err(stat->dev, "get gyroscope data failed.\n");
+	else {
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+		mutex_lock(&stat->lock);
+		if (stat->gyr_discard_samples > 0) {
+			stat->gyr_discard_samples--;
+			mutex_unlock(&stat->lock);
+		} else {
+			mutex_unlock(&stat->lock);
+			lsm6ds0_gyr_report_values(stat, xyz);
+		}
+#else
+		lsm6ds0_gyr_report_values(stat, xyz);
+#endif
+	}
+
+	hrtimer_start(&stat->hr_timer_gyr, stat->ktime_gyr, HRTIMER_MODE_REL);
+}
+
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+int32_t lsm6ds0_hw_comp_read_k(struct lsm6ds0_status *stat, uint8_t reg,
+								int8_t *val)
+{
+	int32_t err = -1;
+
+	/* Read hardcoded factor */
+	(*val) = reg;
+	err = stat->tf->read(stat, reg, 1, val);
+	if (err < 0) {
+		return err;
+	}
+
+	if ((*val) & (0x20)) {
+		(*val) |= (0xE0);
+		(*val) &= (0xFF);
+	} else {
+		(*val) &= (0x3F);
+	}
+	return err;
+}
+
+int32_t lsm6ds0_hw_compensation_disable(struct lsm6ds0_status *stat,
+								uint8_t reg)
+{
+	int32_t err = -1;
+	uint8_t tmp = 0;
+
+	switch(reg) {
+	case COMP_X_FACTOR_ADDR:
+		tmp = stat->k_coeff[0];
+		break;
+
+	case COMP_Y_FACTOR_ADDR:
+		tmp = stat->k_coeff[1];
+		break;
+
+	case COMP_Z_FACTOR_ADDR:
+		tmp = stat->k_coeff[2];
+		break;
+	}
+
+	/* Disable HW compensation */
+	err = stat->tf->write(stat, reg, 1, &tmp);
+
+	return err;
+}
+
+static int32_t lsm6ds0_gyr_temp_compensation_init(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+	int8_t k_coeff[3] = { 0 };
+
+	/* reset coefficients */
+	mutex_lock(&stat->lock);
+	stat->k_coeff[0] = 0;
+	stat->k_coeff[1] = 0;
+	stat->k_coeff[2] = 0;
+	mutex_unlock(&stat->lock);
+
+	err = lsm6ds0_hw_comp_read_k(stat, COMP_X_FACTOR_ADDR, &k_coeff[0]);
+	if (err < 0) {
+		return err;
+	}
+
+	err = lsm6ds0_hw_comp_read_k(stat, COMP_Y_FACTOR_ADDR, &k_coeff[1]);
+	if (err < 0) {
+		return err;
+	}
+
+	err = lsm6ds0_hw_comp_read_k(stat, COMP_Z_FACTOR_ADDR, &k_coeff[2]);
+	if (err < 0) {
+		return err;
+	}
+
+	mutex_lock(&stat->lock);
+	err = lsm6ds0_hw_compensation_disable(stat, COMP_X_FACTOR_ADDR);
+	if (err < 0) {
+		goto err_dis_comp;
+	}
+	stat->k_coeff[0] = k_coeff[0];
+
+	err = lsm6ds0_hw_compensation_disable(stat, COMP_Y_FACTOR_ADDR);
+	if (err < 0) {
+		goto err_dis_comp;
+	}
+	stat->k_coeff[1] = k_coeff[1];
+
+	err = lsm6ds0_hw_compensation_disable(stat, COMP_Z_FACTOR_ADDR);
+	if (err < 0) {
+		goto err_dis_comp;
+	}
+	stat->k_coeff[2] = k_coeff[2];
+
+err_dis_comp:
+	mutex_unlock(&stat->lock);
+	return err;
+}
+#endif
+
+#ifdef CONFIG_OF
+static int32_t lsm6ds0_parse_dt(struct lsm6ds0_status *stat,
+                                        struct device* dev)
+{
+	struct device_node *dn;
+	uint8_t i, j;
+	uint32_t val;
+	uint32_t vect[9] = { 0 };
+
+	mutex_lock(&stat->lock);
+	dn = dev->of_node;
+	stat->pdata_main->of_node = dn;
+	stat->pdata_main->gpio_int1 = of_get_gpio(dn, 0);
+	if (!gpio_is_valid(stat->pdata_main->gpio_int1)) {
+		dev_err(dev, "failed to get gpio_int1\n");
+			stat->pdata_main->gpio_int1 = LSM6DS0_INT1_GPIO_DEF;
+	}
+
+	stat->pdata_main->gpio_int2 = of_get_gpio(dn, 1);
+	if (!gpio_is_valid(stat->pdata_main->gpio_int2)) {
+		dev_err(dev, "failed to get gpio_int2\n");
+			stat->pdata_main->gpio_int2 = LSM6DS0_INT2_GPIO_DEF;
+	}
+
+	if (of_property_read_u32_array(dn, "rot-matrix", vect,
+		      ARRAY_SIZE(vect)) >= 0) {
+		for (j = 0; j < 3; j++) {
+			for (i = 0; i < 3; i++) {
+				stat->pdata_main->rot_matrix[i][j] = vect[3 * j + i];
+			}
+		}
+	} else {
+		for (j = 0; j < 3; j++) {
+			for (i = 0; i < 3; i++) {
+				stat->pdata_main->rot_matrix[i][j] =
+		default_lsm6ds0_main_platform_data.rot_matrix[i][j];
+			}
+		}
+	}
+
+	if (!of_property_read_u32(dn, "g-poll-interval", &val)) {
+		stat->pdata_gyr->poll_interval = MS_TO_US(val);
+	} else {
+		stat->pdata_gyr->poll_interval =
+			LSM6DS0_GYR_POLL_INTERVAL_DEF;
+	}
+
+	if (!of_property_read_u32(dn, "g-min-interval", &val)) {
+		stat->pdata_gyr->min_interval = val;
+	} else {
+		stat->pdata_gyr->min_interval =
+			LSM6DS0_GYR_MIN_POLL_PERIOD_US;
+	}
+	
+	if (!of_property_read_u32(dn, "g-fs-range", &val)) {
+		stat->pdata_gyr->fs_range = val;
+	} else {
+	stat->pdata_gyr->fs_range = LSM6DS0_GYR_FS_245DPS;
+	}
+
+	if (!of_property_read_u32(dn, "x-poll-interval", &val)) {
+		stat->pdata_acc->poll_interval = MS_TO_US(val);
+	} else {
+		stat->pdata_acc->poll_interval =
+			LSM6DS0_ACC_MIN_POLL_PERIOD_US;
+	}
+
+	if (!of_property_read_u32(dn, "x-min-interval", &val)) {
+		stat->pdata_acc->min_interval = MS_TO_US(val);
+	} else {
+		stat->pdata_acc->min_interval =
+			LSM6DS0_ACC_MIN_POLL_PERIOD_US;
+	}
+
+	if (!of_property_read_u32(dn, "x-fs-range", &val)) {
+		stat->pdata_acc->fs_range = val;
+	} else {
+		stat->pdata_acc->fs_range = LSM6DS0_ACC_FS_2G;
+	}
+
+	if (!of_property_read_u32(dn, "aa-filter-bw", &val)) {
+		stat->pdata_acc->aa_filter_bandwidth = val;
+	} else {
+		stat->pdata_acc->aa_filter_bandwidth = LSM6DS0_ACC_BW_400;
+	}
+	mutex_unlock(&stat->lock);
+
+	return 0;
+}
+#endif
+
+int32_t lsm6ds0_common_probe(struct lsm6ds0_status *stat)
+{
+	int32_t err = -1;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_init(&stat->tb.buf_lock);
+	if (!lsm6ds0_workqueue)
+		lsm6ds0_workqueue = create_workqueue("lsm6ds0_workqueue");
+
+	hrtimer_init(&stat->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_acc.function = &poll_function_read_acc;
+	hrtimer_init(&stat->hr_timer_gyr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	stat->hr_timer_gyr.function = &poll_function_read_gyr;
+
+	stat->pdata_main = kzalloc(sizeof(*stat->pdata_main), GFP_KERNEL);
+	stat->pdata_acc = kzalloc(sizeof(*stat->pdata_acc), GFP_KERNEL);
+	stat->pdata_gyr = kzalloc(sizeof(*stat->pdata_gyr), GFP_KERNEL);
+
+	if ((stat->pdata_main == NULL) || (stat->pdata_acc == NULL) ||
+						  (stat->pdata_gyr == NULL)){
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_memory_alloc;
+	}
+
+	stat->pdata_main->pdata_acc = stat->pdata_acc;
+	stat->pdata_main->pdata_gyr = stat->pdata_gyr;
+
+#ifdef CONFIG_OF
+	lsm6ds0_parse_dt(stat, stat->dev);
+#else
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata_main,
+				&default_lsm6ds0_main_platform_data,
+				sizeof(*stat->pdata_main));
+		memcpy(stat->pdata_acc, &default_lsm6ds0_acc_pdata,
+						sizeof(*stat->pdata_acc));
+		memcpy(stat->pdata_gyr, &default_lsm6ds0_gyr_pdata,
+						sizeof(*stat->pdata_gyr));
+		dev_info(stat->dev, "using default plaform_data for "
+					"accelerometer and gyroscope\n");
+	} else {
+		struct lsm6ds0_main_platform_data *platform_data;
+		platform_data = stat->dev->platform_data;
+
+		if (platform_data == NULL) {
+			memcpy(stat->pdata_main,
+				&default_lsm6ds0_main_platform_data,
+				sizeof(*stat->pdata_main));
+			dev_info(stat->dev, "using default plaform_data for "
+							"accelerometer\n");
+		} else {
+			memcpy(stat->pdata_main, platform_data,
+						sizeof(*stat->pdata_acc));
+		}
+
+		if (platform_data->pdata_acc == NULL) {
+			memcpy(stat->pdata_acc, &default_lsm6ds0_acc_pdata,
+						sizeof(*stat->pdata_acc));
+			dev_info(stat->dev, "using default plaform_data for "
+							"accelerometer\n");
+		} else {
+			memcpy(stat->pdata_acc, platform_data->pdata_acc,
+						sizeof(*stat->pdata_acc));
+		}
+
+		if (platform_data->pdata_gyr == NULL) {
+			memcpy(stat->pdata_gyr, &default_lsm6ds0_gyr_pdata,
+						sizeof(*stat->pdata_gyr));
+			dev_info(stat->dev, "using default plaform_data for "
+							"gyroscope\n");
+		} else {
+			memcpy(stat->pdata_gyr, platform_data->pdata_gyr,
+						sizeof(*stat->pdata_gyr));
+		}
+	}
+#endif
+
+	err = lsm6ds0_acc_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data for "
+							"accelerometer \n");
+		goto exit_kfree_pdata;
+	}
+
+	err = lsm6ds0_gyr_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data for "
+							"gyroscope\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (stat->pdata_acc->init) {
+		err = stat->pdata_acc->init();
+		if (err < 0) {
+			dev_err(stat->dev, "accelerometer init failed: "
+								"%d\n", err);
+			goto err_pdata_acc_init;
+		}
+	}
+	if (stat->pdata_gyr->init) {
+		err = stat->pdata_gyr->init();
+		if (err < 0) {
+			dev_err(stat->dev, "gyroscope init failed: "
+								"%d\n", err);
+			goto err_pdata_gyr_init;
+		}
+	}
+
+	err = lsm6ds0_hw_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm6ds0_acc_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "accelerometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm6ds0_gyr_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "gyroscope power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm6ds0_acc_update_fs_range(stat, stat->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer full scale range "
+								"failed\n");
+		goto  err_power_off_acc;
+	}
+
+	err = lsm6ds0_gyr_update_fs_range(stat, stat->pdata_gyr->fs_range);
+	if (err < 0) {
+		dev_err(stat->dev, "update gyroscope full scale range "
+								"failed\n");
+		goto  err_power_off_gyr;
+	}
+
+	err = lsm6ds0_acc_update_odr(stat, stat->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer ODR failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm6ds0_gyr_update_odr(stat, stat->pdata_gyr->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update gyroscope ODR failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm6ds0_acc_update_filter(stat,
+					stat->pdata_acc->aa_filter_bandwidth);
+	if (err < 0) {
+		dev_err(stat->dev, "update accelerometer filter "
+								"failed\n");
+		goto  err_power_off;
+	}
+
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	err = lsm6ds0_gyr_temp_compensation_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "sw temperature compensation init "
+								"failed\n");
+		goto  err_power_off;
+	}
+#endif
+
+	err = lsm6ds0_acc_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = lsm6ds0_gyr_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "gyroscope input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "device %s sysfs register failed\n",
+			LSM6DS0_ACC_GYR_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lsm6ds0_acc_device_power_off(stat);
+	lsm6ds0_gyr_device_power_off(stat);
+	INIT_WORK(&stat->input_work_acc, poll_function_work_acc);
+	INIT_WORK(&stat->input_work_gyr, poll_function_work_gyr);
+	dev_info(stat->dev, "%s: probed\n", LSM6DS0_ACC_GYR_DEV_NAME);
+
+	return 0;
+
+err_input_cleanup:
+	lsm6ds0_input_cleanup(stat);
+
+err_power_off:
+err_power_off_gyr:
+	lsm6ds0_gyr_device_power_off(stat);
+
+err_power_off_acc:
+	lsm6ds0_acc_device_power_off(stat);
+
+err_hw_init:
+err_pdata_init:
+err_pdata_gyr_init:
+	if (stat->pdata_gyr->exit)
+		stat->pdata_gyr->exit();
+
+err_pdata_acc_init:
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+exit_kfree_pdata:
+	mutex_lock(&stat->lock);
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_gyr);
+	kfree(stat->pdata_main);
+	mutex_unlock(&stat->lock);
+
+err_memory_alloc:
+	if (lsm6ds0_workqueue) {
+		flush_workqueue(lsm6ds0_workqueue);
+		destroy_workqueue(lsm6ds0_workqueue);
+		lsm6ds0_workqueue = NULL;
+	}
+
+	dev_err(stat->dev,"%s: Driver Init failed\n",
+						LSM6DS0_ACC_GYR_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm6ds0_common_probe);
+
+int32_t lsm6ds0_common_remove(struct lsm6ds0_status *stat)
+{
+	remove_sysfs_interfaces(stat);
+	if (atomic_read(&stat->enabled_gyr)) {
+		lsm6ds0_gyr_disable(stat);
+		lsm6ds0_gyr_input_cleanup(stat);
+
+		if (stat->pdata_gyr->exit)
+			stat->pdata_gyr->exit();
+	}
+
+	lsm6ds0_acc_disable(stat);
+	lsm6ds0_acc_input_cleanup(stat);
+
+	if (stat->pdata_acc->exit)
+		stat->pdata_acc->exit();
+
+	if(lsm6ds0_workqueue) {
+		flush_workqueue(lsm6ds0_workqueue);
+		destroy_workqueue(lsm6ds0_workqueue);
+		lsm6ds0_workqueue = NULL;
+	}
+
+	kfree(stat->pdata_acc);
+	kfree(stat->pdata_gyr);
+	kfree(stat->pdata_main);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds0_common_remove);
+
+#ifdef CONFIG_PM
+int32_t lsm6ds0_common_suspend(struct lsm6ds0_status *stat)
+{
+	if (atomic_read(&stat->enabled_gyr) > 0) {
+		cancel_work_sync(&stat->input_work_gyr);
+		hrtimer_cancel(&stat->hr_timer_gyr);
+		_lsm6ds0_gyr_device_power_off(stat);
+	}
+
+	if (atomic_read(&stat->enabled_acc) > 0) {
+		cancel_work_sync(&stat->input_work_acc);
+		hrtimer_cancel(&stat->hr_timer_acc);
+		_lsm6ds0_acc_device_power_off(stat);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds0_common_suspend);
+
+int32_t lsm6ds0_common_resume(struct lsm6ds0_status *stat)
+{
+	if (atomic_read(&stat->enabled_acc) > 0) {
+		_lsm6ds0_acc_device_power_on(stat);
+		hrtimer_start(&stat->hr_timer_acc, stat->ktime_acc,
+							HRTIMER_MODE_REL);
+	}
+
+	if (atomic_read(&stat->enabled_gyr) > 0) {
+		_lsm6ds0_gyr_device_power_on(stat);
+		hrtimer_start(&(stat->hr_timer_gyr), stat->ktime_gyr,
+							HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds0_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION(LSM6DS0_MOD_DESCRIPTION);
+MODULE_AUTHOR("Giuseppe Barba,STMicroelectronics");
+MODULE_LICENSE("GPL");
diff -uNr a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0.h b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0.h
--- a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,265 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ******************
+*
+* File Name		: lsm6ds0.h
+* Author		: AMS - Motion Mems Division - Application Team
+*			: Giuseppe Barba (giuseppe.barba@st.com)
+* Version		: V.1.1.0
+* Date			: 2016/May/13
+*
+******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*****************************************************************************/
+
+#ifndef	__LSM6DS0_H__
+#define	__LSM6DS0_H__
+
+/** LSM6DS0 model */
+#define LSM6DS0_ACC_GYR_DEV_NAME	"lsm6ds0"
+#define LSM6DS0_ACC_DEV_NAME		"lsm6ds0_acc"
+#define LSM6DS0_GYR_DEV_NAME    	"lsm6ds0_gyr"
+#define LSM6DS0_MOD_DESCRIPTION	"lsm6ds0 driver"
+
+/**********************************************/
+/* 	Accelerometer section defines	 	*/
+/**********************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define LSM6DS0_ACC_FS_MASK		0x18
+#define LSM6DS0_ACC_FS_2G 		0x00	/* Full scale 2g */
+#define LSM6DS0_ACC_FS_4G 		0x08	/* Full scale 4g */
+#define LSM6DS0_ACC_FS_8G 		0x10	/* Full scale 8g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define LSM6DS0_ACC_BW_400		0X00
+#define LSM6DS0_ACC_BW_200		0X01
+#define LSM6DS0_ACC_BW_100		0X02
+#define LSM6DS0_ACC_BW_50		0X03
+#define LSM6DS0_ACC_BW_MASK		0X03
+
+#define LSM6DS0_INT1_GPIO_DEF		(-EINVAL)
+#define LSM6DS0_INT2_GPIO_DEF		(-EINVAL)
+
+#define LSM6DS0_ACC_ODR_OFF		0x00
+#define LSM6DS0_ACC_ODR_MASK		0xE0
+#define LSM6DS0_ACC_ODR_14_9		0x20
+#define LSM6DS0_ACC_ODR_59_5		0x40
+#define LSM6DS0_ACC_ODR_119		0x60
+#define LSM6DS0_ACC_ODR_238		0x80
+#define LSM6DS0_ACC_ODR_476		0xA0
+#define LSM6DS0_ACC_ODR_952		0xC0
+
+#define LSM6DL0_ACC_ODR_20		0x20
+#define LSM6DL0_ACC_ODR_80		0x40
+#define LSM6DL0_ACC_ODR_160		0x60
+#define LSM6DL0_ACC_ODR_320		0x80
+#define LSM6DL0_ACC_ODR_640		0xA0
+#define LSM6DL0_ACC_ODR_1280		0xC0
+
+/**********************************************/
+/* 	Gyroscope section defines	 	*/
+/**********************************************/
+
+
+#define LSM6DS0_GYR_FS_MASK		0x18
+#define LSM6DS0_GYR_FS_245DPS		0x00
+#define LSM6DS0_GYR_FS_500DPS		0x08
+#define LSM6DS0_GYR_FS_2000DPS		0x18
+
+#define LSM6DS0_GYR_ODR_OFF		0x00
+#define LSM6DS0_GYR_ODR_MASK		0xE0
+#define LSM6DS0_GYR_ODR_MASK_SHIFT	5
+#define LSM6DS0_GYR_ODR_001		(1 << LSM6DS0_GYR_ODR_MASK_SHIFT)
+#define LSM6DS0_GYR_ODR_010		(2 << LSM6DS0_GYR_ODR_MASK_SHIFT)
+#define LSM6DS0_GYR_ODR_011		(3 << LSM6DS0_GYR_ODR_MASK_SHIFT)
+#define LSM6DS0_GYR_ODR_100		(4 << LSM6DS0_GYR_ODR_MASK_SHIFT)
+#define LSM6DS0_GYR_ODR_101		(5 << LSM6DS0_GYR_ODR_MASK_SHIFT)
+#define LSM6DS0_GYR_ODR_110		(6 << LSM6DS0_GYR_ODR_MASK_SHIFT)
+
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+#define LSM6DS0_GYR_MAX_LP_ODR_US	8
+#endif
+
+#define LSM6DS0_GYR_BW_00		0x00
+#define LSM6DS0_GYR_BW_01		0x01
+#define LSM6DS0_GYR_BW_10		0x02
+#define LSM6DS0_GYR_BW_11		0x03
+
+/** ODR periods in msec */
+#ifdef CONFIG_INPUT_LSM6DS0_S_MODEL
+/** LSM6DS0 model */
+#define LSM6DS0_ODR_14_9_US		67115
+#define LSM6DS0_ODR_59_5_US		16807
+#define LSM6DS0_ODR_119_US		 8404
+#define LSM6DS0_ODR_238_US		 4202
+#define LSM6DS0_ODR_476_US		 2101
+#define LSM6DS0_ODR_952_US		 1051
+
+#define LSM6DS0_ODR_US_001		LSM6DS0_ODR_14_9_US
+#define LSM6DS0_ODR_US_010		LSM6DS0_ODR_59_5_US
+#define LSM6DS0_ODR_US_011		LSM6DS0_ODR_119_US
+#define LSM6DS0_ODR_US_100		LSM6DS0_ODR_238_US
+#define LSM6DS0_ODR_US_101		LSM6DS0_ODR_476_US
+#define LSM6DS0_ODR_US_110		LSM6DS0_ODR_952_US
+#else
+/** LSM6DL0 model */
+#define LSM6DL0_ODR_20_US		50000
+#define LSM6DL0_ODR_80_US		12500
+#define LSM6DL0_ODR_160_US		 6250
+#define LSM6DL0_ODR_320_US		 3125
+#define LSM6DL0_ODR_640_US		 1563
+#define LSM6DL0_ODR_1280_US		  782
+
+#define LSM6DS0_ODR_US_001		LSM6DL0_ODR_20_US
+#define LSM6DS0_ODR_US_010		LSM6DL0_ODR_80_US
+#define LSM6DS0_ODR_US_011		LSM6DL0_ODR_160_US
+#define LSM6DS0_ODR_US_100		LSM6DL0_ODR_320_US
+#define LSM6DS0_ODR_US_101		LSM6DL0_ODR_640_US
+#define LSM6DS0_ODR_US_110		LSM6DL0_ODR_1280_US
+#endif
+
+#define LSM6DS0_GYR_MIN_POLL_PERIOD_US	LSM6DS0_ODR_US_110
+#define LSM6DS0_ACC_MIN_POLL_PERIOD_US	LSM6DS0_ODR_US_110
+#define LSM6DS0_GYR_POLL_INTERVAL_DEF	LSM6DS0_ODR_US_001
+#define LSM6DS0_ACC_POLL_INTERVAL_DEF	LSM6DS0_ODR_US_001
+
+#define LSM6DS0_RX_MAX_LENGTH		500
+#define LSM6DS0_TX_MAX_LENGTH		500
+
+struct lsm6ds0_status;
+
+struct lsm6ds0_acc_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+	uint8_t aa_filter_bandwidth;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct lsm6ds0_gyr_platform_data {
+	uint32_t poll_interval;
+	uint32_t min_interval;
+	uint8_t fs_range;
+
+	int32_t (*init)(void);
+	void (*exit)(void);
+	int32_t (*power_on)(void);
+	int32_t (*power_off)(void);
+};
+
+struct lsm6ds0_main_platform_data {
+	int32_t gpio_int1;
+	int32_t gpio_int2;
+	short rot_matrix[3][3];
+	struct lsm6ds0_acc_platform_data *pdata_acc;
+	struct lsm6ds0_gyr_platform_data *pdata_gyr;
+#ifdef CONFIG_OF
+	struct device_node	*of_node;
+#endif
+};
+
+struct lsm6ds0_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM6DS0_RX_MAX_LENGTH];
+	u8 tx_buf[LSM6DS0_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6ds0_transfer_function {
+	int (*write) (struct lsm6ds0_status *cdata, u8 reg_addr, int len, u8 *data);
+	int (*read) (struct lsm6ds0_status *cdata, u8 reg_addr, int len, u8 *data);
+};
+
+struct lsm6ds0_status {
+	struct lsm6ds0_main_platform_data *pdata_main;
+	struct lsm6ds0_acc_platform_data *pdata_acc;
+	struct lsm6ds0_gyr_platform_data *pdata_gyr;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct work_struct input_work_gyr;
+
+	struct hrtimer hr_timer_acc;
+	ktime_t ktime_acc;
+	struct hrtimer hr_timer_gyr;
+	ktime_t ktime_gyr;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_gyr;
+	struct device *dev;
+	u16 bustype;
+
+	int8_t hw_initialized;
+
+	/* hw_working=-1 means not tested yet */
+	int8_t hw_working;
+
+	atomic_t enabled_acc;
+	atomic_t enabled_gyr;
+	atomic_t enabled_temp;
+
+	int32_t on_before_suspend;
+
+	uint32_t sensitivity_acc;
+	uint32_t sensitivity_gyr;
+	int32_t irq;
+
+	int32_t irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+
+	int32_t irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+#ifdef CONFIG_INPUT_LSM6DS0_SW_COMP
+	int8_t k_fs;
+	int8_t k_coeff[3];
+	int32_t compensation_temp;
+#endif
+#ifdef CONFIG_INPUT_LSM6DS0_LP
+	atomic_t low_power_state;
+	atomic_t enabled_lp_mode;
+
+	/** gyr_discard_samples count the number of samples to be discarded
+	    after switching between low-power and normal mode */
+	uint8_t gyr_discard_samples;
+#endif
+	/** acc_discard_samples count the number of samples to be discarded
+	    after switching between power-down mode and normal mode */
+	uint8_t acc_discard_samples;
+
+	const struct lsm6ds0_transfer_function *tf;
+	struct lsm6ds0_transfer_buffer tb;
+};
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int32_t lsm6ds0_common_probe(struct lsm6ds0_status *stat);
+int32_t lsm6ds0_common_remove(struct lsm6ds0_status *stat);
+
+#ifdef CONFIG_PM
+int32_t lsm6ds0_common_suspend(struct lsm6ds0_status *stat);
+int32_t lsm6ds0_common_resume(struct lsm6ds0_status *stat);
+#endif /* CONFIG_PM */
+
+#endif	/* __LSM6DS0_H__ */
diff -uNr a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_i2c.c b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_i2c.c
--- a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,170 @@
+/*
+ * STMicroelectronics lsm6ds0 i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "lsm6ds0.h"
+
+static int lsm6ds0_i2c_read(struct lsm6ds0_status *cdata, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	return (err == 2) ? 0 : 1;
+}
+
+static int lsm6ds0_i2c_write(struct lsm6ds0_status *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return (err == 1) ? 0 : 1;
+}
+
+
+static const struct lsm6ds0_transfer_function lsm6ds0_tf_i2c = {
+	.write = lsm6ds0_i2c_write,
+	.read = lsm6ds0_i2c_read,
+};
+
+static int lsm6ds0_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6ds0_status *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->irq = client->irq;
+	cdata->tf = &lsm6ds0_tf_i2c;
+	cdata->bustype = BUS_I2C;
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm6ds0_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lsm6ds0_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6ds0_status *cdata = i2c_get_clientdata(client);
+
+	lsm6ds0_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DS0_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6ds0_suspend(struct device *dev)
+{
+	struct lsm6ds0_status *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6ds0_common_suspend(cdata);
+}
+
+static int lsm6ds0_resume(struct device *dev)
+{
+	struct lsm6ds0_status *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6ds0_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6ds0_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6ds0_suspend, lsm6ds0_resume)
+};
+
+#define LSM6DS0_PM_OPS		(&lsm6ds0_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DS0_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lsm6ds0_ids[] = {
+	{ LSM6DS0_ACC_GYR_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lsm6ds0_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds0_id_table[] = {
+	{ .compatible = "st,lsm6ds0", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6ds0_id_table);
+#endif
+
+static struct i2c_driver lsm6ds0_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DS0_ACC_GYR_DEV_NAME,
+		.pm = LSM6DS0_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lsm6ds0_id_table),
+#endif
+	},
+	.probe    = lsm6ds0_i2c_probe,
+	.remove   = lsm6ds0_i2c_remove,
+	.id_table = lsm6ds0_ids,
+};
+
+module_i2c_driver(lsm6ds0_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds0 i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_spi.c b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_spi.c
--- a/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds0/lsm6ds0_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,191 @@
+/*
+ * STMicroelectronics lsm6ds0 spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "lsm6ds0.h"
+
+#define SENSORS_SPI_READ 0x80
+
+static int lsm6ds0_spi_read(struct lsm6ds0_status *cdata, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (!err)
+		memcpy(data, cdata->tb.rx_buf, len);
+		
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int lsm6ds0_spi_write(struct lsm6ds0_status *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM6DS0_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static const struct lsm6ds0_transfer_function lsm6ds0_tf_spi = {
+	.write = lsm6ds0_spi_write,
+	.read = lsm6ds0_spi_read,
+};
+
+static int lsm6ds0_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6ds0_status *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->irq = spi->irq;
+	cdata->tf = &lsm6ds0_tf_spi;
+	cdata->bustype = BUS_SPI;
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm6ds0_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lsm6ds0_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lsm6ds0_status *cdata = spi_get_drvdata(spi);
+
+	lsm6ds0_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DS0_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6ds0_suspend(struct device *dev)
+{
+	struct lsm6ds0_status *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6ds0_common_suspend(cdata);
+}
+
+static int lsm6ds0_resume(struct device *dev)
+{
+	struct lsm6ds0_status *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6ds0_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6ds0_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6ds0_suspend, lsm6ds0_resume)
+};
+
+#define LSM6DS0_PM_OPS		(&lsm6ds0_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DS0_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lsm6ds0_ids[] = {
+	{ LSM6DS0_ACC_GYR_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm6ds0_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds0_id_table[] = {
+	{ .compatible = "st,lsm6ds0", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6ds0_id_table);
+#endif
+
+static struct spi_driver lsm6ds0_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DS0_ACC_GYR_DEV_NAME,
+		.pm = LSM6DS0_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lsm6ds0_id_table),
+#endif
+	},
+	.probe    = lsm6ds0_spi_probe,
+	.remove   = lsm6ds0_spi_remove,
+	.id_table = lsm6ds0_ids,
+};
+
+module_spi_driver(lsm6ds0_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds0 spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6ds0/Makefile b/drivers/input/misc/st/imu/lsm6ds0/Makefile
--- a/drivers/input/misc/st/imu/lsm6ds0/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds0/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM imu lsm6ds0 driver
+#
+lsm6ds0-core-y += lsm6ds0_core.o
+obj-$(CONFIG_INPUT_LSM6DS0) += lsm6ds0-core.o
+obj-$(CONFIG_INPUT_LSM6DS0_I2C) += lsm6ds0_i2c.o
+obj-$(CONFIG_INPUT_LSM6DS0_SPI) += lsm6ds0_spi.o
diff -uNr a/drivers/input/misc/st/imu/lsm6ds3/Kconfig b/drivers/input/misc/st/imu/lsm6ds3/Kconfig
--- a/drivers/input/misc/st/imu/lsm6ds3/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds3/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LSM6DS3
+	tristate "STMicroelectronics LSM6DS3/LSM6DS3H sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM6DS3_I2C if (I2C)
+	select INPUT_LSM6DS3_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM6DS3 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm6ds3.
+
+config INPUT_LSM6DS3_I2C
+	tristate
+	depends on INPUT_LSM6DS3
+	depends on I2C
+
+config INPUT_LSM6DS3_SPI
+	tristate
+	depends on INPUT_LSM6DS3
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.c b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.c
--- a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1593 @@
+/*
+ * STMicroelectronics lsm6ds3 driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.2.1
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <asm/unaligned.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm6ds3_core.h"
+
+/* COMMON VALUES FOR ACCEL-GYRO SENSORS */
+#define LSM6DS3_WHO_AM_I			0x0f
+#define LSM6DS3_WHO_AM_I_DEF			0x69
+#define LSM6DS3_AXIS_EN_MASK			0x38
+#define LSM6DS3_INT1_CTRL_ADDR			0x0d
+#define LSM6DS3_INT2_CTRL_ADDR			0x0e
+#define LSM6DS3_INT1_FULL			0x20
+#define LSM6DS3_INT1_FTH			0x08
+#define LSM6DS3_MD1_ADDR			0x5e
+#define LSM6DS3_ODR_LIST_NUM			6
+#define LSM6DS3_ODR_POWER_OFF_VAL		0x00
+#define LSM6DS3_ODR_13HZ_VAL			0x01
+#define LSM6DS3_ODR_26HZ_VAL			0x02
+#define LSM6DS3_ODR_52HZ_VAL			0x03
+#define LSM6DS3_ODR_104HZ_VAL			0x04
+#define LSM6DS3_ODR_208HZ_VAL			0x05
+#define LSM6DS3_ODR_416HZ_VAL			0x06
+#define LSM6DS3_FS_LIST_NUM			4
+#define LSM6DS3_BDU_ADDR			0x12
+#define LSM6DS3_BDU_MASK			0x40
+#define LSM6DS3_EN_BIT				0x01
+#define LSM6DS3_DIS_BIT				0x00
+#define LSM6DS3_FUNC_EN_ADDR			0x19
+#define LSM6DS3_FUNC_EN_MASK			0x04
+#define LSM6DS3_FUNC_CFG_ACCESS_ADDR		0x01
+#define LSM6DS3_FUNC_CFG_ACCESS_MASK		0x01
+#define LSM6DS3_FUNC_CFG_ACCESS_MASK2		0x04
+#define LSM6DS3_FUNC_CFG_REG2_MASK		0x80
+#define LSM6DS3_FUNC_CFG_START1_ADDR		0x62
+#define LSM6DS3_FUNC_CFG_START2_ADDR		0x63
+#define LSM6DS3_SELFTEST_ADDR			0x14
+#define LSM6DS3_SELFTEST_ACCEL_MASK		0x03
+#define LSM6DS3_SELFTEST_GYRO_MASK		0x0c
+#define LSM6DS3_SELF_TEST_DISABLED_VAL		0x00
+#define LSM6DS3_SELF_TEST_POS_SIGN_VAL		0x01
+#define LSM6DS3_SELF_TEST_NEG_ACCEL_SIGN_VAL	0x02
+#define LSM6DS3_SELF_TEST_NEG_GYRO_SIGN_VAL	0x03
+#define LSM6DS3_LIR_ADDR			0x58
+#define LSM6DS3_LIR_MASK			0x01
+#define LSM6DS3_TIMER_EN_ADDR			0x58
+#define LSM6DS3_TIMER_EN_MASK			0x80
+#define LSM6DS3_PEDOMETER_EN_ADDR		0x58
+#define LSM6DS3_PEDOMETER_EN_MASK		0x40
+#define LSM6DS3_INT2_ON_INT1_ADDR		0x13
+#define LSM6DS3_INT2_ON_INT1_MASK		0x20
+#define LSM6DS3_MIN_DURATION_MS			1638
+#define LSM6DS3_ROUNDING_ADDR			0x16
+#define LSM6DS3_ROUNDING_MASK			0x04
+#define LSM6DS3_FIFO_MODE_ADDR			0x0a
+#define LSM6DS3_FIFO_MODE_MASK			0x07
+#define LSM6DS3_FIFO_MODE_BYPASS		0x00
+#define LSM6DS3_FIFO_MODE_CONTINUOS		0x06
+#define LSM6DS3_FIFO_THRESHOLD_IRQ_MASK		0x08
+#define LSM6DS3_FIFO_ODR_ADDR			0x0a
+#define LSM6DS3_FIFO_ODR_MASK			0x78
+#define LSM6DS3_FIFO_ODR_MAX			0x07
+#define LSM6DS3_FIFO_ODR_MAX_HZ			800
+#define LSM6DS3_FIFO_ODR_OFF			0x00
+#define LSM6DS3_FIFO_CTRL3_ADDR			0x08
+#define LSM6DS3_FIFO_ACCEL_DECIMATOR_MASK	0x07
+#define LSM6DS3_FIFO_GYRO_DECIMATOR_MASK	0x38
+#define LSM6DS3_FIFO_CTRL4_ADDR			0x09
+#define LSM6DS3_FIFO_STEP_C_DECIMATOR_MASK	0x38
+#define LSM6DS3_FIFO_THR_L_ADDR			0x06
+#define LSM6DS3_FIFO_THR_H_ADDR			0x07
+#define LSM6DS3_FIFO_THR_H_MASK			0x0f
+#define LSM6DS3_FIFO_THR_IRQ_MASK		0x08
+#define LSM6DS3_FIFO_PEDO_E_ADDR		0x07
+#define LSM6DS3_FIFO_PEDO_E_MASK		0x80
+#define LSM6DS3_FIFO_STEP_C_FREQ		25
+
+/* CUSTOM VALUES FOR ACCEL SENSOR */
+#define LSM6DS3_ACCEL_ODR_ADDR			0x10
+#define LSM6DS3_ACCEL_ODR_MASK			0xf0
+#define LSM6DS3_ACCEL_FS_ADDR			0x10
+#define LSM6DS3_ACCEL_FS_MASK			0x0c
+#define LSM6DS3_ACCEL_FS_2G_VAL			0x00
+#define LSM6DS3_ACCEL_FS_4G_VAL			0x02
+#define LSM6DS3_ACCEL_FS_8G_VAL			0x03
+#define LSM6DS3_ACCEL_FS_16G_VAL		0x01
+#define LSM6DS3_ACCEL_FS_2G_GAIN		61
+#define LSM6DS3_ACCEL_FS_4G_GAIN		122
+#define LSM6DS3_ACCEL_FS_8G_GAIN		244
+#define LSM6DS3_ACCEL_FS_16G_GAIN		488
+#define LSM6DS3_ACCEL_OUT_X_L_ADDR		0x28
+#define LSM6DS3_ACCEL_OUT_Y_L_ADDR		0x2a
+#define LSM6DS3_ACCEL_OUT_Z_L_ADDR		0x2c
+#define LSM6DS3_ACCEL_AXIS_EN_ADDR		0x18
+#define LSM6DS3_ACCEL_DRDY_IRQ_MASK		0x01
+#define LSM6DS3_ACCEL_STD			1
+#define LSM6DS3_ACCEL_STD_FROM_PD		2
+
+/* CUSTOM VALUES FOR GYRO SENSOR */
+#define LSM6DS3_GYRO_ODR_ADDR			0x11
+#define LSM6DS3_GYRO_ODR_MASK			0xf0
+#define LSM6DS3_GYRO_FS_ADDR			0x11
+#define LSM6DS3_GYRO_FS_MASK			0x0c
+#define LSM6DS3_GYRO_FS_245_VAL			0x00
+#define LSM6DS3_GYRO_FS_500_VAL			0x01
+#define LSM6DS3_GYRO_FS_1000_VAL		0x02
+#define LSM6DS3_GYRO_FS_2000_VAL		0x03
+#define LSM6DS3_GYRO_FS_245_GAIN		8750
+#define LSM6DS3_GYRO_FS_500_GAIN		17500
+#define LSM6DS3_GYRO_FS_1000_GAIN		35000
+#define LSM6DS3_GYRO_FS_2000_GAIN		70000
+#define LSM6DS3_GYRO_OUT_X_L_ADDR		0x22
+#define LSM6DS3_GYRO_OUT_Y_L_ADDR		0x24
+#define LSM6DS3_GYRO_OUT_Z_L_ADDR		0x26
+#define LSM6DS3_GYRO_AXIS_EN_ADDR		0x19
+#define LSM6DS3_GYRO_DRDY_IRQ_MASK		0x02
+#define LSM6DS3_GYRO_STD			6
+#define LSM6DS3_GYRO_STD_FROM_PD		2
+
+/* CUSTOM VALUES FOR SIGNIFICANT MOTION SENSOR */
+#define LSM6DS3_SIGN_MOTION_EN_ADDR		0x19
+#define LSM6DS3_SIGN_MOTION_EN_MASK		0x01
+#define LSM6DS3_SIGN_MOTION_DRDY_IRQ_MASK	0x40
+
+/* CUSTOM VALUES FOR STEP DETECTOR SENSOR */
+#define LSM6DS3_ACC_DRDY_IRQ_MASK		0x01
+#define LSM6DS3_GYRO_DRDY_IRQ_MASK		0x02
+#define LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK	0x80
+#define LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK	0x80
+
+/* CUSTOM VALUES FOR STEP COUNTER SENSOR */
+#define LSM6DS3_STEP_COUNTER_DRDY_IRQ_MASK	0x80
+#define LSM6DS3_STEP_COUNTER_OUT_L_ADDR		0x4b
+#define LSM6DS3_STEP_COUNTER_OUT_SIZE		2
+#define LSM6DS3_STEP_COUNTER_RES_ADDR		0x19
+#define LSM6DS3_STEP_COUNTER_RES_MASK		0x06
+#define LSM6DS3_STEP_COUNTER_RES_ALL_EN		0x03
+#define LSM6DS3_STEP_COUNTER_RES_FUNC_EN	0x02
+#define LSM6DS3_STEP_COUNTER_DURATION_ADDR	0x15
+
+/* CUSTOM VALUES FOR TILT SENSOR */
+#define LSM6DS3_TILT_EN_ADDR			0x58
+#define LSM6DS3_TILT_EN_MASK			0x20
+#define LSM6DS3_TILT_DRDY_IRQ_MASK		0x02
+
+#define LSM6DS3_ENABLE_AXIS			0x07
+#define LSM6DS3_FIFO_DIFF_L			0x3a
+#define LSM6DS3_FIFO_DIFF_MASK			0x0fff
+#define LSM6DS3_FIFO_DATA_OUT_L			0x3e
+#define LSM6DS3_FIFO_ELEMENT_LEN_BYTE		6
+#define LSM6DS3_FIFO_BYTE_FOR_CHANNEL		2
+#define LSM6DS3_FIFO_DATA_OVR_2REGS		0x4000
+#define LSM6DS3_FIFO_DATA_OVR			0x40
+
+#define LSM6DS3_STATUS_REG			0x1e
+#define LSM6DS3_SRC_FUNC_ADDR			0x53
+#define LSM6DS3_FIFO_DATA_AVL_ADDR		0x3b
+
+#define LSM6DS3_SRC_SIGN_MOTION_DATA_AVL	0x40
+#define LSM6DS3_SRC_STEP_DETECTOR_DATA_AVL	0x10
+#define LSM6DS3_SRC_TILT_DATA_AVL		0x20
+#define LSM6DS3_SRC_STEP_COUNTER_DATA_AVL	0x80
+#define LSM6DS3_FIFO_DATA_AVL			0x80
+#define LSM6DS3_RESET_ADDR			0x12
+#define LSM6DS3_RESET_MASK			0x01
+
+#define LSM6DS3_OUT_XYZ_SIZE	6
+
+static const struct lsm6ds3_sensor_name {
+	const char *name;
+	const char *description;
+} lsm6ds3_sensor_name[LSM6DS3_SENSORS_NUMB] = {
+	[LSM6DS3_ACCEL] = {
+		.name = "accel",
+		.description = "ST LSM6DS3 Accelerometer Sensor",
+	},
+	[LSM6DS3_GYRO] = {
+		.name = "gyro",
+		.description = "ST LSM6DS3 Gyroscope Sensor",
+	},
+	[LSM6DS3_SIGN_MOTION] = {
+		.name = "sign_m",
+		.description = "ST LSM6DS3 Significant Motion Sensor",
+	},
+	[LSM6DS3_STEP_COUNTER] = {
+		.name = "step_c",
+		.description = "ST LSM6DS3 Step Counter Sensor",
+	},
+	[LSM6DS3_STEP_DETECTOR] = {
+		.name = "step_d",
+		.description = "ST LSM6DS3 Step Detector Sensor",
+	},
+	[LSM6DS3_TILT] = {
+		.name = "tilt",
+		.description = "ST LSM6DS3 Tilt Sensor",
+	},
+};
+
+struct lsm6ds3_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+static const struct lsm6ds3_odr_table {
+	u8 addr[2];
+	u8 mask[2];
+	struct lsm6ds3_odr_reg odr_avl[6];
+} lsm6ds3_odr_table = {
+	.addr[LSM6DS3_ACCEL] = LSM6DS3_ACC_ODR_ADDR,
+	.mask[LSM6DS3_ACCEL] = LSM6DS3_ACC_ODR_MASK,
+	.addr[LSM6DS3_GYRO] = LSM6DS3_GYR_ODR_ADDR,
+	.mask[LSM6DS3_GYRO] = LSM6DS3_GYR_ODR_MASK,
+	.odr_avl[0] = { .hz = 13, .value = LSM6DS3_ODR_13HZ_VAL },
+	.odr_avl[1] = { .hz = 26, .value = LSM6DS3_ODR_26HZ_VAL },
+	.odr_avl[2] = { .hz = 52, .value = LSM6DS3_ODR_52HZ_VAL },
+	.odr_avl[3] = { .hz = 104, .value = LSM6DS3_ODR_104HZ_VAL },
+	.odr_avl[4] = { .hz = 208, .value = LSM6DS3_ODR_208HZ_VAL },
+	.odr_avl[5] = { .hz = 416, .value = LSM6DS3_ODR_416HZ_VAL },
+};
+
+struct lsm6ds3_fs_reg {
+	unsigned int gain;
+	u8 value;
+	int urv;
+};
+
+static struct lsm6ds3_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lsm6ds3_fs_reg fs_avl[LSM6DS3_FS_LIST_NUM];
+} lsm6ds3_fs_table[LSM6DS3_SENSORS_NUMB] = {
+	[LSM6DS3_ACCEL] = {
+		.addr = LSM6DS3_ACCEL_FS_ADDR,
+		.mask = LSM6DS3_ACCEL_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DS3_ACCEL_FS_2G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_2G_VAL,
+					.urv = 2, },
+		.fs_avl[1] = { .gain = LSM6DS3_ACCEL_FS_4G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_4G_VAL,
+					.urv = 4, },
+		.fs_avl[2] = { .gain = LSM6DS3_ACCEL_FS_8G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_8G_VAL,
+					.urv = 8, },
+		.fs_avl[3] = { .gain = LSM6DS3_ACCEL_FS_16G_GAIN,
+					.value = LSM6DS3_ACCEL_FS_16G_VAL,
+					.urv = 16, },
+	},
+	[LSM6DS3_GYRO] = {
+		.addr = LSM6DS3_GYRO_FS_ADDR,
+		.mask = LSM6DS3_GYRO_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DS3_GYRO_FS_245_GAIN,
+					.value = LSM6DS3_GYRO_FS_245_VAL,
+					.urv = 245, },
+		.fs_avl[1] = { .gain = LSM6DS3_GYRO_FS_500_GAIN,
+					.value = LSM6DS3_GYRO_FS_500_VAL,
+					.urv = 500, },
+		.fs_avl[2] = { .gain = LSM6DS3_GYRO_FS_1000_GAIN,
+					.value = LSM6DS3_GYRO_FS_1000_VAL,
+					.urv = 1000, },
+		.fs_avl[3] = { .gain = LSM6DS3_GYRO_FS_2000_GAIN,
+					.value = LSM6DS3_GYRO_FS_2000_VAL,
+					.urv = 2000, },
+	}
+};
+
+static struct workqueue_struct *lsm6ds3_workqueue;
+
+static inline void lsm6ds3_flush_works(void)
+{
+	flush_workqueue(lsm6ds3_workqueue);
+}
+
+static inline int64_t lsm6ds3_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int lsm6ds3_write_data_with_mask(struct lsm6ds3_data *cdata,
+					u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+
+static int lsm6ds3_input_init(struct lsm6ds3_sensor_data *sdata, u16 bustype,
+			      const char *description)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = lsm6ds3_sensor_name[sdata->sindex].description;
+
+	sdata->input_dev->id.bustype = bustype;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	sdata->input_dev->name = description;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if ((sdata->sindex == LSM6DS3_ACCEL) ||
+	    (sdata->sindex == LSM6DS3_GYRO)) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+			sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lsm6ds3_input_cleanup(struct lsm6ds3_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lsm6ds3_report_3axes_event(struct lsm6ds3_sensor_data *sdata,
+				       s32 *xyz, int64_t timestamp)
+{
+	struct input_dev  *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static void lsm6ds3_report_single_event(struct lsm6ds3_sensor_data *sdata,
+					s32 data, int64_t timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static int lsm6ds3_get_step_c_data(struct lsm6ds3_sensor_data *sdata, u16 *steps)
+{
+	u8 data[2];
+	int err = 0;
+	err = sdata->cdata->tf->read(sdata->cdata,
+				     LSM6DS3_STEP_COUNTER_OUT_L_ADDR,
+				     LSM6DS3_STEP_COUNTER_OUT_SIZE,
+				     data, true);
+	if (err < 0)
+		return err;
+
+	*steps = data[0] | (data[1] << 8);
+
+	return 0;
+}
+
+static int lsm6ds3_get_poll_data(struct lsm6ds3_sensor_data *sdata, u8 *data)
+{
+	int err = 0;
+	u8 reg_addr;
+
+	switch(sdata->sindex) {
+	case LSM6DS3_ACCEL:
+		reg_addr = LSM6DS3_ACCEL_OUT_X_L_ADDR;
+		break;
+	case LSM6DS3_GYRO:
+		reg_addr = LSM6DS3_GYRO_OUT_X_L_ADDR;
+		break;
+	default:
+		dev_err(sdata->cdata->dev, "invalid polling mode for sensor %s\n",
+			sdata->name);
+		return -1;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata, reg_addr, LSM6DS3_OUT_XYZ_SIZE,
+				     data, true);
+
+	return err;
+}
+
+static void lsm6ds3_push_data(struct work_struct *input_work)
+{
+	int xyz[3];
+	u8 data[LSM6DS3_OUT_XYZ_SIZE];
+	struct lsm6ds3_sensor_data *sdata;
+
+	sdata = container_of((struct work_struct *)input_work,
+			     struct lsm6ds3_sensor_data, input_work);
+
+	if (lsm6ds3_get_poll_data(sdata, data) < 0) {
+		return;
+	} else {
+		xyz[0] = (s16)get_unaligned_le16(&data[0]) * sdata->c_gain;
+		xyz[1] = (s16)get_unaligned_le16(&data[2]) * sdata->c_gain;
+		xyz[2] = (s16)get_unaligned_le16(&data[4]) * sdata->c_gain;
+
+		lsm6ds3_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+}
+
+int lsm6ds3_set_drdy_irq(struct lsm6ds3_sensor_data *sdata, bool state)
+{
+	u8 reg_addr, mask, value;
+
+	if (state)
+		value = LSM6DS3_EN_BIT;
+	else
+		value = LSM6DS3_DIS_BIT;
+
+	switch (sdata->sindex) {
+	case LSM6DS3_ACCEL:
+	case LSM6DS3_GYRO:
+		return 0;
+	case LSM6DS3_STEP_COUNTER:
+	case LSM6DS3_SIGN_MOTION:
+	case LSM6DS3_STEP_DETECTOR:
+		if ((sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled) ||
+		    (sdata->cdata->sensors[LSM6DS3_SIGN_MOTION].enabled))
+			return 0;
+
+		reg_addr = LSM6DS3_INT1_CTRL_ADDR;
+		mask = LSM6DS3_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case LSM6DS3_TILT:
+		reg_addr = LSM6DS3_MD1_ADDR;
+		mask = LSM6DS3_TILT_DRDY_IRQ_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lsm6ds3_write_data_with_mask(sdata->cdata, reg_addr, mask, value,
+					    true);
+}
+
+static int lsm6ds3_set_fs(struct lsm6ds3_sensor_data *sdata, u32 gain)
+{
+	int err, i;
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++) {
+		if (lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain == gain)
+			break;
+	}
+
+	if (i == LSM6DS3_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_fs_table[sdata->sindex].addr,
+				lsm6ds3_fs_table[sdata->sindex].mask,
+				lsm6ds3_fs_table[sdata->sindex].fs_avl[i].value,
+				true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = gain;
+
+	return 0;
+}
+
+static irqreturn_t lsm6ds3_save_timestamp(int irq, void *private)
+{
+	struct lsm6ds3_data *cdata = (struct lsm6ds3_data *)private;
+
+	cdata->timestamp = lsm6ds3_get_time_ns();
+
+	return IRQ_WAKE_THREAD;
+}
+
+static int lsm6ds3_disable_sensors(struct lsm6ds3_sensor_data *sdata);
+
+static irqreturn_t lsm6ds3_irq_management(int irq, void *private)
+{
+	int err;
+	u16 steps_c;
+	u8 src_value = 0x00, src_fifo = 0x00;
+	struct lsm6ds3_sensor_data *sdata;
+	struct lsm6ds3_data *cdata = (struct lsm6ds3_data *)private;
+
+	cdata->tf->read(cdata, LSM6DS3_SRC_FUNC_ADDR, 1, &src_value, true);
+	cdata->tf->read(cdata, LSM6DS3_FIFO_DATA_AVL_ADDR, 1, &src_fifo, true);
+
+	if (src_value & LSM6DS3_SRC_STEP_COUNTER_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DS3_STEP_COUNTER];
+		sdata->timestamp = cdata->timestamp;
+		err = lsm6ds3_get_step_c_data(sdata, &steps_c);
+		if (err < 0) {
+			dev_err(cdata->dev,
+				"error while reading step counter data\n");
+			return IRQ_HANDLED;
+		}
+
+		lsm6ds3_report_single_event(&cdata->sensors[LSM6DS3_STEP_COUNTER],
+					    steps_c,
+					    cdata->sensors[LSM6DS3_STEP_COUNTER].timestamp);
+		cdata->steps_c = steps_c;
+	}
+
+	if (src_value & LSM6DS3_SRC_STEP_DETECTOR_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DS3_STEP_DETECTOR];
+		sdata->timestamp = cdata->timestamp;
+		lsm6ds3_report_single_event(sdata, 1, sdata->timestamp);
+
+		if (cdata->sign_motion_event_ready) {
+			sdata = &cdata->sensors[LSM6DS3_SIGN_MOTION];
+			sdata->timestamp = cdata->timestamp;
+			lsm6ds3_report_single_event(sdata, 1, sdata->timestamp);
+			cdata->sign_motion_event_ready = false;
+			lsm6ds3_disable_sensors(sdata);
+		}
+	}
+
+	if (src_value & LSM6DS3_SRC_TILT_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DS3_TILT];
+		sdata->timestamp = cdata->timestamp;
+		lsm6ds3_report_single_event(sdata, 1, sdata->timestamp);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int lsm6ds3_allocate_workqueue(struct lsm6ds3_data *cdata)
+{
+	int err;
+
+	if (!lsm6ds3_workqueue)
+		lsm6ds3_workqueue = create_workqueue(cdata->name);
+
+	if (!lsm6ds3_workqueue)
+		return -EINVAL;
+
+	err = request_threaded_irq(cdata->irq, lsm6ds3_save_timestamp,
+				   lsm6ds3_irq_management,
+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				   cdata->name, cdata);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static enum hrtimer_restart lsm6ds3_poll_function_read(struct hrtimer *timer)
+{
+	struct lsm6ds3_sensor_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct lsm6ds3_sensor_data,
+			     hr_timer);
+
+	sdata->timestamp = lsm6ds3_get_time_ns();
+
+	queue_work(lsm6ds3_workqueue, &sdata->input_work);
+
+	hrtimer_forward(timer, ktime_get(), sdata->delta_ts);
+
+	return HRTIMER_RESTART;
+}
+
+static int lsm6ds3_set_extra_dependency(struct lsm6ds3_sensor_data *sdata,
+					bool enable)
+{
+	int err;
+
+	if (!(sdata->cdata->sensors[LSM6DS3_SIGN_MOTION].enabled |
+	    sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled |
+	    sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled |
+	    sdata->cdata->sensors[LSM6DS3_TILT].enabled)) {
+		if (enable) {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_FUNC_EN_ADDR,
+						LSM6DS3_FUNC_EN_MASK,
+						LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_FUNC_EN_ADDR,
+						LSM6DS3_FUNC_EN_MASK,
+						LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	if (!sdata->cdata->sensors[LSM6DS3_ACCEL].enabled) {
+		if (enable) {
+			u8 idx = 1;
+			u16 acc_odr = sdata->cdata->sensors[LSM6DS3_ACCEL].c_odr;
+
+			if (acc_odr > 26) {
+				for (; idx < LSM6DS3_ODR_LIST_NUM; idx++)
+					if (lsm6ds3_odr_table.odr_avl[idx].hz == acc_odr)
+						break;
+			}
+
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+				lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+				lsm6ds3_odr_table.odr_avl[idx].value, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+				lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+				LSM6DS3_ODR_POWER_OFF_VAL, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lsm6ds3_enable_pedometer(struct lsm6ds3_sensor_data *sdata,
+				    bool enable)
+{
+	int err = 0;
+	u8 value = LSM6DS3_DIS_BIT;
+
+	if (sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled &&
+	    sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled)
+		return 0;
+
+	if (enable)
+		value = LSM6DS3_EN_BIT;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_FIFO_PEDO_E_ADDR,
+						LSM6DS3_FIFO_PEDO_E_MASK,
+						value, true);
+	if (err < 0)
+		return err;
+
+	return lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_PEDOMETER_EN_ADDR,
+						LSM6DS3_PEDOMETER_EN_MASK,
+						value, true);
+}
+
+static int _lsm6ds3_enable_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	int err, i;
+
+	switch (sdata->sindex) {
+	case LSM6DS3_ACCEL:
+	case LSM6DS3_GYRO:
+		for (i = 0; i < LSM6DS3_ODR_LIST_NUM; i++) {
+			if (lsm6ds3_odr_table.odr_avl[i].hz == sdata->c_odr)
+				break;
+		}
+		if (i == LSM6DS3_ODR_LIST_NUM)
+			return -EINVAL;
+
+		if (sdata->sindex == LSM6DS3_ACCEL)
+			sdata->sample_to_discard = LSM6DS3_ACCEL_STD +
+						LSM6DS3_ACCEL_STD_FROM_PD;
+
+		sdata->cdata->sensors[LSM6DS3_GYRO].sample_to_discard =
+						LSM6DS3_GYRO_STD +
+						LSM6DS3_GYRO_STD_FROM_PD;
+
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[sdata->sindex],
+				lsm6ds3_odr_table.mask[sdata->sindex],
+				lsm6ds3_odr_table.odr_avl[i].value, true);
+		if (err < 0)
+			return err;
+
+		sdata->c_odr = lsm6ds3_odr_table.odr_avl[i].hz;
+		hrtimer_start(&sdata->hr_timer, sdata->delta_ts, HRTIMER_MODE_REL);
+		break;
+	case LSM6DS3_SIGN_MOTION:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_SIGN_MOTION_EN_ADDR,
+						LSM6DS3_SIGN_MOTION_EN_MASK,
+						LSM6DS3_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		if ((sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled) ||
+		    (sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled)) {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_PEDOMETER_EN_ADDR,
+						LSM6DS3_PEDOMETER_EN_MASK,
+						LSM6DS3_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+						LSM6DS3_PEDOMETER_EN_ADDR,
+						LSM6DS3_PEDOMETER_EN_MASK,
+						LSM6DS3_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6ds3_enable_pedometer(sdata, true);
+			if (err < 0)
+				return err;
+		}
+
+		sdata->cdata->sign_motion_event_ready = true;
+
+		break;
+	case LSM6DS3_STEP_COUNTER:
+	case LSM6DS3_STEP_DETECTOR:
+		err = lsm6ds3_enable_pedometer(sdata, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DS3_TILT:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_TILT_EN_ADDR,
+					LSM6DS3_TILT_EN_MASK,
+					LSM6DS3_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6ds3_set_extra_dependency(sdata, true);
+	if (err < 0)
+		return err;
+
+
+	err = lsm6ds3_set_drdy_irq(sdata, true);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm6ds3_enable_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	int err;
+
+	if (sdata->enabled)
+		return 0;
+
+	err = _lsm6ds3_enable_sensors(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = true;
+
+	return 0;
+}
+
+static int _lsm6ds3_disable_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	int err;
+
+	switch (sdata->sindex) {
+	case LSM6DS3_ACCEL:
+		if (sdata->cdata->sensors[LSM6DS3_SIGN_MOTION].enabled |
+		    sdata->cdata->sensors[LSM6DS3_STEP_COUNTER].enabled |
+		    sdata->cdata->sensors[LSM6DS3_STEP_DETECTOR].enabled |
+		    sdata->cdata->sensors[LSM6DS3_TILT].enabled) {
+
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+				lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+				lsm6ds3_odr_table.odr_avl[0].value, true);
+		} else {
+			err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[LSM6DS3_ACCEL],
+				lsm6ds3_odr_table.mask[LSM6DS3_ACCEL],
+				LSM6DS3_ODR_POWER_OFF_VAL, true);
+		}
+		if (err < 0)
+			return err;
+
+		hrtimer_cancel(&sdata->hr_timer);
+		break;
+	case LSM6DS3_GYRO:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[LSM6DS3_GYRO],
+				lsm6ds3_odr_table.mask[LSM6DS3_GYRO],
+				LSM6DS3_ODR_POWER_OFF_VAL, true);
+		if (err < 0)
+			return err;
+
+		hrtimer_cancel(&sdata->hr_timer);
+		break;
+	case LSM6DS3_SIGN_MOTION:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				LSM6DS3_SIGN_MOTION_EN_ADDR,
+				LSM6DS3_SIGN_MOTION_EN_MASK,
+				LSM6DS3_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6ds3_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		sdata->cdata->sign_motion_event_ready = false;
+
+		break;
+	case LSM6DS3_STEP_COUNTER:
+	case LSM6DS3_STEP_DETECTOR:
+		err = lsm6ds3_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DS3_TILT:
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				LSM6DS3_TILT_EN_ADDR,
+				LSM6DS3_TILT_EN_MASK,
+				LSM6DS3_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6ds3_set_extra_dependency(sdata, false);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_set_drdy_irq(sdata, false);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm6ds3_disable_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	err = _lsm6ds3_disable_sensors(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = false;
+
+	return 0;
+}
+
+static int lsm6ds3_reset_steps(struct lsm6ds3_data *cdata)
+{
+	int err;
+	u8 reg_value = 0x00;
+
+	err = cdata->tf->read(cdata,
+			LSM6DS3_STEP_COUNTER_RES_ADDR, 1, &reg_value, true);
+	if (err < 0)
+		return err;
+
+	if (reg_value & LSM6DS3_FUNC_EN_MASK)
+		reg_value = LSM6DS3_STEP_COUNTER_RES_FUNC_EN;
+	else
+		reg_value = LSM6DS3_DIS_BIT;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+				LSM6DS3_STEP_COUNTER_RES_ADDR,
+				LSM6DS3_STEP_COUNTER_RES_MASK,
+				LSM6DS3_STEP_COUNTER_RES_ALL_EN, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+				LSM6DS3_STEP_COUNTER_RES_ADDR,
+				LSM6DS3_STEP_COUNTER_RES_MASK,
+				reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->reset_steps = true;
+
+	return 0;
+}
+
+static int lsm6ds3_init_sensors(struct lsm6ds3_data *cdata)
+{
+	int err, i;
+	u8 default_reg_value = 0;
+	struct lsm6ds3_sensor_data *sdata;
+
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+
+		err = lsm6ds3_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+
+		if ((sdata->sindex == LSM6DS3_ACCEL) ||
+		    (sdata->sindex == LSM6DS3_GYRO)) {
+			err = lsm6ds3_set_fs(sdata, sdata->c_gain);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	cdata->steps_c = 0;
+	cdata->reset_steps = false;
+
+	err = lsm6ds3_write_data_with_mask(cdata, LSM6DS3_RESET_ADDR,
+					   LSM6DS3_RESET_MASK, LSM6DS3_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					   LSM6DS3_LIR_ADDR,
+					   LSM6DS3_LIR_MASK,
+					   LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					   LSM6DS3_TIMER_EN_ADDR,
+					   LSM6DS3_TIMER_EN_MASK,
+					   LSM6DS3_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					   LSM6DS3_BDU_ADDR,
+					   LSM6DS3_BDU_MASK,
+					   LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					   LSM6DS3_ROUNDING_ADDR,
+					   LSM6DS3_ROUNDING_MASK,
+					   LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_write_data_with_mask(cdata,
+					   LSM6DS3_INT2_ON_INT1_ADDR,
+					   LSM6DS3_INT2_ON_INT1_MASK,
+					   LSM6DS3_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6ds3_reset_steps(sdata->cdata);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&cdata->bank_registers_lock);
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					   LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DS3_FUNC_CFG_REG2_MASK,
+					   LSM6DS3_EN_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_init_sensor_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+				      LSM6DS3_STEP_COUNTER_DURATION_ADDR,
+				      1, &default_reg_value, false);
+	if (err < 0)
+		goto lsm6ds3_init_sensor_mutex_unlock;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					   LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DS3_FUNC_CFG_REG2_MASK,
+					   LSM6DS3_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_init_sensor_mutex_unlock;
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return 0;
+
+lsm6ds3_init_sensor_mutex_unlock:
+	mutex_unlock(&cdata->bank_registers_lock);
+	return err;
+}
+
+static int lsm6ds3_set_odr(struct lsm6ds3_sensor_data *sdata, u32 odr)
+{
+	int err = 0, i;
+
+	for (i = 0; i < LSM6DS3_ODR_LIST_NUM; i++) {
+		if (lsm6ds3_odr_table.odr_avl[i].hz >= odr)
+			break;
+	}
+	if (i == LSM6DS3_ODR_LIST_NUM)
+		return -EINVAL;
+
+	if (sdata->c_odr == lsm6ds3_odr_table.odr_avl[i].hz)
+		return 0;
+
+	if (sdata->enabled) {
+		disable_irq(sdata->cdata->irq);
+		lsm6ds3_flush_works();
+
+		if (sdata->sindex == LSM6DS3_ACCEL)
+			sdata->cdata->sensors[LSM6DS3_ACCEL].sample_to_discard +=
+							LSM6DS3_ACCEL_STD;
+
+		if (sdata->cdata->sensors[LSM6DS3_GYRO].enabled)
+			sdata->cdata->sensors[LSM6DS3_GYRO].sample_to_discard +=
+							LSM6DS3_GYRO_STD;
+
+		err = lsm6ds3_write_data_with_mask(sdata->cdata,
+				lsm6ds3_odr_table.addr[sdata->sindex],
+				lsm6ds3_odr_table.mask[sdata->sindex],
+				lsm6ds3_odr_table.odr_avl[i].value, true);
+		if (err < 0) {
+			enable_irq(sdata->cdata->irq);
+
+			return err;
+		}
+
+		sdata->c_odr = lsm6ds3_odr_table.odr_avl[i].hz;
+		enable_irq(sdata->cdata->irq);
+	} else
+		sdata->c_odr = lsm6ds3_odr_table.odr_avl[i].hz;
+
+	sdata->delta_ts = ktime_set(0, 1000000000 / sdata->c_odr);
+
+	return err;
+}
+
+static ssize_t get_enable(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t set_enable(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int err;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = lsm6ds3_enable_sensors(sdata);
+	else
+		err = lsm6ds3_disable_sensors(sdata);
+
+	return count;
+}
+
+static ssize_t get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->poll_interval);
+}
+
+static ssize_t set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	/*
+	 * Polling interval is in msec, then we have to convert it in Hz to
+	 * configure ODR through lsm6ds3_set_odr
+	 */
+	err = lsm6ds3_set_odr(sdata, 1000 / polling_rate);
+	if (!(err < 0))
+		sdata->poll_interval = polling_rate;
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+static ssize_t get_sampling_freq(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->c_odr);
+}
+
+static ssize_t set_sampling_freq(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int err;
+	unsigned int odr;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	err = lsm6ds3_set_odr(sdata, odr);
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+static ssize_t reset_steps(struct device *dev,
+			   struct device_attribute *attr, const char *buf,
+			   size_t count)
+{
+	int err;
+	unsigned int reset;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &reset);
+	if (err < 0)
+		return err;
+
+	lsm6ds3_reset_steps(sdata->cdata);
+
+	return count;
+}
+
+static ssize_t set_max_delivery_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	u8 duration;
+	int err, err2;
+	unsigned int max_delivery_rate;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtouint(buf, 10, &max_delivery_rate);
+	if (err < 0)
+		return -EINVAL;
+
+	if (max_delivery_rate == sdata->c_odr)
+		return size;
+
+	duration = max_delivery_rate / LSM6DS3_MIN_DURATION_MS;
+
+	mutex_lock(&sdata->cdata->bank_registers_lock);
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					   LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DS3_FUNC_CFG_REG2_MASK,
+					   LSM6DS3_EN_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_set_max_delivery_rate_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+				      LSM6DS3_STEP_COUNTER_DURATION_ADDR,
+				      1, &duration, false);
+	if (err < 0)
+		goto lsm6ds3_set_max_delivery_rate_restore_bank;
+
+	err = lsm6ds3_write_data_with_mask(sdata->cdata,
+					   LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DS3_FUNC_CFG_REG2_MASK,
+					   LSM6DS3_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6ds3_set_max_delivery_rate_restore_bank;
+
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+
+	sdata->c_odr = max_delivery_rate;
+
+	return size;
+
+lsm6ds3_set_max_delivery_rate_restore_bank:
+	do {
+		err2 = lsm6ds3_write_data_with_mask(sdata->cdata,
+					LSM6DS3_FUNC_CFG_ACCESS_ADDR,
+					LSM6DS3_FUNC_CFG_REG2_MASK,
+					LSM6DS3_DIS_BIT, false);
+
+		msleep(500);
+	} while (err2 < 0);
+
+lsm6ds3_set_max_delivery_rate_mutex_unlock:
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+	return err;
+}
+
+static ssize_t get_max_delivery_rate(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", sdata->c_odr);
+}
+
+static ssize_t get_sampling_frequency_avail(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LSM6DS3_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 lsm6ds3_odr_table.odr_avl[i].hz);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_scale_avail(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lsm6ds3_fs_table[sdata->sindex].fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_cur_scale(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++)
+		if (sdata->c_gain ==
+				lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain)
+			break;
+
+	return sprintf(buf, "%d\n",
+		       lsm6ds3_fs_table[sdata->sindex].fs_avl[i].urv);
+}
+
+static ssize_t set_cur_scale(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int i, urv, err;
+	struct lsm6ds3_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < LSM6DS3_FS_LIST_NUM; i++)
+		if (urv == lsm6ds3_fs_table[sdata->sindex].fs_avl[i].urv)
+			break;
+
+	if (i == LSM6DS3_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6ds3_set_fs(sdata,
+				lsm6ds3_fs_table[sdata->sindex].fs_avl[i].gain);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO, get_enable, set_enable);
+static DEVICE_ATTR(sampling_freq, S_IWUSR | S_IRUGO, get_sampling_freq,
+		   set_sampling_freq);
+static DEVICE_ATTR(polling_rate, S_IWUSR | S_IRUGO, get_polling_rate,
+		   set_polling_rate);
+static DEVICE_ATTR(reset_steps, S_IWUSR, NULL, reset_steps);
+static DEVICE_ATTR(max_delivery_rate, S_IWUSR | S_IRUGO, get_max_delivery_rate,
+		   set_max_delivery_rate);
+static DEVICE_ATTR(sampling_freq_avail, S_IRUGO, get_sampling_frequency_avail,
+		   NULL);
+static DEVICE_ATTR(scale_avail, S_IRUGO, get_scale_avail, NULL);
+static DEVICE_ATTR(scale, S_IWUSR | S_IRUGO, get_cur_scale, set_cur_scale);
+
+static struct attribute *lsm6ds3_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_gyro_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_sign_m_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_step_c_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_reset_steps.attr,
+	&dev_attr_max_delivery_rate.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_step_d_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6ds3_tilt_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lsm6ds3_attribute_groups[] = {
+	[LSM6DS3_ACCEL] = {
+		.attrs = lsm6ds3_accel_attribute,
+		.name = "accel",
+	},
+	[LSM6DS3_GYRO] = {
+		.attrs = lsm6ds3_gyro_attribute,
+		.name = "gyro",
+	},
+	[LSM6DS3_SIGN_MOTION] = {
+		.attrs = lsm6ds3_sign_m_attribute,
+		.name = "sign_m",
+	},
+	[LSM6DS3_STEP_COUNTER] = {
+		.attrs = lsm6ds3_step_c_attribute,
+		.name = "step_c",
+	},
+	[LSM6DS3_STEP_DETECTOR] = {
+		.attrs = lsm6ds3_step_d_attribute,
+		.name = "step_d",
+	},
+	[LSM6DS3_TILT] = {
+		.attrs = lsm6ds3_tilt_attribute,
+		.name = "tilt",
+	},
+};
+
+#ifdef CONFIG_OF
+static u32 lsm6ds3_parse_dt(struct lsm6ds3_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+				  (val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	return 0;
+}
+#endif
+
+int lsm6ds3_common_probe(struct lsm6ds3_data *cdata, int irq, u16 bustype)
+{
+	/* TODO: add errors management */
+	int32_t err, i;
+	u8 wai =0x00;
+	struct lsm6ds3_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->tb.buf_lock);
+	mutex_init(&cdata->lock);
+
+	/* Read Chip ID register */
+	err = cdata->tf->read(cdata, LSM6DS3_WHO_AM_I, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		return err;
+	}
+	if (wai != LSM6DS3_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+
+	if (irq > 0) {
+#ifdef CONFIG_OF
+		err = lsm6ds3_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lsm6ds3_platform_data *)
+					cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) ||
+			    (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else {
+			cdata->drdy_int_pin = 1;
+		}
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+			 cdata->drdy_int_pin);
+	}
+
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lsm6ds3_sensor_name[i].name;
+		if ((i == LSM6DS3_ACCEL) || (i == LSM6DS3_GYRO)) {
+			sdata->c_odr = lsm6ds3_odr_table.odr_avl[0].hz;
+			sdata->c_gain = lsm6ds3_fs_table[i].fs_avl[0].gain;
+			sdata->poll_interval = 1000 / sdata->c_odr;
+
+			hrtimer_init(&sdata->hr_timer, CLOCK_MONOTONIC,
+				     HRTIMER_MODE_REL);
+			sdata->hr_timer.function = &lsm6ds3_poll_function_read;
+			INIT_WORK(&sdata->input_work, lsm6ds3_push_data);
+		}
+		if (i == LSM6DS3_STEP_COUNTER) {
+			sdata->c_odr = LSM6DS3_MIN_DURATION_MS;
+		}
+
+		if (lsm6ds3_input_init(sdata, bustype,
+				       lsm6ds3_sensor_name[i].description)) {
+			dev_err(cdata->dev,
+				"failed to register input device %s",
+				sdata->name);
+			sdata->input_dev = NULL;
+			continue;
+		}
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+				       &lsm6ds3_attribute_groups[i])) {
+			dev_err(cdata->dev,
+				"failed to create sysfs group for sensor %s",
+				sdata->name);
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+	}
+
+	if(!lsm6ds3_workqueue)
+		lsm6ds3_workqueue = create_workqueue("lsm6ds3_workqueue");
+
+	err = lsm6ds3_init_sensors(cdata);
+	if (err < 0)
+		return err;
+	if (irq > 0)
+		cdata->irq = irq;
+
+	if (irq > 0) {
+		err = lsm6ds3_allocate_workqueue(cdata);
+		if (err < 0)
+			return err;
+	}
+
+	dev_info(cdata->dev, "%s: probed\n", LSM6DS3_ACC_GYR_DEV_NAME);
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds3_common_probe);
+
+void lsm6ds3_common_remove(struct lsm6ds3_data *cdata, int irq)
+{
+	u8 i;
+
+	for (i = 0; i < LSM6DS3_SENSORS_NUMB; i++) {
+		lsm6ds3_disable_sensors(&cdata->sensors[i]);
+		lsm6ds3_input_cleanup(&cdata->sensors[i]);
+	}
+
+	if(lsm6ds3_workqueue) {
+		flush_workqueue(lsm6ds3_workqueue);
+		destroy_workqueue(lsm6ds3_workqueue);
+		lsm6ds3_workqueue = NULL;
+	}
+}
+EXPORT_SYMBOL(lsm6ds3_common_remove);
+
+#ifdef CONFIG_PM
+static int lsm6ds3_resume_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lsm6ds3_enable_sensors(sdata);
+}
+
+static int lsm6ds3_suspend_sensors(struct lsm6ds3_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lsm6ds3_disable_sensors(sdata);
+}
+int lsm6ds3_common_suspend(struct lsm6ds3_data *cdata)
+{
+	lsm6ds3_suspend_sensors(&cdata->sensors[LSM6DS3_ACCEL]);
+	lsm6ds3_suspend_sensors(&cdata->sensors[LSM6DS3_GYRO]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds3_common_suspend);
+
+int lsm6ds3_common_resume(struct lsm6ds3_data *cdata)
+{
+	lsm6ds3_resume_sensors(&cdata->sensors[LSM6DS3_ACCEL]);
+	lsm6ds3_resume_sensors(&cdata->sensors[LSM6DS3_GYRO]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6ds3_common_resume);
+
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.h b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.h
--- a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_core.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,164 @@
+/*
+ * STMicroelectronics lsm6ds3 driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.2.1
+ * Licensed under the GPL-2.
+ */
+
+#ifndef DRIVERS_INPUT_MISC_LSM6DS3_CORE_H_
+#define DRIVERS_INPUT_MISC_LSM6DS3_CORE_H_
+
+#define LSM6DS3_ACC_GYR_DEV_NAME	"lsm6ds3"
+
+#define HZ_TO_PERIOD_NSEC(hz)		(1000 * 1000 * 1000 / ((u32)(hz)))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+
+enum {
+	LSM6DS3_ACCEL = 0,
+	LSM6DS3_GYRO,
+	LSM6DS3_SIGN_MOTION,
+	LSM6DS3_STEP_COUNTER,
+	LSM6DS3_STEP_DETECTOR,
+	LSM6DS3_TILT,
+	LSM6DS3_SENSORS_NUMB,
+};
+
+#define DEF_ZERO			0x00
+
+/* First Out register for Acc and Gyro */
+#define LSM6DS3_ACC_OUT_X_L_ADDR	0x28
+#define LSM6DS3_GYR_OUT_X_L_ADDR	0x22
+
+/* Output data rate registers */
+#define LSM6DS3_ACC_ODR_ADDR		CTRL1_ADDR
+#define LSM6DS3_ACC_ODR_MASK		0xf0
+#define LSM6DS3_GYR_ODR_ADDR		CTRL2_ADDR
+#define LSM6DS3_GYR_ODR_MASK		0xf0
+
+#define LSM6DS3_ACC_FS_ADDR		CTRL1_ADDR
+#define LSM6DS3_GYR_FS_ADDR		CTRL2_ADDR
+
+#define LSM6DS3_IF_INC_MASK		0x04
+
+#define LSM6DS3_HPERF_GYR_ADDR		CTRL7_ADDR
+#define LSM6DS3_HPERF_GYR_MASK		0x80
+
+#define LSM6DS3_HPERF_ACC_ADDR		CTRL6_ADDR
+#define LSM6DS3_HPERF_ACC_MASK		0x10
+#define LSM6DS3_HPERF_ACC_ENABLE	0x00
+
+#define CTRL1_ADDR			0x10
+#define CTRL2_ADDR			0x11
+#define CTRL3_ADDR			0x12
+#define CTRL6_ADDR			0x15
+#define CTRL7_ADDR			0x16
+
+
+/* Sensitivity Acc */
+#define SENSITIVITY_ACC_2G		61	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		122	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		244	/** ug/LSB */
+#define SENSITIVITY_ACC_16G		488	/** ug/LSB */
+/* Sensitivity Gyr */
+#define SENSITIVITY_GYR_125		437	/** 10udps/LSB */
+#define SENSITIVITY_GYR_245		875	/** 10udps/LSB */
+#define SENSITIVITY_GYR_500		1750	/** 10udps/LSB */
+#define SENSITIVITY_GYR_1000		3500	/** 10udps/LSB */
+#define SENSITIVITY_GYR_2000		7000	/** 10udps/LSB */
+
+#define FUZZ				0
+#define FLAT				0
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define LSM6DS3_RX_MAX_LENGTH		500
+#define LSM6DS3_TX_MAX_LENGTH		500
+
+#define to_dev(obj) 			container_of(obj, struct device, kobj)
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lsm6ds3_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM6DS3_RX_MAX_LENGTH];
+	u8 tx_buf[LSM6DS3_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6ds3_data;
+
+struct lsm6ds3_transfer_function {
+	int (*write) (struct lsm6ds3_data *cdata, u8 reg_addr, int len, u8 *data,
+		      bool b_lock);
+	int (*read) (struct lsm6ds3_data *cdata, u8 reg_addr, int len, u8 *data,
+		     bool b_lock);
+};
+
+struct lsm6ds3_sensor_data {
+	struct lsm6ds3_data *cdata;
+	const char* name;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+
+	struct input_dev *input_dev;
+	unsigned int poll_interval;
+
+	int64_t timestamp;
+	struct work_struct input_work;
+	struct hrtimer hr_timer;
+	ktime_t delta_ts;
+};
+
+struct lsm6ds3_data {
+	const char *name;
+	bool reset_steps;
+	bool sign_motion_event_ready;
+	u16 steps_c;
+	u8 drdy_int_pin;
+	int irq;
+	int64_t timestamp;
+
+	struct mutex lock;
+	struct device *dev;
+	struct lsm6ds3_sensor_data sensors[LSM6DS3_SENSORS_NUMB];
+	struct mutex bank_registers_lock;
+	const struct lsm6ds3_transfer_function *tf;
+	struct lsm6ds3_transfer_buffer tb;
+};
+
+int lsm6ds3_common_probe(struct lsm6ds3_data *cdata, int irq, u16 bustype);
+void lsm6ds3_common_remove(struct lsm6ds3_data *cdata, int irq);
+
+#ifdef CONFIG_PM
+int lsm6ds3_common_suspend(struct lsm6ds3_data *cdata);
+int lsm6ds3_common_resume(struct lsm6ds3_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* DRIVERS_INPUT_MISC_LSM6DS3_CORE_H_ */
diff -uNr a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_i2c.c b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_i2c.c
--- a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,173 @@
+/*
+ * STMicroelectronics lsm6ds3 i2c driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.2.1
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lsm6ds3_core.h"
+
+static int lsm6ds3_i2c_read(struct lsm6ds3_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int lsm6ds3_i2c_write(struct lsm6ds3_data *cdata, u8 reg_addr, int len,
+			     u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+
+static const struct lsm6ds3_transfer_function lsm6ds3_tf_i2c = {
+	.write = lsm6ds3_i2c_write,
+	.read = lsm6ds3_i2c_read,
+};
+
+static int lsm6ds3_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6ds3_data *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &lsm6ds3_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm6ds3_common_probe(cdata, client->irq, BUS_I2C);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lsm6ds3_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(client);
+
+	lsm6ds3_common_remove(cdata, client->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DS3_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6ds3_suspend(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6ds3_common_suspend(cdata);
+}
+
+static int lsm6ds3_resume(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6ds3_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6ds3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6ds3_suspend, lsm6ds3_resume)
+};
+
+#define LSM6DS3_PM_OPS		(&lsm6ds3_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DS3_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lsm6ds3_ids[] = {
+	{LSM6DS3_ACC_GYR_DEV_NAME, 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lsm6ds3_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds3_id_table[] = {
+	{.compatible = "st,lsm6ds3", },
+	{.compatible = "st,lsm6ds3h", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6ds3_id_table);
+#endif
+
+static struct i2c_driver lsm6ds3_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DS3_ACC_GYR_DEV_NAME,
+		.pm = LSM6DS3_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6ds3_id_table,
+#endif
+	},
+	.probe    = lsm6ds3_i2c_probe,
+	.remove   = lsm6ds3_i2c_remove,
+	.id_table = lsm6ds3_ids,
+};
+
+module_i2c_driver(lsm6ds3_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_spi.c b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_spi.c
--- a/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds3/lsm6ds3_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,204 @@
+/*
+ * STMicroelectronics lsm6ds3 i2c driver
+ *
+ * Copyright 2014 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * v 1.2.1
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lsm6ds3_core.h"
+
+#define SENSORS_SPI_READ			0x80
+
+static int lsm6ds3_spi_read(struct lsm6ds3_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len * sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lsm6ds3_spi_write(struct lsm6ds3_data *cdata, u8 reg_addr, int len,
+			     u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM6DS3_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+
+static const struct lsm6ds3_transfer_function lsm6ds3_tf_spi = {
+	.write = lsm6ds3_spi_write,
+	.read = lsm6ds3_spi_read,
+};
+
+static int lsm6ds3_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6ds3_data *cdata;
+
+	cdata = kzalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &lsm6ds3_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm6ds3_common_probe(cdata, spi->irq, BUS_SPI);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lsm6ds3_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lsm6ds3_data *cdata = spi_get_drvdata(spi);
+
+	lsm6ds3_common_remove(cdata, spi->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DS3_ACC_GYR_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6ds3_suspend(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6ds3_common_suspend(cdata);
+}
+
+static int lsm6ds3_resume(struct device *dev)
+{
+	struct lsm6ds3_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6ds3_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6ds3_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6ds3_suspend, lsm6ds3_resume)
+};
+
+#define LSM6DS3_PM_OPS		(&lsm6ds3_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DS3_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lsm6ds3_ids[] = {
+	{LSM6DS3_ACC_GYR_DEV_NAME, 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm6ds3_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6ds3_id_table[] = {
+	{.compatible = "st,lsm6ds3", },
+	{.compatible = "st,lsm6ds3h", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6ds3_id_table);
+#endif
+
+static struct spi_driver lsm6ds3_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DS3_ACC_GYR_DEV_NAME,
+		.pm = LSM6DS3_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6ds3_id_table,
+#endif
+	},
+	.probe    = lsm6ds3_spi_probe,
+	.remove   = lsm6ds3_spi_remove,
+	.id_table = lsm6ds3_ids,
+};
+
+module_spi_driver(lsm6ds3_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6ds3 spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6ds3/Makefile b/drivers/input/misc/st/imu/lsm6ds3/Makefile
--- a/drivers/input/misc/st/imu/lsm6ds3/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6ds3/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM imu lsm6ds3 driver
+#
+lsm6ds3-core-y += lsm6ds3_core.o
+obj-$(CONFIG_INPUT_LSM6DS3) += lsm6ds3-core.o
+obj-$(CONFIG_INPUT_LSM6DS3_I2C) += lsm6ds3_i2c.o
+obj-$(CONFIG_INPUT_LSM6DS3_SPI) += lsm6ds3_spi.o
diff -uNr a/drivers/input/misc/st/imu/lsm6dsl/Kconfig b/drivers/input/misc/st/imu/lsm6dsl/Kconfig
--- a/drivers/input/misc/st/imu/lsm6dsl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsl/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LSM6DSL
+	tristate "STMicroelectronics LSM6DSL sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM6DSL_I2C if (I2C)
+	select INPUT_LSM6DSL_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM6DSL sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm6dsl.
+
+config INPUT_LSM6DSL_I2C
+	tristate
+	depends on INPUT_LSM6DSL
+	depends on I2C
+
+config INPUT_LSM6DSL_SPI
+	tristate
+	depends on INPUT_LSM6DSL
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.c b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.c
--- a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1598 @@
+/*
+ * STMicroelectronics lsm6dsl driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.0.1
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm6dsl_core.h"
+
+/* COMMON DEFINE FOR ACCEL-GYRO SENSORS */
+#define LSM6DSL_EN_BIT			0x01
+#define LSM6DSL_DIS_BIT			0x00
+
+#define LSM6DSL_WHO_AM_I		0x0f
+#define LSM6DSL_WHO_AM_I_DEF		0x6a
+
+#define LSM6DSL_INT1_CTRL_ADDR		0x0d
+#define LSM6DSL_MD1_ADDR		0x5e
+
+#define LSM6DSL_ODR_LIST_NUM		5
+#define LSM6DSL_ODR_POWER_OFF_VAL	0x00
+#define LSM6DSL_ODR_13HZ_VAL		0x01
+#define LSM6DSL_ODR_26HZ_VAL		0x02
+#define LSM6DSL_ODR_52HZ_VAL		0x03
+#define LSM6DSL_ODR_104HZ_VAL		0x04
+#define LSM6DSL_ODR_208HZ_VAL		0x05
+#define LSM6DSL_ODR_416HZ_VAL		0x06
+#define LSM6DSL_FS_LIST_NUM		4
+
+#define LSM6DSL_BDU_ADDR		0x12
+#define LSM6DSL_BDU_MASK		0x40
+
+#define LSM6DSL_FUNC_EN_ADDR		0x19
+#define LSM6DSL_FUNC_EN_MASK		0x04
+#define LSM6DSL_FUNC_CFG_ACCESS_ADDR	0x01
+#define LSM6DSL_FUNC_CFG_REG_MASK	0x80
+
+#define LSM6DSL_LIR_ADDR		0x58
+#define LSM6DSL_LIR_MASK		0x01
+
+#define LSM6DSL_TIMER_EN_ADDR		0x19
+#define LSM6DSL_TIMER_EN_MASK		0x20
+
+#define LSM6DSL_PEDOMETER_EN_ADDR	0x19
+#define LSM6DSL_PEDOMETER_EN_MASK	0x10
+
+#define LSM6DSL_INT2_ON_INT1_ADDR	0x13
+#define LSM6DSL_INT2_ON_INT1_MASK	0x20
+
+#define LSM6DSL_MIN_DURATION_MS		1638
+#define LSM6DSL_ROUNDING_ADDR		0x16
+#define LSM6DSL_ROUNDING_MASK		0x04
+
+#define LSM6DSL_FIFO_PEDO_E_ADDR	0x07
+#define LSM6DSL_FIFO_PEDO_E_MASK	0x80
+
+/* CUSTOM VALUES FOR ACCEL SENSOR */
+#define LSM6DSL_ACCEL_ODR_ADDR		0x10
+#define LSM6DSL_ACCEL_ODR_MASK		0xf0
+#define LSM6DSL_ACCEL_FS_ADDR		0x10
+#define LSM6DSL_ACCEL_FS_MASK		0x0c
+#define LSM6DSL_ACCEL_FS_2G_VAL		0x00
+#define LSM6DSL_ACCEL_FS_4G_VAL		0x02
+#define LSM6DSL_ACCEL_FS_8G_VAL		0x03
+#define LSM6DSL_ACCEL_FS_16G_VAL	0x01
+#define LSM6DSL_ACCEL_FS_2G_GAIN	61
+#define LSM6DSL_ACCEL_FS_4G_GAIN	122
+#define LSM6DSL_ACCEL_FS_8G_GAIN	244
+#define LSM6DSL_ACCEL_FS_16G_GAIN	488
+#define LSM6DSL_ACCEL_OUT_X_L_ADDR	0x28
+#define LSM6DSL_ACCEL_OUT_Y_L_ADDR	0x2a
+#define LSM6DSL_ACCEL_OUT_Z_L_ADDR	0x2c
+#define LSM6DSL_ACCEL_AXIS_EN_ADDR	0x18
+#define LSM6DSL_ACCEL_DRDY_IRQ_MASK	0x01
+#define LSM6DSL_ACCEL_STD		1
+#define LSM6DSL_ACCEL_STD_FROM_PD	2
+
+/* CUSTOM VALUES FOR GYRO SENSOR */
+#define LSM6DSL_GYRO_ODR_ADDR		0x11
+#define LSM6DSL_GYRO_ODR_MASK		0xf0
+#define LSM6DSL_GYRO_FS_ADDR		0x11
+#define LSM6DSL_GYRO_FS_MASK		0x0c
+#define LSM6DSL_GYRO_FS_245_VAL		0x00
+#define LSM6DSL_GYRO_FS_500_VAL		0x01
+#define LSM6DSL_GYRO_FS_1000_VAL	0x02
+#define LSM6DSL_GYRO_FS_2000_VAL	0x03
+#define LSM6DSL_GYRO_FS_245_GAIN	8750
+#define LSM6DSL_GYRO_FS_500_GAIN	17500
+#define LSM6DSL_GYRO_FS_1000_GAIN	35000
+#define LSM6DSL_GYRO_FS_2000_GAIN	70000
+#define LSM6DSL_GYRO_OUT_X_L_ADDR	0x22
+#define LSM6DSL_GYRO_OUT_Y_L_ADDR	0x24
+#define LSM6DSL_GYRO_OUT_Z_L_ADDR	0x26
+#define LSM6DSL_GYRO_AXIS_EN_ADDR	0x19
+#define LSM6DSL_GYRO_DRDY_IRQ_MASK	0x02
+#define LSM6DSL_GYRO_STD		6
+#define LSM6DSL_GYRO_STD_FROM_PD	2
+
+#define LSM6DSL_OUT_XYZ_SIZE		6
+
+/* CUSTOM VALUES FOR SIGNIFICANT MOTION SENSOR */
+#define LSM6DSL_SIGN_MOTION_EN_ADDR	0x19
+#define LSM6DSL_SIGN_MOTION_EN_MASK	0x01
+#define LSM6DSL_SIGN_MOTION_DRDY_IRQ_MASK	0x40
+
+/* CUSTOM VALUES FOR STEP DETECTOR SENSOR */
+#define LSM6DSL_STEP_DETECTOR_DRDY_IRQ_MASK	0x80
+
+/* CUSTOM VALUES FOR STEP COUNTER SENSOR */
+#define LSM6DSL_STEP_COUNTER_OUT_L_ADDR		0x4b
+#define LSM6DSL_STEP_COUNTER_OUT_SIZE	2
+#define LSM6DSL_STEP_COUNTER_RES_ADDR	0x19
+#define LSM6DSL_STEP_COUNTER_RES_MASK	0x06
+#define LSM6DSL_STEP_COUNTER_RES_ALL_EN		0x03
+#define LSM6DSL_STEP_COUNTER_RES_FUNC_EN	0x02
+#define LSM6DSL_STEP_COUNTER_DURATION_ADDR	0x15
+
+/* CUSTOM VALUES FOR TILT SENSOR */
+#define LSM6DSL_TILT_EN_ADDR		0x19
+#define LSM6DSL_TILT_EN_MASK		0x08
+#define LSM6DSL_TILT_DRDY_IRQ_MASK	0x02
+
+#define LSM6DSL_SRC_FUNC_ADDR		0x53
+#define LSM6DSL_SRC2_FUNC_ADDR		0x54
+#define LSM6DSL_SRC_SIGN_MOTION_DATA_AVL	0x40
+#define LSM6DSL_SRC_TILT_DATA_AVL	0x20
+#define LSM6DSL_SRC_STEP_DETECTOR_DATA_AVL	0x10
+#define LSM6DSL_SRC_STEP_COUNTER_DATA_AVL	0x80
+
+/* Sensor Software Reset Bit */
+#define LSM6DSL_RESET_ADDR		0x12
+#define LSM6DSL_RESET_MASK		0x01
+
+static const struct lsm6dsl_sensor_name {
+	const char *name;
+	const char *description;
+} lsm6dsl_sensor_name[LSM6DSL_SENSORS_NUMB] = {
+	[LSM6DSL_ACCEL] = {
+		.name = "accel",
+		.description = "ST LSM6DSL Accelerometer Sensor",
+	},
+	[LSM6DSL_GYRO] = {
+		.name = "gyro",
+		.description = "ST LSM6DSL Gyroscope Sensor",
+	},
+	[LSM6DSL_SIGN_MOTION] = {
+		.name = "sign_m",
+		.description = "ST LSM6DSL Significant Motion Sensor",
+	},
+	[LSM6DSL_STEP_COUNTER] = {
+		.name = "step_c",
+		.description = "ST LSM6DSL Step Counter Sensor",
+	},
+	[LSM6DSL_STEP_DETECTOR] = {
+		.name = "step_d",
+		.description = "ST LSM6DSL Step Detector Sensor",
+	},
+	[LSM6DSL_TILT] = {
+		.name = "tilt",
+		.description = "ST LSM6DSL Tilt Sensor",
+	},
+};
+
+struct lsm6dsl_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+static const struct lsm6dsl_odr_table {
+	u8 addr[2];
+	u8 mask[2];
+	struct lsm6dsl_odr_reg odr_avl[6];
+} lsm6dsl_odr_table = {
+	.addr[LSM6DSL_ACCEL] = LSM6DSL_ACC_ODR_ADDR,
+	.mask[LSM6DSL_ACCEL] = LSM6DSL_ACC_ODR_MASK,
+	.addr[LSM6DSL_GYRO] = LSM6DSL_GYR_ODR_ADDR,
+	.mask[LSM6DSL_GYRO] = LSM6DSL_GYR_ODR_MASK,
+	.odr_avl[0] = { .hz = 13, .value = LSM6DSL_ODR_13HZ_VAL },
+	.odr_avl[1] = { .hz = 26, .value = LSM6DSL_ODR_26HZ_VAL },
+	.odr_avl[2] = { .hz = 52, .value = LSM6DSL_ODR_52HZ_VAL },
+	.odr_avl[3] = { .hz = 104, .value = LSM6DSL_ODR_104HZ_VAL },
+	.odr_avl[4] = { .hz = 208, .value = LSM6DSL_ODR_208HZ_VAL },
+	.odr_avl[5] = { .hz = 416, .value = LSM6DSL_ODR_416HZ_VAL },
+};
+
+struct lsm6dsl_fs_reg {
+	unsigned int gain;
+	u8 value;
+	int urv;
+};
+
+static struct lsm6dsl_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lsm6dsl_fs_reg fs_avl[LSM6DSL_FS_LIST_NUM];
+} lsm6dsl_fs_table[LSM6DSL_SENSORS_NUMB] = {
+	[LSM6DSL_ACCEL] = {
+		.addr = LSM6DSL_ACCEL_FS_ADDR,
+		.mask = LSM6DSL_ACCEL_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DSL_ACCEL_FS_2G_GAIN,
+			       .value = LSM6DSL_ACCEL_FS_2G_VAL,
+			       .urv = 2, },
+		.fs_avl[1] = { .gain = LSM6DSL_ACCEL_FS_4G_GAIN,
+			       .value = LSM6DSL_ACCEL_FS_4G_VAL,
+			       .urv = 4, },
+		.fs_avl[2] = { .gain = LSM6DSL_ACCEL_FS_8G_GAIN,
+			       .value = LSM6DSL_ACCEL_FS_8G_VAL,
+			       .urv = 8, },
+		.fs_avl[3] = { .gain = LSM6DSL_ACCEL_FS_16G_GAIN,
+			       .value = LSM6DSL_ACCEL_FS_16G_VAL,
+			       .urv = 16, },
+	},
+	[LSM6DSL_GYRO] = {
+		.addr = LSM6DSL_GYRO_FS_ADDR,
+		.mask = LSM6DSL_GYRO_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DSL_GYRO_FS_245_GAIN,
+			       .value = LSM6DSL_GYRO_FS_245_VAL,
+			       .urv = 245, },
+		.fs_avl[1] = { .gain = LSM6DSL_GYRO_FS_500_GAIN,
+			       .value = LSM6DSL_GYRO_FS_500_VAL,
+			       .urv = 500, },
+		.fs_avl[2] = { .gain = LSM6DSL_GYRO_FS_1000_GAIN,
+			       .value = LSM6DSL_GYRO_FS_1000_VAL,
+			        .urv = 1000, },
+		.fs_avl[3] = { .gain = LSM6DSL_GYRO_FS_2000_GAIN,
+			       .value = LSM6DSL_GYRO_FS_2000_VAL,
+			       .urv = 2000, },
+	}
+};
+
+static struct workqueue_struct *lsm6dsl_workqueue;
+
+static inline void lsm6dsl_flush_works(void)
+{
+	flush_workqueue(lsm6dsl_workqueue);
+}
+
+static inline int64_t lsm6dsl_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int lsm6dsl_write_data_with_mask(struct lsm6dsl_data *cdata,
+					u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+
+static int lsm6dsl_input_init(struct lsm6dsl_sensor_data *sdata, u16 bustype,
+			      const char *description)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = lsm6dsl_sensor_name[sdata->sindex].description;
+
+	sdata->input_dev->id.bustype = bustype;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	sdata->input_dev->name = description;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if ((sdata->sindex == LSM6DSL_ACCEL) ||
+	    (sdata->sindex == LSM6DSL_GYRO)) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+			sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lsm6dsl_input_cleanup(struct lsm6dsl_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lsm6dsl_report_3axes_event(struct lsm6dsl_sensor_data *sdata,
+				       s32 *xyz, int64_t timestamp)
+{
+	struct input_dev  *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static void lsm6dsl_report_single_event(struct lsm6dsl_sensor_data *sdata,
+					s32 data, int64_t timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static enum hrtimer_restart lsm6dsl_poll_function_read(struct hrtimer *timer)
+{
+	struct lsm6dsl_sensor_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct lsm6dsl_sensor_data,
+			     hr_timer);
+
+	sdata->timestamp = lsm6dsl_get_time_ns();
+	queue_work(lsm6dsl_workqueue, &sdata->input_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static int lsm6dsl_get_step_c_data(struct lsm6dsl_sensor_data *sdata, u16 *steps)
+{
+	u8 data[2];
+	int err = 0;
+	err = sdata->cdata->tf->read(sdata->cdata,
+				     LSM6DSL_STEP_COUNTER_OUT_L_ADDR,
+				     LSM6DSL_STEP_COUNTER_OUT_SIZE,
+				     data, true);
+	if (err < 0)
+		return err;
+
+	*steps = data[0] | (data[1] << 8);
+
+	return 0;
+}
+
+static int lsm6dsl_get_poll_data(struct lsm6dsl_sensor_data *sdata, u8 *data)
+{
+	int err = 0;
+	u8 reg_addr;
+
+	switch(sdata->sindex) {
+	case LSM6DSL_ACCEL:
+		reg_addr = LSM6DSL_ACCEL_OUT_X_L_ADDR;
+
+		break;
+	case LSM6DSL_GYRO:
+		reg_addr = LSM6DSL_GYRO_OUT_X_L_ADDR;
+
+		break;
+	default:
+		dev_err(sdata->cdata->dev, "invalid polling mode for sensor %s\n",
+			sdata->name);
+		return -1;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata, reg_addr, LSM6DSL_OUT_XYZ_SIZE,
+				     data, true);
+
+	return err;
+}
+
+static void poll_function_work(struct work_struct *input_work)
+{
+	struct lsm6dsl_sensor_data *sdata;
+	int xyz[3] = { 0 };
+	ktime_t delta;
+	u8 data[6];
+	int err;
+
+	sdata = container_of((struct work_struct *)input_work,
+			     struct lsm6dsl_sensor_data, input_work);
+
+	delta = ktime_set(0, lsm6dsl_get_time_ns() - sdata->timestamp);
+	hrtimer_start(&sdata->hr_timer, ktime_sub(sdata->ktime, delta),
+		      HRTIMER_MODE_REL);
+
+	if(sdata->sample_to_discard) {
+		sdata->sample_to_discard--;
+		return;
+	}
+
+	err = lsm6dsl_get_poll_data(sdata, data);
+	if (err < 0)
+		dev_err(sdata->cdata->dev, "get %s data failed %d\n",
+			sdata->name, err);
+	else {
+		xyz[0] = (s32)((s16)(data[0] | (data[1] << 8)));
+		xyz[1] = (s32)((s16)(data[2] | (data[3] << 8)));
+		xyz[2] = (s32)((s16)(data[4] | (data[5] << 8)));
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+
+		lsm6dsl_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+}
+
+static int lsm6dsl_set_drdy_irq(struct lsm6dsl_sensor_data *sdata, bool state)
+{
+	u8 reg_addr = 0, mask = 0, value;
+
+	if (state)
+		value = LSM6DSL_EN_BIT;
+	else
+		value = LSM6DSL_DIS_BIT;
+
+	switch (sdata->sindex) {
+	case LSM6DSL_ACCEL:
+	case LSM6DSL_GYRO:
+		return 0;
+
+	/* Route Step Detection/sig. Motion Interrupt on INT1 */
+	case LSM6DSL_SIGN_MOTION:
+	case LSM6DSL_STEP_DETECTOR:
+	case LSM6DSL_STEP_COUNTER:
+		if (sdata->cdata->sensors[LSM6DSL_STEP_DETECTOR].enabled ||
+		    sdata->cdata->sensors[LSM6DSL_SIGN_MOTION].enabled ||
+		    sdata->cdata->sensors[LSM6DSL_STEP_COUNTER].enabled)
+			return 0;
+
+		reg_addr = LSM6DSL_INT1_CTRL_ADDR;
+		mask = LSM6DSL_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case LSM6DSL_TILT:
+		reg_addr = LSM6DSL_MD1_ADDR;
+		mask = LSM6DSL_TILT_DRDY_IRQ_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lsm6dsl_write_data_with_mask(sdata->cdata, reg_addr, mask, value,
+					    true);
+}
+
+static int lsm6dsl_set_fs(struct lsm6dsl_sensor_data *sdata, u32 gain)
+{
+	int err, i;
+
+	for (i = 0; i < LSM6DSL_FS_LIST_NUM; i++) {
+		if (lsm6dsl_fs_table[sdata->sindex].fs_avl[i].gain == gain)
+			break;
+	}
+
+	if (i == LSM6DSL_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_fs_table[sdata->sindex].addr,
+				lsm6dsl_fs_table[sdata->sindex].mask,
+				lsm6dsl_fs_table[sdata->sindex].fs_avl[i].value,
+				true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = gain;
+
+	return 0;
+}
+
+static irqreturn_t lsm6dsl_save_timestamp(int irq, void *private)
+{
+	struct lsm6dsl_data *cdata = (struct lsm6dsl_data *)private;
+
+	cdata->timestamp = lsm6dsl_get_time_ns();
+	queue_work(lsm6dsl_workqueue, &cdata->input_work);
+
+	disable_irq_nosync(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int lsm6dsl_disable_sensors(struct lsm6dsl_sensor_data *sdata);
+
+static void lsm6dsl_irq_management(struct work_struct *input_work)
+{
+	struct lsm6dsl_data *cdata;
+	u8 src_value = 0x00, src2_value = 0x00;
+	struct lsm6dsl_sensor_data *sdata;
+	u16 steps_c;
+	int err;
+
+	cdata = container_of((struct work_struct *)input_work,
+			     struct lsm6dsl_data, input_work);
+
+	cdata->tf->read(cdata, LSM6DSL_SRC_FUNC_ADDR, 1, &src_value, true);
+	cdata->tf->read(cdata, LSM6DSL_SRC2_FUNC_ADDR, 1, &src2_value, true);
+
+	if (src_value & LSM6DSL_SRC_STEP_COUNTER_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSL_STEP_COUNTER];
+		sdata->timestamp = cdata->timestamp;
+		err = lsm6dsl_get_step_c_data(sdata, &steps_c);
+		if (err < 0) {
+			dev_err(cdata->dev,
+				"error while reading step counter data\n");
+			enable_irq(cdata->irq);
+
+			return;
+		}
+
+		lsm6dsl_report_single_event(&cdata->sensors[LSM6DSL_STEP_COUNTER],
+					    steps_c,
+					    cdata->sensors[LSM6DSL_STEP_COUNTER].timestamp);
+		cdata->steps_c = steps_c;
+	}
+
+	if (src_value & LSM6DSL_SRC_STEP_DETECTOR_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSL_STEP_DETECTOR];
+		sdata->timestamp = cdata->timestamp;
+		lsm6dsl_report_single_event(sdata, 1, sdata->timestamp);
+
+		if (cdata->sign_motion_event_ready) {
+			sdata = &cdata->sensors[LSM6DSL_SIGN_MOTION];
+			sdata->timestamp = cdata->timestamp;
+			lsm6dsl_report_single_event(sdata, 1, sdata->timestamp);
+			cdata->sign_motion_event_ready = false;
+			lsm6dsl_disable_sensors(sdata);
+		}
+	}
+
+	if (src_value & LSM6DSL_SRC_TILT_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSL_TILT];
+		sdata->timestamp = cdata->timestamp;
+		lsm6dsl_report_single_event(sdata, 1, sdata->timestamp);
+	}
+
+	enable_irq(cdata->irq);
+}
+
+static int lsm6dsl_allocate_workqueue(struct lsm6dsl_data *cdata)
+{
+	int err;
+
+	if (!lsm6dsl_workqueue)
+		lsm6dsl_workqueue = create_workqueue(cdata->name);
+
+	if (!lsm6dsl_workqueue)
+		return -EINVAL;
+
+	INIT_WORK(&cdata->input_work, lsm6dsl_irq_management);
+
+	err = request_threaded_irq(cdata->irq, lsm6dsl_save_timestamp, NULL,
+				   IRQF_TRIGGER_HIGH, cdata->name, cdata);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int lsm6dsl_set_extra_dependency(struct lsm6dsl_sensor_data *sdata,
+					bool enable)
+{
+	int err;
+
+	if (!(sdata->cdata->sensors[LSM6DSL_SIGN_MOTION].enabled |
+	    sdata->cdata->sensors[LSM6DSL_STEP_COUNTER].enabled |
+	    sdata->cdata->sensors[LSM6DSL_STEP_DETECTOR].enabled |
+	    sdata->cdata->sensors[LSM6DSL_TILT].enabled)) {
+		/* Enable/Disable Embedded Function only once */
+		if (enable) {
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+						LSM6DSL_FUNC_EN_ADDR,
+						LSM6DSL_FUNC_EN_MASK,
+						LSM6DSL_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+						LSM6DSL_FUNC_EN_ADDR,
+						LSM6DSL_FUNC_EN_MASK,
+						LSM6DSL_DIS_BIT, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	if (!sdata->cdata->sensors[LSM6DSL_ACCEL].enabled) {
+		if (enable) {
+			u8 idx = 1;
+			u16 acc_odr = sdata->cdata->sensors[LSM6DSL_ACCEL].c_odr;
+
+			if (acc_odr > 26) {
+				for (; idx < LSM6DSL_ODR_LIST_NUM; idx++)
+					if (lsm6dsl_odr_table.odr_avl[idx].hz == acc_odr)
+						break;
+			}
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[LSM6DSL_ACCEL],
+				lsm6dsl_odr_table.mask[LSM6DSL_ACCEL],
+				lsm6dsl_odr_table.odr_avl[idx].value, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[LSM6DSL_ACCEL],
+				lsm6dsl_odr_table.mask[LSM6DSL_ACCEL],
+				LSM6DSL_ODR_POWER_OFF_VAL, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lsm6dsl_enable_pedometer(struct lsm6dsl_sensor_data *sdata,
+				    bool enable)
+{
+	int err = 0;
+	u8 value = LSM6DSL_DIS_BIT;
+
+	if (sdata->cdata->sensors[LSM6DSL_STEP_COUNTER].enabled &&
+	    sdata->cdata->sensors[LSM6DSL_STEP_DETECTOR].enabled)
+		return 0;
+
+	if (enable)
+		value = LSM6DSL_EN_BIT;
+
+	err = lsm6dsl_write_data_with_mask(sdata->cdata,
+					   LSM6DSL_FIFO_PEDO_E_ADDR,
+					   LSM6DSL_FIFO_PEDO_E_MASK,
+					   value, true);
+	if (err < 0)
+		return err;
+
+	return lsm6dsl_write_data_with_mask(sdata->cdata,
+					    LSM6DSL_PEDOMETER_EN_ADDR,
+					    LSM6DSL_PEDOMETER_EN_MASK,
+					    value, true);
+}
+
+static int _lsm6dsl_enable_sensors(struct lsm6dsl_sensor_data *sdata)
+{
+	int err, i;
+
+	switch (sdata->sindex) {
+	case LSM6DSL_ACCEL:
+	case LSM6DSL_GYRO:
+		for (i = 0; i < LSM6DSL_ODR_LIST_NUM; i++) {
+			if (lsm6dsl_odr_table.odr_avl[i].hz == sdata->c_odr)
+				break;
+		}
+		if (i == LSM6DSL_ODR_LIST_NUM)
+			return -EINVAL;
+
+		if (sdata->sindex == LSM6DSL_ACCEL)
+			sdata->sample_to_discard = LSM6DSL_ACCEL_STD +
+						LSM6DSL_ACCEL_STD_FROM_PD;
+
+		sdata->cdata->sensors[LSM6DSL_GYRO].sample_to_discard =
+						LSM6DSL_GYRO_STD +
+						LSM6DSL_GYRO_STD_FROM_PD;
+
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[sdata->sindex],
+				lsm6dsl_odr_table.mask[sdata->sindex],
+				lsm6dsl_odr_table.odr_avl[i].value, true);
+		if (err < 0)
+			return err;
+
+		hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+		sdata->c_odr = lsm6dsl_odr_table.odr_avl[i].hz;
+
+		break;
+	case LSM6DSL_SIGN_MOTION:
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+						LSM6DSL_SIGN_MOTION_EN_ADDR,
+						LSM6DSL_SIGN_MOTION_EN_MASK,
+						LSM6DSL_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		if ((sdata->cdata->sensors[LSM6DSL_STEP_COUNTER].enabled) ||
+		    (sdata->cdata->sensors[LSM6DSL_STEP_DETECTOR].enabled)) {
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+						LSM6DSL_PEDOMETER_EN_ADDR,
+						LSM6DSL_PEDOMETER_EN_MASK,
+						LSM6DSL_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+						LSM6DSL_PEDOMETER_EN_ADDR,
+						LSM6DSL_PEDOMETER_EN_MASK,
+						LSM6DSL_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6dsl_enable_pedometer(sdata, true);
+			if (err < 0)
+				return err;
+		}
+
+		sdata->cdata->sign_motion_event_ready = true;
+
+		break;
+	case LSM6DSL_STEP_COUNTER:
+	case LSM6DSL_STEP_DETECTOR:
+		err = lsm6dsl_enable_pedometer(sdata, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DSL_TILT:
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+					LSM6DSL_TILT_EN_ADDR,
+					LSM6DSL_TILT_EN_MASK,
+					LSM6DSL_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6dsl_set_extra_dependency(sdata, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsl_set_drdy_irq(sdata, true);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm6dsl_enable_sensors(struct lsm6dsl_sensor_data *sdata)
+{
+	int err;
+
+	if (sdata->enabled)
+		return 0;
+
+	err = _lsm6dsl_enable_sensors(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = true;
+
+	return 0;
+}
+
+static int _lsm6dsl_disable_sensors(struct lsm6dsl_sensor_data *sdata)
+{
+	int err;
+
+	switch (sdata->sindex) {
+	case LSM6DSL_ACCEL:
+		if (sdata->cdata->sensors[LSM6DSL_SIGN_MOTION].enabled |
+		    sdata->cdata->sensors[LSM6DSL_STEP_COUNTER].enabled |
+		    sdata->cdata->sensors[LSM6DSL_STEP_DETECTOR].enabled |
+		    sdata->cdata->sensors[LSM6DSL_TILT].enabled) {
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[LSM6DSL_ACCEL],
+				lsm6dsl_odr_table.mask[LSM6DSL_ACCEL],
+				lsm6dsl_odr_table.odr_avl[0].value, true);
+		} else {
+			err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[LSM6DSL_ACCEL],
+				lsm6dsl_odr_table.mask[LSM6DSL_ACCEL],
+				LSM6DSL_ODR_POWER_OFF_VAL, true);
+		}
+		if (err < 0)
+			return err;
+
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+
+		break;
+	case LSM6DSL_GYRO:
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[LSM6DSL_GYRO],
+				lsm6dsl_odr_table.mask[LSM6DSL_GYRO],
+				LSM6DSL_ODR_POWER_OFF_VAL, true);
+		if (err < 0)
+			return err;
+
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+
+		break;
+	case LSM6DSL_SIGN_MOTION:
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				LSM6DSL_SIGN_MOTION_EN_ADDR,
+				LSM6DSL_SIGN_MOTION_EN_MASK,
+				LSM6DSL_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6dsl_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		sdata->cdata->sign_motion_event_ready = false;
+
+		break;
+	case LSM6DSL_STEP_COUNTER:
+	case LSM6DSL_STEP_DETECTOR:
+		err = lsm6dsl_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DSL_TILT:
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				LSM6DSL_TILT_EN_ADDR,
+				LSM6DSL_TILT_EN_MASK,
+				LSM6DSL_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6dsl_set_extra_dependency(sdata, false);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsl_set_drdy_irq(sdata, false);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm6dsl_disable_sensors(struct lsm6dsl_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	err = _lsm6dsl_disable_sensors(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = false;
+
+	return 0;
+}
+
+static int lsm6dsl_reset_steps(struct lsm6dsl_data *cdata)
+{
+	int err;
+	u8 reg_value = 0x00;
+
+	err = cdata->tf->read(cdata, LSM6DSL_STEP_COUNTER_RES_ADDR, 1,
+			      &reg_value, true);
+	if (err < 0)
+		return err;
+
+	/* Check if embedded functionalities are enabled */
+	if (reg_value & LSM6DSL_FUNC_EN_MASK)
+		reg_value = LSM6DSL_STEP_COUNTER_RES_FUNC_EN;
+	else
+		reg_value = LSM6DSL_DIS_BIT;
+
+	err = lsm6dsl_write_data_with_mask(cdata,
+				LSM6DSL_STEP_COUNTER_RES_ADDR,
+				LSM6DSL_STEP_COUNTER_RES_MASK,
+				LSM6DSL_STEP_COUNTER_RES_ALL_EN, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsl_write_data_with_mask(cdata,
+				LSM6DSL_STEP_COUNTER_RES_ADDR,
+				LSM6DSL_STEP_COUNTER_RES_MASK,
+				reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->reset_steps = true;
+
+	return 0;
+}
+
+static int lsm6dsl_init_sensors(struct lsm6dsl_data *cdata)
+{
+	int err, i;
+	u8 default_reg_value = 0;
+	struct lsm6dsl_sensor_data *sdata;
+
+	for (i = 0; i < LSM6DSL_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+
+		err = lsm6dsl_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+
+		if ((sdata->sindex == LSM6DSL_ACCEL) ||
+		    (sdata->sindex == LSM6DSL_GYRO)) {
+			err = lsm6dsl_set_fs(sdata, sdata->c_gain);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	hrtimer_init(&cdata->sensors[LSM6DSL_ACCEL].hr_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	hrtimer_init(&cdata->sensors[LSM6DSL_GYRO].hr_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	cdata->sensors[LSM6DSL_ACCEL].hr_timer.function =
+						&lsm6dsl_poll_function_read;
+	cdata->sensors[LSM6DSL_GYRO].hr_timer.function =
+						&lsm6dsl_poll_function_read;
+
+	cdata->steps_c = 0;
+	cdata->reset_steps = false;
+
+	/* Software reset */
+	err = lsm6dsl_write_data_with_mask(cdata, LSM6DSL_RESET_ADDR,
+					   LSM6DSL_RESET_MASK, LSM6DSL_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	/* Enable Latch Mode Bit */
+	err = lsm6dsl_write_data_with_mask(cdata, LSM6DSL_LIR_ADDR,
+					   LSM6DSL_LIR_MASK, LSM6DSL_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	/* Enable timestamp count */
+	err = lsm6dsl_write_data_with_mask(cdata, LSM6DSL_TIMER_EN_ADDR,
+					   LSM6DSL_TIMER_EN_MASK,
+					   LSM6DSL_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+	/* Output data not updated until have been read */
+	err = lsm6dsl_write_data_with_mask(cdata, LSM6DSL_BDU_ADDR,
+					   LSM6DSL_BDU_MASK, LSM6DSL_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	/* Enable Source Rounding function */
+	err = lsm6dsl_write_data_with_mask(cdata, LSM6DSL_ROUNDING_ADDR,
+					   LSM6DSL_ROUNDING_MASK,
+					   LSM6DSL_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/* Set all interrupt signals in logic or on INT1 pad */
+	err = lsm6dsl_write_data_with_mask(cdata,
+					   LSM6DSL_INT2_ON_INT1_ADDR,
+					   LSM6DSL_INT2_ON_INT1_MASK,
+					   LSM6DSL_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsl_reset_steps(sdata->cdata);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&cdata->bank_registers_lock);
+	err = lsm6dsl_write_data_with_mask(sdata->cdata,
+					   LSM6DSL_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSL_FUNC_CFG_REG_MASK,
+					   LSM6DSL_EN_BIT, false);
+	if (err < 0)
+		goto lsm6dsl_init_sensor_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+				      LSM6DSL_STEP_COUNTER_DURATION_ADDR,
+				      1, &default_reg_value, false);
+	if (err < 0)
+		goto lsm6dsl_init_sensor_mutex_unlock;
+
+	err = lsm6dsl_write_data_with_mask(sdata->cdata,
+					   LSM6DSL_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSL_FUNC_CFG_REG_MASK,
+					   LSM6DSL_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6dsl_init_sensor_mutex_unlock;
+
+	mutex_unlock(&cdata->bank_registers_lock);
+	cdata->sensors[LSM6DSL_ACCEL].ktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LSM6DSL_ACCEL].poll_interval));
+	cdata->sensors[LSM6DSL_GYRO].ktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LSM6DSL_GYRO].poll_interval));
+	INIT_WORK(&cdata->sensors[LSM6DSL_ACCEL].input_work, poll_function_work);
+	INIT_WORK(&cdata->sensors[LSM6DSL_GYRO].input_work, poll_function_work);
+
+	return 0;
+
+lsm6dsl_init_sensor_mutex_unlock:
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lsm6dsl_set_odr(struct lsm6dsl_sensor_data *sdata, u32 odr)
+{
+	int err = 0, i;
+
+	for (i = 0; i < LSM6DSL_ODR_LIST_NUM; i++) {
+		if (lsm6dsl_odr_table.odr_avl[i].hz >= odr)
+			break;
+	}
+	if (i == LSM6DSL_ODR_LIST_NUM)
+		return -EINVAL;
+
+	if (sdata->c_odr == lsm6dsl_odr_table.odr_avl[i].hz)
+		return 0;
+
+	if (sdata->enabled) {
+		disable_irq(sdata->cdata->irq);
+		lsm6dsl_flush_works();
+
+		if (sdata->sindex == LSM6DSL_ACCEL)
+			sdata->cdata->sensors[LSM6DSL_ACCEL].sample_to_discard +=
+							LSM6DSL_ACCEL_STD;
+
+		if (sdata->cdata->sensors[LSM6DSL_GYRO].enabled)
+			sdata->cdata->sensors[LSM6DSL_GYRO].sample_to_discard +=
+							LSM6DSL_GYRO_STD;
+
+		err = lsm6dsl_write_data_with_mask(sdata->cdata,
+				lsm6dsl_odr_table.addr[sdata->sindex],
+				lsm6dsl_odr_table.mask[sdata->sindex],
+				lsm6dsl_odr_table.odr_avl[i].value, true);
+		if (err < 0) {
+			enable_irq(sdata->cdata->irq);
+
+			return err;
+		}
+
+		sdata->c_odr = lsm6dsl_odr_table.odr_avl[i].hz;
+		enable_irq(sdata->cdata->irq);
+	} else {
+		sdata->c_odr = lsm6dsl_odr_table.odr_avl[i].hz;
+	}
+
+	return err;
+}
+
+static ssize_t get_enable(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t set_enable(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int err;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = lsm6dsl_enable_sensors(sdata);
+	else
+		err = lsm6dsl_disable_sensors(sdata);
+
+	return count;
+}
+
+static ssize_t get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->poll_interval);
+}
+
+static ssize_t set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	/*
+	 * Polling interval is in msec, then we have to convert it in Hz to
+	 * configure ODR through lsm6dsl_set_odr
+	 */
+	err = lsm6dsl_set_odr(sdata, 1000 / polling_rate);
+	if (!(err < 0)) {
+		sdata->poll_interval = 1000 / sdata->c_odr;
+		sdata->ktime = ktime_set(0, MS_TO_NS(sdata->poll_interval));
+	}
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+static ssize_t get_sampling_freq(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->c_odr);
+}
+
+static ssize_t set_sampling_freq(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int err;
+	unsigned int odr;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	err = lsm6dsl_set_odr(sdata, odr);
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+static ssize_t reset_steps(struct device *dev,
+			   struct device_attribute *attr, const char *buf,
+			   size_t count)
+{
+	int err;
+	unsigned int reset;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &reset);
+	if (err < 0)
+		return err;
+
+	lsm6dsl_reset_steps(sdata->cdata);
+
+	return count;
+}
+
+static ssize_t set_max_delivery_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	u8 duration;
+	int err, err2;
+	unsigned int max_delivery_rate;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtouint(buf, 10, &max_delivery_rate);
+	if (err < 0)
+		return -EINVAL;
+
+	if (max_delivery_rate == sdata->c_odr)
+		return size;
+
+	duration = max_delivery_rate / LSM6DSL_MIN_DURATION_MS;
+
+	mutex_lock(&sdata->cdata->bank_registers_lock);
+
+	err = lsm6dsl_write_data_with_mask(sdata->cdata,
+					   LSM6DSL_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSL_FUNC_CFG_REG_MASK,
+					   LSM6DSL_EN_BIT, false);
+	if (err < 0)
+		goto lsm6dsl_set_max_delivery_rate_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+				      LSM6DSL_STEP_COUNTER_DURATION_ADDR,
+				      1, &duration, false);
+	if (err < 0)
+		goto lsm6dsl_set_max_delivery_rate_restore_bank;
+
+	err = lsm6dsl_write_data_with_mask(sdata->cdata,
+					   LSM6DSL_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSL_FUNC_CFG_REG_MASK,
+					   LSM6DSL_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6dsl_set_max_delivery_rate_restore_bank;
+
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+
+	sdata->c_odr = max_delivery_rate;
+
+	return size;
+
+lsm6dsl_set_max_delivery_rate_restore_bank:
+	do {
+		err2 = lsm6dsl_write_data_with_mask(sdata->cdata,
+					LSM6DSL_FUNC_CFG_ACCESS_ADDR,
+					LSM6DSL_FUNC_CFG_REG_MASK,
+					LSM6DSL_DIS_BIT, false);
+
+		msleep(500);
+	} while (err2 < 0);
+
+lsm6dsl_set_max_delivery_rate_mutex_unlock:
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+	return err;
+}
+
+static ssize_t get_max_delivery_rate(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", sdata->c_odr);
+}
+
+static ssize_t get_sampling_frequency_avail(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LSM6DSL_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 lsm6dsl_odr_table.odr_avl[i].hz);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_scale_avail(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DSL_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lsm6dsl_fs_table[sdata->sindex].fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_cur_scale(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DSL_FS_LIST_NUM; i++)
+		if (sdata->c_gain ==
+				lsm6dsl_fs_table[sdata->sindex].fs_avl[i].gain)
+			break;
+
+	return sprintf(buf, "%d\n",
+		       lsm6dsl_fs_table[sdata->sindex].fs_avl[i].urv);
+}
+
+static ssize_t set_cur_scale(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int i, urv, err;
+	struct lsm6dsl_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < LSM6DSL_FS_LIST_NUM; i++)
+		if (urv == lsm6dsl_fs_table[sdata->sindex].fs_avl[i].urv)
+			break;
+
+	if (i == LSM6DSL_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6dsl_set_fs(sdata,
+			     lsm6dsl_fs_table[sdata->sindex].fs_avl[i].gain);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO, get_enable, set_enable);
+static DEVICE_ATTR(sampling_freq, S_IWUSR | S_IRUGO, get_sampling_freq,
+		   set_sampling_freq);
+static DEVICE_ATTR(polling_rate, S_IWUSR | S_IRUGO, get_polling_rate,
+		   set_polling_rate);
+static DEVICE_ATTR(reset_steps, S_IWUSR, NULL, reset_steps);
+static DEVICE_ATTR(max_delivery_rate, S_IWUSR | S_IRUGO, get_max_delivery_rate,
+		   set_max_delivery_rate);
+static DEVICE_ATTR(sampling_freq_avail, S_IRUGO, get_sampling_frequency_avail,
+		   NULL);
+static DEVICE_ATTR(scale_avail, S_IRUGO, get_scale_avail, NULL);
+static DEVICE_ATTR(scale, S_IWUSR | S_IRUGO, get_cur_scale, set_cur_scale);
+
+static struct attribute *lsm6dsl_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsl_gyro_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsl_sign_m_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsl_step_c_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_reset_steps.attr,
+	&dev_attr_max_delivery_rate.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsl_step_d_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsl_tilt_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lsm6dsl_attribute_groups[] = {
+	[LSM6DSL_ACCEL] = {
+		.attrs = lsm6dsl_accel_attribute,
+		.name = "accel",
+	},
+	[LSM6DSL_GYRO] = {
+		.attrs = lsm6dsl_gyro_attribute,
+		.name = "gyro",
+	},
+	[LSM6DSL_SIGN_MOTION] = {
+		.attrs = lsm6dsl_sign_m_attribute,
+		.name = "sign_m",
+	},
+	[LSM6DSL_STEP_COUNTER] = {
+		.attrs = lsm6dsl_step_c_attribute,
+		.name = "step_c",
+	},
+	[LSM6DSL_STEP_DETECTOR] = {
+		.attrs = lsm6dsl_step_d_attribute,
+		.name = "step_d",
+	},
+	[LSM6DSL_TILT] = {
+		.attrs = lsm6dsl_tilt_attribute,
+		.name = "tilt",
+	},
+};
+
+#ifdef CONFIG_OF
+static u32 lsm6dsl_parse_dt(struct lsm6dsl_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+				  (val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	return 0;
+}
+#endif
+
+int lsm6dsl_common_probe(struct lsm6dsl_data *cdata, int irq, u16 bustype)
+{
+	int32_t err, i;
+	u8 wai = 0x00;
+	struct lsm6dsl_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->tb.buf_lock);
+
+	/* Read Chip ID register */
+	err = cdata->tf->read(cdata, LSM6DSL_WHO_AM_I, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		return err;
+	}
+	if (wai != LSM6DSL_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+
+	if (irq > 0) {
+#ifdef CONFIG_OF
+		err = lsm6dsl_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lsm6dsl_platform_data *)
+					cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) ||
+			    (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else {
+			cdata->drdy_int_pin = 1;
+		}
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+			 cdata->drdy_int_pin);
+	}
+
+	for (i = 0; i < LSM6DSL_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lsm6dsl_sensor_name[i].name;
+		if ((i == LSM6DSL_ACCEL) || (i == LSM6DSL_GYRO)) {
+			sdata->c_odr = lsm6dsl_odr_table.odr_avl[0].hz;
+			sdata->c_gain = lsm6dsl_fs_table[i].fs_avl[0].gain;
+			sdata->poll_interval = 1000 / sdata->c_odr;
+		}
+		if (i == LSM6DSL_STEP_COUNTER) {
+			sdata->c_odr = LSM6DSL_MIN_DURATION_MS;
+		}
+
+		if (lsm6dsl_input_init(sdata, bustype,
+				       lsm6dsl_sensor_name[i].description)) {
+			dev_err(cdata->dev,
+				"failed to register input device %s",
+				sdata->name);
+			sdata->input_dev = NULL;
+			continue;
+		}
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+				       &lsm6dsl_attribute_groups[i])) {
+			dev_err(cdata->dev,
+				"failed to create sysfs group for sensor %s",
+				sdata->name);
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+	}
+
+	err = lsm6dsl_init_sensors(cdata);
+	if (err < 0)
+		return err;
+	if (irq > 0)
+		cdata->irq = irq;
+
+	if (irq > 0) {
+		err = lsm6dsl_allocate_workqueue(cdata);
+		if (err < 0)
+			return err;
+	}
+
+	dev_info(cdata->dev, "%s: probed\n", LSM6DSL_DEV_NAME);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsl_common_probe);
+
+void lsm6dsl_common_remove(struct lsm6dsl_data *cdata, int irq)
+{
+	u8 i;
+
+	for (i = 0; i < LSM6DSL_SENSORS_NUMB; i++) {
+		lsm6dsl_disable_sensors(&cdata->sensors[i]);
+		lsm6dsl_input_cleanup(&cdata->sensors[i]);
+	}
+
+	if(lsm6dsl_workqueue) {
+		flush_workqueue(lsm6dsl_workqueue);
+		destroy_workqueue(lsm6dsl_workqueue);
+		lsm6dsl_workqueue = NULL;
+	}
+}
+EXPORT_SYMBOL(lsm6dsl_common_remove);
+
+#ifdef CONFIG_PM
+static int lsm6dsl_resume_sensors(struct lsm6dsl_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lsm6dsl_enable_sensors(sdata);
+}
+
+static int lsm6dsl_suspend_sensors(struct lsm6dsl_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lsm6dsl_disable_sensors(sdata);
+}
+
+int lsm6dsl_common_suspend(struct lsm6dsl_data *cdata)
+{
+	lsm6dsl_suspend_sensors(&cdata->sensors[LSM6DSL_ACCEL]);
+	lsm6dsl_suspend_sensors(&cdata->sensors[LSM6DSL_GYRO]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsl_common_suspend);
+
+int lsm6dsl_common_resume(struct lsm6dsl_data *cdata)
+{
+	lsm6dsl_resume_sensors(&cdata->sensors[LSM6DSL_ACCEL]);
+	lsm6dsl_resume_sensors(&cdata->sensors[LSM6DSL_GYRO]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsl_common_resume);
+
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsl driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.h b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.h
--- a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_core.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,156 @@
+/*
+ * STMicroelectronics lsm6dsl driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <giuseppe.barba@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#ifndef DRIVERS_INPUT_MISC_LSM6DSL_CORE_H_
+#define DRIVERS_INPUT_MISC_LSM6DSL_CORE_H_
+
+#define LSM6DSL_DEV_NAME		"lsm6dsl"
+
+#define HZ_TO_PERIOD_NSEC(hz)		(1000 * 1000 * 1000 / ((u32)(hz)))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+enum {
+	LSM6DSL_ACCEL = 0,
+	LSM6DSL_GYRO,
+	LSM6DSL_SIGN_MOTION,
+	LSM6DSL_STEP_COUNTER,
+	LSM6DSL_STEP_DETECTOR,
+	LSM6DSL_TILT,
+	LSM6DSL_SENSORS_NUMB,
+};
+
+#define DEF_ZERO			0x00
+
+/* Output data rate registers */
+#define LSM6DSL_ACC_ODR_ADDR		CTRL1_ADDR
+#define LSM6DSL_ACC_ODR_MASK		0xf0
+#define LSM6DSL_GYR_ODR_ADDR		CTRL2_ADDR
+#define LSM6DSL_GYR_ODR_MASK		0xf0
+
+#define LSM6DSL_ACC_FS_ADDR		CTRL1_ADDR
+#define LSM6DSL_GYR_FS_ADDR		CTRL2_ADDR
+
+#define LSM6DSL_IF_INC_MASK		0x04
+
+#define LSM6DSL_HPERF_GYR_ADDR		CTRL7_ADDR
+#define LSM6DSL_HPERF_GYR_MASK		0x80
+
+#define LSM6DSL_HPERF_ACC_ADDR		CTRL6_ADDR
+#define LSM6DSL_HPERF_ACC_MASK		0x10
+#define LSM6DSL_HPERF_ACC_ENABLE	0x00
+
+#define CTRL1_ADDR			0x10
+#define CTRL2_ADDR			0x11
+#define CTRL3_ADDR			0x12
+#define CTRL6_ADDR			0x15
+#define CTRL7_ADDR			0x16
+
+/* Sensitivity Acc */
+#define SENSITIVITY_ACC_2G		61	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		122	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		244	/** ug/LSB */
+#define SENSITIVITY_ACC_16G		488	/** ug/LSB */
+/* Sensitivity Gyr */
+#define SENSITIVITY_GYR_125		437	/** 10udps/LSB */
+#define SENSITIVITY_GYR_245		875	/** 10udps/LSB */
+#define SENSITIVITY_GYR_500		1750	/** 10udps/LSB */
+#define SENSITIVITY_GYR_1000		3500	/** 10udps/LSB */
+#define SENSITIVITY_GYR_2000		7000	/** 10udps/LSB */
+
+#define FUZZ				0
+#define FLAT				0
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define LSM6DSL_RX_MAX_LENGTH		500
+#define LSM6DSL_TX_MAX_LENGTH		500
+
+#define to_dev(obj) 			container_of(obj, struct device, kobj)
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lsm6dsl_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM6DSL_RX_MAX_LENGTH];
+	u8 tx_buf[LSM6DSL_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6dsl_data;
+
+struct lsm6dsl_transfer_function {
+	int (*write)(struct lsm6dsl_data *cdata, u8 reg_addr, int len, u8 *data,
+		     bool b_lock);
+	int (*read)(struct lsm6dsl_data *cdata, u8 reg_addr, int len, u8 *data,
+		    bool b_lock);
+};
+
+struct lsm6dsl_sensor_data {
+	struct lsm6dsl_data *cdata;
+	const char* name;
+	int64_t timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+	struct input_dev *input_dev;
+	unsigned int poll_interval;
+	struct hrtimer hr_timer;
+	struct work_struct input_work;
+	ktime_t ktime;
+};
+
+struct lsm6dsl_data {
+	const char *name;
+	bool reset_steps;
+	bool sign_motion_event_ready;
+	u16 steps_c;
+	u8 drdy_int_pin;
+	int irq;
+	int64_t timestamp;
+	struct work_struct input_work;
+	struct device *dev;
+	struct lsm6dsl_sensor_data sensors[LSM6DSL_SENSORS_NUMB];
+	struct mutex bank_registers_lock;
+	const struct lsm6dsl_transfer_function *tf;
+	struct lsm6dsl_transfer_buffer tb;
+};
+
+int lsm6dsl_common_probe(struct lsm6dsl_data *cdata, int irq, u16 bustype);
+void lsm6dsl_common_remove(struct lsm6dsl_data *cdata, int irq);
+
+#ifdef CONFIG_PM
+int lsm6dsl_common_suspend(struct lsm6dsl_data *cdata);
+int lsm6dsl_common_resume(struct lsm6dsl_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* DRIVERS_INPUT_MISC_LSM6DSL_CORE_H_ */
diff -uNr a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_i2c.c b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_i2c.c
--- a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,175 @@
+/*
+ * STMicroelectronics lsm6dsl i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lsm6dsl_core.h"
+
+static int lsm6dsl_i2c_read(struct lsm6dsl_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int lsm6dsl_i2c_write(struct lsm6dsl_data *cdata, u8 reg_addr, int len,
+			     u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+
+static const struct lsm6dsl_transfer_function lsm6dsl_tf_i2c = {
+	.write = lsm6dsl_i2c_write,
+	.read = lsm6dsl_i2c_read,
+};
+
+static int lsm6dsl_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6dsl_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &lsm6dsl_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm6dsl_common_probe(cdata, client->irq, BUS_I2C);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lsm6dsl_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6dsl_data *cdata = i2c_get_clientdata(client);
+
+	lsm6dsl_common_remove(cdata, client->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DSL_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6dsl_suspend(struct device *dev)
+{
+	struct lsm6dsl_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6dsl_common_suspend(cdata);
+}
+
+static int lsm6dsl_resume(struct device *dev)
+{
+	struct lsm6dsl_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6dsl_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6dsl_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6dsl_suspend, lsm6dsl_resume)
+};
+
+#define LSM6DSL_PM_OPS		(&lsm6dsl_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DSL_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lsm6dsl_ids[] = {
+	{ LSM6DSL_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lsm6dsl_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dsl_id_table[] = {
+	{ .compatible = "st,lsm6dsl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6dsl_id_table);
+#endif
+
+static struct i2c_driver lsm6dsl_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DSL_DEV_NAME,
+		.pm = LSM6DSL_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6dsl_id_table,
+#endif
+	},
+	.probe    = lsm6dsl_i2c_probe,
+	.remove   = lsm6dsl_i2c_remove,
+	.id_table = lsm6dsl_ids,
+};
+
+module_i2c_driver(lsm6dsl_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsl i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_spi.c b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_spi.c
--- a/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsl/lsm6dsl_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,204 @@
+/*
+ * STMicroelectronics lsm6dsl spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lsm6dsl_core.h"
+
+#define SENSORS_SPI_READ 0x80
+
+static int lsm6dsl_spi_read(struct lsm6dsl_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lsm6dsl_spi_write(struct lsm6dsl_data *cdata, u8 reg_addr, int len,
+			     u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM6DSL_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static const struct lsm6dsl_transfer_function lsm6dsl_tf_spi = {
+	.write = lsm6dsl_spi_write,
+	.read = lsm6dsl_spi_read,
+};
+
+static int lsm6dsl_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6dsl_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &lsm6dsl_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm6dsl_common_probe(cdata, spi->irq, BUS_SPI);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lsm6dsl_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lsm6dsl_data *cdata = spi_get_drvdata(spi);
+
+	lsm6dsl_common_remove(cdata, spi->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DSL_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6dsl_suspend(struct device *dev)
+{
+	struct lsm6dsl_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6dsl_common_suspend(cdata);
+}
+
+static int lsm6dsl_resume(struct device *dev)
+{
+	struct lsm6dsl_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6dsl_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6dsl_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6dsl_suspend, lsm6dsl_resume)
+};
+
+#define LSM6DSL_PM_OPS		(&lsm6dsl_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DSL_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct spi_device_id lsm6dsl_ids[] = {
+	{ LSM6DSL_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm6dsl_ids);
+
+static const struct of_device_id lsm6dsl_id_table[] = {
+	{ .compatible = "st,lsm6dsl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6dsl_id_table);
+#endif
+
+static struct spi_driver lsm6dsl_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DSL_DEV_NAME,
+		.pm = LSM6DSL_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6dsl_id_table,
+#endif
+	},
+	.probe    = lsm6dsl_spi_probe,
+	.remove   = lsm6dsl_spi_remove,
+	.id_table = lsm6dsl_ids,
+};
+
+module_spi_driver(lsm6dsl_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsl spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dsl/Makefile b/drivers/input/misc/st/imu/lsm6dsl/Makefile
--- a/drivers/input/misc/st/imu/lsm6dsl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsl/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM imu lsm6dsl driver
+#
+lsm6dsl-core-y += lsm6dsl_core.o
+obj-$(CONFIG_INPUT_LSM6DSL) += lsm6dsl-core.o
+obj-$(CONFIG_INPUT_LSM6DSL_I2C) += lsm6dsl_i2c.o
+obj-$(CONFIG_INPUT_LSM6DSL_SPI) += lsm6dsl_spi.o
diff -uNr a/drivers/input/misc/st/imu/lsm6dsm/Kconfig b/drivers/input/misc/st/imu/lsm6dsm/Kconfig
--- a/drivers/input/misc/st/imu/lsm6dsm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsm/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LSM6DSM
+	tristate "STMicroelectronics LSM6DSM sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM6DSM_I2C if (I2C)
+	select INPUT_LSM6DSM_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM6DSM sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm6dsm.
+
+config INPUT_LSM6DSM_I2C
+	tristate
+	depends on INPUT_LSM6DSM
+	depends on I2C
+
+config INPUT_LSM6DSM_SPI
+	tristate
+	depends on INPUT_LSM6DSM
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.c b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.c
--- a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1652 @@
+/*
+ * STMicroelectronics lsm6dsm driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm6dsm_core.h"
+
+/* COMMON DEFINE FOR ACCEL-GYRO SENSORS */
+#define LSM6DSM_EN_BIT				0x01
+#define LSM6DSM_DIS_BIT				0x00
+
+#define LSM6DSM_WHO_AM_I			0x0f
+#define LSM6DSM_WHO_AM_I_DEF			0x6a
+
+#define LSM6DSM_INT1_CTRL_ADDR			0x0d
+#define LSM6DSM_MD1_ADDR			0x5e
+
+#define LSM6DSM_ODR_LIST_NUM			6
+#define LSM6DSM_ODR_POWER_OFF_VAL		0x00
+#define LSM6DSM_ODR_13HZ_VAL			0x01
+#define LSM6DSM_ODR_26HZ_VAL			0x02
+#define LSM6DSM_ODR_52HZ_VAL			0x03
+#define LSM6DSM_ODR_104HZ_VAL			0x04
+#define LSM6DSM_ODR_208HZ_VAL			0x05
+#define LSM6DSM_ODR_416HZ_VAL			0x06
+#define LSM6DSM_FS_LIST_NUM			4
+
+#define LSM6DSM_BDU_ADDR			0x12
+#define LSM6DSM_BDU_MASK			0x40
+
+#define LSM6DSM_FUNC_EN_ADDR			0x19
+#define LSM6DSM_FUNC_EN_MASK			0x04
+#define LSM6DSM_FUNC_CFG_ACCESS_ADDR		0x01
+#define LSM6DSM_FUNC_CFG_REG_MASK		0x80
+
+#define LSM6DSM_LIR_ADDR			0x58
+#define LSM6DSM_LIR_MASK			0x01
+
+#define LSM6DSM_TIMER_EN_ADDR			0x19
+#define LSM6DSM_TIMER_EN_MASK			0x20
+
+#define LSM6DSM_PEDOMETER_EN_ADDR		0x19
+#define LSM6DSM_PEDOMETER_EN_MASK		0x10
+
+#define LSM6DSM_INT2_ON_INT1_ADDR		0x13
+#define LSM6DSM_INT2_ON_INT1_MASK		0x20
+
+#define LSM6DSM_MIN_DURATION_MS			1638
+#define LSM6DSM_ROUNDING_ADDR			0x16
+#define LSM6DSM_ROUNDING_MASK			0x04
+
+#define LSM6DSM_FIFO_PEDO_E_ADDR		0x07
+#define LSM6DSM_FIFO_PEDO_E_MASK		0x80
+
+/* CUSTOM VALUES FOR ACCEL SENSOR */
+#define LSM6DSM_ACCEL_ODR_ADDR			0x10
+#define LSM6DSM_ACCEL_ODR_MASK			0xf0
+#define LSM6DSM_ACCEL_FS_ADDR			0x10
+#define LSM6DSM_ACCEL_FS_MASK			0x0c
+#define LSM6DSM_ACCEL_FS_2G_VAL			0x00
+#define LSM6DSM_ACCEL_FS_4G_VAL			0x02
+#define LSM6DSM_ACCEL_FS_8G_VAL			0x03
+#define LSM6DSM_ACCEL_FS_16G_VAL		0x01
+#define LSM6DSM_ACCEL_FS_2G_GAIN		61
+#define LSM6DSM_ACCEL_FS_4G_GAIN		122
+#define LSM6DSM_ACCEL_FS_8G_GAIN		244
+#define LSM6DSM_ACCEL_FS_16G_GAIN		488
+#define LSM6DSM_ACCEL_OUT_X_L_ADDR		0x28
+#define LSM6DSM_ACCEL_OUT_Y_L_ADDR		0x2a
+#define LSM6DSM_ACCEL_OUT_Z_L_ADDR		0x2c
+#define LSM6DSM_ACCEL_AXIS_EN_ADDR		0x18
+#define LSM6DSM_ACCEL_DRDY_IRQ_MASK		0x01
+#define LSM6DSM_ACCEL_STD			1
+#define LSM6DSM_ACCEL_STD_FROM_PD		2
+
+/* CUSTOM VALUES FOR GYRO SENSOR */
+#define LSM6DSM_GYRO_ODR_ADDR			0x11
+#define LSM6DSM_GYRO_ODR_MASK			0xf0
+#define LSM6DSM_GYRO_FS_ADDR			0x11
+#define LSM6DSM_GYRO_FS_MASK			0x0c
+#define LSM6DSM_GYRO_FS_245_VAL			0x00
+#define LSM6DSM_GYRO_FS_500_VAL			0x01
+#define LSM6DSM_GYRO_FS_1000_VAL		0x02
+#define LSM6DSM_GYRO_FS_2000_VAL		0x03
+#define LSM6DSM_GYRO_FS_245_GAIN		8750
+#define LSM6DSM_GYRO_FS_500_GAIN		17500
+#define LSM6DSM_GYRO_FS_1000_GAIN		35000
+#define LSM6DSM_GYRO_FS_2000_GAIN		70000
+#define LSM6DSM_GYRO_OUT_X_L_ADDR		0x22
+#define LSM6DSM_GYRO_OUT_Y_L_ADDR		0x24
+#define LSM6DSM_GYRO_OUT_Z_L_ADDR		0x26
+#define LSM6DSM_GYRO_AXIS_EN_ADDR		0x19
+#define LSM6DSM_GYRO_DRDY_IRQ_MASK		0x02
+#define LSM6DSM_GYRO_STD			6
+#define LSM6DSM_GYRO_STD_FROM_PD		2
+
+#define LSM6DSM_OUT_XYZ_SIZE			6
+
+/* CUSTOM VALUES FOR SIGNIFICANT MOTION SENSOR */
+#define LSM6DSM_SIGN_MOTION_EN_ADDR		0x19
+#define LSM6DSM_SIGN_MOTION_EN_MASK		0x01
+#define LSM6DSM_SIGN_MOTION_DRDY_IRQ_MASK	0x40
+
+/* CUSTOM VALUES FOR STEP DETECTOR SENSOR */
+#define LSM6DSM_STEP_DETECTOR_DRDY_IRQ_MASK	0x80
+
+/* CUSTOM VALUES FOR STEP COUNTER SENSOR */
+#define LSM6DSM_STEP_COUNTER_OUT_L_ADDR		0x4b
+#define LSM6DSM_STEP_COUNTER_OUT_SIZE		2
+#define LSM6DSM_STEP_COUNTER_RES_ADDR		0x19
+#define LSM6DSM_STEP_COUNTER_RES_MASK		0x06
+#define LSM6DSM_STEP_COUNTER_RES_ALL_EN		0x03
+#define LSM6DSM_STEP_COUNTER_RES_FUNC_EN	0x02
+#define LSM6DSM_STEP_COUNTER_DURATION_ADDR	0x15
+
+/* CUSTOM VALUES FOR TILT SENSOR */
+ #define LSM6DSM_TILT_EN_ADDR			0x19
+#define LSM6DSM_TILT_EN_MASK			0x08
+#define LSM6DSM_TILT_DRDY_IRQ_MASK		0x02
+
+#define LSM6DSM_WRIST_TILT_EN_ADDR		0x19
+#define LSM6DSM_WRIST_TILT_EN_MASK		0x80
+#define LSM6DSM_WRIST_TILT_DRDY			0x0b
+#define LSM6DSM_WRIST_TILT_DRDY_MASK		0x01
+
+#define LSM6DSM_SRC_FUNC_ADDR			0x53
+#define LSM6DSM_SRC2_FUNC_ADDR			0x54
+#define LSM6DSM_SRC_SIGN_MOTION_DATA_AVL	0x40
+#define LSM6DSM_SRC_TILT_DATA_AVL		0x20
+#define LSM6DSM_SRC_STEP_DETECTOR_DATA_AVL	0x10
+#define LSM6DSM_SRC_STEP_COUNTER_DATA_AVL	0x80
+#define LSM6DSM_SRC2_WRIST_TILT_DATA_AVL	0x01
+
+/* Sensor Software Reset Bit */
+#define LSM6DSM_RESET_ADDR			0x12
+#define LSM6DSM_RESET_MASK			0x01
+
+static const struct lsm6dsm_sensor_name {
+	const char *name;
+	const char *description;
+} lsm6dsm_sensor_name[LSM6DSM_SENSORS_NUMB] = {
+	[LSM6DSM_ACCEL] = {
+		.name = "accel",
+		.description = "ST LSM6DSM Accelerometer Sensor",
+	},
+	[LSM6DSM_GYRO] = {
+		.name = "gyro",
+		.description = "ST LSM6DSM Gyroscope Sensor",
+	},
+	[LSM6DSM_SIGN_MOTION] = {
+		.name = "sign_m",
+		.description = "ST LSM6DSM Significant Motion Sensor",
+	},
+	[LSM6DSM_STEP_COUNTER] = {
+		.name = "step_c",
+		.description = "ST LSM6DSM Step Counter Sensor",
+	},
+	[LSM6DSM_STEP_DETECTOR] = {
+		.name = "step_d",
+		.description = "ST LSM6DSM Step Detector Sensor",
+	},
+	[LSM6DSM_TILT] = {
+		.name = "tilt",
+		.description = "ST LSM6DSM Tilt Sensor",
+	},
+	[LSM6DSM_WRIST_TILT] = {
+		.name = "wrist_t",
+		.description = "ST LSM6DSM Wrist Tilt Sensor",
+	},
+};
+
+struct lsm6dsm_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+static const struct lsm6dsm_odr_table {
+	u8 addr[2];
+	u8 mask[2];
+	struct lsm6dsm_odr_reg odr_avl[6];
+} lsm6dsm_odr_table = {
+	.addr[LSM6DSM_ACCEL] = LSM6DSM_ACC_ODR_ADDR,
+	.mask[LSM6DSM_ACCEL] = LSM6DSM_ACC_ODR_MASK,
+	.addr[LSM6DSM_GYRO] = LSM6DSM_GYR_ODR_ADDR,
+	.mask[LSM6DSM_GYRO] = LSM6DSM_GYR_ODR_MASK,
+	.odr_avl[0] = { .hz = 13, .value = LSM6DSM_ODR_13HZ_VAL },
+	.odr_avl[1] = { .hz = 26, .value = LSM6DSM_ODR_26HZ_VAL },
+	.odr_avl[2] = { .hz = 52, .value = LSM6DSM_ODR_52HZ_VAL },
+	.odr_avl[3] = { .hz = 104, .value = LSM6DSM_ODR_104HZ_VAL },
+	.odr_avl[4] = { .hz = 208, .value = LSM6DSM_ODR_208HZ_VAL },
+	.odr_avl[5] = { .hz = 416, .value = LSM6DSM_ODR_416HZ_VAL },
+};
+
+struct lsm6dsm_fs_reg {
+	unsigned int gain;
+	u8 value;
+	int urv;
+};
+
+static struct lsm6dsm_fs_table {
+	u8 addr;
+	u8 mask;
+	struct lsm6dsm_fs_reg fs_avl[LSM6DSM_FS_LIST_NUM];
+} lsm6dsm_fs_table[LSM6DSM_SENSORS_NUMB] = {
+	[LSM6DSM_ACCEL] = {
+		.addr = LSM6DSM_ACCEL_FS_ADDR,
+		.mask = LSM6DSM_ACCEL_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DSM_ACCEL_FS_2G_GAIN,
+			       .value = LSM6DSM_ACCEL_FS_2G_VAL,
+			       .urv = 2, },
+		.fs_avl[1] = { .gain = LSM6DSM_ACCEL_FS_4G_GAIN,
+			       .value = LSM6DSM_ACCEL_FS_4G_VAL,
+			       .urv = 4, },
+		.fs_avl[2] = { .gain = LSM6DSM_ACCEL_FS_8G_GAIN,
+			       .value = LSM6DSM_ACCEL_FS_8G_VAL,
+			       .urv = 8, },
+		.fs_avl[3] = { .gain = LSM6DSM_ACCEL_FS_16G_GAIN,
+			       .value = LSM6DSM_ACCEL_FS_16G_VAL,
+			       .urv = 16, },
+	},
+	[LSM6DSM_GYRO] = {
+		.addr = LSM6DSM_GYRO_FS_ADDR,
+		.mask = LSM6DSM_GYRO_FS_MASK,
+		.fs_avl[0] = { .gain = LSM6DSM_GYRO_FS_245_GAIN,
+			       .value = LSM6DSM_GYRO_FS_245_VAL,
+			       .urv = 245, },
+		.fs_avl[1] = { .gain = LSM6DSM_GYRO_FS_500_GAIN,
+			       .value = LSM6DSM_GYRO_FS_500_VAL,
+			       .urv = 500, },
+		.fs_avl[2] = { .gain = LSM6DSM_GYRO_FS_1000_GAIN,
+			       .value = LSM6DSM_GYRO_FS_1000_VAL,
+			        .urv = 1000, },
+		.fs_avl[3] = { .gain = LSM6DSM_GYRO_FS_2000_GAIN,
+			       .value = LSM6DSM_GYRO_FS_2000_VAL,
+			       .urv = 2000, },
+	}
+};
+
+static struct workqueue_struct *lsm6dsm_workqueue;
+
+static inline void lsm6dsm_flush_works(void)
+{
+	flush_workqueue(lsm6dsm_workqueue);
+}
+
+static inline int64_t lsm6dsm_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int lsm6dsm_write_data_with_mask(struct lsm6dsm_data *cdata,
+					u8 reg_addr, u8 mask, u8 data, bool b_lock)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data, b_lock);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data, b_lock);
+}
+
+static int lsm6dsm_input_init(struct lsm6dsm_sensor_data *sdata, u16 bustype,
+			      const char *description)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = lsm6dsm_sensor_name[sdata->sindex].description;
+
+	sdata->input_dev->id.bustype = bustype;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	sdata->input_dev->name = description;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if ((sdata->sindex == LSM6DSM_ACCEL) ||
+	    (sdata->sindex == LSM6DSM_GYRO)) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+			sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lsm6dsm_input_cleanup(struct lsm6dsm_sensor_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lsm6dsm_report_3axes_event(struct lsm6dsm_sensor_data *sdata,
+				       s32 *xyz, int64_t timestamp)
+{
+	struct input_dev  *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static void lsm6dsm_report_single_event(struct lsm6dsm_sensor_data *sdata,
+					s32 data, int64_t timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, data);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static enum hrtimer_restart lsm6dsm_poll_function_read(struct hrtimer *timer)
+{
+	struct lsm6dsm_sensor_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct lsm6dsm_sensor_data,
+			     hr_timer);
+
+	sdata->timestamp = lsm6dsm_get_time_ns();
+	queue_work(lsm6dsm_workqueue, &sdata->input_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static int lsm6dsm_get_step_c_data(struct lsm6dsm_sensor_data *sdata, u16 *steps)
+{
+	u8 data[2];
+	int err = 0;
+	err = sdata->cdata->tf->read(sdata->cdata,
+				     LSM6DSM_STEP_COUNTER_OUT_L_ADDR,
+				     LSM6DSM_STEP_COUNTER_OUT_SIZE,
+				     data, true);
+	if (err < 0)
+		return err;
+
+	*steps = data[0] | (data[1] << 8);
+
+	return 0;
+}
+
+static int lsm6dsm_get_poll_data(struct lsm6dsm_sensor_data *sdata, u8 *data)
+{
+	int err = 0;
+	u8 reg_addr;
+
+	switch(sdata->sindex) {
+	case LSM6DSM_ACCEL:
+		reg_addr = LSM6DSM_ACCEL_OUT_X_L_ADDR;
+
+		break;
+	case LSM6DSM_GYRO:
+		reg_addr = LSM6DSM_GYRO_OUT_X_L_ADDR;
+
+		break;
+	default:
+		dev_err(sdata->cdata->dev, "invalid polling mode for sensor %s\n",
+			sdata->name);
+		return -1;
+	}
+
+	err = sdata->cdata->tf->read(sdata->cdata, reg_addr, LSM6DSM_OUT_XYZ_SIZE,
+				     data, true);
+
+	return err;
+}
+
+static void poll_function_work(struct work_struct *input_work)
+{
+	struct lsm6dsm_sensor_data *sdata;
+	int xyz[3] = { 0 };
+	u8 data[6];
+	int err;
+	ktime_t tmpkt;
+
+	sdata = container_of((struct work_struct *)input_work,
+			     struct lsm6dsm_sensor_data, input_work);
+
+	/* Adjust new timeout */
+	tmpkt = ktime_sub(sdata->oldktime,
+					  ktime_set(0, (lsm6dsm_get_time_ns() - sdata->timestamp)));
+
+	hrtimer_start(&sdata->hr_timer, tmpkt, HRTIMER_MODE_REL);
+	if(sdata->sample_to_discard) {
+		sdata->sample_to_discard--;
+		return;
+	}
+
+	err = lsm6dsm_get_poll_data(sdata, data);
+	if (err < 0)
+		dev_err(sdata->cdata->dev, "get %s data failed %d\n",
+			sdata->name, err);
+	else {
+		xyz[0] = (s32)((s16)(data[0] | (data[1] << 8)));
+		xyz[1] = (s32)((s16)(data[2] | (data[3] << 8)));
+		xyz[2] = (s32)((s16)(data[4] | (data[5] << 8)));
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+
+		lsm6dsm_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+}
+
+static int lsm6dsm_set_drdy_irq(struct lsm6dsm_sensor_data *sdata, bool state)
+{
+	u8 reg_addr = 0, mask = 0, value;
+
+	if (state)
+		value = LSM6DSM_EN_BIT;
+	else
+		value = LSM6DSM_DIS_BIT;
+
+	switch (sdata->sindex) {
+	case LSM6DSM_ACCEL:
+	case LSM6DSM_GYRO:
+		return 0;
+
+	/* Route Step Detection/sig. Motion Interrupt on INT1 */
+	case LSM6DSM_STEP_COUNTER:
+	case LSM6DSM_SIGN_MOTION:
+	case LSM6DSM_STEP_DETECTOR:
+		if (sdata->cdata->sensors[LSM6DSM_STEP_DETECTOR].enabled ||
+		    sdata->cdata->sensors[LSM6DSM_SIGN_MOTION].enabled ||
+		    sdata->cdata->sensors[LSM6DSM_STEP_COUNTER].enabled)
+			return 0;
+
+		reg_addr = LSM6DSM_INT1_CTRL_ADDR;
+		mask = LSM6DSM_STEP_DETECTOR_DRDY_IRQ_MASK;
+		break;
+	case LSM6DSM_TILT:
+		reg_addr = LSM6DSM_MD1_ADDR;
+		mask = LSM6DSM_TILT_DRDY_IRQ_MASK;
+		break;
+	case LSM6DSM_WRIST_TILT:
+		reg_addr = LSM6DSM_WRIST_TILT_DRDY;
+		mask = LSM6DSM_WRIST_TILT_DRDY_MASK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lsm6dsm_write_data_with_mask(sdata->cdata, reg_addr, mask, value,
+					    true);
+}
+
+static int lsm6dsm_set_fs(struct lsm6dsm_sensor_data *sdata, u32 gain)
+{
+	int err, i;
+
+	for (i = 0; i < LSM6DSM_FS_LIST_NUM; i++) {
+		if (lsm6dsm_fs_table[sdata->sindex].fs_avl[i].gain == gain)
+			break;
+	}
+
+	if (i == LSM6DSM_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_fs_table[sdata->sindex].addr,
+				lsm6dsm_fs_table[sdata->sindex].mask,
+				lsm6dsm_fs_table[sdata->sindex].fs_avl[i].value,
+				true);
+	if (err < 0)
+		return err;
+
+	sdata->c_gain = gain;
+
+	return 0;
+}
+
+static irqreturn_t lsm6dsm_save_timestamp(int irq, void *private)
+{
+	struct lsm6dsm_data *cdata = (struct lsm6dsm_data *)private;
+
+	cdata->timestamp = lsm6dsm_get_time_ns();
+	queue_work(lsm6dsm_workqueue, &cdata->input_work);
+
+	disable_irq_nosync(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int lsm6dsm_disable_sensors(struct lsm6dsm_sensor_data *sdata);
+
+static void lsm6dsm_irq_management(struct work_struct *input_work)
+{
+	struct lsm6dsm_data *cdata;
+	u8 src_value = 0x00, src2_value = 0x00;
+	struct lsm6dsm_sensor_data *sdata;
+	u16 steps_c;
+	int err;
+
+	cdata = container_of((struct work_struct *)input_work,
+			     struct lsm6dsm_data, input_work);
+
+	cdata->tf->read(cdata, LSM6DSM_SRC_FUNC_ADDR, 1, &src_value, true);
+	cdata->tf->read(cdata, LSM6DSM_SRC2_FUNC_ADDR, 1, &src2_value, true);
+
+	if (src_value & LSM6DSM_SRC_STEP_COUNTER_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSM_STEP_COUNTER];
+		sdata->timestamp = cdata->timestamp;
+		err = lsm6dsm_get_step_c_data(sdata, &steps_c);
+		if (err < 0) {
+			dev_err(cdata->dev,
+				"error while reading step counter data\n");
+			enable_irq(cdata->irq);
+
+			return;
+		}
+
+		lsm6dsm_report_single_event(&cdata->sensors[LSM6DSM_STEP_COUNTER],
+					    steps_c,
+					    cdata->sensors[LSM6DSM_STEP_COUNTER].timestamp);
+		cdata->steps_c = steps_c;
+	}
+
+	if (src_value & LSM6DSM_SRC_STEP_DETECTOR_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSM_STEP_DETECTOR];
+		sdata->timestamp = cdata->timestamp;
+		lsm6dsm_report_single_event(sdata, 1, sdata->timestamp);
+
+		if (cdata->sign_motion_event_ready) {
+			sdata = &cdata->sensors[LSM6DSM_SIGN_MOTION];
+			sdata->timestamp = cdata->timestamp;
+			lsm6dsm_report_single_event(sdata, 1, sdata->timestamp);
+			cdata->sign_motion_event_ready = false;
+			lsm6dsm_disable_sensors(sdata);
+		}
+	}
+
+	if (src_value & LSM6DSM_SRC_TILT_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSM_TILT];
+		sdata->timestamp = cdata->timestamp;
+		lsm6dsm_report_single_event(sdata, 1, sdata->timestamp);
+	}
+
+	if (src2_value & LSM6DSM_SRC2_WRIST_TILT_DATA_AVL) {
+		sdata = &cdata->sensors[LSM6DSM_WRIST_TILT];
+		sdata->timestamp = cdata->timestamp;
+		lsm6dsm_report_single_event(sdata, 1, sdata->timestamp);
+	}
+
+	enable_irq(cdata->irq);
+}
+
+static int lsm6dsm_allocate_workqueue(struct lsm6dsm_data *cdata)
+{
+	int err;
+
+	if (!lsm6dsm_workqueue)
+		lsm6dsm_workqueue = create_workqueue(cdata->name);
+
+	if (!lsm6dsm_workqueue)
+		return -EINVAL;
+
+	INIT_WORK(&cdata->input_work, lsm6dsm_irq_management);
+
+	err = request_threaded_irq(cdata->irq, lsm6dsm_save_timestamp, NULL,
+				   IRQF_TRIGGER_HIGH, cdata->name, cdata);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int lsm6dsm_set_extra_dependency(struct lsm6dsm_sensor_data *sdata,
+					bool enable)
+{
+	int err;
+
+	if (!(sdata->cdata->sensors[LSM6DSM_SIGN_MOTION].enabled |
+	    sdata->cdata->sensors[LSM6DSM_STEP_COUNTER].enabled |
+	    sdata->cdata->sensors[LSM6DSM_STEP_DETECTOR].enabled |
+	    sdata->cdata->sensors[LSM6DSM_TILT].enabled |
+	    sdata->cdata->sensors[LSM6DSM_WRIST_TILT].enabled)) {
+		/* Enable/Disable Embedded Function only once */
+		if (enable) {
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+						LSM6DSM_FUNC_EN_ADDR,
+						LSM6DSM_FUNC_EN_MASK,
+						LSM6DSM_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+						LSM6DSM_FUNC_EN_ADDR,
+						LSM6DSM_FUNC_EN_MASK,
+						LSM6DSM_DIS_BIT, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	if (!sdata->cdata->sensors[LSM6DSM_ACCEL].enabled) {
+		if (enable) {
+			u8 idx = 1;
+			u16 acc_odr = sdata->cdata->sensors[LSM6DSM_ACCEL].c_odr;
+
+			if (acc_odr > 26) {
+				for (; idx < LSM6DSM_ODR_LIST_NUM; idx++)
+					if (lsm6dsm_odr_table.odr_avl[idx].hz == acc_odr)
+						break;
+			}
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[LSM6DSM_ACCEL],
+				lsm6dsm_odr_table.mask[LSM6DSM_ACCEL],
+				lsm6dsm_odr_table.odr_avl[idx].value, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[LSM6DSM_ACCEL],
+				lsm6dsm_odr_table.mask[LSM6DSM_ACCEL],
+				LSM6DSM_ODR_POWER_OFF_VAL, true);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lsm6dsm_enable_pedometer(struct lsm6dsm_sensor_data *sdata,
+				    bool enable)
+{
+	int err = 0;
+	u8 value = LSM6DSM_DIS_BIT;
+
+	if (sdata->cdata->sensors[LSM6DSM_STEP_COUNTER].enabled &&
+	    sdata->cdata->sensors[LSM6DSM_STEP_DETECTOR].enabled)
+		return 0;
+
+	if (enable)
+		value = LSM6DSM_EN_BIT;
+
+	err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					   LSM6DSM_FIFO_PEDO_E_ADDR,
+					   LSM6DSM_FIFO_PEDO_E_MASK,
+					   value, true);
+	if (err < 0)
+		return err;
+
+	return lsm6dsm_write_data_with_mask(sdata->cdata,
+					    LSM6DSM_PEDOMETER_EN_ADDR,
+					    LSM6DSM_PEDOMETER_EN_MASK,
+					    value, true);
+}
+
+static int _lsm6dsm_enable_sensors(struct lsm6dsm_sensor_data *sdata)
+{
+	int err, i;
+	int64_t newTime;
+
+	switch (sdata->sindex) {
+	case LSM6DSM_ACCEL:
+	case LSM6DSM_GYRO:
+		for (i = 0; i < LSM6DSM_ODR_LIST_NUM; i++) {
+			if (lsm6dsm_odr_table.odr_avl[i].hz == sdata->c_odr)
+				break;
+		}
+		if (i == LSM6DSM_ODR_LIST_NUM)
+			return -EINVAL;
+
+		if (sdata->sindex == LSM6DSM_ACCEL)
+			sdata->sample_to_discard = LSM6DSM_ACCEL_STD +
+						LSM6DSM_ACCEL_STD_FROM_PD;
+
+		sdata->cdata->sensors[LSM6DSM_GYRO].sample_to_discard =
+						LSM6DSM_GYRO_STD +
+						LSM6DSM_GYRO_STD_FROM_PD;
+
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[sdata->sindex],
+				lsm6dsm_odr_table.mask[sdata->sindex],
+				lsm6dsm_odr_table.odr_avl[i].value, true);
+		if (err < 0)
+			return err;
+
+		sdata->c_odr = lsm6dsm_odr_table.odr_avl[i].hz;
+		newTime = 1000000000 / sdata->c_odr;
+		sdata->oldktime = ktime_set(0, newTime);
+		hrtimer_start(&sdata->hr_timer, sdata->oldktime, HRTIMER_MODE_REL);
+
+		break;
+	case LSM6DSM_SIGN_MOTION:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+						LSM6DSM_SIGN_MOTION_EN_ADDR,
+						LSM6DSM_SIGN_MOTION_EN_MASK,
+						LSM6DSM_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		if ((sdata->cdata->sensors[LSM6DSM_STEP_COUNTER].enabled) ||
+		    (sdata->cdata->sensors[LSM6DSM_STEP_DETECTOR].enabled)) {
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+						LSM6DSM_PEDOMETER_EN_ADDR,
+						LSM6DSM_PEDOMETER_EN_MASK,
+						LSM6DSM_DIS_BIT, true);
+			if (err < 0)
+				return err;
+
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+						LSM6DSM_PEDOMETER_EN_ADDR,
+						LSM6DSM_PEDOMETER_EN_MASK,
+						LSM6DSM_EN_BIT, true);
+			if (err < 0)
+				return err;
+		} else {
+			err = lsm6dsm_enable_pedometer(sdata, true);
+			if (err < 0)
+				return err;
+		}
+
+		sdata->cdata->sign_motion_event_ready = true;
+
+		break;
+	case LSM6DSM_STEP_COUNTER:
+	case LSM6DSM_STEP_DETECTOR:
+		err = lsm6dsm_enable_pedometer(sdata, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DSM_TILT:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					LSM6DSM_TILT_EN_ADDR,
+					LSM6DSM_TILT_EN_MASK,
+					LSM6DSM_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DSM_WRIST_TILT:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					LSM6DSM_WRIST_TILT_EN_ADDR,
+					LSM6DSM_WRIST_TILT_EN_MASK,
+					LSM6DSM_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6dsm_set_extra_dependency(sdata, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsm_set_drdy_irq(sdata, true);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm6dsm_enable_sensors(struct lsm6dsm_sensor_data *sdata)
+{
+	int err;
+
+	if (sdata->enabled)
+		return 0;
+
+	err = _lsm6dsm_enable_sensors(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = true;
+
+	return 0;
+}
+
+static int _lsm6dsm_disable_sensors(struct lsm6dsm_sensor_data *sdata)
+{
+	int err;
+
+	switch (sdata->sindex) {
+	case LSM6DSM_ACCEL:
+		if (sdata->cdata->sensors[LSM6DSM_SIGN_MOTION].enabled |
+		    sdata->cdata->sensors[LSM6DSM_STEP_COUNTER].enabled |
+		    sdata->cdata->sensors[LSM6DSM_STEP_DETECTOR].enabled |
+		    sdata->cdata->sensors[LSM6DSM_TILT].enabled |
+		    sdata->cdata->sensors[LSM6DSM_WRIST_TILT].enabled) {
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[LSM6DSM_ACCEL],
+				lsm6dsm_odr_table.mask[LSM6DSM_ACCEL],
+				lsm6dsm_odr_table.odr_avl[0].value, true);
+		} else {
+			err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[LSM6DSM_ACCEL],
+				lsm6dsm_odr_table.mask[LSM6DSM_ACCEL],
+				LSM6DSM_ODR_POWER_OFF_VAL, true);
+		}
+		if (err < 0)
+			return err;
+
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+
+		break;
+	case LSM6DSM_GYRO:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[LSM6DSM_GYRO],
+				lsm6dsm_odr_table.mask[LSM6DSM_GYRO],
+				LSM6DSM_ODR_POWER_OFF_VAL, true);
+		if (err < 0)
+			return err;
+
+		cancel_work_sync(&sdata->input_work);
+		hrtimer_cancel(&sdata->hr_timer);
+
+		break;
+	case LSM6DSM_SIGN_MOTION:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				LSM6DSM_SIGN_MOTION_EN_ADDR,
+				LSM6DSM_SIGN_MOTION_EN_MASK,
+				LSM6DSM_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		err = lsm6dsm_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		sdata->cdata->sign_motion_event_ready = false;
+
+		break;
+	case LSM6DSM_STEP_COUNTER:
+	case LSM6DSM_STEP_DETECTOR:
+		err = lsm6dsm_enable_pedometer(sdata, false);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DSM_TILT:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				LSM6DSM_TILT_EN_ADDR,
+				LSM6DSM_TILT_EN_MASK,
+				LSM6DSM_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	case LSM6DSM_WRIST_TILT:
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					LSM6DSM_WRIST_TILT_EN_ADDR,
+					LSM6DSM_WRIST_TILT_EN_MASK,
+					LSM6DSM_DIS_BIT, true);
+		if (err < 0)
+			return err;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = lsm6dsm_set_extra_dependency(sdata, false);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsm_set_drdy_irq(sdata, false);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm6dsm_disable_sensors(struct lsm6dsm_sensor_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	err = _lsm6dsm_disable_sensors(sdata);
+	if (err < 0)
+		return err;
+
+	sdata->enabled = false;
+
+	return 0;
+}
+
+static int lsm6dsm_reset_steps(struct lsm6dsm_data *cdata)
+{
+	int err;
+	u8 reg_value = 0x00;
+
+	err = cdata->tf->read(cdata, LSM6DSM_STEP_COUNTER_RES_ADDR, 1,
+			      &reg_value, true);
+	if (err < 0)
+		return err;
+
+	/* Check if embedded functionalities are enabled */
+	if (reg_value & LSM6DSM_FUNC_EN_MASK)
+		reg_value = LSM6DSM_STEP_COUNTER_RES_FUNC_EN;
+	else
+		reg_value = LSM6DSM_DIS_BIT;
+
+	err = lsm6dsm_write_data_with_mask(cdata,
+				LSM6DSM_STEP_COUNTER_RES_ADDR,
+				LSM6DSM_STEP_COUNTER_RES_MASK,
+				LSM6DSM_STEP_COUNTER_RES_ALL_EN, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsm_write_data_with_mask(cdata,
+				LSM6DSM_STEP_COUNTER_RES_ADDR,
+				LSM6DSM_STEP_COUNTER_RES_MASK,
+				reg_value, true);
+	if (err < 0)
+		return err;
+
+	cdata->reset_steps = true;
+
+	return 0;
+}
+
+static int lsm6dsm_init_sensors(struct lsm6dsm_data *cdata)
+{
+	int err, i;
+	u8 default_reg_value = 0;
+	struct lsm6dsm_sensor_data *sdata;
+
+	for (i = 0; i < LSM6DSM_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+
+		err = lsm6dsm_disable_sensors(sdata);
+		if (err < 0)
+			return err;
+
+		if ((sdata->sindex == LSM6DSM_ACCEL) ||
+		    (sdata->sindex == LSM6DSM_GYRO)) {
+			err = lsm6dsm_set_fs(sdata, sdata->c_gain);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	hrtimer_init(&cdata->sensors[LSM6DSM_ACCEL].hr_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	hrtimer_init(&cdata->sensors[LSM6DSM_GYRO].hr_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	cdata->sensors[LSM6DSM_ACCEL].hr_timer.function =
+						&lsm6dsm_poll_function_read;
+	cdata->sensors[LSM6DSM_GYRO].hr_timer.function =
+						&lsm6dsm_poll_function_read;
+
+	cdata->steps_c = 0;
+	cdata->reset_steps = false;
+
+	/* Software reset */
+	err = lsm6dsm_write_data_with_mask(cdata, LSM6DSM_RESET_ADDR,
+					   LSM6DSM_RESET_MASK, LSM6DSM_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	/* Enable Latch Mode Bit */
+	err = lsm6dsm_write_data_with_mask(cdata, LSM6DSM_LIR_ADDR,
+					   LSM6DSM_LIR_MASK, LSM6DSM_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	/* Enable timestamp count */
+	err = lsm6dsm_write_data_with_mask(cdata, LSM6DSM_TIMER_EN_ADDR,
+					   LSM6DSM_TIMER_EN_MASK,
+					   LSM6DSM_EN_BIT, true);
+		if (err < 0)
+			return err;
+
+	/* Output data not updated until have been read */
+	err = lsm6dsm_write_data_with_mask(cdata, LSM6DSM_BDU_ADDR,
+					   LSM6DSM_BDU_MASK, LSM6DSM_EN_BIT,
+					   true);
+	if (err < 0)
+		return err;
+
+	/* Enable Source Rounding function */
+	err = lsm6dsm_write_data_with_mask(cdata, LSM6DSM_ROUNDING_ADDR,
+					   LSM6DSM_ROUNDING_MASK,
+					   LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	/* Set all interrupt signals in logic or on INT1 pad */
+	err = lsm6dsm_write_data_with_mask(cdata,
+					   LSM6DSM_INT2_ON_INT1_ADDR,
+					   LSM6DSM_INT2_ON_INT1_MASK,
+					   LSM6DSM_EN_BIT, true);
+	if (err < 0)
+		return err;
+
+	err = lsm6dsm_reset_steps(sdata->cdata);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&cdata->bank_registers_lock);
+	err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					   LSM6DSM_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSM_FUNC_CFG_REG_MASK,
+					   LSM6DSM_EN_BIT, false);
+	if (err < 0)
+		goto lsm6dsm_init_sensor_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+				      LSM6DSM_STEP_COUNTER_DURATION_ADDR,
+				      1, &default_reg_value, false);
+	if (err < 0)
+		goto lsm6dsm_init_sensor_mutex_unlock;
+
+	err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					   LSM6DSM_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSM_FUNC_CFG_REG_MASK,
+					   LSM6DSM_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6dsm_init_sensor_mutex_unlock;
+
+	mutex_unlock(&cdata->bank_registers_lock);
+	cdata->sensors[LSM6DSM_ACCEL].oldktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LSM6DSM_ACCEL].poll_interval));
+	cdata->sensors[LSM6DSM_GYRO].oldktime = ktime_set(0,
+			MS_TO_NS(cdata->sensors[LSM6DSM_ACCEL].poll_interval));
+	INIT_WORK(&cdata->sensors[LSM6DSM_ACCEL].input_work, poll_function_work);
+	INIT_WORK(&cdata->sensors[LSM6DSM_GYRO].input_work, poll_function_work);
+
+	return 0;
+
+lsm6dsm_init_sensor_mutex_unlock:
+	mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lsm6dsm_set_odr(struct lsm6dsm_sensor_data *sdata, u32 odr)
+{
+	int err = 0, i;
+
+	for (i = 0; i < LSM6DSM_ODR_LIST_NUM; i++) {
+		if (lsm6dsm_odr_table.odr_avl[i].hz >= odr)
+			break;
+	}
+	if (i == LSM6DSM_ODR_LIST_NUM)
+		return -EINVAL;
+
+	if (sdata->c_odr == lsm6dsm_odr_table.odr_avl[i].hz)
+		return 0;
+
+	if (sdata->enabled) {
+		disable_irq(sdata->cdata->irq);
+		lsm6dsm_flush_works();
+
+		if (sdata->sindex == LSM6DSM_ACCEL)
+			sdata->cdata->sensors[LSM6DSM_ACCEL].sample_to_discard +=
+							LSM6DSM_ACCEL_STD;
+
+		if (sdata->cdata->sensors[LSM6DSM_GYRO].enabled)
+			sdata->cdata->sensors[LSM6DSM_GYRO].sample_to_discard +=
+							LSM6DSM_GYRO_STD;
+
+		err = lsm6dsm_write_data_with_mask(sdata->cdata,
+				lsm6dsm_odr_table.addr[sdata->sindex],
+				lsm6dsm_odr_table.mask[sdata->sindex],
+				lsm6dsm_odr_table.odr_avl[i].value, true);
+		if (err < 0) {
+			enable_irq(sdata->cdata->irq);
+
+			return err;
+		}
+
+		sdata->c_odr = lsm6dsm_odr_table.odr_avl[i].hz;
+		enable_irq(sdata->cdata->irq);
+	} else
+		sdata->c_odr = lsm6dsm_odr_table.odr_avl[i].hz;
+
+	return err;
+}
+
+static ssize_t get_enable(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t set_enable(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	int err;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (strict_strtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = lsm6dsm_enable_sensors(sdata);
+	else
+		err = lsm6dsm_disable_sensors(sdata);
+
+	return count;
+}
+
+static ssize_t get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->poll_interval);
+}
+
+static ssize_t set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	unsigned int polling_rate;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+	int64_t newTime;
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	/*
+	 * Polling interval is in msec, then we have to convert it in Hz to
+	 * configure ODR through lsm6dsm_set_odr
+	 */
+	err = lsm6dsm_set_odr(sdata, 1000 / polling_rate);
+	if (!(err < 0)) {
+		sdata->poll_interval = 1000 / sdata->c_odr;
+		newTime = MS_TO_NS(sdata->poll_interval);
+		sdata->oldktime = ktime_set(0, newTime);
+	}
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+static ssize_t get_sampling_freq(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->c_odr);
+}
+
+static ssize_t set_sampling_freq(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int err;
+	unsigned int odr;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	err = lsm6dsm_set_odr(sdata, odr);
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	return (err < 0 ? err : count);
+}
+
+static ssize_t reset_steps(struct device *dev,
+			   struct device_attribute *attr, const char *buf,
+			   size_t count)
+{
+	int err;
+	unsigned int reset;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &reset);
+	if (err < 0)
+		return err;
+
+	lsm6dsm_reset_steps(sdata->cdata);
+
+	return count;
+}
+
+static ssize_t set_max_delivery_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	u8 duration;
+	int err, err2;
+	unsigned int max_delivery_rate;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtouint(buf, 10, &max_delivery_rate);
+	if (err < 0)
+		return -EINVAL;
+
+	if (max_delivery_rate == sdata->c_odr)
+		return size;
+
+	duration = max_delivery_rate / LSM6DSM_MIN_DURATION_MS;
+
+	mutex_lock(&sdata->cdata->bank_registers_lock);
+
+	err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					   LSM6DSM_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSM_FUNC_CFG_REG_MASK,
+					   LSM6DSM_EN_BIT, false);
+	if (err < 0)
+		goto lsm6dsm_set_max_delivery_rate_mutex_unlock;
+
+	err = sdata->cdata->tf->write(sdata->cdata,
+				      LSM6DSM_STEP_COUNTER_DURATION_ADDR,
+				      1, &duration, false);
+	if (err < 0)
+		goto lsm6dsm_set_max_delivery_rate_restore_bank;
+
+	err = lsm6dsm_write_data_with_mask(sdata->cdata,
+					   LSM6DSM_FUNC_CFG_ACCESS_ADDR,
+					   LSM6DSM_FUNC_CFG_REG_MASK,
+					   LSM6DSM_DIS_BIT, false);
+	if (err < 0)
+		goto lsm6dsm_set_max_delivery_rate_restore_bank;
+
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+
+	sdata->c_odr = max_delivery_rate;
+
+	return size;
+
+lsm6dsm_set_max_delivery_rate_restore_bank:
+	do {
+		err2 = lsm6dsm_write_data_with_mask(sdata->cdata,
+					LSM6DSM_FUNC_CFG_ACCESS_ADDR,
+					LSM6DSM_FUNC_CFG_REG_MASK,
+					LSM6DSM_DIS_BIT, false);
+
+		msleep(500);
+	} while (err2 < 0);
+
+lsm6dsm_set_max_delivery_rate_mutex_unlock:
+	mutex_unlock(&sdata->cdata->bank_registers_lock);
+	return err;
+}
+
+static ssize_t get_max_delivery_rate(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", sdata->c_odr);
+}
+
+static ssize_t get_sampling_frequency_avail(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < LSM6DSM_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 lsm6dsm_odr_table.odr_avl[i].hz);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_scale_avail(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int i, len = 0;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DSM_FS_LIST_NUM; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+			lsm6dsm_fs_table[sdata->sindex].fs_avl[i].urv);
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t get_cur_scale(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	int i;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	for (i = 0; i < LSM6DSM_FS_LIST_NUM; i++)
+		if (sdata->c_gain ==
+				lsm6dsm_fs_table[sdata->sindex].fs_avl[i].gain)
+			break;
+
+	return sprintf(buf, "%d\n",
+		       lsm6dsm_fs_table[sdata->sindex].fs_avl[i].urv);
+}
+
+static ssize_t set_cur_scale(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	int i, urv, err;
+	struct lsm6dsm_sensor_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &urv);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < LSM6DSM_FS_LIST_NUM; i++)
+		if (urv == lsm6dsm_fs_table[sdata->sindex].fs_avl[i].urv)
+			break;
+
+	if (i == LSM6DSM_FS_LIST_NUM)
+		return -EINVAL;
+
+	err = lsm6dsm_set_fs(sdata,
+			     lsm6dsm_fs_table[sdata->sindex].fs_avl[i].gain);
+	if (err < 0)
+		return err;
+
+	return count;
+}
+
+
+static DEVICE_ATTR(enable, S_IWUSR | S_IRUGO, get_enable, set_enable);
+static DEVICE_ATTR(sampling_freq, S_IWUSR | S_IRUGO, get_sampling_freq,
+		   set_sampling_freq);
+static DEVICE_ATTR(polling_rate, S_IWUSR | S_IRUGO, get_polling_rate,
+		   set_polling_rate);
+static DEVICE_ATTR(reset_steps, S_IWUSR, NULL, reset_steps);
+static DEVICE_ATTR(max_delivery_rate, S_IWUSR | S_IRUGO, get_max_delivery_rate,
+		   set_max_delivery_rate);
+static DEVICE_ATTR(sampling_freq_avail, S_IRUGO, get_sampling_frequency_avail,
+		   NULL);
+static DEVICE_ATTR(scale_avail, S_IRUGO, get_scale_avail, NULL);
+static DEVICE_ATTR(scale, S_IWUSR | S_IRUGO, get_cur_scale, set_cur_scale);
+
+static struct attribute *lsm6dsm_accel_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsm_gyro_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_sampling_freq.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_sampling_freq_avail.attr,
+	&dev_attr_scale_avail.attr,
+	&dev_attr_scale.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsm_sign_m_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsm_step_c_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_reset_steps.attr,
+	&dev_attr_max_delivery_rate.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsm_step_d_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsm_tilt_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static struct attribute *lsm6dsm_wrist_t_attribute[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group lsm6dsm_attribute_groups[] = {
+	[LSM6DSM_ACCEL] = {
+		.attrs = lsm6dsm_accel_attribute,
+		.name = "accel",
+	},
+	[LSM6DSM_GYRO] = {
+		.attrs = lsm6dsm_gyro_attribute,
+		.name = "gyro",
+	},
+	[LSM6DSM_SIGN_MOTION] = {
+		.attrs = lsm6dsm_sign_m_attribute,
+		.name = "sign_m",
+	},
+	[LSM6DSM_STEP_COUNTER] = {
+		.attrs = lsm6dsm_step_c_attribute,
+		.name = "step_c",
+	},
+	[LSM6DSM_STEP_DETECTOR] = {
+		.attrs = lsm6dsm_step_d_attribute,
+		.name = "step_d",
+	},
+	[LSM6DSM_TILT] = {
+		.attrs = lsm6dsm_tilt_attribute,
+		.name = "tilt",
+	},
+	[LSM6DSM_WRIST_TILT] = {
+		.attrs = lsm6dsm_wrist_t_attribute,
+		.name = "wrist_t",
+	},
+};
+
+#ifdef CONFIG_OF
+static u32 lsm6dsm_parse_dt(struct lsm6dsm_data *cdata)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = cdata->dev->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "st,drdy-int-pin", &val) &&
+				  (val <= 2) && (val > 0))
+		cdata->drdy_int_pin = (u8)val;
+	else
+		cdata->drdy_int_pin = 1;
+
+	return 0;
+}
+#endif
+
+int lsm6dsm_common_probe(struct lsm6dsm_data *cdata, int irq, u16 bustype)
+{
+	int32_t err, i;
+	u8 wai =0x00;
+	struct lsm6dsm_sensor_data *sdata;
+
+	mutex_init(&cdata->bank_registers_lock);
+	mutex_init(&cdata->tb.buf_lock);
+
+	/* Read Chip ID register */
+	err = cdata->tf->read(cdata, LSM6DSM_WHO_AM_I, 1, &wai, true);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+		return err;
+	}
+	if (wai != LSM6DSM_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+
+	if (irq > 0) {
+#ifdef CONFIG_OF
+		err = lsm6dsm_parse_dt(cdata);
+		if (err < 0)
+			return err;
+#else /* CONFIG_OF */
+		if (cdata->dev->platform_data) {
+			cdata->drdy_int_pin = ((struct lsm6dsm_platform_data *)
+					cdata->dev->platform_data)->drdy_int_pin;
+
+			if ((cdata->drdy_int_pin > 2) ||
+			    (cdata->drdy_int_pin < 1))
+				cdata->drdy_int_pin = 1;
+		} else {
+			cdata->drdy_int_pin = 1;
+		}
+#endif /* CONFIG_OF */
+
+		dev_info(cdata->dev, "driver use DRDY int pin %d\n",
+			 cdata->drdy_int_pin);
+	}
+
+	for (i = 0; i < LSM6DSM_SENSORS_NUMB; i++) {
+		sdata = &cdata->sensors[i];
+		sdata->enabled = false;
+		sdata->cdata = cdata;
+		sdata->sindex = i;
+		sdata->name = lsm6dsm_sensor_name[i].name;
+		if ((i == LSM6DSM_ACCEL) || (i == LSM6DSM_GYRO)) {
+			sdata->c_odr = lsm6dsm_odr_table.odr_avl[0].hz;
+			sdata->c_gain = lsm6dsm_fs_table[i].fs_avl[0].gain;
+			sdata->poll_interval = 1000 / sdata->c_odr;
+		}
+		if (i == LSM6DSM_STEP_COUNTER) {
+			sdata->c_odr = LSM6DSM_MIN_DURATION_MS;
+		}
+
+		if (lsm6dsm_input_init(sdata, bustype,
+				       lsm6dsm_sensor_name[i].description)) {
+			dev_err(cdata->dev,
+				"failed to register input device %s",
+				sdata->name);
+			sdata->input_dev = NULL;
+			continue;
+		}
+
+		if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+				       &lsm6dsm_attribute_groups[i])) {
+			dev_err(cdata->dev,
+				"failed to create sysfs group for sensor %s",
+				sdata->name);
+			input_unregister_device(sdata->input_dev);
+			sdata->input_dev = NULL;
+		}
+	}
+
+	err = lsm6dsm_init_sensors(cdata);
+	if (err < 0)
+		return err;
+	if (irq > 0)
+		cdata->irq = irq;
+
+	if (irq > 0) {
+		err = lsm6dsm_allocate_workqueue(cdata);
+		if (err < 0)
+			return err;
+	}
+
+	dev_info(cdata->dev, "%s: probed\n", LSM6DSM_DEV_NAME);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsm_common_probe);
+
+void lsm6dsm_common_remove(struct lsm6dsm_data *cdata, int irq)
+{
+	u8 i;
+
+	for (i = 0; i < LSM6DSM_SENSORS_NUMB; i++) {
+		lsm6dsm_disable_sensors(&cdata->sensors[i]);
+		lsm6dsm_input_cleanup(&cdata->sensors[i]);
+	}
+
+	if(lsm6dsm_workqueue) {
+		flush_workqueue(lsm6dsm_workqueue);
+		destroy_workqueue(lsm6dsm_workqueue);
+		lsm6dsm_workqueue = NULL;
+	}
+}
+EXPORT_SYMBOL(lsm6dsm_common_remove);
+
+#ifdef CONFIG_PM
+static int lsm6dsm_resume_sensors(struct lsm6dsm_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lsm6dsm_enable_sensors(sdata);
+}
+
+static int lsm6dsm_suspend_sensors(struct lsm6dsm_sensor_data *sdata)
+{
+	if (!sdata->enabled)
+		return 0;
+
+	return _lsm6dsm_disable_sensors(sdata);
+}
+
+int lsm6dsm_common_suspend(struct lsm6dsm_data *cdata)
+{
+	lsm6dsm_suspend_sensors(&cdata->sensors[LSM6DSM_ACCEL]);
+	lsm6dsm_suspend_sensors(&cdata->sensors[LSM6DSM_GYRO]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsm_common_suspend);
+
+int lsm6dsm_common_resume(struct lsm6dsm_data *cdata)
+{
+	lsm6dsm_resume_sensors(&cdata->sensors[LSM6DSM_ACCEL]);
+	lsm6dsm_resume_sensors(&cdata->sensors[LSM6DSM_GYRO]);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm6dsm_common_resume);
+
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.h b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.h
--- a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_core.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,161 @@
+/*
+ * STMicroelectronics lsm6dsm driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <giuseppe.barba@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#ifndef DRIVERS_INPUT_MISC_LSM6DSM_CORE_H_
+#define DRIVERS_INPUT_MISC_LSM6DSM_CORE_H_
+
+#define LSM6DSM_DEV_NAME		"lsm6dsm"
+
+#define HZ_TO_PERIOD_NSEC(hz)		(1000 * 1000 * 1000 / ((u32)(hz)))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+
+enum {
+	LSM6DSM_ACCEL = 0,
+	LSM6DSM_GYRO,
+	LSM6DSM_SIGN_MOTION,
+	LSM6DSM_STEP_COUNTER,
+	LSM6DSM_STEP_DETECTOR,
+	LSM6DSM_TILT,
+	LSM6DSM_WRIST_TILT ,
+	LSM6DSM_SENSORS_NUMB,
+};
+
+#define DEF_ZERO			0x00
+
+/* First Out register for Acc and Gyro */
+#define LSM6DSM_ACC_OUT_X_L_ADDR	0x28
+#define LSM6DSM_GYR_OUT_X_L_ADDR	0x22
+
+/* Output data rate registers */
+#define LSM6DSM_ACC_ODR_ADDR		CTRL1_ADDR
+#define LSM6DSM_ACC_ODR_MASK		0xf0
+#define LSM6DSM_GYR_ODR_ADDR		CTRL2_ADDR
+#define LSM6DSM_GYR_ODR_MASK		0xf0
+
+#define LSM6DSM_ACC_FS_ADDR		CTRL1_ADDR
+#define LSM6DSM_GYR_FS_ADDR		CTRL2_ADDR
+
+#define LSM6DSM_IF_INC_MASK		0x04
+
+#define LSM6DSM_HPERF_GYR_ADDR		CTRL7_ADDR
+#define LSM6DSM_HPERF_GYR_MASK		0x80
+
+#define LSM6DSM_HPERF_ACC_ADDR		CTRL6_ADDR
+#define LSM6DSM_HPERF_ACC_MASK		0x10
+#define LSM6DSM_HPERF_ACC_ENABLE	0x00
+
+#define CTRL1_ADDR			0x10
+#define CTRL2_ADDR			0x11
+#define CTRL3_ADDR			0x12
+#define CTRL6_ADDR			0x15
+#define CTRL7_ADDR			0x16
+
+/* Sensitivity Acc */
+#define SENSITIVITY_ACC_2G		61	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		122	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		244	/** ug/LSB */
+#define SENSITIVITY_ACC_16G		488	/** ug/LSB */
+/* Sensitivity Gyr */
+#define SENSITIVITY_GYR_125		437	/** 10udps/LSB */
+#define SENSITIVITY_GYR_245		875	/** 10udps/LSB */
+#define SENSITIVITY_GYR_500		1750	/** 10udps/LSB */
+#define SENSITIVITY_GYR_1000		3500	/** 10udps/LSB */
+#define SENSITIVITY_GYR_2000		7000	/** 10udps/LSB */
+
+#define FUZZ				0
+#define FLAT				0
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+#define LSM6DSM_RX_MAX_LENGTH		500
+#define LSM6DSM_TX_MAX_LENGTH		500
+
+#define to_dev(obj) 			container_of(obj, struct device, kobj)
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lsm6dsm_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LSM6DSM_RX_MAX_LENGTH];
+	u8 tx_buf[LSM6DSM_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lsm6dsm_data;
+
+struct lsm6dsm_transfer_function {
+	int (*write) (struct lsm6dsm_data *cdata, u8 reg_addr, int len, u8 *data,
+		      bool b_lock);
+	int (*read) (struct lsm6dsm_data *cdata, u8 reg_addr, int len, u8 *data,
+		     bool b_lock);
+};
+
+struct lsm6dsm_sensor_data {
+	struct lsm6dsm_data *cdata;
+	const char* name;
+	int64_t timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+	struct input_dev *input_dev;
+	unsigned int poll_interval;
+	struct hrtimer hr_timer;
+	struct work_struct input_work;
+	ktime_t oldktime;
+};
+
+struct lsm6dsm_data {
+	const char *name;
+	bool reset_steps;
+	bool sign_motion_event_ready;
+	u16 steps_c;
+	u8 drdy_int_pin;
+	int irq;
+	int64_t timestamp;
+	struct work_struct input_work;
+	struct device *dev;
+	struct lsm6dsm_sensor_data sensors[LSM6DSM_SENSORS_NUMB];
+	struct mutex bank_registers_lock;
+	const struct lsm6dsm_transfer_function *tf;
+	struct lsm6dsm_transfer_buffer tb;
+};
+
+int lsm6dsm_common_probe(struct lsm6dsm_data *cdata, int irq, u16 bustype);
+void lsm6dsm_common_remove(struct lsm6dsm_data *cdata, int irq);
+
+#ifdef CONFIG_PM
+int lsm6dsm_common_suspend(struct lsm6dsm_data *cdata);
+int lsm6dsm_common_resume(struct lsm6dsm_data *cdata);
+#endif /* CONFIG_PM */
+
+#endif /* DRIVERS_INPUT_MISC_LSM6DSM_CORE_H_ */
diff -uNr a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_i2c.c b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_i2c.c
--- a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,175 @@
+/*
+ * STMicroelectronics lsm6dsm i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lsm6dsm_core.h"
+
+static int lsm6dsm_i2c_read(struct lsm6dsm_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, msg, 2);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, msg, 2);
+
+	return err;
+}
+
+static int lsm6dsm_i2c_write(struct lsm6dsm_data *cdata, u8 reg_addr, int len,
+			     u8 *data, bool b_lock)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	if (b_lock) {
+		mutex_lock(&cdata->bank_registers_lock);
+		err = i2c_transfer(client->adapter, &msg, 1);
+		mutex_unlock(&cdata->bank_registers_lock);
+	} else
+		err = i2c_transfer(client->adapter, &msg, 1);
+
+	return err;
+}
+
+
+static const struct lsm6dsm_transfer_function lsm6dsm_tf_i2c = {
+	.write = lsm6dsm_i2c_write,
+	.read = lsm6dsm_i2c_read,
+};
+
+static int lsm6dsm_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm6dsm_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &lsm6dsm_tf_i2c;
+	i2c_set_clientdata(client, cdata);
+
+	err = lsm6dsm_common_probe(cdata, client->irq, BUS_I2C);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lsm6dsm_i2c_remove(struct i2c_client *client)
+{
+	struct lsm6dsm_data *cdata = i2c_get_clientdata(client);
+
+	lsm6dsm_common_remove(cdata, client->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DSM_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6dsm_suspend(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6dsm_common_suspend(cdata);
+}
+
+static int lsm6dsm_resume(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lsm6dsm_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6dsm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6dsm_suspend, lsm6dsm_resume)
+};
+
+#define LSM6DSM_PM_OPS		(&lsm6dsm_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DSM_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lsm6dsm_ids[] = {
+	{ LSM6DSM_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lsm6dsm_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dsm_id_table[] = {
+	{ .compatible = "st,lsm6dsm", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6dsm_id_table);
+#endif
+
+static struct i2c_driver lsm6dsm_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DSM_DEV_NAME,
+		.pm = LSM6DSM_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6dsm_id_table,
+#endif
+	},
+	.probe    = lsm6dsm_i2c_probe,
+	.remove   = lsm6dsm_i2c_remove,
+	.id_table = lsm6dsm_ids,
+};
+
+module_i2c_driver(lsm6dsm_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_spi.c b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_spi.c
--- a/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsm/lsm6dsm_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,204 @@
+/*
+ * STMicroelectronics lsm6dsm spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#include "lsm6dsm_core.h"
+
+#define SENSORS_SPI_READ 0x80
+
+static int lsm6dsm_spi_read(struct lsm6dsm_data *cdata, u8 reg_addr, int len,
+			    u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (err)
+		goto acc_spi_read_error;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return len;
+
+acc_spi_read_error:
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static int lsm6dsm_spi_write(struct lsm6dsm_data *cdata, u8 reg_addr, int len,
+			     u8 *data, bool b_lock)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM6DSM_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (b_lock)
+		mutex_lock(&cdata->bank_registers_lock);
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+	if (b_lock)
+		mutex_unlock(&cdata->bank_registers_lock);
+
+	return err;
+}
+
+static const struct lsm6dsm_transfer_function lsm6dsm_tf_spi = {
+	.write = lsm6dsm_spi_write,
+	.read = lsm6dsm_spi_read,
+};
+
+static int lsm6dsm_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm6dsm_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &lsm6dsm_tf_spi;
+	spi_set_drvdata(spi, cdata);
+
+	err = lsm6dsm_common_probe(cdata, spi->irq, BUS_SPI);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lsm6dsm_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lsm6dsm_data *cdata = spi_get_drvdata(spi);
+
+	lsm6dsm_common_remove(cdata, spi->irq);
+	dev_info(cdata->dev, "%s: removed\n", LSM6DSM_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lsm6dsm_suspend(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6dsm_common_suspend(cdata);
+}
+
+static int lsm6dsm_resume(struct device *dev)
+{
+	struct lsm6dsm_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lsm6dsm_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lsm6dsm_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm6dsm_suspend, lsm6dsm_resume)
+};
+
+#define LSM6DSM_PM_OPS		(&lsm6dsm_pm_ops)
+#else /* CONFIG_PM */
+#define LSM6DSM_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lsm6dsm_ids[] = {
+	{ LSM6DSM_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lsm6dsm_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm6dsm_id_table[] = {
+	{ .compatible = "st,lsm6dsm", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm6dsm_id_table);
+#endif
+
+static struct spi_driver lsm6dsm_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LSM6DSM_DEV_NAME,
+		.pm = LSM6DSM_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = lsm6dsm_id_table,
+#endif
+	},
+	.probe    = lsm6dsm_spi_probe,
+	.remove   = lsm6dsm_spi_remove,
+	.id_table = lsm6dsm_ids,
+};
+
+module_spi_driver(lsm6dsm_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lsm6dsm spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm6dsm/Makefile b/drivers/input/misc/st/imu/lsm6dsm/Makefile
--- a/drivers/input/misc/st/imu/lsm6dsm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm6dsm/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM imu lsm6dsm driver
+#
+lsm6dsm-core-y += lsm6dsm_core.o
+obj-$(CONFIG_INPUT_LSM6DSM) += lsm6dsm-core.o
+obj-$(CONFIG_INPUT_LSM6DSM_I2C) += lsm6dsm_i2c.o
+obj-$(CONFIG_INPUT_LSM6DSM_SPI) += lsm6dsm_spi.o
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/Kconfig b/drivers/input/misc/st/imu/lsm9ds0/Kconfig
--- a/drivers/input/misc/st/imu/lsm9ds0/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,21 @@
+
+config INPUT_LSM9DS0
+	tristate "STMicroelectronics LSM9DS0 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM9DS0_I2C if (I2C)
+	select INPUT_LSM9DS0_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM9DS0 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm9ds0.
+
+config INPUT_LSM9DS0_I2C
+	tristate
+	depends on INPUT_LSM9DS0
+	depends on I2C
+
+config INPUT_LSM9DS0_SPI
+	tristate
+	depends on INPUT_LSM9DS0
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag.c b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag.c
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,3199 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics *******************
+*
+* File Name	: lsm9ds0_acc_mag.c
+* Authors	: AMS - Motion Sensors Div - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Denis Ciocca (denis.ciocca@st.com)
+*		: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*		: Authors are willing to be considered the contact
+*		: and update points for the driver.
+* Version       : V.1.0.5
+* Date          : 2016/May/13
+* Description   : LSM9DS0 accelerometer & magnetometer driver
+*
+*******************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+******************************************************************************/
+/******************************************************************************
+Version History.
+
+Revision 1-0-0 2012/05/04
+ first revision
+Revision 1-0-1 2012/05/07
+ New sysfs architecture
+ Support antialiasing filter
+Revision 1-0-2 2012/10/15
+ I2C address bugfix
+Revision 1-0-3 2013/01/21
+ Move CTLREG7 resume write from acc_power_on to magn_power_on
+Revision 1-0-4 2013/05/09
+ Added rotation matrix
+Revision 1-0-5 2013/10/23
+ Corrects Mag Enable bug, Corrects missing BDU enable
+******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include "lsm9ds0.h"
+
+#define MS_TO_NS(x)				((x) * 1000000L)
+#define SEC_PORTION_FROM_MS(x)			(s64)((x) / 1000)
+#define NSEC_PORTION_FROM_MS(x)			MS_TO_NS((x) % 1000)
+
+/* Address registers */
+#define REG_WHOAMI_ADDR		0x0F	/** Who am i address register */
+#define REG_CNTRL0_ADDR		0x1F	/** CNTRL0 address register */
+#define REG_CNTRL1_ADDR		0x20	/** CNTRL1 address register */
+#define REG_CNTRL2_ADDR		0x21	/** CNTRL2 address register */
+#define REG_CNTRL3_ADDR		0x22	/** CNTRL3 address register */
+#define REG_CNTRL4_ADDR		0x23	/** CNTRL4 address register */
+#define REG_CNTRL5_ADDR		0x24	/** CNTRL5 address register */
+#define REG_CNTRL6_ADDR		0x25	/** CNTRL6 address register */
+#define REG_CNTRL7_ADDR		0x26	/** CNTRL7 address register */
+
+#define REG_ACC_DATA_ADDR	0x28	/** Acc. data low address register */
+#define REG_MAG_DATA_ADDR	0x08	/** Mag. data low address register */
+#define REG_TEMP_DATA_ADDR	0x05	/** Temp. data low address register */
+
+#define REG_GEN_MAG_ADDR	0x12	/** INT_CTRL_REG_M address register */
+#define INT_SRC_REG_M_ADDR	0x13	/** INT_SRC_REG_M address register */
+#define REG_GEN_MAG_THR_ADDR	0x14	/** INT_THS_L_M address register */
+#define MIG_THRESHOLD_ADDR_H	0x15	/** INT_THS_H_M address register */
+#define REG_GEN1_AXIS_ADDR	0x30	/** INT_GEN1_REG address register */
+#define INT_GEN1_SRC_ADDR	0x31	/** INT_GEN1_SRC address register */
+#define REG_GEN1_THR_ADDR	0x32	/** INT_GEN1_THS address register */
+#define REG_GEN1_DUR_ADDR	0x33	/** INT_GEN1_DUR address register */
+#define REG_GEN2_AXIS_ADDR	0x34	/** INT_GEN2_REG address register */
+#define INT_GEN2_SRC_ADDR	0x35	/** INT_GEN2_SRC address register */
+#define REG_GEN2_THR_ADDR	0x36	/** INT_GEN2_THS address register */
+#define REG_GEN2_DUR_ADDR	0x37	/** INT_GEN2_DUR address register */
+
+/* Sensitivity [ug/LSB] */
+#define SENSITIVITY_ACC_2G	60
+#define SENSITIVITY_ACC_4G	120
+#define SENSITIVITY_ACC_8G	240
+#define SENSITIVITY_ACC_16G	730
+
+/* [ugauss/LSB] */
+#define SENSITIVITY_MAG_2G	80
+#define SENSITIVITY_MAG_4G	160
+#define SENSITIVITY_MAG_8G	320
+#define SENSITIVITY_MAG_12G	480
+
+/* ODR */
+#define ODR_ACC_MASK		0xF0	/* Mask for odr change on acc */
+#define LSM9DS0_ACC_ODR_OFF	0x00  /* Power down */
+#define LSM9DS0_ACC_ODR3_125	0x10  /* 3.25Hz output data rate */
+#define LSM9DS0_ACC_ODR6_25	0x20  /* 6.25Hz output data rate */
+#define LSM9DS0_ACC_ODR12_5	0x30  /* 12.5Hz output data rate */
+#define LSM9DS0_ACC_ODR25	0x40  /* 25Hz output data rate */
+#define LSM9DS0_ACC_ODR50	0x50  /* 50Hz output data rate */
+#define LSM9DS0_ACC_ODR100	0x60  /* 100Hz output data rate */
+#define LSM9DS0_ACC_ODR200	0x70  /* 200Hz output data rate */
+#define LSM9DS0_ACC_ODR400	0x80  /* 400Hz output data rate */
+#define LSM9DS0_ACC_ODR800	0x90  /* 800Hz output data rate */
+#define LSM9DS0_ACC_ODR1600	0xA0  /* 1600Hz output data rate */
+
+#define ODR_MAG_MASK		0x1C  /* Mask for odr change on mag */
+#define LSM9DS0_MAG_ODR3_125	0x00  /* 3.25Hz output data rate */
+#define LSM9DS0_MAG_ODR6_25	0x04  /* 6.25Hz output data rate */
+#define LSM9DS0_MAG_ODR12_5	0x08  /* 12.5Hz output data rate */
+#define LSM9DS0_MAG_ODR25	0x0C  /* 25Hz output data rate */
+#define LSM9DS0_MAG_ODR50	0x10  /* 50Hz output data rate */
+#define LSM9DS0_MAG_ODR100	0x14  /* 100Hz output data rate */
+
+/* Magnetic sensor mode */
+#define MSMS_MASK		0x03	/* Mask magnetic sensor mode */
+#define POWEROFF_MAG		0x02	/* Power Down */
+#define CONTINUOS_CONVERSION	0x00	/* Continuos Conversion */
+
+/* Default values loaded in probe function */
+#define WHOIAM_VALUE		0x49	/** Who Am I default value */
+#define REG_DEF_CNTRL0		0x00	/** CNTRL0 default value */
+#define REG_DEF_CNTRL1		0x0F	/** CNTRL1 default value */
+#define REG_DEF_CNTRL2		0x00	/** CNTRL2 default value */
+#define REG_DEF_CNTRL3		0x00	/** CNTRL3 default value */
+#define REG_DEF_CNTRL4		0x00	/** CNTRL4 default value */
+#define REG_DEF_CNTRL5		0x18	/** CNTRL5 default value */
+#define REG_DEF_CNTRL6		0x20	/** CNTRL6 default value */
+#define REG_DEF_CNTRL7		0x02	/** CNTRL7 default value */
+
+#define REG_DEF_INT_CNTRL_MAG	0x00	/** INT_CTRL_REG_M default value */
+#define REG_DEF_INT_GEN1	0x00	/** INT_GEN1_REG default value */
+#define REG_DEF_INT_GEN2	0x00	/** INT_GEN2_REG default value */
+#define REG_DEF_IIG1_DURATION	0x00	/** INT_GEN1_DUR default value */
+#define REG_DEF_IIG2_DURATION	0x00	/** INT_GEN2_DUR default value */
+#define REG_DEF_IIG1_THRESHOLD	0x00	/** INT_GEN1_THS default value */
+#define REG_DEF_IIG2_THRESHOLD	0x00	/** INT_GEN2_THS default value */
+#define REG_DEF_MIG_THRESHOLD_L	0x00	/** INT_THS_L_M default value */
+#define REG_DEF_MIG_THRESHOLD_H	0x00	/** INT_THS_H_M default value */
+
+#define REG_DEF_ALL_ZEROS	0x00
+
+/* Accelerometer Filter */
+#define LSM9DS0_ACC_FILTER_MASK	0xC0	/* Mask for filter band change on acc */
+#define FILTER_773		773	/* Anti-Aliasing 773 Hz */
+#define FILTER_362		362	/* Anti-Aliasing 362 Hz */
+#define FILTER_194		194	/* Anti-Aliasing 194 Hz */
+#define FILTER_50		50	/* Anti-Aliasing 50 Hz */
+
+/* Temperature */
+#define TEMP_MASK		0x80	/* Mask for temperature change */
+#define TEMP_ON			0x80	/* Enable temperature */
+#define TEMP_OFF		0x00	/* Disable temperature */
+#define TEMP_SENSITIVITY	8	/* Sensitivity temperature */
+#define OFFSET_TEMP		25	/* Offset temperature */
+#define NDTEMP			1000	/* Not Available temperature */
+
+/* Interrupt */
+#define GEN1_PIN1_MASK		0x20
+#define GEN1_PIN2_MASK		0x40
+#define GEN2_PIN1_MASK		0x10
+#define GEN2_PIN2_MASK		0x20
+#define GEN_MAG_PIN1_MASK	0x08
+#define GEN_MAG_PIN2_MASK	0x10
+#define GEN_MAG_EN_MASK		0x01
+#define MAX_DUR_TH		127
+#define MAX_TH_MAG		131071
+#define GEN_X_HIGH_MASK		0x02
+#define GEN_X_LOW_MASK		0x01
+#define GEN_Y_HIGH_MASK		0x08
+#define GEN_Y_LOW_MASK		0x04
+#define GEN_Z_HIGH_MASK		0x20
+#define GEN_Z_LOW_MASK		0x10
+#define GEN_X_MAG_MASK		0x80
+#define GEN_Y_MAG_MASK		0x40
+#define GEN_Z_MAG_MASK		0x20
+
+#define GEN1_AND_OR_MASK	0x80
+#define GEN2_AND_OR_MASK	0x83
+
+#define INT_PIN_CONF_MASK	0x10
+#define INT_POLARITY_MASK	0x80
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+#define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
+
+static struct kobject *acc_kobj;
+static struct kobject *mag_kobj;
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm9ds0_acc_odr_table[] = {
+	{   1, LSM9DS0_ACC_ODR800  },
+	{   2, LSM9DS0_ACC_ODR400  },
+	{   5, LSM9DS0_ACC_ODR200  },
+	{  10, LSM9DS0_ACC_ODR100  },
+	{  20, LSM9DS0_ACC_ODR50   },
+	{  40, LSM9DS0_ACC_ODR25   },
+	{  80, LSM9DS0_ACC_ODR12_5 },
+	{ 160, LSM9DS0_ACC_ODR6_25 },
+	{ 320, LSM9DS0_ACC_ODR3_125},
+};
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm9ds0_mag_odr_table[] = {
+	{  10, LSM9DS0_MAG_ODR100  },
+	{  20, LSM9DS0_MAG_ODR50   },
+	{  40, LSM9DS0_MAG_ODR25   },
+	{  80, LSM9DS0_MAG_ODR12_5 },
+	{ 160, LSM9DS0_MAG_ODR6_25 },
+	{ 320, LSM9DS0_MAG_ODR3_125},
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	u8 address;
+	u8 mask;
+};
+
+struct interrupt_value {
+	int value;
+	u8 address;
+};
+
+struct lsm9ds0_interrupt {
+	struct interrupt_enable gen1_pin1;
+	struct interrupt_enable gen1_pin2;
+	struct interrupt_enable gen2_pin1;
+	struct interrupt_enable gen2_pin2;
+	struct interrupt_value gen1_threshold;
+	struct interrupt_value gen2_threshold;
+	struct interrupt_value gen1_duration;
+	struct interrupt_value gen2_duration;
+	struct interrupt_enable gen_mag_pin1;
+	struct interrupt_enable gen_mag_pin2;
+	struct interrupt_enable gen_mag;
+	struct interrupt_value gen_mag_threshold;
+	struct interrupt_enable gen1_axis[6];
+	struct interrupt_enable gen2_axis[6];
+	struct interrupt_enable gen_mag_axis[3];
+	struct interrupt_enable gen1_and_or;
+	struct interrupt_enable gen2_and_or;
+	struct interrupt_enable interrupt_pin_conf;
+	struct interrupt_enable interrupt_polarity;
+};
+
+static const struct lsm9ds0_acc_platform_data default_lsm9ds0_acc_pdata = {
+	.fs_range = LSM9DS0_ACC_FS_2G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+	.poll_interval = 100,
+	.min_interval = LSM9DS0_ACC_MIN_POLL_PERIOD_MS,
+	.aa_filter_bandwidth = ANTI_ALIASING_773,
+	.gpio_int1 = DEFAULT_INT1_GPIO,
+	.gpio_int2 = DEFAULT_INT2_GPIO,
+};
+
+static const struct lsm9ds0_mag_platform_data default_lsm9ds0_mag_pdata = {
+	.poll_interval = 100,
+	.min_interval = LSM9DS0_MAG_MIN_POLL_PERIOD_MS,
+	.fs_range = LSM9DS0_MAG_FS_2G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+};
+
+struct reg_rw {
+	u8 address;
+	u8 default_value;
+	u8 resume_value;
+};
+
+struct reg_r {
+	u8 address;
+	u8 value;
+};
+
+static struct status_registers {
+	struct reg_r who_am_i;
+	struct reg_rw cntrl0;
+	struct reg_rw cntrl1;
+	struct reg_rw cntrl2;
+	struct reg_rw cntrl3;
+	struct reg_rw cntrl4;
+	struct reg_rw cntrl5;
+	struct reg_rw cntrl6;
+	struct reg_rw cntrl7;
+	struct reg_rw int_ctrl_reg_m;
+	struct reg_rw int_mag_threshold_low;
+	struct reg_rw int_mag_threshold_high;
+	struct reg_rw int_gen1_reg;
+	struct reg_rw int_gen2_reg;
+	struct reg_rw int_gen1_duration;
+	struct reg_rw int_gen2_duration;
+	struct reg_rw int_gen1_threshold;
+	struct reg_rw int_gen2_threshold;
+	struct reg_r int_src_reg_m;
+	struct reg_r int_gen1_src;
+	struct reg_r int_gen2_src;
+	struct reg_r int_gen_mag_src;
+} status_registers = {
+	.who_am_i.address=REG_WHOAMI_ADDR, .who_am_i.value=WHOIAM_VALUE,
+	.cntrl0.address=REG_CNTRL0_ADDR, .cntrl0.default_value=REG_DEF_CNTRL0,
+	.cntrl1.address=REG_CNTRL1_ADDR, .cntrl1.default_value=REG_DEF_CNTRL1,
+	.cntrl2.address=REG_CNTRL2_ADDR, .cntrl2.default_value=REG_DEF_CNTRL2,
+	.cntrl3.address=REG_CNTRL3_ADDR, .cntrl3.default_value=REG_DEF_CNTRL3,
+	.cntrl4.address=REG_CNTRL4_ADDR, .cntrl4.default_value=REG_DEF_CNTRL4,
+	.cntrl5.address=REG_CNTRL5_ADDR, .cntrl5.default_value=REG_DEF_CNTRL5,
+	.cntrl6.address=REG_CNTRL6_ADDR, .cntrl6.default_value=REG_DEF_CNTRL6,
+	.cntrl7.address=REG_CNTRL7_ADDR, .cntrl7.default_value=REG_DEF_CNTRL7,
+	.int_ctrl_reg_m.address=REG_GEN_MAG_ADDR,
+		.int_ctrl_reg_m.default_value=REG_DEF_INT_CNTRL_MAG,
+	.int_mag_threshold_low.address=REG_GEN_MAG_THR_ADDR,
+		.int_mag_threshold_low.default_value=REG_DEF_MIG_THRESHOLD_L,
+	.int_mag_threshold_low.address=MIG_THRESHOLD_ADDR_H,
+		.int_mag_threshold_low.default_value=REG_DEF_MIG_THRESHOLD_H,
+	.int_gen1_reg.address=REG_GEN1_AXIS_ADDR,
+		.int_gen1_reg.default_value=REG_DEF_INT_GEN1,
+	.int_gen2_reg.address=REG_GEN2_AXIS_ADDR,
+		.int_gen2_reg.default_value=REG_DEF_INT_GEN2,
+	.int_gen1_duration.address=REG_GEN1_DUR_ADDR,
+		.int_gen1_duration.default_value=REG_DEF_IIG1_DURATION,
+	.int_gen2_duration.address=REG_GEN2_DUR_ADDR,
+		.int_gen2_duration.default_value=REG_DEF_IIG2_DURATION,
+	.int_gen1_threshold.address=REG_GEN1_THR_ADDR,
+		.int_gen1_threshold.default_value=REG_DEF_IIG1_THRESHOLD,
+	.int_gen2_threshold.address=REG_GEN2_THR_ADDR,
+		.int_gen2_threshold.default_value=REG_DEF_IIG2_THRESHOLD,
+	.int_src_reg_m.address = INT_SRC_REG_M_ADDR,
+				.int_src_reg_m.value = REG_DEF_ALL_ZEROS,
+	.int_gen1_src.address = INT_GEN1_SRC_ADDR,
+				.int_gen1_src.value = REG_DEF_ALL_ZEROS,
+	.int_gen2_src.address = INT_GEN2_SRC_ADDR,
+				.int_gen2_src.value = REG_DEF_ALL_ZEROS,
+	.int_gen_mag_src.address = INT_SRC_REG_M_ADDR,
+				.int_gen_mag_src.value = REG_DEF_ALL_ZEROS,
+};
+
+static int lsm9ds0_check_whoami(struct lsm9ds0_dev *dev)
+{
+	int err;
+	u8 data;
+
+	err = dev->tf->read(dev->dev, status_registers.who_am_i.address, 1,
+			    &data);
+	if (err < 0) {
+		dev_warn(dev->dev, "error reading who_am_i\n");
+		return err;
+	} else
+		dev->hw_working = 1;
+
+	if (data != status_registers.who_am_i.value) {
+		dev_err(dev->dev,
+			"device unknown. expected: 0x%02x-0x%02x\n",
+			status_registers.who_am_i.value, data);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_hw_init(struct lsm9ds0_dev *dev)
+{
+	int i, err = -1;
+
+#ifdef LSM9DS0_DEBUG
+	pr_info("%s: hw init start\n", LSM9DS0_DEV_NAME);
+#endif
+
+	status_registers.cntrl1.resume_value =
+					status_registers.cntrl1.default_value;
+	status_registers.cntrl2.resume_value =
+					status_registers.cntrl2.default_value;
+	status_registers.cntrl3.resume_value =
+					status_registers.cntrl3.default_value;
+	status_registers.cntrl4.resume_value =
+					status_registers.cntrl4.default_value;
+	status_registers.cntrl5.resume_value =
+					status_registers.cntrl5.default_value;
+	status_registers.cntrl6.resume_value =
+					status_registers.cntrl6.default_value;
+	status_registers.cntrl7.resume_value =
+					status_registers.cntrl7.default_value;
+
+	status_registers.int_ctrl_reg_m.resume_value =
+			status_registers.int_ctrl_reg_m.default_value;
+	status_registers.int_mag_threshold_low.resume_value =
+			status_registers.int_mag_threshold_low.default_value;
+	status_registers.int_mag_threshold_high.resume_value =
+			status_registers.int_mag_threshold_high.default_value;
+	status_registers.int_gen1_reg.resume_value =
+			status_registers.int_gen1_reg.default_value;
+	status_registers.int_gen2_reg.resume_value =
+			status_registers.int_gen2_reg.default_value;
+	status_registers.int_gen1_duration.resume_value =
+			status_registers.int_gen1_duration.default_value;
+	status_registers.int_gen2_duration.resume_value =
+			status_registers.int_gen2_duration.default_value;
+	status_registers.int_gen1_threshold.resume_value =
+			status_registers.int_gen1_threshold.default_value;
+	status_registers.int_gen2_threshold.resume_value =
+			status_registers.int_gen2_threshold.default_value;
+
+
+	dev->temp_value_dec = NDTEMP;
+
+	if ((dev->pdata_acc->gpio_int1 >= 0) ||
+	    (dev->pdata_acc->gpio_int2 >= 0)) {
+
+		dev->interrupt = kmalloc(sizeof(*dev->interrupt), GFP_KERNEL);
+		if (dev->interrupt == NULL)
+			goto error_interrupt;
+
+		dev->interrupt->gen1_pin1.address = REG_CNTRL3_ADDR;
+		dev->interrupt->gen1_pin2.address = REG_CNTRL4_ADDR;
+		dev->interrupt->gen2_pin1.address = REG_CNTRL3_ADDR;
+		dev->interrupt->gen2_pin2.address = REG_CNTRL4_ADDR;
+		dev->interrupt->gen_mag_pin1.address = REG_CNTRL3_ADDR;
+		dev->interrupt->gen_mag_pin2.address = REG_CNTRL4_ADDR;
+		dev->interrupt->gen_mag.address = REG_GEN_MAG_ADDR;
+		dev->interrupt->gen1_duration.address = REG_GEN1_DUR_ADDR;
+		dev->interrupt->gen2_duration.address = REG_GEN2_DUR_ADDR;
+		dev->interrupt->gen1_threshold.address = REG_GEN1_THR_ADDR;
+		dev->interrupt->gen2_threshold.address = REG_GEN2_THR_ADDR;
+		dev->interrupt->gen_mag_threshold.address =
+							REG_GEN_MAG_THR_ADDR;
+
+		dev->interrupt->gen1_pin1.mask = GEN1_PIN1_MASK;
+		dev->interrupt->gen1_pin2.mask = GEN1_PIN2_MASK;
+		dev->interrupt->gen2_pin1.mask = GEN2_PIN1_MASK;
+		dev->interrupt->gen2_pin2.mask = GEN2_PIN2_MASK;
+		dev->interrupt->gen_mag_pin1.mask = GEN_MAG_PIN1_MASK;
+		dev->interrupt->gen_mag_pin2.mask = GEN_MAG_PIN2_MASK;
+		dev->interrupt->gen_mag.mask = GEN_MAG_EN_MASK;
+
+		atomic_set(&dev->interrupt->gen1_pin1.enable, 0);
+		atomic_set(&dev->interrupt->gen1_pin2.enable, 0);
+		atomic_set(&dev->interrupt->gen2_pin1.enable, 0);
+		atomic_set(&dev->interrupt->gen2_pin2.enable, 0);
+		atomic_set(&dev->interrupt->gen_mag_pin1.enable, 0);
+		atomic_set(&dev->interrupt->gen_mag_pin2.enable, 0);
+		atomic_set(&dev->interrupt->gen_mag.enable, 0);
+
+		dev->interrupt->gen1_threshold.value = 0;
+		dev->interrupt->gen2_threshold.value = 0;
+		dev->interrupt->gen1_duration.value = 0;
+		dev->interrupt->gen2_duration.value = 0;
+		dev->interrupt->gen_mag_threshold.value = 0;
+
+		for (i = 0; i < 6; i++) {
+			dev->interrupt->gen1_axis[i].address =
+						REG_GEN1_AXIS_ADDR;
+			dev->interrupt->gen2_axis[i].address =
+						REG_GEN2_AXIS_ADDR;
+
+			atomic_set(&dev->interrupt->gen1_axis[i].enable, 0);
+			atomic_set(&dev->interrupt->gen2_axis[i].enable, 0);
+		}
+
+		for (i = 0; i < 3; i++) {
+			dev->interrupt->gen_mag_axis[i].address =
+						REG_GEN_MAG_ADDR;
+			atomic_set(&dev->interrupt->gen_mag_axis[i].enable, 0);
+		}
+
+		dev->interrupt->gen1_axis[0].mask = GEN_X_LOW_MASK;
+		dev->interrupt->gen1_axis[1].mask = GEN_Y_LOW_MASK;
+		dev->interrupt->gen1_axis[2].mask = GEN_Z_LOW_MASK;
+		dev->interrupt->gen1_axis[3].mask = GEN_X_HIGH_MASK;
+		dev->interrupt->gen1_axis[4].mask = GEN_Y_HIGH_MASK;
+		dev->interrupt->gen1_axis[5].mask = GEN_Z_HIGH_MASK;
+
+		dev->interrupt->gen2_axis[0].mask = GEN_X_LOW_MASK;
+		dev->interrupt->gen2_axis[1].mask = GEN_Y_LOW_MASK;
+		dev->interrupt->gen2_axis[2].mask = GEN_Z_LOW_MASK;
+		dev->interrupt->gen2_axis[3].mask = GEN_X_HIGH_MASK;
+		dev->interrupt->gen2_axis[4].mask = GEN_Y_HIGH_MASK;
+		dev->interrupt->gen2_axis[5].mask = GEN_Z_HIGH_MASK;
+
+		dev->interrupt->gen_mag_axis[0].mask = GEN_X_MAG_MASK;
+		dev->interrupt->gen_mag_axis[1].mask = GEN_Y_MAG_MASK;
+		dev->interrupt->gen_mag_axis[2].mask = GEN_Z_MAG_MASK;
+
+		dev->interrupt->gen1_and_or.address = REG_GEN1_AXIS_ADDR;
+		dev->interrupt->gen1_and_or.mask = GEN1_AND_OR_MASK;
+		atomic_set(&dev->interrupt->gen1_and_or.enable, 0);
+		dev->interrupt->gen2_and_or.address = REG_GEN1_DUR_ADDR;
+		dev->interrupt->gen2_and_or.mask = GEN2_AND_OR_MASK;
+		atomic_set(&dev->interrupt->gen2_and_or.enable, 0);
+
+		dev->interrupt->interrupt_pin_conf.address = REG_GEN_MAG_ADDR;
+		dev->interrupt->interrupt_pin_conf.mask = INT_PIN_CONF_MASK;
+		atomic_set(&dev->interrupt->interrupt_pin_conf.enable, 0);
+
+		dev->interrupt->interrupt_polarity.address = REG_GEN_MAG_ADDR;
+		dev->interrupt->interrupt_polarity.mask = INT_POLARITY_MASK;
+		atomic_set(&dev->interrupt->interrupt_polarity.enable, 0);
+	}
+
+	dev->hw_initialized = 1;
+
+#ifdef LSM9DS0_DEBUG
+	pr_info("%s: hw init done\n", LSM9DS0_DEV_NAME);
+#endif
+
+	return 0;
+
+error_interrupt:
+	dev->hw_working = 0;
+	dev->hw_initialized = 0;
+	return err;
+}
+
+static irqreturn_t lsm9ds0_isr1(int irq, void *data)
+{
+	struct lsm9ds0_dev *dev = (struct lsm9ds0_dev *)data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq1_work_queue, &dev->irq1_work);
+	pr_debug("%s: isr1 queued\n", LSM9DS0_DEV_NAME);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lsm9ds0_isr2(int irq, void *data)
+{
+	struct lsm9ds0_dev *dev = (struct lsm9ds0_dev *)data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq2_work_queue, &dev->irq2_work);
+	pr_debug("%s: isr2 queued\n", LSM9DS0_DEV_NAME);
+	return IRQ_HANDLED;
+}
+
+static void lsm9ds0_interrupt_catch(struct lsm9ds0_dev *dev, int pin) 
+{
+	u8 buf[1];
+	u8 val;
+
+	mutex_lock(&dev->lock);
+	if (atomic_read(&dev->interrupt->gen1_pin1.enable) == 1) {
+		val = dev->tf->read(dev->dev,
+				    status_registers.int_gen1_src.address, 1,
+				    buf);
+		if (val < 0)
+			return;
+		status_registers.int_gen1_src.value = buf[0];
+
+		if (((int)status_registers.int_gen1_src.value) > 64)
+			pr_info("interrupt send by acc interrupt generator 1\n");
+	}
+
+	if (atomic_read(&dev->interrupt->gen_mag_pin1.enable) == 1) {
+		val = dev->tf->read(dev->dev,
+				    status_registers.int_gen_mag_src.address,
+				    1, buf);
+		if(val < 0)
+			return;
+		status_registers.int_gen_mag_src.value = buf[0];
+
+		if (((int)status_registers.int_gen_mag_src.value) > 1)
+			pr_info("interrupt send by magn interrupt generator\n");
+	}
+	mutex_unlock(&dev->lock);
+}
+
+static void lsm9ds0_irq1_work_func(struct work_struct *work)
+{
+
+	struct lsm9ds0_dev *dev;
+
+	dev = container_of(work, struct lsm9ds0_dev, irq1_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm9ds0_get_int1_source(dev); */
+
+	lsm9ds0_interrupt_catch(dev, 1);
+	pr_info("%s: IRQ1 triggered\n", LSM9DS0_DEV_NAME);
+
+	enable_irq(dev->irq1);
+}
+
+static void lsm9ds0_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm9ds0_dev *dev;
+
+	dev = container_of(work, struct lsm9ds0_dev, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm9ds0_get_int2_source(dev); */
+
+	lsm9ds0_interrupt_catch(dev, 2);
+	pr_info("%s: IRQ2 triggered\n", LSM9DS0_DEV_NAME);
+
+	enable_irq(dev->irq2);
+}
+
+static int lsm9ds0_acc_device_power_off(struct lsm9ds0_dev *dev)
+{
+	int err;
+	u8 buf[1];
+
+	buf[0] = ((ODR_ACC_MASK & LSM9DS0_ACC_ODR_OFF) | 
+		  (~ODR_ACC_MASK & status_registers.cntrl1.resume_value));
+
+	err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 1,
+			     buf);
+	if (err < 0)
+		dev_err(dev->dev, "accelerometer soft power off failed: %d\n",
+			err);
+
+	if (dev->pdata_acc->power_off) {
+		dev->pdata_acc->power_off();
+	}
+
+	atomic_set(&dev->enabled_acc, 0);
+
+	return 0;
+}
+
+static int lsm9ds0_mag_device_power_off(struct lsm9ds0_dev *dev)
+{
+	int err;
+	u8 buf[1];
+
+	buf[0] = ((MSMS_MASK & POWEROFF_MAG) |
+		  (~MSMS_MASK & status_registers.cntrl7.resume_value));
+
+	err = dev->tf->write(dev->dev, status_registers.cntrl7.address, 1,
+			     buf);
+	if (err < 0)
+		dev_err(dev->dev, "magn soft power off failed: %d\n", err);
+
+	if (dev->pdata_mag->power_off) {
+		dev->pdata_mag->power_off();
+	}
+
+	atomic_set(&dev->enabled_mag, 0);
+
+	return 0;
+}
+
+static int lsm9ds0_acc_device_power_on(struct lsm9ds0_dev *dev)
+{
+	int err = -1;
+	u8 buf[4];
+
+	if (dev->pdata_acc->power_on) {
+		err = dev->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(dev->dev,
+				"accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.cntrl0.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl0.address, 1,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.cntrl1.resume_value;
+	buf[1] = status_registers.cntrl2.resume_value;
+	buf[2] = status_registers.cntrl3.resume_value;
+	buf[3] = status_registers.cntrl4.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen1_reg.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_gen1_reg.address, 1,
+			 buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen1_threshold.resume_value;
+	buf[1] = status_registers.int_gen1_duration.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_gen1_threshold.address,
+			 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen2_reg.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_gen2_reg.address, 1,
+			 buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen2_threshold.resume_value;
+	buf[1] = status_registers.int_gen2_duration.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_gen2_threshold.address,
+			 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_acc, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&dev->enabled_acc, 0);
+	dev_err(dev->dev, "accelerometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm9ds0_mag_device_power_on(struct lsm9ds0_dev *dev)
+{
+	int err = -1;
+	u8 buf[5];
+
+	if (dev->pdata_mag->power_on) {
+		err = dev->pdata_mag->power_on();
+		if (err < 0) {
+			dev_err(dev->dev,
+				"magnetometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.cntrl0.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl0.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.cntrl3.resume_value;
+	buf[1] = status_registers.cntrl4.resume_value;
+	buf[2] = status_registers.cntrl5.resume_value;
+	buf[3] = status_registers.cntrl6.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.cntrl3.address, 4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_ctrl_reg_m.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_ctrl_reg_m.address,
+			 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_mag_threshold_low.resume_value;
+	buf[1] = status_registers.int_mag_threshold_high.resume_value;
+	err = dev->tf->write(dev->dev,
+			 status_registers.int_mag_threshold_low.address,
+			 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = ((MSMS_MASK & CONTINUOS_CONVERSION) |
+		  (~MSMS_MASK & status_registers.cntrl7.resume_value));
+	err = dev->tf->write(dev->dev, status_registers.cntrl7.address, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_mag, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&dev->enabled_mag, 0);
+	dev_err(dev->dev, "magnetometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm9ds0_acc_update_filter(struct lsm9ds0_dev *dev,
+				     u8 new_bandwidth)
+{
+	int err;
+	u8 updated_val, buf[1];
+
+	switch (new_bandwidth) {
+	case ANTI_ALIASING_50:
+		break;
+	case ANTI_ALIASING_194:
+		break;
+	case ANTI_ALIASING_362:
+		break;
+	case ANTI_ALIASING_773:
+		break;
+	default:
+		dev_err(dev->dev, "invalid accelerometer "
+			"update bandwidth requested: %u\n", new_bandwidth);
+		return -EINVAL;
+	}
+
+	err = dev->tf->read(dev->dev, status_registers.cntrl2.address, 1,
+			    buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl2.resume_value = buf[0];
+	updated_val = ((LSM9DS0_ACC_FILTER_MASK & new_bandwidth) |
+		       (~LSM9DS0_ACC_FILTER_MASK & buf[0]));
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.cntrl2.address, 1, buf);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl2.resume_value = updated_val;
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer fs range failed "
+		"0x%02x: %d\n", buf[0], err);
+	return err;
+}
+
+static int lsm9ds0_acc_update_fs_range(struct lsm9ds0_dev *dev,
+				       u8 new_fs_range)
+{
+	int err=-1;
+	u16 sensitivity;
+	u8 updated_val;
+	u8 buf[1];
+
+	switch (new_fs_range) {
+	case LSM9DS0_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case LSM9DS0_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case LSM9DS0_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	case LSM9DS0_ACC_FS_16G:
+		sensitivity = SENSITIVITY_ACC_16G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid accelerometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	err = dev->tf->read(dev->dev, status_registers.cntrl2.address, 1,
+			    buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl2.resume_value = buf[0];
+	updated_val = ((LSM9DS0_ACC_FS_MASK & new_fs_range) |
+		       (~LSM9DS0_ACC_FS_MASK & buf[0]));
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.cntrl2.address, 1, buf);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl2.resume_value = updated_val;
+	dev->sensitivity_acc = sensitivity;
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer fs range failed "
+		"0x%02x %d\n", buf[0], err);
+	return err;
+}
+
+static int lsm9ds0_mag_update_fs_range(struct lsm9ds0_dev *dev,
+				       u8 new_fs_range)
+{
+	int err=-1;
+	u16 sensitivity;
+	u8 buf[1];
+
+	switch (new_fs_range) {
+	case LSM9DS0_MAG_FS_2G:
+		sensitivity = SENSITIVITY_MAG_2G;
+		break;
+	case LSM9DS0_MAG_FS_4G:
+		sensitivity = SENSITIVITY_MAG_4G;
+		break;
+	case LSM9DS0_MAG_FS_8G:
+		sensitivity = SENSITIVITY_MAG_8G;
+		break;
+	case LSM9DS0_MAG_FS_12G:
+		sensitivity = SENSITIVITY_MAG_12G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid magnetometer "
+				"fs range requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	err = dev->tf->read(dev->dev, status_registers.cntrl6.address, 1,
+			    buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.cntrl6.resume_value = buf[0];
+	buf[0] = (LSM9DS0_MAG_FS_MASK & new_fs_range);
+	err = dev->tf->write(dev->dev, status_registers.cntrl6.address, 1, buf);
+	if (err < 0)
+		goto error;
+	status_registers.cntrl6.resume_value = buf[0];
+	dev->sensitivity_mag = sensitivity;
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update magnetometer fs range failed "
+		"0x%02x: %d\n", buf[0], err);
+	return err;
+}
+
+static int lsm9ds0_acc_update_odr(struct lsm9ds0_dev *dev,
+				  unsigned int poll_ms)
+{
+	int i, err = -1;
+	u8 config[1];
+
+	for (i = ARRAY_SIZE(lsm9ds0_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lsm9ds0_acc_odr_table[i].cutoff_us <= poll_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	config[0] = ((ODR_ACC_MASK & lsm9ds0_acc_odr_table[i].value) |
+		     (~ODR_ACC_MASK & status_registers.cntrl1.resume_value));
+
+	if (atomic_read(&dev->enabled_acc)) {
+		err = dev->tf->write(dev->dev, status_registers.cntrl1.address, 1,
+				 config);
+		if (err < 0)
+			goto error;
+	}
+
+	status_registers.cntrl1.resume_value = config[0];
+	dev->ktime_acc = ktime_set(SEC_PORTION_FROM_MS(poll_ms),
+				   NSEC_PORTION_FROM_MS(poll_ms));
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer odr failed "
+		"0x%02x: %d\n", config[0], err);
+
+	return err;
+}
+
+static int lsm9ds0_mag_update_odr(struct lsm9ds0_dev *dev,
+				  unsigned int poll_ms)
+{
+	int i, err = -1;
+	u8 config[0];
+
+	for (i = ARRAY_SIZE(lsm9ds0_mag_odr_table) - 1; i >= 0; i--) {
+		if ((lsm9ds0_mag_odr_table[i].cutoff_us <= poll_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	config[0] = ((ODR_MAG_MASK & lsm9ds0_mag_odr_table[i].value) |
+		     (~ODR_MAG_MASK & status_registers.cntrl5.resume_value));
+
+	if (atomic_read(&dev->enabled_mag)) {
+		err = dev->tf->write(dev->dev, status_registers.cntrl5.address,
+				     1, config);
+		if (err < 0)
+			goto error;
+	}
+
+	status_registers.cntrl5.resume_value = config[0];
+	dev->ktime_mag = ktime_set(SEC_PORTION_FROM_MS(poll_ms),
+				   NSEC_PORTION_FROM_MS(poll_ms));
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update magnetometer odr failed "
+			"0x%02x,0x%02x: %d\n", config[0], config[1], err);
+
+	return err;
+}
+
+static void lsm9ds0_validate_polling(unsigned int *min_interval,
+				     unsigned int *poll_interval,
+				     unsigned int min)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int lsm9ds0_acc_validate_pdata(struct lsm9ds0_dev *dev)
+{
+	int res = -EINVAL;
+
+	lsm9ds0_validate_polling(&dev->pdata_acc->min_interval,
+				&dev->pdata_acc->poll_interval,
+				(unsigned int)LSM9DS0_ACC_MIN_POLL_PERIOD_MS);
+
+	switch (dev->pdata_acc->aa_filter_bandwidth) {
+		case ANTI_ALIASING_50:
+			res = 1;
+			break;
+		case ANTI_ALIASING_194:
+			res = 1;
+			break;
+		case ANTI_ALIASING_362:
+			res = 1;
+			break;
+		case ANTI_ALIASING_773:
+			res = 1;
+			break;
+		default:
+			dev_err(dev->dev, "invalid accelerometer "
+				"bandwidth selected: %u\n",
+					dev->pdata_acc->aa_filter_bandwidth);
+	}
+
+	return res;
+}
+
+static int lsm9ds0_mag_validate_pdata(struct lsm9ds0_dev *dev)
+{
+	lsm9ds0_validate_polling(&dev->pdata_mag->min_interval,
+				&dev->pdata_mag->poll_interval,
+				(unsigned int)LSM9DS0_MAG_MIN_POLL_PERIOD_MS);
+
+	return 0;
+}
+
+static int lsm9ds0_acc_enable(struct lsm9ds0_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled_acc, 0, 1)) {
+		int err;
+
+		mutex_lock(&dev->lock);
+		err = lsm9ds0_acc_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled_acc, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		hrtimer_start(&dev->hr_timer_acc, dev->ktime_acc,
+			      HRTIMER_MODE_REL);
+		if (!atomic_read(&dev->enabled_mag)) {
+			if (dev->pdata_acc->gpio_int1 >= 0)
+				enable_irq(dev->irq1);
+			if (dev->pdata_acc->gpio_int2 >= 0)
+				enable_irq(dev->irq2);
+		}
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_acc_disable(struct lsm9ds0_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_acc, 1, 0)) {
+		cancel_work_sync(&dev->input_work_acc);
+
+		mutex_lock(&dev->lock);
+		hrtimer_cancel(&dev->hr_timer_acc);
+		lsm9ds0_acc_device_power_off(dev);
+
+		if (!atomic_read(&dev->enabled_mag)) {
+			if (dev->pdata_acc->gpio_int1 >= 0)
+				disable_irq_nosync(dev->irq1);
+			if (dev->pdata_acc->gpio_int2 >= 0)
+				disable_irq_nosync(dev->irq2);
+		}
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_mag_enable(struct lsm9ds0_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled_mag, 0, 1)) {
+		int err;
+
+		mutex_lock(&dev->lock);
+		err = lsm9ds0_mag_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled_mag, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		if (!atomic_read(&dev->enabled_temp)) {
+			hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag,
+				      HRTIMER_MODE_REL);
+		}
+		if (!atomic_read(&dev->enabled_acc)) {
+			if (dev->pdata_acc->gpio_int1 >= 0)
+				enable_irq(dev->irq1);
+			if (dev->pdata_acc->gpio_int2 >= 0)
+				enable_irq(dev->irq2);
+		}
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_mag_disable(struct lsm9ds0_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_mag, 1, 0)) {
+		if (!atomic_read(&dev->enabled_temp)) {
+			cancel_work_sync(&dev->input_work_mag);
+			hrtimer_cancel(&dev->hr_timer_mag);
+		}
+
+		mutex_lock(&dev->lock);
+		lsm9ds0_mag_device_power_off(dev);
+		if (!atomic_read(&dev->enabled_acc)) {
+			if (dev->pdata_acc->gpio_int1 >= 0)
+				disable_irq(dev->irq1);
+			if (dev->pdata_acc->gpio_int2 >= 0)
+				disable_irq(dev->irq2);
+		}
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_temperature_enable(struct lsm9ds0_dev *dev)
+{
+	int err;
+	u8 buf[1];
+	u8 updated_val;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, status_registers.cntrl5.address, 1,
+			    buf);
+	if (err < 0)
+		goto out;
+
+	status_registers.cntrl5.resume_value = buf[0];
+	updated_val = ((TEMP_MASK & TEMP_ON) | (~TEMP_MASK & buf[0]));
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.cntrl5.address, 1,
+			     buf);
+	if (err < 0)
+		goto out;
+	status_registers.cntrl5.resume_value = updated_val;
+
+	if (!atomic_read(&dev->enabled_mag))
+		hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag,
+			      HRTIMER_MODE_REL);
+
+	atomic_set(&dev->enabled_temp, 1);
+
+out:
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+
+static int lsm9ds0_temperature_disable(struct lsm9ds0_dev *dev)
+{
+	int err;
+	u8 buf[1];
+	u8 updated_val;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, status_registers.cntrl5.address, 1,
+			    buf);
+	if (err < 0)
+		goto err;
+
+	status_registers.cntrl5.resume_value = buf[0];	
+	updated_val = ((TEMP_MASK & TEMP_OFF) | (~TEMP_MASK & buf[0]));
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.cntrl5.address, 1,
+			     buf);
+	if (err < 0)
+		goto err;
+	status_registers.cntrl5.resume_value = updated_val;
+	mutex_unlock(&dev->lock);
+
+	if (!atomic_read(&dev->enabled_mag)) {
+		cancel_work_sync(&dev->input_work_mag);
+		hrtimer_cancel(&dev->hr_timer_mag);
+	}
+	atomic_set(&dev->enabled_temp, 0);
+	dev->temp_value_dec = NDTEMP;
+
+	return 0;
+
+err:
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+
+int lsm9ds0_enable(struct lsm9ds0_dev *dev)
+{
+	int err;
+
+	err = lsm9ds0_acc_enable(dev);
+	if (err < 0)
+		return err;
+
+	err = lsm9ds0_mag_enable(dev);
+	if (err < 0)
+		return err;
+
+	return lsm9ds0_temperature_enable(dev);
+}
+EXPORT_SYMBOL(lsm9ds0_enable);
+
+int lsm9ds0_disable(struct lsm9ds0_dev *dev)
+{
+	int err;
+
+	err = lsm9ds0_acc_disable(dev);
+	if (err < 0)
+		return err;
+
+	err = lsm9ds0_mag_disable(dev);
+	if (err < 0)
+		return err;
+
+	return lsm9ds0_temperature_disable(dev);
+
+}
+EXPORT_SYMBOL(lsm9ds0_disable);
+
+static void lsm9ds0_acc_input_cleanup(struct lsm9ds0_dev *dev)
+{
+	input_unregister_device(dev->input_dev_acc);
+	input_free_device(dev->input_dev_acc);
+}
+
+static void lsm9ds0_mag_input_cleanup(struct lsm9ds0_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static ssize_t attr_get_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	mutex_lock(&dev->lock);
+	val = dev->pdata_acc->poll_interval;
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_get_polling_rate_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	mutex_lock(&dev->lock);
+	val = dev->pdata_mag->poll_interval;
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate_acc(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+						dev->pdata_acc->min_interval);
+	mutex_lock(&dev->lock);
+	dev->pdata_acc->poll_interval = (unsigned int)interval_ms;
+	lsm9ds0_acc_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_set_polling_rate_mag(struct kobject *kobj,
+					 struct kobj_attribute *attr,
+					 const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+					dev->pdata_mag->min_interval);
+	mutex_lock(&dev->lock);
+	dev->pdata_mag->poll_interval = (unsigned int)interval_ms;
+	lsm9ds0_mag_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_acc(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", (int)atomic_read(&dev->enabled_acc));
+}
+
+static ssize_t attr_get_enable_mag(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", (int)atomic_read(&dev->enabled_mag));
+}
+
+static ssize_t attr_set_enable_acc(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm9ds0_acc_enable(dev);
+	else
+		lsm9ds0_acc_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_set_enable_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm9ds0_mag_enable(dev);
+	else
+		lsm9ds0_mag_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	u8 val;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	int range = 2;
+	mutex_lock(&dev->lock);
+	val = dev->pdata_acc->fs_range ;
+	switch (val) {
+	case LSM9DS0_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM9DS0_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM9DS0_ACC_FS_8G:
+		range = 8;
+		break;
+	case LSM9DS0_ACC_FS_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_get_range_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	u8 val;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	int range = 2;
+	mutex_lock(&dev->lock);
+	val = dev->pdata_mag->fs_range ;
+	switch (val) {
+	case LSM9DS0_MAG_FS_2G:
+		range = 2;
+		break;
+	case LSM9DS0_MAG_FS_4G:
+		range = 4;
+		break;
+	case LSM9DS0_MAG_FS_8G:
+		range = 8;
+		break;
+	case LSM9DS0_MAG_FS_12G:
+		range = 12;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM9DS0_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM9DS0_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM9DS0_ACC_FS_8G;
+		break;
+	case 16:
+		range = LSM9DS0_ACC_FS_16G;
+		break;
+	default:
+		dev_err(dev->dev, "accelerometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_acc_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_acc->fs_range = range;
+	mutex_unlock(&dev->lock);
+	dev_info(dev->dev, "accelerometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_set_range_mag(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 2:
+		range = LSM9DS0_MAG_FS_2G;
+		break;
+	case 4:
+		range = LSM9DS0_MAG_FS_4G;
+		break;
+	case 8:
+		range = LSM9DS0_MAG_FS_8G;
+		break;
+	case 12:
+		range = LSM9DS0_MAG_FS_12G;
+		break;
+	default:
+		dev_err(dev->dev, "magnetometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_mag_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_mag->fs_range = range;
+	mutex_unlock(&dev->lock);
+	dev_info(dev->dev, "magnetometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	u8 val;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	int frequency=FILTER_773;
+	mutex_lock(&dev->lock);
+	val = dev->pdata_acc->aa_filter_bandwidth;
+	switch (val) {
+	case ANTI_ALIASING_50:
+		frequency = FILTER_50;
+		break;
+	case ANTI_ALIASING_194:
+		frequency = FILTER_194;
+		break;
+	case ANTI_ALIASING_362:
+		frequency = FILTER_362;
+		break;
+	case ANTI_ALIASING_773:
+		frequency = FILTER_773;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%d\n", frequency);
+}
+
+static ssize_t attr_set_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 frequency;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case FILTER_50:
+		frequency = ANTI_ALIASING_50;
+		break;
+	case FILTER_194:
+		frequency = ANTI_ALIASING_194;
+		break;
+	case FILTER_362:
+		frequency = ANTI_ALIASING_362;
+		break;
+	case FILTER_773:
+		frequency = ANTI_ALIASING_773;
+		break;
+	default:
+		dev_err(dev->dev, "accelerometer invalid filter "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_acc_update_filter(dev, frequency);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_acc->aa_filter_bandwidth = frequency;
+	mutex_unlock(&dev->lock);
+	dev_info(dev->dev, "accelerometer anti-aliasing filter "
+					"set to: %lu Hz\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_temp_enable(struct device *device,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", (int)atomic_read(&dev->enabled_temp));
+}
+
+static ssize_t attr_set_temp_enable(struct device *device,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	atomic_set(&dev->enabled_temp, (int)val);
+
+	if (val > 0)
+		lsm9ds0_temperature_enable(dev);
+	else
+		lsm9ds0_temperature_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_temp(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int dec;
+	unsigned int flo;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	dec = dev->temp_value_dec;
+	flo = dev->temp_value_flo;
+
+	if(dec==NDTEMP)
+		return sprintf(buf, "n.d.\n");
+
+	return sprintf(buf, "%d.%u\n", dec, flo);
+}
+
+static struct kobj_attribute poll_attr_acc =
+__ATTR(pollrate_ms, 0664, attr_get_polling_rate_acc, attr_set_polling_rate_acc);
+static struct kobj_attribute enable_attr_acc =
+__ATTR(enable_device, 0664, attr_get_enable_acc, attr_set_enable_acc);
+static struct kobj_attribute fs_attr_acc =
+__ATTR(full_scale, 0664, attr_get_range_acc, attr_set_range_acc);
+static struct kobj_attribute aa_filter_attr  =
+__ATTR(anti_aliasing_frequency, 0664, attr_get_aa_filter, attr_set_aa_filter);
+static struct kobj_attribute poll_attr_mag =
+__ATTR(pollrate_ms, 0664, attr_get_polling_rate_mag, attr_set_polling_rate_mag);
+static struct kobj_attribute enable_attr_mag =
+__ATTR(enable_device, 0664, attr_get_enable_mag, attr_set_enable_mag);
+static struct kobj_attribute fs_attr_mag =
+__ATTR(full_scale, 0664, attr_get_range_mag, attr_set_range_mag);
+
+static int write_bit_on_register(struct lsm9ds0_dev *dev, u8 address,
+				 u8 *resume_value, u8 mask, int value)
+{
+	int err;
+	u8 updated_val, buf[1], val = 0;
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, address, 1, buf);
+	if (err < 0) {
+		err = -1;
+		goto out;
+	}
+
+	if (resume_value != NULL)
+		*resume_value = buf[0];
+
+	if (mask == 0) {
+		updated_val = (u8)value;
+	} else {
+		if (value > 0)
+			val = 0xFF;
+		updated_val = (mask & val) | ((~mask) & buf[0]);
+	}
+
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, address, 1, buf);
+	if (err < 0) {
+		err = -1;
+		goto out;
+	}
+
+	if (resume_value != NULL)
+		*resume_value = updated_val;
+
+out:
+	mutex_unlock(&dev->lock);
+	return err;
+}
+
+static int write_gen_int(struct lsm9ds0_dev *dev, struct interrupt_enable *ie,
+			 int val)
+{
+	int err;
+
+	if (val > 0)
+		val = 1;
+	else
+		val = 0;
+
+	err = write_bit_on_register(dev, ie->address, NULL, ie->mask, val);
+	if(err < 0)
+		return -1;
+
+	atomic_set(&ie->enable, val);
+
+	return err;
+}
+
+static int write_duration_threshold_int(struct lsm9ds0_dev *dev,
+					struct interrupt_value *ie, int val)
+{
+	int err;
+
+	if (val < 0)
+		return -1;
+
+	if (val > MAX_DUR_TH)
+		return -1;
+
+	err = write_bit_on_register(dev, ie->address, NULL, 0, val);
+	if (err < 0)
+		return -1;
+
+	ie->value = val;
+
+	return err;
+}
+
+static int write_threshold_mag_int(struct lsm9ds0_dev *dev,
+				   struct interrupt_value *ie, int val)
+{
+	int err;
+	u8 high;
+	u8 low;
+
+	if(val<0)
+		return -1;
+
+	if(val>MAX_TH_MAG)
+		return -1;
+
+	low = (u8)(0xff & val);
+
+	err = write_bit_on_register(dev, ie->address, NULL, 0, low);
+	if(err<0)
+		return -1;
+
+	high = (u8)(0xff & (val >> 8));
+
+	err = write_bit_on_register(dev, (ie->address)+1, NULL, 0, high);
+	if(err<0)
+		return -1;
+
+	ie->value = val;
+
+	return err;
+}
+
+static ssize_t attr_get_gen1_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&dev->interrupt->gen1_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&dev->interrupt->gen1_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(dev,
+					&dev->interrupt->gen1_pin1, (int)val);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(dev,
+					&dev->interrupt->gen1_pin2, (int)val);
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen2_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&dev->interrupt->gen2_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&dev->interrupt->gen2_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(dev,
+					&dev->interrupt->gen2_pin1, (int)val);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(dev,
+					&dev->interrupt->gen2_pin2, (int)val);
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen1_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = dev->interrupt->gen1_duration.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(dev,
+				&dev->interrupt->gen1_duration, (int)val);
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = dev->interrupt->gen2_duration.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_duration(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(dev,
+				&dev->interrupt->gen2_duration, (int)val);
+
+	return size;
+}
+
+static ssize_t attr_get_gen1_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = dev->interrupt->gen1_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(dev,
+				&dev->interrupt->gen1_threshold, (int)val);
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = dev->interrupt->gen2_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_duration_threshold_int(dev,
+				&dev->interrupt->gen2_threshold, (int)val);
+
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val = -1;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		val = atomic_read(&dev->interrupt->gen_mag_pin1.enable);
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		val = atomic_read(&dev->interrupt->gen_mag_pin2.enable);
+	}
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_status(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if(strcmp(attr->attr.name, "pin1_enable") == 0) {
+		err = write_gen_int(dev,
+				&dev->interrupt->gen_mag_pin1, (int)val);
+		if(err >= 0) {
+		if((atomic_read(&dev->interrupt->gen_mag_pin2.enable))==0)
+			write_gen_int(dev,
+					&dev->interrupt->gen_mag, (int)val);
+		}
+	}
+	if(strcmp(attr->attr.name, "pin2_enable") == 0) {
+		err = write_gen_int(dev,
+				&dev->interrupt->gen_mag_pin2, (int)val);
+		if(err >= 0) {
+		if((atomic_read(&dev->interrupt->gen_mag_pin1.enable))==0)
+			write_gen_int(dev,
+					&dev->interrupt->gen_mag, (int)val);
+		}
+	}
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = dev->interrupt->gen_mag_threshold.value;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_threshold(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err = -1;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_threshold_mag_int(dev,
+				&dev->interrupt->gen_mag_threshold, (int)val);
+
+	return size;
+}
+
+static int get_axis(struct lsm9ds0_dev *dev,
+					int generator, const char *name) {
+
+	int val;
+	int axis;
+
+	if(strcmp(name, "x_high_enable") == 0) {
+		axis = 3;
+	}
+	if(strcmp(name, "x_low_enable") == 0) {
+		axis = 0;
+	}
+	if(strcmp(name, "y_high_enable") == 0) {
+		axis = 4;
+	}
+	if(strcmp(name, "y_low_enable") == 0) {
+		axis = 1;
+	}
+	if(strcmp(name, "z_high_enable") == 0) {
+		axis = 5;
+	}
+	if(strcmp(name, "z_low_enable") == 0) {
+		axis = 2;
+	}
+
+	if(generator == 1)
+		val = atomic_read(&dev->interrupt->gen1_axis[axis].enable);
+	else
+		val = atomic_read(&dev->interrupt->gen2_axis[axis].enable);
+
+	return val;
+}
+
+static int set_axis(struct lsm9ds0_dev *dev, int generator,
+					const char *name, unsigned long value)
+{
+	int err = -1;
+	int axis;
+
+	if(strcmp(name, "x_high_enable") == 0) {
+		axis = 3;
+	}
+	if((strcmp(name, "x_low_enable") == 0) ||
+					(strcmp(name, "x_enable") == 0)) {
+		axis = 0;
+	}
+	if(strcmp(name, "y_high_enable") == 0) {
+		axis = 4;
+	}
+	if((strcmp(name, "y_low_enable") == 0) ||
+					(strcmp(name, "y_enable") == 0)) {
+		axis = 1;
+	}
+	if(strcmp(name, "z_high_enable") == 0) {
+		axis = 5;
+	}
+	if((strcmp(name, "z_low_enable") == 0) ||
+					(strcmp(name, "z_enable") == 0)) {
+		axis = 2;
+	}
+
+	if(generator == 1)
+		err = write_gen_int(dev,
+			&(dev->interrupt->gen1_axis[axis]), (int)value);
+	if(generator == 2)
+		err = write_gen_int(dev,
+			&(dev->interrupt->gen2_axis[axis]), (int)value);
+	if(generator == 3)
+		err = write_gen_int(dev,
+			&(dev->interrupt->gen_mag_axis[axis]), (int)value);
+
+	if(err < 0)
+		return -1;
+
+	return err;
+}
+
+static ssize_t attr_get_gen1_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = get_axis(dev,1,attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(dev, 1, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = get_axis(dev,2,attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(dev, 2, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen_mag_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = get_axis(dev, 3, attr->attr.name);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen_mag_axis(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = set_axis(dev, 3, attr->attr.name, val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen1_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = atomic_read(&dev->interrupt->gen1_and_or.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen1_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(dev, &(dev->interrupt->gen1_and_or), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_gen2_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = atomic_read(&dev->interrupt->gen2_and_or.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_gen2_and_or(struct kobject *kobj,
+						struct kobj_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(dev, &(dev->interrupt->gen2_and_or), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_set_pin_conf(struct device *device,
+						struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(dev,
+			&(dev->interrupt->interrupt_pin_conf), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_pin_conf(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = atomic_read(&dev->interrupt->interrupt_pin_conf.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_interrupt_polarity(struct device *device,
+						struct device_attribute *attr,
+						const char *buf, size_t size)
+{
+	int err;
+	unsigned long val;
+
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	err = write_gen_int(dev,
+			&(dev->interrupt->interrupt_polarity), (int)val);
+	if(err < 0)
+		return -1;
+
+	return size;
+}
+
+static ssize_t attr_get_interrupt_polarity(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	val = atomic_read(&dev->interrupt->interrupt_polarity.enable);
+	return sprintf(buf, "%d\n", val);
+}
+
+static struct kobj_attribute gen1_interrupt_pin1_enable =
+__ATTR(pin1_enable, 0664, attr_get_gen1_status, attr_set_gen1_status);
+static struct kobj_attribute gen1_interrupt_pin2_enable =
+__ATTR(pin2_enable, 0664, attr_get_gen1_status, attr_set_gen1_status);
+
+static struct kobj_attribute gen2_interrupt_pin1_enable =
+__ATTR(pin1_enable, 0664, attr_get_gen2_status, attr_set_gen2_status);
+static struct kobj_attribute gen2_interrupt_pin2_enable =
+__ATTR(pin2_enable, 0664, attr_get_gen2_status, attr_set_gen2_status);
+
+static struct kobj_attribute gen1_duration =
+__ATTR(duration, 0664, attr_get_gen1_duration, attr_set_gen1_duration);
+static struct kobj_attribute gen2_duration =
+__ATTR(duration, 0664, attr_get_gen2_duration, attr_set_gen2_duration);
+
+static struct kobj_attribute gen1_threshold =
+__ATTR(threshold, 0664, attr_get_gen1_threshold, attr_set_gen1_threshold);
+static struct kobj_attribute gen2_threshold =
+__ATTR(threshold, 0664, attr_get_gen2_threshold, attr_set_gen2_threshold);
+
+static struct kobj_attribute mag_gen_interrupt_pin1 =
+__ATTR(pin1_enable, 0664, attr_get_gen_mag_status, attr_set_gen_mag_status);
+static struct kobj_attribute mag_gen_interrupt_pin2 =
+__ATTR(pin2_enable, 0664, attr_get_gen_mag_status, attr_set_gen_mag_status);
+
+static struct kobj_attribute mag_gen_threshold =
+__ATTR(threshold, 0664, attr_get_gen_mag_threshold, attr_set_gen_mag_threshold);
+
+static struct kobj_attribute gen1_x_high =
+__ATTR(x_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_x_low =
+__ATTR(x_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_x_high =
+__ATTR(x_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_x_low =
+__ATTR(x_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen1_y_high =
+__ATTR(y_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_y_low =
+__ATTR(y_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_y_high =
+__ATTR(y_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_y_low =
+__ATTR(y_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen1_z_high =
+__ATTR(z_high_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+static struct kobj_attribute gen1_z_low =
+__ATTR(z_low_enable, 0664, attr_get_gen1_axis, attr_set_gen1_axis);
+
+static struct kobj_attribute gen2_z_high =
+__ATTR(z_high_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+static struct kobj_attribute gen2_z_low =
+__ATTR(z_low_enable, 0664, attr_get_gen2_axis, attr_set_gen2_axis);
+
+static struct kobj_attribute gen_mag_x =
+__ATTR(x_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+static struct kobj_attribute gen_mag_y =
+__ATTR(y_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+static struct kobj_attribute gen_mag_z =
+__ATTR(z_enable, 0664, attr_get_gen_mag_axis, attr_set_gen_mag_axis);
+
+static struct kobj_attribute gen1_and_or =
+__ATTR(and(1)_or(0)_combination, 0664, attr_get_gen1_and_or,
+							attr_set_gen1_and_or);
+static struct kobj_attribute gen2_and_or =
+__ATTR(and(1)_or(0)_combination, 0664, attr_get_gen2_and_or,
+							attr_set_gen2_and_or);
+
+
+static struct attribute *attributes_acc_interrupt1[] = {
+	&gen1_interrupt_pin1_enable.attr,
+	&gen1_interrupt_pin2_enable.attr,
+	&gen1_duration.attr,
+	&gen1_threshold.attr,
+	&gen1_x_high.attr,
+	&gen1_x_low.attr,
+	&gen1_y_high.attr,
+	&gen1_y_low.attr,
+	&gen1_z_high.attr,
+	&gen1_z_low.attr,
+	&gen1_and_or.attr,
+	NULL,
+};
+
+static struct attribute *attributes_acc_interrupt2[] = {
+	&gen2_interrupt_pin1_enable.attr,
+	&gen2_interrupt_pin2_enable.attr,
+	&gen2_duration.attr,
+	&gen2_threshold.attr,
+	&gen2_x_high.attr,
+	&gen2_x_low.attr,
+	&gen2_y_high.attr,
+	&gen2_y_low.attr,
+	&gen2_z_high.attr,
+	&gen2_z_low.attr,
+	&gen2_and_or.attr,
+	NULL,
+};
+
+static struct attribute *attributes_mag_interrupt[] = {
+	&mag_gen_interrupt_pin1.attr,
+	&mag_gen_interrupt_pin2.attr,
+	&mag_gen_threshold.attr,
+	&gen_mag_x.attr,
+	&gen_mag_y.attr,
+	&gen_mag_z.attr,
+	NULL,
+};
+
+static struct attribute *attributes_acc[] = {
+	&poll_attr_acc.attr,
+	&enable_attr_acc.attr,
+	&fs_attr_acc.attr,
+	&aa_filter_attr.attr,
+	NULL,
+};
+
+static struct attribute *attributes_mag[] = {
+	&poll_attr_mag.attr,
+	&enable_attr_mag.attr,
+	&fs_attr_mag.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_mag = {
+	.attrs = attributes_mag,
+};
+
+static struct attribute_group attr_group_int1_acc = {
+	.attrs = attributes_acc_interrupt1,
+	.name = "interrupt_generator1",
+};
+
+static struct attribute_group attr_group_int2_acc = {
+	.attrs = attributes_acc_interrupt2,
+	.name = "interrupt_generator2",
+};
+
+static struct attribute_group attr_group_int_mag = {
+	.attrs = attributes_mag_interrupt,
+	.name = "interrupt_generator",
+};
+
+static struct device_attribute attributes_com[] = {
+	__ATTR(enable_temperature, 0664, attr_get_temp_enable,
+							attr_set_temp_enable),
+	__ATTR(read_temperature, 0444, attr_get_temp, NULL),
+};
+
+static struct device_attribute attributes_interrupt_com[] = {
+	__ATTR(interrupt_pin_configuration, 0664, attr_get_pin_conf,
+						attr_set_pin_conf),
+	__ATTR(interrupt_polarity, 0664, attr_get_interrupt_polarity,
+						attr_set_interrupt_polarity),
+};
+
+static int create_sysfs_interfaces(struct device *device)
+{
+	int err;
+	int i,n;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+
+	acc_kobj = kobject_create_and_add("accelerometer", &device->kobj);
+	if(!acc_kobj)
+		return -ENOMEM;
+
+	mag_kobj = kobject_create_and_add("magnetometer", &device->kobj);
+	if(!mag_kobj)
+		return -ENOMEM;
+
+	err = sysfs_create_group(acc_kobj, &attr_group_acc);
+	if (err)
+		kobject_put(acc_kobj);
+
+	err = sysfs_create_group(mag_kobj, &attr_group_mag);
+	if (err)
+		kobject_put(mag_kobj);
+
+	if((dev->pdata_acc->gpio_int1 >= 0)||
+					(dev->pdata_acc->gpio_int2 >= 0)) {
+		err = sysfs_create_group(acc_kobj, &attr_group_int1_acc);
+		if (err)
+			kobject_put(acc_kobj);
+
+		err = sysfs_create_group(acc_kobj, &attr_group_int2_acc);
+		if (err)
+			kobject_put(acc_kobj);
+
+		err = sysfs_create_group(mag_kobj, &attr_group_int_mag);
+		if (err)
+			kobject_put(mag_kobj);
+
+		for (n = 0; n < ARRAY_SIZE(attributes_interrupt_com); n++)
+		if (device_create_file(device, attributes_interrupt_com + n))
+			goto error1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(attributes_com); i++)
+		if (device_create_file(device, attributes_com + i))
+			goto error;
+
+
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(device, attributes_com + i);
+
+error1:
+	for ( ; n >= 0; n--)
+		device_remove_file(device, attributes_interrupt_com + n);
+
+	dev_err(device, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static void remove_sysfs_interfaces(struct device *device)
+{
+	int i;
+	struct lsm9ds0_dev *dev = dev_get_drvdata(device);
+	kobject_put(acc_kobj);
+	kobject_put(mag_kobj);
+	for (i = 0; i < ARRAY_SIZE(attributes_com); i++)
+		device_remove_file(device, attributes_com + i);
+	if((dev->pdata_acc->gpio_int1 >= 0)||
+					(dev->pdata_acc->gpio_int2 >= 0)) {
+		for (i = 0; i < ARRAY_SIZE(attributes_interrupt_com); i++)
+			device_remove_file(device, attributes_interrupt_com + i);
+	}
+}
+
+static int lsm9ds0_acc_get_data(struct lsm9ds0_dev *dev, int *xyz)
+{
+	int i, err = -1;
+	u8 acc_data[6];
+	s32 hw_d[3] = { 0 };
+
+	err = dev->tf->read(dev->dev, REG_ACC_DATA_ADDR, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)( (s16)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((s32)( (s16)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((s32)( (s16)((acc_data[5] << 8) | (acc_data[4]))));
+
+#ifdef LSM9DS0_DEBUG
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM9DS0_ACC_DEV_NAME, acc_data[1], acc_data[0], hw_d[0]);
+	pr_debug("%s read y=%X %X(regH regL), y=%d(dec) [ug]\n",
+		LSM9DS0_ACC_DEV_NAME, acc_data[3], acc_data[2], hw_d[1]);
+	pr_debug("%s read z=%X %X(regH regL), z=%d(dec) [ug]\n",
+		LSM9DS0_ACC_DEV_NAME, acc_data[5], acc_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * dev->sensitivity_acc;
+	hw_d[1] = hw_d[1] * dev->sensitivity_acc;
+	hw_d[2] = hw_d[2] * dev->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = dev->pdata_acc->rot_matrix[0][i] * hw_d[0] +
+				dev->pdata_acc->rot_matrix[1][i] * hw_d[1] +
+				dev->pdata_acc->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm9ds0_mag_get_data(struct lsm9ds0_dev *dev, int *xyz)
+{
+	int i, err = -1;
+	u8 mag_data[6];
+	s32 hw_d[3] = { 0 };
+
+	err = dev->tf->read(dev->dev, REG_MAG_DATA_ADDR, 6, mag_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)( (s16)((mag_data[1] << 8) | (mag_data[0]))));
+	hw_d[1] = ((s32)( (s16)((mag_data[3] << 8) | (mag_data[2]))));
+	hw_d[2] = ((s32)( (s16)((mag_data[5] << 8) | (mag_data[4]))));
+
+#ifdef LSM9DS0_DEBUG
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM9DS0_MAG_DEV_NAME, mag_data[1], mag_data[0], hw_d[0]);
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM9DS0_MAG_DEV_NAME, mag_data[3], mag_data[2], hw_d[1]);
+	pr_debug("%s read x=%X %X(regH regL), x=%d(dec) [ug]\n",
+		LSM9DS0_MAG_DEV_NAME, mag_data[5], mag_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * dev->sensitivity_mag;
+	hw_d[1] = hw_d[1] * dev->sensitivity_mag;
+	hw_d[2] = hw_d[2] * dev->sensitivity_mag;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = dev->pdata_acc->rot_matrix[0][i] * hw_d[0] +
+				dev->pdata_acc->rot_matrix[1][i] * hw_d[1] +
+				dev->pdata_acc->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm9ds0_temp_get_data(struct lsm9ds0_dev *dev,
+				 int *dec, int *flo)
+{
+	int err = -1;
+	u8 temp_data[2];
+	s16 hw_d = 0;
+
+	err = dev->tf->read(dev->dev, REG_TEMP_DATA_ADDR, 2, temp_data);
+	if (err < 0)
+		return err;
+
+	hw_d = (s16)((temp_data[1] << 8) | (temp_data[0]));
+
+#ifdef LSM9DS0_DEBUG
+	pr_debug("%s read T=%X %X(regH regL), T=%d(dec) [C]\n",
+		LSM9DS0_DEV_NAME, temp_data[1], temp_data[0], hw_d);
+#endif
+
+	*dec = (int)(hw_d/TEMP_SENSITIVITY) + OFFSET_TEMP;
+	*flo = (((unsigned int)hw_d)%TEMP_SENSITIVITY);
+
+	return err;
+}
+
+static void lsm9ds0_acc_report_values(struct lsm9ds0_dev *dev, int *xyz)
+{
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(dev->input_dev_acc);
+}
+
+static void lsm9ds0_mag_report_values(struct lsm9ds0_dev *dev, int *xyz)
+{
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_sync(dev->input_dev_mag);
+}
+
+static int lsm9ds0_acc_input_init(struct lsm9ds0_dev *dev)
+{
+	int err;
+
+	dev->input_dev_acc = input_allocate_device();
+	if (!dev->input_dev_acc) {
+		dev_err(dev->dev, "acc input dev allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev_acc->name = LSM9DS0_ACC_DEV_NAME;
+	dev->input_dev_acc->id.bustype = dev->bus_type;
+	dev->input_dev_acc->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_acc, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev_acc->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev_acc->mscbit);
+
+	err = input_register_device(dev->input_dev_acc);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register accelerometer input device %s\n",
+			dev->input_dev_acc->name);
+		input_free_device(dev->input_dev_acc);
+		return err;
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_mag_input_init(struct lsm9ds0_dev *dev)
+{
+	int err;
+
+	dev->input_dev_mag = input_allocate_device();
+	if (!dev->input_dev_mag) {
+		dev_err(dev->dev, "magn input dev allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev_mag->name = LSM9DS0_MAG_DEV_NAME;
+	dev->input_dev_mag->id.bustype = dev->bus_type;
+	dev->input_dev_mag->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_mag, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev_mag->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev_mag->mscbit);
+
+	err = input_register_device(dev->input_dev_mag);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register magnetometer input device %s\n",
+			dev->input_dev_mag->name);
+		input_free_device(dev->input_dev_mag);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lsm9ds0_input_cleanup(struct lsm9ds0_dev *dev)
+{
+	input_unregister_device(dev->input_dev_acc);
+	input_free_device(dev->input_dev_acc);
+
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static void poll_function_work_acc(struct work_struct *input_work_acc)
+{
+	struct lsm9ds0_dev *dev;
+	int xyz[3] = { 0 };
+	int err;
+
+	dev = container_of((struct work_struct *)input_work_acc,
+			   struct lsm9ds0_dev, input_work_acc);
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_acc_get_data(dev, xyz);
+	if (err < 0)
+		dev_err(dev->dev, "get_accelerometer_data failed\n");
+	else
+		lsm9ds0_acc_report_values(dev, xyz);
+
+	mutex_unlock(&dev->lock);
+	hrtimer_start(&dev->hr_timer_acc, dev->ktime_acc, HRTIMER_MODE_REL);
+}
+
+static void poll_function_work_mag(struct work_struct *input_work_mag)
+{
+	struct lsm9ds0_dev *dev;
+	int xyz[3] = { 0 };
+	int err;
+	int dec;
+	int flo;
+
+	dev = container_of((struct work_struct *)input_work_mag,
+			   struct lsm9ds0_dev, input_work_mag);
+
+	mutex_lock(&dev->lock);
+
+	if(atomic_read(&dev->enabled_temp)) {
+		err = lsm9ds0_temp_get_data(dev, &dec, &flo);
+		if (err < 0)
+			dev_err(dev->dev, "get_temperature_data"
+								" failed\n");
+		else {
+			dev->temp_value_dec = dec;
+			dev->temp_value_flo = flo;
+		}
+	}
+
+	if(atomic_read(&dev->enabled_mag)) {
+		err = lsm9ds0_mag_get_data(dev, xyz);
+		if (err < 0)
+			dev_err(dev->dev, "get_magnetometer_data"
+								" failed\n");
+		else
+			lsm9ds0_mag_report_values(dev, xyz);
+	}
+
+	mutex_unlock(&dev->lock);
+	hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag, HRTIMER_MODE_REL);
+}
+
+enum hrtimer_restart poll_function_read_acc(struct hrtimer *timer)
+{
+	struct lsm9ds0_dev *dev;
+
+
+	dev = container_of((struct hrtimer *)timer,
+			   struct lsm9ds0_dev, hr_timer_acc);
+
+	queue_work(dev->data_workqueue, &dev->input_work_acc);
+	return HRTIMER_NORESTART;
+}
+
+enum hrtimer_restart poll_function_read_mag(struct hrtimer *timer)
+{
+	struct lsm9ds0_dev *dev;
+
+
+	dev = container_of((struct hrtimer *)timer,
+			   struct lsm9ds0_dev, hr_timer_mag);
+
+	queue_work(dev->data_workqueue, &dev->input_work_mag);
+	return HRTIMER_NORESTART;
+}
+
+int lsm9ds0_probe(struct lsm9ds0_dev *dev)
+{
+	int err;
+
+	mutex_lock(&dev->lock);
+
+	err = lsm9ds0_check_whoami(dev);
+	if (err < 0)
+		goto err_mutexunlock;
+
+	dev->pdata_acc = kzalloc(sizeof(*dev->pdata_acc), GFP_KERNEL);
+	dev->pdata_mag = kzalloc(sizeof(*dev->pdata_mag), GFP_KERNEL);
+	if ((dev->pdata_acc == NULL) || (dev->pdata_mag == NULL)) {
+		err = -ENOMEM;
+		dev_err(dev->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	if (dev->dev->platform_data == NULL) {
+		memcpy(dev->pdata_acc, &default_lsm9ds0_acc_pdata,
+		       sizeof(*dev->pdata_acc));
+		memcpy(dev->pdata_mag, &default_lsm9ds0_mag_pdata,
+		       sizeof(*dev->pdata_mag));
+		dev_info(dev->dev, "using def pdata for acc and magn\n");
+	} else {
+		struct lsm9ds0_main_platform_data *tmp;
+		tmp = kzalloc(sizeof(struct lsm9ds0_main_platform_data),
+			      GFP_KERNEL);
+		if (tmp == NULL)
+			goto exit_kfree_pdata;
+		memcpy(tmp, dev->dev->platform_data, sizeof(*tmp));
+		if (tmp->pdata_acc == NULL) {
+			memcpy(dev->pdata_acc, &default_lsm9ds0_acc_pdata,
+			       sizeof(*dev->pdata_acc));
+			dev_info(dev->dev, "using def pdata for acc\n");
+		} else {
+			memcpy(dev->pdata_acc, tmp->pdata_acc,
+			       sizeof(*dev->pdata_acc));
+		}
+		if(tmp->pdata_mag == NULL) {
+			memcpy(dev->pdata_mag, &default_lsm9ds0_mag_pdata,
+			       sizeof(*dev->pdata_mag));
+			dev_info(dev->dev, "using def pdata for magn\n");
+		} else {
+			memcpy(dev->pdata_mag, tmp->pdata_mag,
+			       sizeof(*dev->pdata_mag));
+		}
+		kfree(tmp);
+	}
+
+	err = lsm9ds0_acc_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate pdata for acc\n");
+		goto exit_kfree_pdata;
+	}
+
+	err = lsm9ds0_mag_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate pdata for magn\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (dev->pdata_acc->init) {
+		err = dev->pdata_acc->init();
+		if (err < 0) {
+			dev_err(dev->dev, "accelerometer init failed: %d\n",
+				err);
+			goto err_pdata_acc_init;
+		}
+	}
+
+	if (dev->pdata_mag->init) {
+		err = dev->pdata_mag->init();
+		if (err < 0) {
+			dev_err(dev->dev, "magnetometer init failed: %d\n",
+				err);
+			goto err_pdata_mag_init;
+		}
+	}
+
+	if (dev->pdata_acc->gpio_int1 >= 0) {
+		if (!gpio_is_valid(dev->pdata_acc->gpio_int1)) {
+			dev_err(dev->dev, "The requested GPIO [%d] is not "
+				"available\n", dev->pdata_acc->gpio_int1);
+			err = -EINVAL;
+			goto err_gpio1_valid;
+		}
+
+		err = gpio_request(dev->pdata_acc->gpio_int1,
+				   "INTERRUPT_PIN1_LSM9DS0");
+		if(err < 0) {
+			dev_err(dev->dev, "Unable to request GPIO [%d].\n",
+				dev->pdata_acc->gpio_int1);
+			err = -EINVAL;
+			goto err_gpio1_valid;
+		}
+		gpio_direction_input(dev->pdata_acc->gpio_int1);
+		dev->irq1 = gpio_to_irq(dev->pdata_acc->gpio_int1);
+		if(dev->irq1 < 0) {
+			dev_err(dev->dev, "GPIO [%d] cannot be used as "
+				"interrupt.\n", dev->pdata_acc->gpio_int1);
+			err = -EINVAL;
+			goto err_gpio1_irq;
+		}
+		pr_info("%s: %s has set irq1 to irq: %d, mapped on gpio:%d\n",
+			LSM9DS0_DEV_NAME, __func__, dev->irq1,
+			dev->pdata_acc->gpio_int1);
+	}
+
+	if (dev->pdata_acc->gpio_int2 >= 0) {
+		if (!gpio_is_valid(dev->pdata_acc->gpio_int2)) {
+			dev_err(dev->dev, "The requested GPIO [%d] is not "
+				"available\n", dev->pdata_acc->gpio_int2);
+			err = -EINVAL;
+			goto err_gpio2_valid;
+		}
+
+		err = gpio_request(dev->pdata_acc->gpio_int2,
+				   "INTERRUPT_PIN2_LSM9DS0");
+		if(err < 0) {
+			dev_err(dev->dev, "Unable to request GPIO [%d].\n",
+				dev->pdata_acc->gpio_int2);
+			err = -EINVAL;
+			goto err_gpio2_valid;
+		}
+		gpio_direction_input(dev->pdata_acc->gpio_int2);
+		dev->irq2 = gpio_to_irq(dev->pdata_acc->gpio_int2);
+		if(dev->irq2 < 0) {
+			dev_err(dev->dev, "GPIO [%d] cannot be used as "
+				"interrupt.\n", dev->pdata_acc->gpio_int2);
+			err = -EINVAL;
+			goto err_gpio2_irq;
+		}
+		pr_info("%s: %s has set irq2 to irq: %d, mapped on gpio:%d\n",
+			LSM9DS0_DEV_NAME, __func__, dev->irq2,
+			dev->pdata_acc->gpio_int2);
+	}
+
+	err = lsm9ds0_hw_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm9ds0_acc_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "accelerometer power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+	err = lsm9ds0_mag_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer power on failed: %d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm9ds0_acc_update_fs_range(dev, dev->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range on accelerometer failed\n");
+		goto  err_power_off_acc;
+	}
+
+	err = lsm9ds0_mag_update_fs_range(dev, dev->pdata_mag->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range on magnetometer failed\n");
+		goto  err_power_off_mag;
+	}
+
+	err = lsm9ds0_acc_update_odr(dev, dev->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr on accelerometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds0_mag_update_odr(dev, dev->pdata_mag->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr on magnetometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds0_acc_update_filter(dev, 
+					dev->pdata_acc->aa_filter_bandwidth);
+	if (err < 0) {
+		dev_err(dev->dev, "update_filter on accelerometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds0_acc_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = lsm9ds0_mag_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev,
+		"device LSM9DS0_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lsm9ds0_acc_device_power_off(dev);
+	lsm9ds0_mag_device_power_off(dev);
+
+	if(dev->pdata_acc->gpio_int1 >= 0){
+		INIT_WORK(&dev->irq1_work, lsm9ds0_irq1_work_func);
+		dev->irq1_work_queue =
+				create_singlethread_workqueue("lsm9ds0_wq1");
+		if (!dev->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev, "cannot create work queue1: %d\n",
+				err);
+			goto err_remove_sysfs_int;
+		}
+		err = request_irq(dev->irq1, lsm9ds0_isr1, IRQF_TRIGGER_RISING,
+				  "lsm9ds0_irq1", dev);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
+		}
+		disable_irq_nosync(dev->irq1);
+	}
+
+	if(dev->pdata_acc->gpio_int2 >= 0){
+		INIT_WORK(&dev->irq2_work, lsm9ds0_irq2_work_func);
+		dev->irq2_work_queue =
+				create_singlethread_workqueue("lsm9ds0_wq2");
+		if (!dev->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev, "cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(dev->irq2, lsm9ds0_isr2, IRQF_TRIGGER_RISING,
+				  "lsm9ds0_irq2", dev);
+		if (err < 0) {
+			dev_err(dev->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
+		}
+		disable_irq_nosync(dev->irq2);
+	}
+
+	dev->data_workqueue = create_workqueue("lsm9ds0_workqueue");
+	if (!dev->data_workqueue)
+		goto err_destoyworkqueue2;
+
+	hrtimer_init(&dev->hr_timer_acc, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer_acc.function = &poll_function_read_acc;
+	hrtimer_init(&dev->hr_timer_mag, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer_mag.function = &poll_function_read_mag;
+
+	INIT_WORK(&dev->input_work_acc, poll_function_work_acc);
+	INIT_WORK(&dev->input_work_mag, poll_function_work_mag);
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err_destoyworkqueue2:
+	destroy_workqueue(dev->irq2_work_queue);
+err_free_irq1:
+	free_irq(dev->irq1, dev);
+err_destoyworkqueue1:
+	destroy_workqueue(dev->irq1_work_queue);
+err_remove_sysfs_int:
+	remove_sysfs_interfaces(dev->dev);
+err_input_cleanup:
+	lsm9ds0_input_cleanup(dev);
+err_power_off:
+err_power_off_mag:
+	lsm9ds0_mag_device_power_off(dev);
+err_power_off_acc:
+	lsm9ds0_acc_device_power_off(dev);
+	kfree(dev->interrupt);
+err_hw_init:
+err_gpio2_irq:
+	gpio_free(dev->pdata_acc->gpio_int2);
+err_gpio2_valid:
+err_gpio1_irq:
+	gpio_free(dev->pdata_acc->gpio_int1);
+err_gpio1_valid:
+err_pdata_init:
+err_pdata_mag_init:
+	if (dev->pdata_mag->exit)
+		dev->pdata_mag->exit();
+err_pdata_acc_init:
+	if (dev->pdata_acc->exit)
+		dev->pdata_acc->exit();
+exit_kfree_pdata:
+	kfree(dev->pdata_acc);
+	kfree(dev->pdata_mag);
+err_mutexunlock:
+	mutex_unlock(&dev->lock);
+	if (dev->data_workqueue)
+		destroy_workqueue(dev->data_workqueue);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm9ds0_probe);
+
+int lsm9ds0_remove(struct lsm9ds0_dev *dev)
+{
+	lsm9ds0_disable(dev);
+
+	if (dev->pdata_acc->gpio_int1 >= 0) {
+		free_irq(dev->irq1, dev);
+		gpio_free(dev->pdata_acc->gpio_int1);
+		destroy_workqueue(dev->irq1_work_queue);
+	}
+
+	if (dev->pdata_acc->gpio_int2 >= 0) {
+		free_irq(dev->irq2, dev);
+		gpio_free(dev->pdata_acc->gpio_int2);
+		destroy_workqueue(dev->irq2_work_queue);
+	}
+
+	lsm9ds0_acc_input_cleanup(dev);
+	lsm9ds0_mag_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (dev->pdata_acc->exit)
+		dev->pdata_acc->exit();
+
+	if (dev->pdata_mag->exit)
+		dev->pdata_mag->exit();
+
+	if ((dev->pdata_acc->gpio_int1 >= 0) ||
+	    (dev->pdata_acc->gpio_int2 >= 0))
+		kfree(dev->interrupt);
+
+	if (dev->data_workqueue)
+		destroy_workqueue(dev->data_workqueue);
+
+	kfree(dev->pdata_acc);
+	kfree(dev->pdata_mag);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm9ds0_remove);
+
+MODULE_DESCRIPTION("lsm9ds0 accelerometer and magnetometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_i2c.c b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_i2c.c
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm9ds0_acc_mag_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm9ds0.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds0_acc_mag_i2c_read(struct device *dev, u8 addr,
+				    int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds0_acc_mag_i2c_write(struct device *dev, u8 addr,
+				     int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm9ds0_transfer_function lsm9ds0_acc_mag_i2c_tf = {
+	.write = lsm9ds0_acc_mag_i2c_write,
+	.read = lsm9ds0_acc_mag_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds0_acc_mag_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds0_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds0_enable(dev);
+}
+
+static int lsm9ds0_acc_mag_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds0_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds0_disable(dev);
+}
+
+static const struct dev_pm_ops lsm9ds0_acc_mag_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds0_acc_mag_i2c_suspend,
+				lsm9ds0_acc_mag_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm9ds0_acc_mag_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm9ds0_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds0_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm9ds0_acc_mag_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds0_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds0_acc_mag_i2c_remove(struct i2c_client *client)
+{
+	struct lsm9ds0_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds0_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm9ds0_acc_mag_i2c_id[] = {
+	{ "lsm9ds0_acc_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm9ds0_acc_mag_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds0_acc_mag_i2c_id_table[] = {
+	{ .compatible = "st,lsm9ds0_acc_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds0_acc_mag_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm9ds0_acc_mag_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds0_acc_mag_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds0_acc_mag_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds0_acc_mag_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds0_acc_mag_i2c_probe,
+	.remove = lsm9ds0_acc_mag_i2c_remove,
+	.id_table = lsm9ds0_acc_mag_i2c_id,
+};
+
+module_i2c_driver(lsm9ds0_acc_mag_i2c_driver);
+
+MODULE_DESCRIPTION("lsm9ds0 acc-mag i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_spi.c b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_spi.c
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_acc_mag_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm9ds0_acc_mag_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm9ds0.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm9ds0_acc_mag_spi_read(struct device *device, u8 addr,
+				    int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm9ds0_acc_mag_spi_write(struct device *device, u8 addr,
+				     int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM9DS0_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm9ds0_transfer_function lsm9ds0_acc_mag_spi_tf = {
+	.write = lsm9ds0_acc_mag_spi_write,
+	.read = lsm9ds0_acc_mag_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds0_acc_mag_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds0_enable(dev);
+}
+
+static int lsm9ds0_acc_mag_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds0_disable(dev);
+}
+
+static const struct dev_pm_ops lsm9ds0_acc_mag_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds0_acc_mag_spi_suspend,
+				lsm9ds0_acc_mag_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm9ds0_acc_mag_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm9ds0_dev *dev;
+
+#ifdef LSM9DS0_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds0_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm9ds0_acc_mag_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds0_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds0_acc_mag_spi_remove(struct spi_device *spi)
+{
+	struct lsm9ds0_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LSM9DS0_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds0_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm9ds0_acc_mag_spi_id[] = {
+	{ "lsm9ds0_acc_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm9ds0_acc_mag_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds0_acc_mag_spi_id_table[] = {
+	{ .compatible = "st,lsm9ds0_acc_mag" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds0_acc_mag_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm9ds0_acc_mag_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds0_acc_mag_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds0_acc_mag_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds0_acc_mag_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds0_acc_mag_spi_probe,
+	.remove = lsm9ds0_acc_mag_spi_remove,
+	.id_table = lsm9ds0_acc_mag_spi_id,
+};
+
+module_spi_driver(lsm9ds0_acc_mag_spi_driver);
+
+MODULE_DESCRIPTION("lsm9ds0 acc-mag spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr.c b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr.c
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1360 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name		: lsm9ds0_gyr_sysfs.c
+* Authors		: MEMS Motion Sensors Products Div- Application Team
+*			: Matteo Dameno (matteo.dameno@st.com)
+*			: Denis Ciocca (denis.ciocca@st.com)
+*			: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*			: Both authors are willing to be considered the contact
+*			: and update points for the driver.
+* Version		: V 1.2 sysfs
+* Date			: 2012/Jul/10
+* Description		: LSM9DS0 digital output gyroscope sensor API
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+* REVISON HISTORY
+*
+* VERSION	| DATE		| AUTHORS	  | DESCRIPTION
+* 1.0		| 2010/May/02	| Carmine Iascone | First Release
+* 1.1.3		| 2011/Jun/24	| Matteo Dameno	  | Corrects ODR Bug
+* 1.1.4		| 2011/Sep/02	| Matteo Dameno	  | SMB Bus Mng,
+*		|		|		  | forces BDU setting
+* 1.1.5		| 2011/Sep/24	| Matteo Dameno	  | Introduces FIFO Feat.
+* 1.1.5.2	| 2011/Nov/11	| Matteo Dameno	  | enable gpio_int to be
+*		|		|		  | passed as parameter at
+*		|		|		  | module loading time;
+*		|		|		  | corrects polling
+*		|		|		  | bug at end of probing;
+* 1.1.5.3	| 2011/Dec/20	| Matteo Dameno	  | corrects error in
+*		|		|		  | I2C SADROOT; Modifies
+*		|		|		  | resume suspend func.
+* 1.1.5.4	| 2012/Jan/09	| Matteo Dameno	  | moved under input/misc;
+* 1.1.5.5	| 2012/Mar/30	| Matteo Dameno	  | moved watermark, use_smbus,
+*		|		|		  | fifomode @ struct foo_status
+*		|		|		  | sysfs range input format
+*		|		|		  | changed to decimal
+* 1.2		| 2012/Jul/10	| Denis Ciocca    | input_poll_dev removal
+* 1.2.1		| 2012/Jul/10	| Denis Ciocca	  | added high resolution timers
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/stat.h>
+
+#include "lsm9ds0.h"
+
+/* Maximum polled-device-reported rot speed value value in dps */
+#define FS_MAX		32768
+#define MS_TO_NS(x)	((x) * 1000000L)
+#define SEC_PORTION_FROM_MS(x)	(s64)((x) / 1000)
+#define NSEC_PORTION_FROM_MS(x)	MS_TO_NS((x) % 1000)
+
+/* lsm9ds0 gyroscope registers */
+#define WHO_AM_I	0x0F
+
+/* udps/LSB */
+#define SENSITIVITY_250		8750
+#define SENSITIVITY_500		17500
+#define SENSITIVITY_2000	70000
+
+#define CTRL_REG1	0x20
+#define CTRL_REG2	0x21
+#define CTRL_REG3	0x22
+#define CTRL_REG4	0x23
+#define CTRL_REG5	0x24
+#define REFERENCE	0x25
+#define FIFO_CTRL_REG	0x2E
+#define FIFO_SRC_REG	0x2F
+#define OUT_X_L		0x28
+
+#define AXISDATA_REG	OUT_X_L
+
+/* CTRL_REG1 */
+#define ALL_ZEROES	0x00
+#define PM_OFF		0x00
+#define PM_NORMAL	0x08
+#define ENABLE_ALL_AXES	0x07
+#define ENABLE_NO_AXES	0x00
+#define BW00		0x00
+#define BW01		0x10
+#define BW10		0x20
+#define BW11		0x30
+#define ODR095		0x00  /* ODR =  95Hz */
+#define ODR190		0x40  /* ODR = 190Hz */
+#define ODR380		0x80  /* ODR = 380Hz */
+#define ODR760		0xC0  /* ODR = 760Hz */
+
+/* CTRL_REG3 bits */
+#define I2_DRDY		0x08
+#define I2_WTM		0x04
+#define I2_OVRUN	0x02
+#define I2_EMPTY	0x01
+#define I2_NONE		0x00
+#define I2_MASK		0x0F
+
+/* CTRL_REG4 bits */
+#define FS_MASK		0x30
+#define BDU_ENABLE	0x80
+
+/* CTRL_REG5 bits */
+#define FIFO_ENABLE	0x40
+#define HPF_ENALBE	0x11
+
+/* FIFO_CTRL_REG bits */
+#define FIFO_MODE_MASK		0xE0
+#define FIFO_MODE_BYPASS	0x00
+#define FIFO_MODE_FIFO		0x20
+#define FIFO_MODE_STREAM	0x40
+#define FIFO_MODE_STR2FIFO	0x60
+#define FIFO_MODE_BYPASS2STR	0x80
+#define FIFO_WATERMARK_MASK	0x1F
+
+#define FIFO_STORED_DATA_MASK	0x1F
+
+/* RESUME STATE INDICES */
+#define RES_CTRL_REG1			0
+#define RES_CTRL_REG2			1
+#define RES_CTRL_REG3			2
+#define RES_CTRL_REG4			3
+#define RES_CTRL_REG5			4
+#define RES_FIFO_CTRL_REG		5
+
+/** Registers Contents */
+#define WHOAMI_LSM9DS0_GYR	0xD4
+
+static int int1_gpio = LSM9DS0_GYR_DEFAULT_INT1_GPIO;
+static int int2_gpio = LSM9DS0_GYR_DEFAULT_INT2_GPIO;
+/* module_param(int1_gpio, int, S_IRUGO); */
+module_param(int2_gpio, int, S_IRUGO);
+
+/*
+ * LSM9DS0 gyroscope data
+ * brief structure containing gyroscope values for yaw, pitch and roll in
+ * s32
+ */
+struct lsm9ds0_gyr_triple {
+	s32 x;
+	s32 y;
+	s32 z;
+};
+
+struct output_rate {
+	int poll_rate_ms;
+	u8 mask;
+};
+
+static const struct output_rate odr_table[] = {
+	{ 2, ODR760 | BW10 },
+	{ 3, ODR380 | BW01 },
+	{ 6, ODR190 | BW00 },
+	{ 11, ODR095 | BW00 },
+};
+
+static struct lsm9ds0_gyr_platform_data default_lsm9ds0_gyr_pdata = {
+	.fs_range = LSM9DS0_GYR_FS_250DPS,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.negate_x = 0,
+	.negate_y = 0,
+	.negate_z = 0,
+
+	.poll_interval = 100,
+	.min_interval = LSM9DS0_GYR_MIN_POLL_PERIOD_MS, /* 2ms */
+
+	.gpio_int1 = LSM9DS0_GYR_DEFAULT_INT1_GPIO,
+	.gpio_int2 = LSM9DS0_GYR_DEFAULT_INT2_GPIO,	/* int for fifo */
+};
+
+static int lsm9ds0_gyr_register_update(struct lsm9ds0_gyr_dev *dev,
+				       u8 reg_address, u8 mask,
+				       u8 new_bit_values)
+{
+	int err;
+	u8 val;
+	err = dev->tf->read(dev->dev, reg_address, 1, &val);
+	if (err < 0)
+		return err;
+
+	val = (mask & new_bit_values) | (~mask & val);
+	err = dev->tf->write(dev->dev, reg_address, 1, &val);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int lsm9ds0_gyr_update_watermark(struct lsm9ds0_gyr_dev *dev,
+					u8 watermark)
+{
+	int res = 0;
+	u8 new_value;
+
+	mutex_lock(&dev->lock);
+	new_value = (watermark % 0x20);
+	res = lsm9ds0_gyr_register_update(dev, FIFO_CTRL_REG,
+					  FIFO_WATERMARK_MASK, new_value);
+	if (res < 0) {
+		dev_err(dev->dev, "failed to update watermark\n");
+		mutex_unlock(&dev->lock);
+		return res;
+	}
+	dev_dbg(dev->dev, "%s new_value:0x%02x,watermark:0x%02x\n",
+		__func__, new_value, watermark);
+
+	dev->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_WATERMARK_MASK & new_value) |
+		 (~FIFO_WATERMARK_MASK &
+		  dev->resume_state[RES_FIFO_CTRL_REG]));
+	dev->watermark = new_value;
+	mutex_unlock(&dev->lock);
+
+	return res;
+}
+
+static int lsm9ds0_gyr_update_fifomode(struct lsm9ds0_gyr_dev *dev,
+				       u8 fifomode)
+{
+	int res;
+
+	res = lsm9ds0_gyr_register_update(dev, FIFO_CTRL_REG,
+					  FIFO_MODE_MASK, fifomode);
+	if (res < 0) {
+		dev_err(dev->dev, "failed to update fifoMode\n");
+		return res;
+	}
+
+	dev->resume_state[RES_FIFO_CTRL_REG] =
+		((FIFO_MODE_MASK & fifomode) |
+		 (~FIFO_MODE_MASK & dev->resume_state[RES_FIFO_CTRL_REG]));
+	dev->fifomode = fifomode;
+
+	return res;
+}
+
+static int lsm9ds0_gyr_fifo_reset(struct lsm9ds0_gyr_dev *dev)
+{
+	u8 oldmode;
+	int res;
+
+	oldmode = dev->fifomode;
+	res = lsm9ds0_gyr_update_fifomode(dev, FIFO_MODE_BYPASS);
+	if (res < 0)
+		return res;
+	res = lsm9ds0_gyr_update_fifomode(dev, oldmode);
+	if (res >= 0)
+		dev_dbg(dev->dev, "%s fifo reset to: 0x%02x\n",
+			__func__, oldmode);
+
+	return res;
+}
+
+static int lsm9ds0_gyr_fifo_hwenable(struct lsm9ds0_gyr_dev *dev, u8 enable)
+{
+	int res;
+	u8 set = (enable) ? FIFO_ENABLE : 0x00;
+
+	res = lsm9ds0_gyr_register_update(dev, CTRL_REG5, FIFO_ENABLE, set);
+	if (res < 0) {
+		dev_err(dev->dev, "fifo_hw switch to:0x%02x failed\n", set);
+		return res;
+	}
+	dev->resume_state[RES_CTRL_REG5] =
+		((FIFO_ENABLE & set) |
+		 (~FIFO_ENABLE & dev->resume_state[RES_CTRL_REG5]));
+
+	return res;
+}
+
+static int lsm9ds0_gyr_manage_int2settings(struct lsm9ds0_gyr_dev *dev,
+					   u8 fifomode)
+{
+	int res;
+	bool enable_fifo_hw, recognized_mode = false;
+	u8 int2bits = I2_NONE;
+
+	switch (fifomode) {
+	case FIFO_MODE_FIFO:
+		recognized_mode = true;
+
+		if (dev->polling_enabled) {
+			int2bits = I2_NONE;
+			enable_fifo_hw = false;
+		} else {
+			int2bits = (I2_WTM | I2_OVRUN);
+			enable_fifo_hw = true;
+		}
+		res = lsm9ds0_gyr_register_update(dev, CTRL_REG3,
+						  I2_MASK, int2bits);
+		if (res < 0) {
+			dev_err(dev->dev,
+				"%s : failed to update CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			return res;
+		}
+		dev->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			 (~I2_MASK & dev->resume_state[RES_CTRL_REG3]));
+		/* enable_fifo_hw = true; */
+		break;
+	case FIFO_MODE_BYPASS:
+		recognized_mode = true;
+
+		if (dev->polling_enabled)
+			int2bits = I2_NONE;
+		else
+			int2bits = I2_DRDY;
+
+		res = lsm9ds0_gyr_register_update(dev, CTRL_REG3, I2_MASK,
+						  int2bits);
+		if (res < 0) {
+			dev_err(dev->dev,
+				"%s : failed to update to CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			return res;
+		}
+		dev->resume_state[RES_CTRL_REG3] =
+			((I2_MASK & int2bits) |
+			 (~I2_MASK & dev->resume_state[RES_CTRL_REG3]));
+		enable_fifo_hw = false;
+		break;
+	default:
+		recognized_mode = false;
+		res = lsm9ds0_gyr_register_update(dev, CTRL_REG3, I2_MASK,
+						  I2_NONE);
+		if (res < 0) {
+			dev_err(dev->dev,
+				"%s: failed to update CTRL_REG3:0x%02x\n",
+				__func__, fifomode);
+			return res;
+		}
+		enable_fifo_hw = false;
+		dev->resume_state[RES_CTRL_REG3] =
+			(~I2_MASK & dev->resume_state[RES_CTRL_REG3]);
+		break;
+	}
+
+	if (recognized_mode) {
+		res = lsm9ds0_gyr_update_fifomode(dev, fifomode);
+		if (res < 0) {
+			dev_err(dev->dev, "%s : failed to set fifoMode\n",
+				__func__);
+			return res;
+		}
+	}
+
+	return lsm9ds0_gyr_fifo_hwenable(dev, enable_fifo_hw);
+}
+
+
+static int lsm9ds0_gyr_update_fs_range(struct lsm9ds0_gyr_dev *dev, u8 new_fs)
+{
+	int res ;
+	u32 sensitivity;
+
+	switch(new_fs) {
+	case LSM9DS0_GYR_FS_250DPS:
+		sensitivity = SENSITIVITY_250;
+		break;
+	case LSM9DS0_GYR_FS_500DPS:
+		sensitivity = SENSITIVITY_500;
+		break;
+	case LSM9DS0_GYR_FS_2000DPS:
+		sensitivity = SENSITIVITY_2000;
+		break;
+	default:
+		dev_err(dev->dev, "invalid g range requested: %u\n", new_fs);
+		return -EINVAL;
+	}
+
+	res = lsm9ds0_gyr_register_update(dev, CTRL_REG4, FS_MASK, new_fs);
+
+	if (res < 0) {
+		dev_err(dev->dev, "%s : failed to update fs:0x%02x\n",
+			__func__, new_fs);
+		return res;
+	}
+	dev->resume_state[RES_CTRL_REG4] =
+		((FS_MASK & new_fs) |
+		 (~FS_MASK & dev->resume_state[RES_CTRL_REG4]));
+
+	dev->sensitivity = sensitivity;
+
+	return res;
+}
+
+
+static int lsm9ds0_gyr_update_odr(struct lsm9ds0_gyr_dev *dev,
+				  unsigned int poll_ms)
+{
+	int i, err = -1;
+	u8 data = ENABLE_ALL_AXES + PM_NORMAL;
+
+	for (i = ARRAY_SIZE(odr_table) - 1; i >= 0; i--) {
+		if ((odr_table[i].poll_rate_ms <= poll_ms) || (i == 0))
+			break;
+	}
+	data |= odr_table[i].mask;
+
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&dev->enabled)) {
+		err = dev->tf->write(dev->dev, CTRL_REG1, 1, &data);
+		if (err < 0)
+			return err;
+	}
+
+	dev->resume_state[RES_CTRL_REG1] = data;
+	dev->ktime = ktime_set(SEC_PORTION_FROM_MS(poll_ms),
+				NSEC_PORTION_FROM_MS(poll_ms));
+
+	return err;
+}
+
+/* gyroscope data readout */
+static int lsm9ds0_gyr_get_data(struct lsm9ds0_gyr_dev *dev,
+				struct lsm9ds0_gyr_triple *data)
+{
+	int err;
+	unsigned char gyro_out[6] = {};
+	/* y,p,r hardware data */
+	s16 hw_d[3];
+
+	err = dev->tf->read(dev->dev, AXISDATA_REG, 6, gyro_out);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = le16_to_cpu(*(s16 *)&gyro_out[0]);
+	hw_d[1] = le16_to_cpu(*(s16 *)&gyro_out[2]);
+	hw_d[2] = le16_to_cpu(*(s16 *)&gyro_out[4]);
+
+	data->x = hw_d[0] * dev->sensitivity;
+	data->y = hw_d[1] * dev->sensitivity;
+	data->z = hw_d[2] * dev->sensitivity;
+
+/*
+	data->x = ((dev->pdata->negate_x) ? (-hw_d[dev->pdata->axis_map_x])
+		   : (hw_d[dev->pdata->axis_map_x]));
+	data->y = ((dev->pdata->negate_y) ? (-hw_d[dev->pdata->axis_map_y])
+		   : (hw_d[dev->pdata->axis_map_y]));
+	data->z = ((dev->pdata->negate_z) ? (-hw_d[dev->pdata->axis_map_z])
+		   : (hw_d[dev->pdata->axis_map_z]));
+		   */
+
+#ifdef LSM9DS0_DEBUG
+	dev_info(dev->dev, "gyro_out: x = %d, y = %d, z = %d\n",
+		 data->x, data->y, data->z);
+#endif
+
+	return err;
+}
+
+static void lsm9ds0_gyr_report_values(struct lsm9ds0_gyr_dev *dev,
+					struct lsm9ds0_gyr_triple *data)
+{
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X, data->x);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y, data->y);
+	input_event(dev->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Z, data->z);
+	input_sync(dev->input_dev);
+}
+
+static int lsm9ds0_gyr_hw_init(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+	u8 buf[5];
+
+	buf[0] = dev->resume_state[RES_CTRL_REG1];
+	buf[1] = dev->resume_state[RES_CTRL_REG2];
+	buf[2] = dev->resume_state[RES_CTRL_REG3];
+	buf[3] = dev->resume_state[RES_CTRL_REG4];
+	buf[4] = dev->resume_state[RES_CTRL_REG5];
+
+	err = dev->tf->write(dev->dev, CTRL_REG1, 5, buf);
+	if (err < 0)
+		return err;
+
+	buf[0] = dev->resume_state[RES_FIFO_CTRL_REG];
+	err = dev->tf->write(dev->dev, FIFO_CTRL_REG, 1, buf);
+	if (err < 0)
+		return err;
+
+	dev->hw_initialized = 1;
+
+	return err;
+}
+
+static void lsm9ds0_gyr_device_power_off(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+	u8 data = PM_OFF;
+
+	err = dev->tf->write(dev->dev, CTRL_REG1, 1, &data);
+	if (err < 0)
+		dev_err(dev->dev, "soft power off failed\n");
+
+	if (dev->pdata->power_off) {
+		/* disable_irq_nosync(acc->irq1); */
+		disable_irq_nosync(dev->irq2);
+		dev->pdata->power_off();
+		dev->hw_initialized = 0;
+	}
+
+	if (dev->hw_initialized) {
+		/*if (dev->pdata->gpio_int1 >= 0)*/
+		/*	disable_irq_nosync(dev->irq1);*/
+		if (dev->pdata->gpio_int2 >= 0) {
+			disable_irq_nosync(dev->irq2);
+			dev_info(dev->dev, "power off: irq2 disabled\n");
+		}
+		dev->hw_initialized = 0;
+	}
+}
+
+static int lsm9ds0_gyr_check_whoami(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+	u8 data;
+
+	err = dev->tf->read(dev->dev, WHO_AM_I, 1, &data);
+	if (err < 0)
+		return err;
+
+	return (data == WHOAMI_LSM9DS0_GYR) ? 0 : -ENODEV;
+}
+
+static int lsm9ds0_gyr_device_power_on(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+
+	if (dev->pdata->power_on) {
+		err = dev->pdata->power_on();
+		if (err < 0)
+			return err;
+		if (dev->pdata->gpio_int2 >= 0)
+			enable_irq(dev->irq2);
+	}
+
+	if (!dev->hw_initialized) {
+		err = lsm9ds0_gyr_hw_init(dev);
+		if (err < 0) {
+			lsm9ds0_gyr_device_power_off(dev);
+			return err;
+		}
+	}
+
+	if (dev->hw_initialized) {
+		/* if (dev->pdata->gpio_int1) {
+			enable_irq(dev->irq1);
+			dev_info(dev->dev, "power on: irq1 enabled\n");
+		} */
+		dev_dbg(dev->dev, "dev->pdata->gpio_int2 = %d\n",
+			dev->pdata->gpio_int2);
+		if (dev->pdata->gpio_int2 >= 0) {
+			enable_irq(dev->irq2);
+			dev_info(dev->dev, "power on: irq2 enabled\n");
+		}
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_gyr_enable(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&dev->enabled, 0, 1)) {
+		mutex_lock(&dev->lock);
+		err = lsm9ds0_gyr_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+
+		if (dev->polling_enabled) {
+			hrtimer_start(&(dev->hr_timer), dev->ktime,
+				      HRTIMER_MODE_REL);
+		}
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+
+static int lsm9ds0_gyr_disable(struct lsm9ds0_gyr_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled, 1, 0)) {
+		hrtimer_cancel(&dev->hr_timer);
+
+		mutex_lock(&dev->lock);
+		lsm9ds0_gyr_device_power_off(dev);
+		mutex_unlock(&dev->lock);
+	}
+	return 0;
+}
+
+static ssize_t attr_polling_rate_show(struct device *device,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	int val;
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata->poll_interval;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_rate_store(struct device *device,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	int err;
+	unsigned long interval_ms;
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &interval_ms) | !interval_ms)
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_gyr_update_odr(dev, interval_ms);
+	if(err >= 0)
+		dev->pdata->poll_interval = interval_ms;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_range_show(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	int range = 0;
+	u8 val;
+	mutex_lock(&dev->lock);
+	val = dev->pdata->fs_range;
+
+	switch (val) {
+	case LSM9DS0_GYR_FS_250DPS:
+		range = 250;
+		break;
+	case LSM9DS0_GYR_FS_500DPS:
+		range = 500;
+		break;
+	case LSM9DS0_GYR_FS_2000DPS:
+		range = 2000;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_range_store(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 250:
+		range = LSM9DS0_GYR_FS_250DPS;
+		break;
+	case 500:
+		range = LSM9DS0_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = LSM9DS0_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(dev->dev, "invalid range request: %lu\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_gyr_update_fs_range(dev, range);
+	if (err >= 0)
+		dev->pdata->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_enable_show(struct device *device,
+			        struct device_attribute *attr, char *buf)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	int val = atomic_read(&dev->enabled);
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_enable_store(struct device *device,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm9ds0_gyr_enable(dev);
+	else
+		lsm9ds0_gyr_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_polling_mode_show(struct device *device,
+				      struct device_attribute *attr, char *buf)
+{
+	int val = 0;
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	if (dev->polling_enabled)
+		val = 1;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_polling_mode_store(struct device *device,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	if (val) {
+		dev->polling_enabled = true;
+		lsm9ds0_gyr_manage_int2settings(dev, dev->fifomode);
+		if (atomic_read(&dev->enabled)) {
+			hrtimer_start(&(dev->hr_timer), dev->ktime,
+				      HRTIMER_MODE_REL);
+		}
+	} else {
+		if (dev->polling_enabled) {
+			hrtimer_cancel(&dev->hr_timer);
+		}
+		dev->polling_enabled = false;
+		lsm9ds0_gyr_manage_int2settings(dev, dev->fifomode);
+	}
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_watermark_store(struct device *device,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long watermark;
+	int res;
+
+	if (strict_strtoul(buf, 16, &watermark))
+		return -EINVAL;
+
+	res = lsm9ds0_gyr_update_watermark(dev, watermark);
+	if (res < 0)
+		return res;
+
+	return size;
+}
+
+static ssize_t attr_watermark_show(struct device *device,
+				   struct device_attribute *attr, char *buf)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "0x%02x\n", dev->watermark);
+}
+
+static ssize_t attr_fifomode_store(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long fifomode;
+	int res;
+
+	if (strict_strtoul(buf, 16, &fifomode))
+		return -EINVAL;
+	/* if (!fifomode)
+		return -EINVAL; */
+
+	mutex_lock(&dev->lock);
+	res = lsm9ds0_gyr_manage_int2settings(dev, (u8) fifomode);
+	mutex_unlock(&dev->lock);
+
+	return (res < 0) ? res : size;
+}
+
+static ssize_t attr_fifomode_show(struct device *device,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "0x%02x\n", dev->fifomode);
+}
+
+#ifdef LSM9DS0_DEBUG
+static ssize_t attr_reg_set(struct device *device,
+			    struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int err;
+	u8 data;
+	unsigned long val;
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	data = (u8)val;
+	mutex_lock(&dev->lock);
+	err = dev->tf->write(dev->dev, dev->reg_addr, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *device,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	int err;
+	u8 data;
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, dev->reg_addr, 1, &data);
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *device,
+			     struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lsm9ds0_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&dev->lock);
+	dev->reg_addr = val;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+#endif /* LSM9DS0_DEBUG */
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_polling_rate_show,
+	       attr_polling_rate_store),
+	__ATTR(range, 0666, attr_range_show, attr_range_store),
+	__ATTR(enable_device, 0666, attr_enable_show, attr_enable_store),
+	__ATTR(enable_polling, 0666, attr_polling_mode_show,
+	       attr_polling_mode_store),
+	__ATTR(fifo_samples, 0666, attr_watermark_show, attr_watermark_store),
+	__ATTR(fifo_mode, 0666, attr_fifomode_show, attr_fifomode_store),
+#ifdef LSM9DS0_DEBUG
+	__ATTR(reg_value, 0600, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0200, NULL, attr_addr_set),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+	return 0;
+}
+
+static void lsm9ds0_gyr_report_triple(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+	struct lsm9ds0_gyr_triple data_out;
+
+	err = lsm9ds0_gyr_get_data(dev, &data_out);
+	if (err < 0)
+		dev_err(dev->dev, "get_gyroscope_data failed\n");
+	else
+		lsm9ds0_gyr_report_values(dev, &data_out);
+}
+
+static void lsm9ds0_gyr_irq2_fifo(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+	u8 data, int_source, samples;
+	u8 workingmode, stored_samples;
+
+	mutex_lock(&dev->lock);
+
+	workingmode = dev->fifomode;
+
+	dev_dbg(dev->dev, "%s : fifomode:0x%02x\n", __func__, workingmode);
+
+	switch (workingmode) {
+	case FIFO_MODE_BYPASS:
+		dev_dbg(dev->dev, "%s : fifomode:0x%02x\n",
+			__func__, dev->fifomode);
+		lsm9ds0_gyr_report_triple(dev);
+		break;
+	case FIFO_MODE_FIFO:
+		samples = (dev->watermark)+1;
+		dev_dbg(dev->dev, "%s : FIFO_SRC_REG init samples:%d\n",
+			__func__, samples);
+		err = dev->tf->read(dev->dev, FIFO_SRC_REG, 1, &data);
+		if (err < 0)
+			dev_err(dev->dev, "error reading fifo source reg\n");
+
+		int_source = data;
+		dev_dbg(dev->dev, "%s :FIFO_SRC_REG content:0x%02x\n",
+			__func__, int_source);
+
+		stored_samples = int_source & FIFO_STORED_DATA_MASK;
+		dev_dbg(dev->dev, "%s : fifomode:0x%02x\n", __func__,
+			dev->fifomode);
+
+		dev_dbg(dev->dev, "%s : samples:%d stored:%d\n",
+			__func__, samples, stored_samples);
+
+		for (; samples > 0; samples--)
+			lsm9ds0_gyr_report_triple(dev);
+		lsm9ds0_gyr_fifo_reset(dev);
+		break;
+	}
+
+	mutex_unlock(&dev->lock);
+}
+
+static irqreturn_t lsm9ds0_gyr_isr2(int irq, void *data)
+{
+	struct lsm9ds0_gyr_dev *dev = (struct lsm9ds0_gyr_dev *)data;
+
+	disable_irq_nosync(irq);
+	queue_work(dev->irq2_work_queue, &dev->irq2_work);
+	pr_debug("%s %s: isr2 queued\n", LSM9DS0_GYR_DEV_NAME, __func__);
+
+	return IRQ_HANDLED;
+}
+
+static void lsm9ds0_gyr_irq2_work_func(struct work_struct *work)
+{
+
+	struct lsm9ds0_gyr_dev *dev =
+		container_of(work, struct lsm9ds0_gyr_dev, irq2_work);
+	/* TODO  add interrupt service procedure.
+		 ie:lsm9ds0_gyr_irq2_XXX(dev); */
+	lsm9ds0_gyr_irq2_fifo(dev);
+	/*  */
+	pr_debug("%s %s: IRQ2 served\n", LSM9DS0_GYR_DEV_NAME, __func__);
+
+	enable_irq(dev->irq2);
+}
+
+static int lsm9ds0_gyr_validate_pdata(struct lsm9ds0_gyr_dev *dev)
+{
+	/* checks for correctness of minimal polling period */
+	dev->pdata->min_interval = max((u32)LSM9DS0_GYR_MIN_POLL_PERIOD_MS,
+				       dev->pdata->min_interval);
+
+	dev->pdata->poll_interval = max(dev->pdata->poll_interval,
+			dev->pdata->min_interval);
+
+	if (dev->pdata->axis_map_x > 2 || dev->pdata->axis_map_y > 2 ||
+	    dev->pdata->axis_map_z > 2) {
+		dev_err(dev->dev, "invalid axis_map value x:%u y:%u z%u\n",
+			dev->pdata->axis_map_x, dev->pdata->axis_map_y,
+			dev->pdata->axis_map_z);
+
+		return -EINVAL;
+	}
+
+	/* Only allow 0 and 1 for negation boolean flag */
+	if (dev->pdata->negate_x > 1 || dev->pdata->negate_y > 1 ||
+	    dev->pdata->negate_z > 1) {
+		dev_err(dev->dev, "invalid negate value x:%u y:%u z:%u\n",
+			dev->pdata->negate_x, dev->pdata->negate_y,
+			dev->pdata->negate_z);
+		return -EINVAL;
+	}
+
+	/* Enforce minimum polling interval */
+	if (dev->pdata->poll_interval < dev->pdata->min_interval) {
+		dev_err(dev->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int lsm9ds0_gyr_input_init(struct lsm9ds0_gyr_dev *dev)
+{
+	int err = -1;
+
+	dev->input_dev = input_allocate_device();
+	if (!dev->input_dev) {
+		dev_err(dev->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev->name = LSM9DS0_GYR_DEV_NAME;
+	dev->input_dev->id.bustype = dev->bus_type;
+	dev->input_dev->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev->mscbit);
+
+	err = input_register_device(dev->input_dev);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register input polled device %s\n",
+			dev->input_dev->name);
+		input_free_device(dev->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lsm9ds0_gyr_input_cleanup(struct lsm9ds0_gyr_dev *dev)
+{
+	input_unregister_device(dev->input_dev);
+	input_free_device(dev->input_dev);
+}
+
+static void poll_function_work(struct work_struct *polling_task)
+{
+	struct lsm9ds0_gyr_dev *dev;
+	struct lsm9ds0_gyr_triple data_out;
+	int err;
+
+	dev = container_of((struct work_struct *)polling_task,
+			   struct lsm9ds0_gyr_dev, polling_task);
+	mutex_lock(&dev->lock);
+	err = lsm9ds0_gyr_get_data(dev, &data_out);
+	mutex_unlock(&dev->lock);
+
+	if (err < 0)
+		dev_err(dev->dev, "get_rotation_data failed.\n");
+	else
+		lsm9ds0_gyr_report_values(dev, &data_out);
+
+	hrtimer_start(&dev->hr_timer, dev->ktime, HRTIMER_MODE_REL);
+}
+
+static enum hrtimer_restart poll_function_read(struct hrtimer *timer)
+{
+	struct lsm9ds0_gyr_dev *dev;
+
+	dev = container_of((struct hrtimer *)timer,
+			   struct lsm9ds0_gyr_dev, hr_timer);
+
+	queue_work(dev->gyr_workqueue, &dev->polling_task);
+
+	return HRTIMER_NORESTART;
+}
+
+int lsm9ds0_gyr_probe(struct lsm9ds0_gyr_dev *dev)
+{
+	int err;
+
+	mutex_lock(&dev->lock);
+
+	err = lsm9ds0_gyr_check_whoami(dev);
+	if (err < 0)
+		goto err1;
+
+	dev->pdata = kzalloc(sizeof(*dev->pdata), GFP_KERNEL);
+	if (dev->pdata == NULL) {
+		dev_err(dev->dev, "failed to allocate memory for pdata: %d\n",
+			err);
+		goto err1;
+	}
+
+	if (dev->dev->platform_data == NULL) {
+		default_lsm9ds0_gyr_pdata.gpio_int1 = int1_gpio;
+		default_lsm9ds0_gyr_pdata.gpio_int2 = int2_gpio;
+		memcpy(dev->pdata, &default_lsm9ds0_gyr_pdata,
+		       sizeof(*dev->pdata));
+		dev_info(dev->dev, "using default plaform_data\n");
+	} else {
+		memcpy(dev->pdata, dev->dev->platform_data,
+		       sizeof(*dev->pdata));
+	}
+
+	err = lsm9ds0_gyr_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data\n");
+		goto err1_1;
+	}
+
+	if (dev->pdata->init) {
+		err = dev->pdata->init();
+		if (err < 0) {
+			dev_err(dev->dev, "init failed: %d\n", err);
+			goto err1_1;
+		}
+	}
+
+	dev->resume_state[RES_CTRL_REG1] = ALL_ZEROES | ENABLE_ALL_AXES |
+					   PM_NORMAL;
+	dev->resume_state[RES_CTRL_REG2] = ALL_ZEROES;
+	dev->resume_state[RES_CTRL_REG3] = ALL_ZEROES;
+	dev->resume_state[RES_CTRL_REG4] = ALL_ZEROES | BDU_ENABLE;
+	dev->resume_state[RES_CTRL_REG5] = ALL_ZEROES;
+	dev->resume_state[RES_FIFO_CTRL_REG] = ALL_ZEROES;
+
+	dev->polling_enabled = true;
+	dev_info(dev->dev, "polling mode enabled\n");
+
+	err = lsm9ds0_gyr_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power on failed: %d\n", err);
+		goto err2;
+	}
+
+	atomic_set(&dev->enabled, 1);
+
+	err = lsm9ds0_gyr_update_fs_range(dev, dev->pdata->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range failed\n");
+		goto err2;
+	}
+
+	err = lsm9ds0_gyr_update_odr(dev, dev->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr failed\n");
+		goto err2;
+	}
+
+	err = lsm9ds0_gyr_input_init(dev);
+	if (err < 0)
+		goto err3;
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "%s device register failed\n",
+			LSM9DS0_GYR_DEV_NAME);
+		goto err4;
+	}
+
+	lsm9ds0_gyr_device_power_off(dev);
+
+	/* As default, do not report information */
+	atomic_set(&dev->enabled, 0);
+
+	if (dev->pdata->gpio_int2 >= 0) {
+		dev->irq2 = gpio_to_irq(dev->pdata->gpio_int2);
+		dev_info(dev->dev,
+			"%s: %s has set irq2 to irq %d mapped on gpio:%d\n",
+			LSM9DS0_GYR_DEV_NAME, __func__, dev->irq2,
+			dev->pdata->gpio_int2);
+
+		INIT_WORK(&dev->irq2_work, lsm9ds0_gyr_irq2_work_func);
+		dev->irq2_work_queue =
+			create_singlethread_workqueue("lsm9ds0_gyr_irq2_wq");
+		if (!dev->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(dev->dev, "cannot create work queue2: %d\n",
+				err);
+			goto err5;
+		}
+
+		err = request_irq(dev->irq2, lsm9ds0_gyr_isr2,
+				  IRQF_TRIGGER_HIGH, "lsm9ds0_gyr_irq2", dev);
+
+		if (err < 0) {
+			dev_err(dev->dev, "request irq2 failed: %d\n", err);
+			goto err6;
+		}
+		disable_irq_nosync(dev->irq2);
+	}
+
+	INIT_WORK(&dev->polling_task, poll_function_work);
+	dev->gyr_workqueue = create_workqueue("lsm9ds0_gyr_workqueue");
+	if (!dev->gyr_workqueue)
+		goto err6;
+
+	hrtimer_init(&dev->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer.function = &poll_function_read;
+
+	mutex_unlock(&dev->lock);
+
+
+	return 0;
+
+/*err7:
+	free_irq(dev->irq2, stat);
+*/
+err6:
+	destroy_workqueue(dev->irq2_work_queue);
+err5:
+	remove_sysfs_interfaces(dev->dev);
+err4:
+	lsm9ds0_gyr_input_cleanup(dev);
+err3:
+	lsm9ds0_gyr_device_power_off(dev);
+err2:
+	if (dev->pdata->exit)
+		dev->pdata->exit();
+err1_1:
+	kfree(dev->pdata);
+err1:
+	mutex_unlock(&dev->lock);
+	if (dev->gyr_workqueue)
+		destroy_workqueue(dev->gyr_workqueue);
+	
+	return err;
+}
+EXPORT_SYMBOL(lsm9ds0_gyr_probe);
+
+int lsm9ds0_gyr_remove(struct lsm9ds0_gyr_dev *dev)
+{
+	cancel_work_sync(&dev->polling_task);
+	if (dev->gyr_workqueue)
+		destroy_workqueue(dev->gyr_workqueue);
+
+	/*
+	if (dev->pdata->gpio_int1 >= 0)
+	{
+		free_irq(dev->irq1, stat);
+		gpio_free(dev->pdata->gpio_int1);
+		destroy_workqueue(dev->irq1_work_queue);
+	}
+	*/
+	if (dev->pdata->gpio_int2 >= 0) {
+		free_irq(dev->irq2, dev);
+		gpio_free(dev->pdata->gpio_int2);
+		destroy_workqueue(dev->irq2_work_queue);
+	}
+
+	lsm9ds0_gyr_disable(dev);
+	lsm9ds0_gyr_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	kfree(dev->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm9ds0_gyr_remove);
+
+int lsm9ds0_gyr_suspend(struct lsm9ds0_gyr_dev *dev)
+{
+	int err = 0;
+
+#define SLEEP
+#ifdef CONFIG_PM
+	if (atomic_read(&dev->enabled)) {
+		mutex_lock(&dev->lock);
+
+		if (dev->polling_enabled)
+			hrtimer_cancel(&dev->hr_timer);
+#ifdef SLEEP
+		err = lsm9ds0_gyr_register_update(dev, CTRL_REG1,
+					  0x0F, (ENABLE_NO_AXES | PM_NORMAL));
+#else
+		err = lsm9ds0_gyr_register_update(dev, CTRL_REG1, 0x08,
+						  PM_OFF);
+#endif /*SLEEP*/
+		mutex_unlock(&dev->lock);
+	}
+#endif /*CONFIG_PM*/
+
+	return err;
+}
+EXPORT_SYMBOL(lsm9ds0_gyr_suspend);
+
+int lsm9ds0_gyr_resume(struct lsm9ds0_gyr_dev *dev)
+{
+	int err = 0;
+
+#ifdef CONFIG_PM
+	if (atomic_read(&dev->enabled)) {
+		mutex_lock(&dev->lock);
+		if (dev->polling_enabled)
+			hrtimer_start(&(dev->hr_timer), dev->ktime,
+				      HRTIMER_MODE_REL);
+#ifdef SLEEP
+		err = lsm9ds0_gyr_register_update(dev, CTRL_REG1, 0x0F,
+					  (ENABLE_ALL_AXES | PM_NORMAL));
+#else
+		err = lsm9ds0_gyr_register_update(dev, CTRL_REG1, 0x08,
+						  PM_NORMAL);
+#endif
+		mutex_unlock(&dev->lock);
+
+	}
+#endif /*CONFIG_PM*/
+
+	return err;
+}
+EXPORT_SYMBOL(lsm9ds0_gyr_resume);
+
+MODULE_DESCRIPTION("lsm9ds0 gyroscope driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_i2c.c b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_i2c.c
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,186 @@
+/*
+ * STMicroelectronics lsm9ds0_gyr_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm9ds0.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds0_gyr_i2c_read(struct device *dev, u8 addr, int len,
+				u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds0_gyr_i2c_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm9ds0_transfer_function lsm9ds0_gyr_i2c_tf = {
+	.write = lsm9ds0_gyr_i2c_write,
+	.read = lsm9ds0_gyr_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds0_gyr_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds0_gyr_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds0_gyr_resume(dev);
+}
+
+static int lsm9ds0_gyr_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds0_gyr_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds0_gyr_suspend(dev);
+}
+
+static const struct dev_pm_ops lsm9ds0_gyr_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds0_gyr_i2c_suspend,
+				lsm9ds0_gyr_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm9ds0_gyr_i2c_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm9ds0_gyr_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds0_gyr_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm9ds0_gyr_i2c_tf;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds0_gyr_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds0_gyr_i2c_remove(struct i2c_client *client)
+{
+	struct lsm9ds0_gyr_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds0_gyr_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm9ds0_gyr_i2c_id[] = {
+	{ "lsm9ds0_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm9ds0_gyr_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds0_gyr_i2c_id_table[] = {
+	{ .compatible = "st,lsm9ds0_gyr", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds0_gyr_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lsm9ds0_gyr_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds0_gyr_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds0_gyr_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds0_gyr_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds0_gyr_i2c_probe,
+	.remove = lsm9ds0_gyr_i2c_remove,
+	.id_table = lsm9ds0_gyr_i2c_id,
+};
+
+module_i2c_driver(lsm9ds0_gyr_i2c_driver);
+
+MODULE_DESCRIPTION("lsm9ds0 gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_spi.c b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_spi.c
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0_gyr_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,199 @@
+/*
+ * STMicroelectronics lsm9ds0_gyr_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm9ds0.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold cdata->lock */
+static int lsm9ds0_gyr_spi_read(struct device *device, u8 addr, int len,
+				u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_gyr_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lsm9ds0_gyr_spi_write(struct device *device, u8 addr, int len,
+				 u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_gyr_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM9DS0_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm9ds0_transfer_function lsm9ds0_gyr_spi_tf = {
+	.write = lsm9ds0_gyr_spi_write,
+	.read = lsm9ds0_gyr_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds0_gyr_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_gyr_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds0_gyr_resume(dev);
+}
+
+static int lsm9ds0_gyr_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds0_gyr_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds0_gyr_suspend(dev);
+}
+
+static const struct dev_pm_ops lsm9ds0_gyr_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds0_gyr_spi_suspend,
+				lsm9ds0_gyr_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lsm9ds0_gyr_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm9ds0_gyr_dev *dev;
+
+#ifdef LSM9DS0_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds0_gyr_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm9ds0_gyr_spi_tf;
+	dev->dev = &spi->dev;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds0_gyr_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds0_gyr_spi_remove(struct spi_device *spi)
+{
+	struct lsm9ds0_gyr_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LSM9DS0_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds0_gyr_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm9ds0_gyr_spi_id[] = {
+	{ "lsm9ds0_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm9ds0_gyr_spi_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds0_gyr_spi_id_table[] = {
+	{ .compatible = "st,lsm9ds0_gyr" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds0_gyr_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lsm9ds0_gyr_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds0_gyr_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds0_gyr_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds0_gyr_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds0_gyr_spi_probe,
+	.remove = lsm9ds0_gyr_spi_remove,
+	.id_table = lsm9ds0_gyr_spi_id,
+};
+
+module_spi_driver(lsm9ds0_gyr_spi_driver);
+
+MODULE_DESCRIPTION("lsm9ds0 gyr spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0.h b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0.h
--- a/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/lsm9ds0.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,325 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm9ds0.h
+* Authors            : MSH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+* Version            : V.1.0.2
+* Date               : 2013/Oct/23
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+********************************************************************************
+* REVISON HISTORY
+* 1.0.1		| 2012/Aug/30	| Denis Ciocca    | corrects gyr_get_data func
+* 1.0.2		| 2013/Oct/23	| Matteo Dameno	  | introduced acc_mag 1.0.5
+*******************************************************************************/
+
+#ifndef	__LSM9DS0_H__
+#define	__LSM9DS0_H__
+
+#define	LSM9DS0_DEV_NAME	"lsm9ds0_acc_mag"
+#define	LSM9DS0_ACC_DEV_NAME	"lsm9ds0_acc"
+#define	LSM9DS0_MAG_DEV_NAME	"lsm9ds0_mag"
+#define LSM9DS0_GYR_DEV_NAME	"lsm9ds0_gyr"
+
+#define LSM9DS0_SAD0L_ACC_MAG		0x02
+#define LSM9DS0_SAD0H_ACC_MAG		0x01
+#define LSM9DS0_SAD0L_GYR		0x00
+#define LSM9DS0_SAD0H_GYR		0x01
+
+/************************************************/
+/* 	Output data			 	*/
+/*************************************************
+accelerometer: ug
+magnetometer: ugauss
+gyroscope: udps
+*************************************************/
+
+/************************************************/
+/* 	sysfs data			 	*/
+/*************************************************
+accelerometer:
+	- pollrate->ms
+	- fullscale->g
+magnetometer:
+	- pollrate->ms
+	- fullscale->gauss
+gyroscope:
+	- pollrate->ms
+	- fullscale->dps
+*************************************************/
+
+#define LSM9DS0_ACC_MAG_I2C_SADROOT	0x07
+
+/* I2C address if gyr SA0 pin to GND */
+#define LSM9DS0_ACC_MAG_I2C_SAD_L	((LSM9DS0_ACC_MAG_I2C_SADROOT << 2) | \
+					 LSM9DS0_SAD0L_ACC_MAG)
+/* I2C address if gyr SA0 pin to Vdd */
+#define LSM9DS0_ACC_MAG_I2C_SAD_H	((LSM9DS0_ACC_MAG_I2C_SADROOT << 2) | \
+					 LSM9DS0_SAD0H_ACC_MAG)
+
+/************************************************/
+/* 	Accelerometer section defines	 	*/
+/************************************************/
+
+/* Accelerometer Sensor Full Scale */
+#define	LSM9DS0_ACC_FS_MASK	0x18
+#define LSM9DS0_ACC_FS_2G 	0x00	/* Full scale 2g */
+#define LSM9DS0_ACC_FS_4G 	0x08	/* Full scale 4g */
+#define LSM9DS0_ACC_FS_8G 	0x10	/* Full scale 8g */
+#define LSM9DS0_ACC_FS_16G	0x18	/* Full scale 16g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define ANTI_ALIASING_773	0X00
+#define ANTI_ALIASING_362	0X40
+#define ANTI_ALIASING_194	0X80
+#define ANTI_ALIASING_50	0XC0
+
+/************************************************/
+/* 	Magnetometer section defines	 	*/
+/************************************************/
+
+/* Magnetometer Sensor Full Scale */
+#define LSM9DS0_MAG_FS_MASK	0x60
+#define LSM9DS0_MAG_FS_2G	0x00	/* Full scale 2 gauss */
+#define LSM9DS0_MAG_FS_4G	0x20	/* Full scale 4 gauss */
+#define LSM9DS0_MAG_FS_8G	0x40	/* Full scale 8 gauss */
+#define LSM9DS0_MAG_FS_12G	0x60	/* Full scale 12 gauss */
+
+/************************************************/
+/* 	Gyroscope section defines	 	*/
+/************************************************/
+
+#define LSM9DS0_GYR_I2C_SADROOT		0x35
+
+/* I2C address if gyr SA0 pin to GND */
+#define LSM9DS0_GYR_I2C_SAD_L		((LSM9DS0_GYR_I2C_SADROOT << 1) | \
+					 LSM9DS0_SAD0L_GYR)
+/* I2C address if gyr SA0 pin to Vdd */
+#define LSM9DS0_GYR_I2C_SAD_H		((LSM9DS0_GYR_I2C_SADROOT << 1) | \
+					 LSM9DS0_SAD0H_GYR)
+
+/* to set gpios numb connected to gyro interrupt pins,
+ * the unused ones havew to be set to -EINVAL
+ */
+#define DEFAULT_INT1_GPIO		-EINVAL
+#define DEFAULT_INT2_GPIO		-EINVAL
+
+#define	LSM9DS0_ACC_MIN_POLL_PERIOD_MS	1
+#define LSM9DS0_MAG_MIN_POLL_PERIOD_MS	5
+
+#define LSM9DS0_GYR_DEFAULT_INT1_GPIO	-EINVAL
+#define LSM9DS0_GYR_DEFAULT_INT2_GPIO	-EINVAL
+
+#define LSM9DS0_GYR_MIN_POLL_PERIOD_MS	2
+
+#define LSM9DS0_GYR_FS_250DPS		0x00
+#define LSM9DS0_GYR_FS_500DPS		0x10
+#define LSM9DS0_GYR_FS_2000DPS		0x30
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+struct lsm9ds0_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LSM9DS0_SPI) || \
+    defined(CONFIG_INPUT_LSM9DS0_SPI_MODULE)
+#define LSM9DS0_RX_MAX_LENGTH		500
+#define LSM9DS0_TX_MAX_LENGTH		500
+
+struct lsm9ds0_transfer_buffer {
+	u8 rx_buf[LSM9DS0_RX_MAX_LENGTH];
+	u8 tx_buf[LSM9DS0_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LSM9DS0_SPI */
+
+struct lsm9ds0_dev {
+	u16 bus_type;
+	const char *name;
+	struct device *dev;
+	struct lsm9ds0_acc_platform_data *pdata_acc;
+	struct lsm9ds0_mag_platform_data *pdata_mag;
+
+	struct mutex lock;
+	struct work_struct input_work_acc;
+	struct work_struct input_work_mag;
+
+	struct hrtimer hr_timer_acc;
+	ktime_t ktime_acc;
+	struct hrtimer hr_timer_mag;
+	ktime_t ktime_mag;
+	struct workqueue_struct *data_workqueue;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_mag;
+	struct input_dev *input_dev_temp;
+
+	struct lsm9ds0_interrupt *interrupt;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+
+	atomic_t enabled_acc;
+	atomic_t enabled_mag;
+	atomic_t enabled_temp;
+
+	int temp_value_dec;
+	unsigned int temp_value_flo;
+
+	int on_before_suspend;
+
+	u16 sensitivity_acc;
+	u16 sensitivity_mag;
+
+	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+	struct lsm9ds0_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM9DS0_SPI) || \
+    defined(CONFIG_INPUT_LSM9DS0_SPI_MODULE)
+	struct lsm9ds0_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM9DS0_SPI */
+};
+
+struct lsm9ds0_acc_platform_data {
+	
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	short rot_matrix[3][3];
+
+	u8 aa_filter_bandwidth;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	int gpio_int1;
+	int gpio_int2;
+};
+
+#define LSM9DS0_GYR_RESUME_ENTRIES	6
+
+struct lsm9ds0_mag_platform_data {
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	short rot_matrix[3][3];
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm9ds0_gyr_dev {
+	u16 bus_type;
+	const char *name;
+
+	struct device *dev;
+	struct lsm9ds0_gyr_platform_data *pdata;
+
+	struct mutex lock;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	atomic_t enabled;
+
+	u8 reg_addr;
+	u8 resume_state[LSM9DS0_GYR_RESUME_ENTRIES];
+
+	u32 sensitivity;
+
+	/* interrupt related */
+	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
+
+	bool polling_enabled;
+	/* fifo related */
+	u8 watermark;
+	u8 fifomode;
+
+	struct hrtimer hr_timer;
+	ktime_t ktime;
+	struct work_struct polling_task;
+	struct workqueue_struct *gyr_workqueue;
+
+	struct lsm9ds0_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM9DS0_SPI) || \
+    defined(CONFIG_INPUT_LSM9DS0_SPI_MODULE)
+	struct lsm9ds0_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSM9DS0_SPI */
+};
+
+struct lsm9ds0_gyr_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+	unsigned int poll_interval;
+	unsigned int min_interval;
+
+	u8 fs_range;
+
+	/* gpio ports for interrupt pads */
+	int gpio_int1;
+	int gpio_int2;		/* int for fifo */
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+struct lsm9ds0_main_platform_data {
+	
+	struct lsm9ds0_acc_platform_data *pdata_acc;
+	struct lsm9ds0_mag_platform_data *pdata_mag;
+};
+
+int lsm9ds0_probe(struct lsm9ds0_dev *dev);
+int lsm9ds0_remove(struct lsm9ds0_dev *dev);
+int lsm9ds0_enable(struct lsm9ds0_dev *dev);
+int lsm9ds0_disable(struct lsm9ds0_dev *dev);
+
+int lsm9ds0_gyr_probe(struct lsm9ds0_gyr_dev *dev);
+int lsm9ds0_gyr_remove(struct lsm9ds0_gyr_dev *dev);
+int lsm9ds0_gyr_resume(struct lsm9ds0_gyr_dev *dev);
+int lsm9ds0_gyr_suspend(struct lsm9ds0_gyr_dev *dev);
+
+#endif	/* __LSM9DS0_H__ */
diff -uNr a/drivers/input/misc/st/imu/lsm9ds0/Makefile b/drivers/input/misc/st/imu/lsm9ds0/Makefile
--- a/drivers/input/misc/st/imu/lsm9ds0/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds0/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the input misc STM imu lsm9ds0 driver
+#
+obj-$(CONFIG_INPUT_LSM9DS0) += lsm9ds0_gyr.o lsm9ds0_acc_mag.o
+obj-$(CONFIG_INPUT_LSM9DS0_I2C) += lsm9ds0_gyr_i2c.o lsm9ds0_acc_mag_i2c.o
+obj-$(CONFIG_INPUT_LSM9DS0_SPI) += lsm9ds0_gyr_spi.o lsm9ds0_acc_mag_spi.o
+
+# ccflags-y += -DLSM9DS0_DEBUG
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/Kconfig b/drivers/input/misc/st/imu/lsm9ds1/Kconfig
--- a/drivers/input/misc/st/imu/lsm9ds1/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,21 @@
+
+config INPUT_LSM9DS1
+	tristate "STMicroelectronics LSM9DS1 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LSM9DS1_I2C if (I2C)
+	select INPUT_LSM9DS1_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LSM9DS1 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lsm9ds1.
+
+config INPUT_LSM9DS1_I2C
+	tristate
+	depends on INPUT_LSM9DS1
+	depends on I2C
+
+config INPUT_LSM9DS1_SPI
+	tristate
+	depends on INPUT_LSM9DS1
+	depends on SPI
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr.c b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr.c
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,2095 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm9ds1_acc_gyr.c
+* Authors            : MSH - C&I BU - Application Team
+*                    : Giuseppe Barba (giuseppe.barba@st.com)
+*                    : Matteo Dameno (matteo.dameno@st.com)
+*                    : Denis Ciocca (denis.ciocca@st.com)
+*                    : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*                    : Authors are willing to be considered the contact
+*                    : and update points for the driver.
+* Version            : V.1.0.0
+* Date               : 2016/May/16
+* Description        : LSM9DS1 accelerometer & gyroscope driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#endif
+
+#include "lsm9ds1.h"
+
+#define MS_TO_NS(x)			(x*1000000L)
+#define REFERENCE_G			(0x0B)
+
+/* Sensitivity */
+#define SENSITIVITY_ACC_2G		(60)	/** ug/LSB */
+#define SENSITIVITY_ACC_4G		(120)	/** ug/LSB */
+#define SENSITIVITY_ACC_8G		(240)	/** ug/LSB */
+#define SENSITIVITY_GYR_250		(8750)	/** udps/LSB */
+#define SENSITIVITY_GYR_500		(17500)	/** udps/LSB */
+#define SENSITIVITY_GYR_2000		(70000)	/** udps/LSB */
+
+#define FILTER_50			(50)/** Anti-Aliasing 50 Hz */
+#define FILTER_105			(105)/** Anti-Aliasing 105 Hz */
+#define FILTER_211			(211)/** Anti-Aliasing 211 Hz */
+#define FILTER_408			(408)/** Anti-Aliasing 408 Hz */
+
+#define RANGE_245DPS			(245)
+#define RANGE_500DPS			(500)
+#define RANGE_2000DPS			(2000)
+
+#define ACT_THS				(0x04)
+#define ACT_DUR				(0x05)
+#define WHO_AM_I			(0x0F)
+#define WHO_AM_I_VAL			(0x68)
+
+/* Angular rate sensor Control Register 1 */
+#define CTRL_REG1_G			(0x10)
+
+#define BW_G_SHIFT			(0)
+#define BW_G_MASK			(0x03)
+
+#define FS_G_SHIFT			(3)
+#define FS_G_MASK			(0x18) 
+
+/* Angular rate sensor Control Register 2 */
+#define CTRL_REG2_G			(0x11)
+
+#define OUT_SEL_SHIFT			(0)
+#define OUT_SEL_MASK			(0x03)
+
+#define INT_SEL_SHIFT			(2)
+#define INT_SEL_MASK			(0x0C)
+
+#define SEL_LPF1			(0x00)
+#define SEL_HPF				(0x01)
+#define SEL_LPF2			(0x02)
+
+
+#define CTRL_REG3_G			(0x12)
+
+/* Angular rate sensor sign and orientation register. */
+#define ORIENT_CFG_G			(0x13)
+#define ORIENT_CFG_G_SIGN_X_MASK	(0x20)
+#define ORIENT_CFG_G_SIGN_Y_MASK	(0x10)
+#define ORIENT_CFG_G_SIGN_Z_MASK	(0x08)
+#define ORIENT_CFG_G_SIGN_ORIENT_MASK	(0x07)
+
+#define OUT_TEMP_L			(0x15)
+#define OUT_TEMP_H			(0x16)
+#define STATUS_REG1			(0x17)
+#define	OUT_X_L_G			(0x18) /* 1st AXIS OUT REG of 6 */
+
+#define CTRL_REG4			(0x1E)
+#define CTRL_REG4_DEF			(0x38)
+#define CTRL_REG4_X_EN			(0x08)
+#define CTRL_REG4_Y_EN			(0x10)
+#define CTRL_REG4_Z_EN			(0x20)
+#define CTRL_REG4_ALL_AXES_EN		(0x38)
+#define CTRL_REG4_AXES_EN_MASK		(0x38)
+
+#define CTRL_REG5_XL			(0x1F)
+#define CTRL_REG5_XL_DEF		(0x38)
+
+/* Linear acceleration sensor Control Register 6 */
+#define CTRL_REG6_XL			(0x20)
+
+#define LSM9DS1_ACC_FS_DEF		(LSM9DS1_ACC_FS_2G)
+
+#define BW_SCAL_ODR_SHIFT		(2)
+#define BW_SCAL_ODR_MASK		(0x04)
+
+#define BW_XL_50			(0x0C)
+#define BW_XL_105			(0x08)
+#define BW_XL_211			(0x04)
+#define BW_XL_408			(0x00)
+#define BW_XL_DEF			(BW_XL_408)
+
+
+#define CTRL_REG7_XL			(0x21)
+
+#define CTRL_REG8			(0x22)
+#define CTRL_REG8_DEF			(0x44)
+
+#define CTRL_REG9			(0x23)
+#define CTRL_REG10			(0x24)
+
+
+#define STATUS_REG2			(0x27)
+#define OUT_X_L_XL			(0x28) /* 1st AXIS OUT REG of 6 */
+
+#define FIFO_CTRL			(0x2E)
+#define FIFO_SRC			(0x2F)
+
+/* INT1_A/G pin control register. */
+#define INT1_CTRL			(0x0C)
+#define INT1_CTRL_IG_G_MASK		(0x80)
+#define INT1_CTRL_IG_XL_MASK		(0x40)
+#define INT1_CTRL_FSS5_MASK		(0x20)
+#define INT1_CTRL_OVR_MASK		(0x10)
+#define INT1_CTRL_FTH_MASK		(0x08)
+#define INT1_CTRL_BOOT_MASK		(0x04)
+#define INT1_CTRL_DRDY_G_MASK		(0x02)
+#define INT1_CTRL_DRDY_XL_MASK		(0x01)
+#define INT1_CTRL_DRDY_BOTH		(INT1_CTRL_DRDY_XL_MASK | \
+					 INT1_CTRL_DRDY_G_MASK)
+
+/* INT2_A/G pin control register. */
+#define INT2_CTRL			(0x0D)
+#define INT2_CTRL_INACT_MASK		(0x80)
+#define INT2_CTRL_FSS5_MASK		(0x20)
+#define INT2_CTRL_OVR_MASK		(0x10)
+#define INT2_CTRL_FTH_MASK		(0x08)
+#define INT2_CTRL_DRDY_TEMP_MASK	(0x04)
+#define INT2_CTRL_DRDY_G_MASK		(0x02)
+#define INT2_CTRL_DRDY_XL_MASK		(0x01)
+
+/* Linear acceleration sensor interrupt source register. */
+#define INT_GEN_SRC_XL			(0x26)
+#define INT_GEN_SRC_XL_IA_MASK		(0x40)
+#define INT_GEN_SRC_XL_ZH_MASK		(0x20)
+#define INT_GEN_SRC_XL_ZL_MASK		(0x10)
+#define INT_GEN_SRC_XL_YH_MASK		(0x08)
+#define INT_GEN_SRC_XL_YL_MASK		(0x04)
+#define INT_GEN_SRC_XL_XH_MASK		(0x02)
+#define INT_GEN_SRC_XL_XL_MASK		(0x01)
+
+/* Linear acceleration sensor interrupt generator configuration register. */
+#define INT_GEN_CFG_XL			(0x06)
+#define INT_GEN_CFG_XL_AOI_MASK	(0x80)
+#define INT_GEN_CFG_XL_6D_MASK		(0x40)
+#define INT_GEN_CFG_XL_ZHIE_MASK	(0x20)
+#define INT_GEN_CFG_XL_ZLIE_MASK	(0x10)
+#define INT_GEN_CFG_XL_YHIE_MASK	(0x08)
+#define INT_GEN_CFG_XL_YLIE_MASK	(0x04)
+#define INT_GEN_CFG_XL_XHIE_MASK	(0x02)
+#define INT_GEN_CFG_XL_XLIE_MASK	(0x01)
+
+/* Linear acceleration sensor interrupt threshold registers. */
+#define INT_GEN_THS_X_XL		(0x07)
+#define INT_GEN_THS_Y_XL		(0x08)
+#define INT_GEN_THS_Z_XL		(0x09)
+
+/* Linear acceleration sensor interrupt duration register. */
+#define INT_GEN_DUR_XL			(0x0A)
+#define INT_GEN_DUR_XL_WAIT_MASK	(0x80)
+#define INT_GEN_DUR_XL_DUR_MASK	(0x7F)
+
+/* Angular rate sensor interrupt source register. */
+#define INT_GEN_SRC_G			(0x14)
+#define INT_GEN_SRC_G_IA_MASK		(0x40)
+#define INT_GEN_SRC_G_ZH_MASK		(0x20)
+#define INT_GEN_SRC_G_ZL_MASK		(0x10)
+#define INT_GEN_SRC_G_YH_MASK		(0x08)
+#define INT_GEN_SRC_G_YL_MASK		(0x04)
+#define INT_GEN_SRC_G_XH_MASK		(0x02)
+#define INT_GEN_SRC_G_XL_MASK		(0x01)
+
+/* Angular rate sensor interrupt generator configuration register. */
+#define INT_GEN_CFG_G			(0x30)
+#define INT_GEN_CFG_G_AOI_MASK		(0x80)
+#define INT_GEN_CFG_G_LIR_MASK		(0x40)
+#define INT_GEN_CFG_G_ZHIE_MASK	(0x20)
+#define INT_GEN_CFG_G_ZLIE_MASK	(0x10)
+#define INT_GEN_CFG_G_YHIE_MASK	(0x08)
+#define INT_GEN_CFG_G_YLIE_MASK	(0x04)
+#define INT_GEN_CFG_G_XHIE_MASK	(0x02)
+#define INT_GEN_CFG_G_XLIE_MASK	(0x01)
+
+/* Angular rate sensor interrupt generator threshold registers. */
+#define INT_GEN_THS_XH_G		(0x31)
+#define INT_GEN_THS_XL_G		(0x32)
+#define INT_GEN_THS_YH_G		(0x33)
+#define INT_GEN_THS_YL_G		(0x34)
+#define INT_GEN_THS_ZH_G		(0x35)
+#define INT_GEN_THS_ZL_G		(0x36)
+
+/* Angular rate sensor interrupt generator duration register. */
+#define INT_GEN_DUR_G			(0x37)
+#define INT_GEN_DUR_G_WAIT_MASK	(0x80)
+#define INT_GEN_DUR_G_DUR_MASK		(0x7F)
+
+#define DEF_ZERO			(0x00)
+#define UNDEF				(0x00)
+#define NDTEMP				(1000)	/* Not Available temperature */
+
+#define GET_BIT(reg,mask)		(((reg & mask) == mask) ? 1 : 0)
+#define SET_BIT(reg,mask)		(reg | mask)
+#define UNSET_BIT(reg,mask)		(reg & (~mask))
+
+static struct kobject *acc_kobj;
+static struct kobject *gyr_kobj;
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+struct output_rate{
+	unsigned int cutoff_ms;
+	u8 value;
+}; 
+
+static const struct output_rate lsm9ds1_gyr_odr_table[] = {
+	{  1, (LSM9DS1_GYR_ODR_952 | (LSM9DS1_GYR_BW_3)) },
+	{  2, (LSM9DS1_GYR_ODR_476 | (LSM9DS1_GYR_BW_3)) },
+	{  4, (LSM9DS1_GYR_ODR_238 | (LSM9DS1_GYR_BW_3)) },
+	{  8, (LSM9DS1_GYR_ODR_119 | (LSM9DS1_GYR_BW_3)) },
+	{ 16, (LSM9DS1_GYR_ODR_59_5 | (LSM9DS1_GYR_BW_3)) },
+	{ 67, (LSM9DS1_GYR_ODR_14_9) },
+};
+
+static const struct output_rate lsm9ds1_acc_odr_table[] = {
+        {  1, (LSM9DS1_ACC_ODR_952) },
+        {  2, (LSM9DS1_ACC_ODR_476) },
+        {  4, (LSM9DS1_ACC_ODR_238) },
+        {  8, (LSM9DS1_ACC_ODR_119) },
+        { 20, (LSM9DS1_ACC_ODR_50) },
+        { 100, (LSM9DS1_ACC_ODR_10) },
+};
+
+static const struct lsm9ds1_acc_platform_data default_lsm9ds1_acc_pdata = {
+	.fs_range = LSM9DS1_ACC_FS_2G,
+	.poll_interval = LSM9DS1_ACC_POLL_INTERVAL_DEF,
+	.min_interval = LSM9DS1_ACC_MIN_POLL_PERIOD_MS,
+	.aa_filter_bandwidth = LSM9DS1_ACC_BW_408,
+};
+
+static const struct lsm9ds1_gyr_platform_data default_lsm9ds1_gyr_pdata = {
+	.fs_range = LSM9DS1_GYR_FS_245DPS,
+	.poll_interval = LSM9DS1_GYR_POLL_INTERVAL_DEF,
+	.min_interval = LSM9DS1_GYR_MIN_POLL_PERIOD_MS,
+};
+
+struct lsm9ds1_acc_gyr_main_platform_data default_lsm9ds1_main_platform_data = {
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	u8 address;
+	u8 mask;
+};
+
+struct interrupt_value {
+	int value;
+	u8 address;
+};
+
+struct reg_rw {
+	u8 address;
+	u8 default_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	u8 address;
+	u8 default_val;
+};
+
+static struct status_registers {
+	struct reg_rw act_ths;
+	struct reg_rw act_dur;
+	struct reg_rw int_gen_cfg_xl;
+	struct reg_rw int_gen_ths_x_xl;
+	struct reg_rw int_gen_ths_y_xl;
+	struct reg_rw int_gen_ths_z_xl;
+	struct reg_rw int_gen_dur_xl;
+	struct reg_rw reference_g;
+	struct reg_rw int1_ctrl;
+	struct reg_rw int2_ctrl;
+	struct reg_r who_am_i;
+	struct reg_rw ctrl_reg1_g;
+	struct reg_rw ctrl_reg2_g;
+	struct reg_rw ctrl_reg3_g;
+	struct reg_rw orient_cfg_g;
+	struct reg_r int_gen_src_g;
+	struct reg_r status_reg1;
+	struct reg_rw ctrl_reg4;
+	struct reg_rw ctrl_reg5_xl;
+	struct reg_rw ctrl_reg6_xl;
+	struct reg_rw ctrl_reg7_xl;
+	struct reg_rw ctrl_reg8;
+	struct reg_rw ctrl_reg9;
+	struct reg_rw ctrl_reg10;	
+	struct reg_r int_gen_src_xl;
+	struct reg_r status_reg2;
+	struct reg_rw fifo_ctrl;
+	struct reg_r fifo_src;
+	struct reg_rw int_gen_cfg_g;
+	struct reg_rw int_gen_ths_xh_g;
+	struct reg_rw int_gen_ths_xl_g;
+	struct reg_rw int_gen_ths_yh_g;
+	struct reg_rw int_gen_ths_yl_g;
+	struct reg_rw int_gen_ths_zh_g;
+	struct reg_rw int_gen_ths_zl_g;
+	struct reg_rw int_gen_dur_g;
+} status_registers = {
+	.act_ths =
+		{.address = ACT_THS, 		.default_val = DEF_ZERO,},
+	.act_dur =
+		{.address = ACT_DUR, 		.default_val = DEF_ZERO,},
+	.int_gen_cfg_xl =
+		{.address = INT_GEN_CFG_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_x_xl =
+		{.address = INT_GEN_THS_X_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_y_xl =
+		{.address = INT_GEN_THS_Y_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_ths_z_xl =
+		{.address = INT_GEN_THS_Z_XL, 	.default_val = DEF_ZERO,},
+	.int_gen_dur_xl = 
+		{.address = INT_GEN_DUR_XL, 	.default_val = DEF_ZERO,},
+	.reference_g =
+		{.address = REFERENCE_G, 	.default_val = DEF_ZERO,},
+	.int1_ctrl =
+		{.address = INT1_CTRL,		.default_val = INT1_CTRL_DRDY_BOTH,},
+	.int2_ctrl =
+		{.address = INT2_CTRL,		.default_val = DEF_ZERO,},
+	.who_am_i =
+		{.address = WHO_AM_I,		.default_val = WHO_AM_I_VAL,},
+	.ctrl_reg1_g =
+		{.address = CTRL_REG1_G,	.default_val = DEF_ZERO,},
+	.ctrl_reg2_g =
+		{.address = CTRL_REG2_G,	.default_val = DEF_ZERO,},
+	.ctrl_reg3_g =
+		{.address = CTRL_REG3_G,	.default_val = DEF_ZERO,},
+	.orient_cfg_g =
+		{.address = ORIENT_CFG_G,	.default_val = DEF_ZERO,},
+	.int_gen_src_g =
+		{.address = INT_GEN_SRC_G,	.default_val = UNDEF,},
+	.status_reg1 =
+		{.address = STATUS_REG1,	.default_val = UNDEF,},
+	.ctrl_reg4 =
+		{.address = CTRL_REG4,		.default_val = CTRL_REG4_DEF,},
+	.ctrl_reg5_xl =
+		{.address = CTRL_REG5_XL,	.default_val = CTRL_REG5_XL_DEF,},
+	.ctrl_reg6_xl =
+		{.address = CTRL_REG6_XL,	.default_val = DEF_ZERO,},
+	.ctrl_reg7_xl =
+		{.address = CTRL_REG7_XL,	.default_val = DEF_ZERO,},
+	.ctrl_reg8 =
+		{.address = CTRL_REG8,		.default_val = CTRL_REG8_DEF,},
+	.ctrl_reg9 =
+		{.address = CTRL_REG9,		.default_val = DEF_ZERO,},
+	.ctrl_reg10 =
+		{.address = CTRL_REG10,	.default_val = DEF_ZERO,},
+	.int_gen_src_xl =
+		{.address = INT_GEN_SRC_XL,	.default_val = DEF_ZERO,},
+	.status_reg2 =
+		{.address = STATUS_REG2,	.default_val = UNDEF,},
+	.fifo_ctrl =
+		{.address = FIFO_CTRL,		.default_val = DEF_ZERO,},
+	.fifo_src =
+		{.address = FIFO_SRC,		.default_val = UNDEF,},
+	.int_gen_cfg_g =
+		{.address = INT_GEN_CFG_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_xh_g =
+		{.address = INT_GEN_THS_XH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_xl_g =
+		{.address = INT_GEN_THS_XL_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_yh_g =
+		{.address = INT_GEN_THS_YH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_yl_g =
+		{.address = INT_GEN_THS_YL_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_zh_g =
+		{.address = INT_GEN_THS_ZH_G,	.default_val = DEF_ZERO,},
+	.int_gen_ths_zl_g =
+		{.address = INT_GEN_THS_ZL_G,	.default_val = DEF_ZERO,},
+	.int_gen_dur_g =
+		{.address = INT_GEN_DUR_G,	.default_val = DEF_ZERO,},
+};
+/*****************************************************************************/
+
+static int lsm9ds1_acc_device_power_off(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+	u8 buf[1];
+
+	buf[0] = (LSM9DS1_ACC_ODR_MASK & LSM9DS1_ACC_ODR_OFF) |
+		 (~LSM9DS1_ACC_ODR_MASK &
+		  status_registers.ctrl_reg6_xl.resume_val);
+
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg6_xl.address,
+			     1, buf);
+	if (err < 0)
+		dev_err(dev->dev, "accelerometer soft power off "
+							"failed: %d\n", err);
+
+	if (dev->pdata_acc->power_off) {
+		dev->pdata_acc->power_off();
+	}
+
+	atomic_set(&dev->enabled_acc, 0);
+	dev->acc_skip_cnt = 0;
+	dev_info(dev->dev, "accelerometer switched off.");
+
+	return 0;
+}
+
+static int lsm9ds1_gyr_device_power_off(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+	u8 buf[1];
+
+	buf[0] = (LSM9DS1_GYR_ODR_MASK & LSM9DS1_GYR_ODR_OFF) |
+		 (~LSM9DS1_GYR_ODR_MASK &
+		  status_registers.ctrl_reg1_g.resume_val);
+
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg1_g.address,
+			     1, buf);
+	if (err < 0)
+		dev_err(dev->dev, "gyroscope soft power off "
+							"failed: %d\n", err);
+
+	if (dev->pdata_gyr->power_off) {
+		dev->pdata_gyr->power_off();
+	}
+
+	atomic_set(&dev->enabled_gyr, 0);
+	dev->gyr_skip_cnt = 0;
+	dev_info(dev->dev, "gyroscope switched off");
+
+	return 0;
+}
+
+static int lsm9ds1_gyr_disable(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_gyr, 1, 0))
+		lsm9ds1_gyr_device_power_off(dev);
+
+	return 0;
+}
+
+static int lsm9ds1_acc_disable(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_acc, 1, 0)) {
+		if (atomic_read(&dev->enabled_gyr) > 0)
+			lsm9ds1_gyr_disable(dev);
+
+		lsm9ds1_acc_device_power_off(dev);
+
+		if (dev->irq > 0)
+			disable_irq(dev->irq);
+	}
+
+	return 0;
+}
+
+int lsm9ds1_acc_gyr_disable(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+
+	err = lsm9ds1_acc_disable(dev);
+	if (err < 0)
+		return err;
+	return lsm9ds1_gyr_disable(dev);
+}
+EXPORT_SYMBOL(lsm9ds1_acc_gyr_disable);
+
+static void lsm9ds1_acc_input_cleanup(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	input_unregister_device(dev->input_dev_acc);
+	input_free_device(dev->input_dev_acc);
+}
+
+static void lsm9ds1_gyr_input_cleanup(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	input_unregister_device(dev->input_dev_gyr);
+	input_free_device(dev->input_dev_gyr);
+}
+
+static void lsm9ds1_validate_polling(unsigned int *min_interval,
+					unsigned int *poll_interval,
+					unsigned int min)
+{
+	*min_interval = max(min, *min_interval);
+	*poll_interval = max(*poll_interval, *min_interval);
+}
+
+static int lsm9ds1_acc_validate_pdata(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int res = -EINVAL;
+
+	lsm9ds1_validate_polling(&dev->pdata_acc->min_interval,
+				 &dev->pdata_acc->poll_interval,
+				(unsigned int)LSM9DS1_ACC_MIN_POLL_PERIOD_MS);
+
+	switch (dev->pdata_acc->aa_filter_bandwidth) {
+	case LSM9DS1_ACC_BW_50:
+		res = 1;
+		break;
+	case LSM9DS1_ACC_BW_105:
+		res = 1;
+		break;
+	case LSM9DS1_ACC_BW_211:
+		res = 1;
+		break;
+	case LSM9DS1_ACC_BW_408:
+		res = 1;
+		break;
+	default:
+		dev_err(dev->dev, "invalid accelerometer "
+			"bandwidth selected: %u\n",
+				dev->pdata_acc->aa_filter_bandwidth);
+	}
+
+	return res;
+}
+
+static int lsm9ds1_gyr_validate_pdata(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	/* checks for correctness of minimal polling period */
+	lsm9ds1_validate_polling(&dev->pdata_gyr->min_interval, 
+				 &dev->pdata_gyr->poll_interval,
+				(unsigned int)LSM9DS1_GYR_MIN_POLL_PERIOD_MS);
+
+	/* Enforce minimum polling interval */
+	if (dev->pdata_gyr->poll_interval < dev->pdata_gyr->min_interval) {
+		dev_err(dev->dev,
+			"minimum poll interval violated\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int lsm9ds1_acc_gyr_check_whoami(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+	u8 data;
+
+	err = dev->tf->read(dev->dev, status_registers.who_am_i.address, 1,
+			    &data);
+	if (err < 0) {
+		dev_warn(dev->dev, "Error reading WHO_AM_I\n");
+		return err;
+	}
+
+	if (data != status_registers.who_am_i.default_val) {
+		dev_err(dev->dev, "device unknown 0x%02x - 0x%02x\n",
+			status_registers.who_am_i.default_val, data);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int lsm9ds1_acc_gyr_hw_init(struct lsm9ds1_acc_gyr_dev *dev)
+{
+#ifdef LSM9DS1_DEBUG
+	dev_info(dev->dev, "%s: hw init start\n", LSM9DS1_ACC_GYR_DEV_NAME);
+#endif
+
+	status_registers.act_ths.resume_val =
+				status_registers.act_ths.default_val;
+	status_registers.act_dur.resume_val =
+				status_registers.act_dur.default_val;
+	status_registers.int_gen_cfg_xl.resume_val =
+				status_registers.int_gen_cfg_xl.default_val;
+	status_registers.int_gen_ths_x_xl.resume_val =
+				status_registers.int_gen_ths_x_xl.default_val;
+	status_registers.int_gen_ths_y_xl.resume_val =
+				status_registers.int_gen_ths_y_xl.default_val;
+	status_registers.int_gen_ths_z_xl.resume_val =
+				status_registers.int_gen_ths_z_xl.default_val;
+	status_registers.int_gen_dur_xl.resume_val =
+				status_registers.int_gen_dur_xl.default_val;
+	status_registers.reference_g.resume_val =
+				status_registers.reference_g.default_val;
+	status_registers.int1_ctrl.resume_val =
+				status_registers.int1_ctrl.default_val;
+	status_registers.int2_ctrl.resume_val =
+				status_registers.int2_ctrl.default_val;
+	status_registers.ctrl_reg1_g.resume_val =
+				status_registers.ctrl_reg1_g.default_val;
+	status_registers.ctrl_reg2_g.resume_val =
+				status_registers.ctrl_reg2_g.default_val;
+	status_registers.ctrl_reg3_g.resume_val =
+				status_registers.ctrl_reg3_g.default_val;
+	status_registers.orient_cfg_g.resume_val =
+				status_registers.orient_cfg_g.default_val;
+	status_registers.ctrl_reg4.resume_val =
+				status_registers.ctrl_reg4.default_val;
+	status_registers.ctrl_reg5_xl.resume_val =
+				status_registers.ctrl_reg5_xl.default_val;
+	status_registers.ctrl_reg6_xl.resume_val =
+				status_registers.ctrl_reg6_xl.default_val;
+	status_registers.ctrl_reg7_xl.resume_val =
+				status_registers.ctrl_reg7_xl.default_val;
+	status_registers.ctrl_reg8.resume_val =
+				status_registers.ctrl_reg8.default_val;
+	status_registers.ctrl_reg9.resume_val =
+				status_registers.ctrl_reg9.default_val;
+	status_registers.ctrl_reg10.resume_val =
+				status_registers.ctrl_reg10.default_val;
+	status_registers.fifo_ctrl.resume_val =
+				status_registers.fifo_ctrl.default_val;
+	status_registers.int_gen_cfg_g.resume_val =
+				status_registers.int_gen_cfg_g.default_val;
+	status_registers.int_gen_ths_xh_g.resume_val =
+				status_registers.int_gen_ths_xh_g.default_val;
+	status_registers.int_gen_ths_xl_g.resume_val =
+				status_registers.int_gen_ths_xl_g.default_val;
+	status_registers.int_gen_ths_yh_g.resume_val =
+				status_registers.int_gen_ths_yh_g.default_val;
+	status_registers.int_gen_ths_yl_g.resume_val =
+				status_registers.int_gen_ths_yl_g.default_val;
+	status_registers.int_gen_ths_zh_g.resume_val =
+				status_registers.int_gen_ths_zh_g.default_val;
+	status_registers.int_gen_ths_zl_g.resume_val =
+				status_registers.int_gen_ths_zl_g.default_val;
+	status_registers.int_gen_dur_g.resume_val =
+				status_registers.int_gen_dur_g.default_val;
+
+	dev->temp_value_dec = NDTEMP;
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(dev->dev, "%s: hw init done\n", LSM9DS1_ACC_GYR_DEV_NAME);
+#endif
+
+	return 0;
+}
+
+static int lsm9ds1_acc_device_power_on(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err = -1;
+	u8 buf[7];
+
+	if (dev->pdata_acc->power_on) {
+		err = dev->pdata_acc->power_on();
+		if (err < 0) {
+			dev_err(dev->dev,
+				"accelerometer power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+ 	buf[0] = status_registers.ctrl_reg4.resume_val;
+ 	buf[1] = status_registers.ctrl_reg5_xl.resume_val;
+	buf[2] = status_registers.ctrl_reg6_xl.resume_val;
+	buf[3] = status_registers.ctrl_reg7_xl.resume_val;
+	buf[4] = status_registers.ctrl_reg8.resume_val;
+	buf[5] = status_registers.ctrl_reg9.resume_val;
+	buf[6] = status_registers.ctrl_reg10.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg4.address,
+			     7, buf);
+	if (err < 0)
+		goto err_resume_state;
+	
+	buf[0] = status_registers.int_gen_cfg_xl.resume_val;
+	buf[1] = status_registers.int_gen_ths_x_xl.resume_val;
+	buf[2] = status_registers.int_gen_ths_y_xl.resume_val;
+	buf[3] = status_registers.int_gen_ths_z_xl.resume_val;
+	buf[4] = status_registers.int_gen_dur_xl.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.int_gen_cfg_xl.address,
+			     5, buf);
+	if (err < 0)
+		goto err_resume_state;
+	
+	buf[0] = status_registers.int1_ctrl.resume_val;
+	buf[1] = status_registers.int2_ctrl.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.int1_ctrl.address,
+			     2, buf);
+	if (err < 0)
+		goto err_resume_state;
+	
+	buf[0] = status_registers.fifo_ctrl.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.fifo_ctrl.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+	
+	buf[0] = status_registers.ctrl_reg8.resume_val;
+	buf[1] = status_registers.ctrl_reg9.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg8.address,
+			     2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_acc, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&dev->enabled_acc, 0);
+	dev_err(dev->dev, "accelerometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm9ds1_gyr_device_power_on(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err = -1;
+	u8 buf[8];
+
+	if (dev->pdata_gyr->power_on) {
+		err = dev->pdata_gyr->power_on();
+		if (err < 0) {
+			dev_err(dev->dev,
+				"gyroscope power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	buf[0] = status_registers.act_ths.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.act_ths.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+	
+	buf[0] = status_registers.reference_g.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.reference_g.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg1_g.resume_val;
+	buf[1] = status_registers.ctrl_reg2_g.resume_val;
+	buf[2] = status_registers.ctrl_reg3_g.resume_val;
+	buf[3] = status_registers.orient_cfg_g.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg1_g.address,
+			     4, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.ctrl_reg4.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg4.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_gen_cfg_g.resume_val;
+	buf[1] = status_registers.int_gen_ths_xh_g.resume_val;
+	buf[2] = status_registers.int_gen_ths_xl_g.resume_val;
+	buf[3] = status_registers.int_gen_ths_yh_g.resume_val;
+	buf[4] = status_registers.int_gen_ths_yl_g.resume_val;
+	buf[5] = status_registers.int_gen_ths_zh_g.resume_val;
+	buf[6] = status_registers.int_gen_ths_zl_g.resume_val;
+	buf[7] = status_registers.int_gen_dur_g.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.int_gen_cfg_g.address,
+			     8, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int1_ctrl.resume_val;
+	buf[1] = status_registers.int2_ctrl.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.int1_ctrl.address,
+			     2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[1] = status_registers.fifo_ctrl.resume_val;
+	err = dev->tf->write(dev->dev, status_registers.fifo_ctrl.address,
+			     1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_gyr, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&dev->enabled_gyr, 0);
+	dev_err(dev->dev, "gyroscope hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm9ds1_acc_update_fs_range(struct lsm9ds1_acc_gyr_dev *dev,
+				       u8 new_fs_range)
+{
+	int err = -1;
+	u16 sensitivity;
+	u8 val, buf[1];
+
+	switch (new_fs_range) {
+	case LSM9DS1_ACC_FS_2G:
+		sensitivity = SENSITIVITY_ACC_2G;
+		break;
+	case LSM9DS1_ACC_FS_4G:
+		sensitivity = SENSITIVITY_ACC_4G;
+		break;
+	case LSM9DS1_ACC_FS_8G:
+		sensitivity = SENSITIVITY_ACC_8G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid acc fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	val = ((LSM9DS1_ACC_FS_MASK & new_fs_range) |
+	       (~LSM9DS1_ACC_FS_MASK &
+		status_registers.ctrl_reg6_xl.resume_val));
+
+	buf[0] = val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg6_xl.address,
+			     1, buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = val;
+	dev->sensitivity_acc = sensitivity;
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer fs range failed "
+		"0x%02x: %d\n", buf[0], err);
+	return err;
+}
+
+static int lsm9ds1_gyr_update_fs_range(struct lsm9ds1_acc_gyr_dev *dev,
+				       u8 new_fs_range)
+{
+	int err = -1;
+	u8 buf[1];
+	u8 updated_val;
+
+	u32 sensitivity;
+
+	switch(new_fs_range) {
+	case LSM9DS1_GYR_FS_245DPS:
+		sensitivity = SENSITIVITY_GYR_250;
+		break;
+	case LSM9DS1_GYR_FS_500DPS:
+		sensitivity = SENSITIVITY_GYR_500;
+		break;
+	case LSM9DS1_GYR_FS_2000DPS:
+		sensitivity = SENSITIVITY_GYR_2000;
+		break;
+	default:
+		dev_err(dev->dev, "invalid g range "
+					"requested: %u\n", new_fs_range);
+		return -EINVAL;
+	}
+
+	updated_val = ((LSM9DS1_GYR_FS_MASK & new_fs_range) |
+		       (~LSM9DS1_GYR_FS_MASK & status_registers.ctrl_reg1_g.resume_val));
+	
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg1_g.address,
+			     1, buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg1_g.resume_val = updated_val;
+	dev->sensitivity_gyr = sensitivity;
+
+error:
+	return err;
+}
+
+static int lsm9ds1_acc_update_odr(struct lsm9ds1_acc_gyr_dev *dev,
+				  unsigned int poll_ms)
+{
+	int i, err = 0;
+	u8 buf[1];
+
+	for (i = ARRAY_SIZE(lsm9ds1_acc_odr_table) - 1; i >= 0; i--) {
+		if ((lsm9ds1_acc_odr_table[i].cutoff_ms <= poll_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	buf[0] = LSM9DS1_ACC_ODR_MASK & lsm9ds1_acc_odr_table[i].value;
+	buf[0] |= (~LSM9DS1_ACC_ODR_MASK) &
+		  status_registers.ctrl_reg6_xl.resume_val;
+
+	if (atomic_read(&dev->enabled_acc)) {
+		err = dev->tf->write(dev->dev,
+				     status_registers.ctrl_reg6_xl.address,
+				     1, buf);
+		if (err < 0)
+			goto error;
+	}
+
+	dev->acc_dec_cnt = poll_ms / lsm9ds1_acc_odr_table[i].cutoff_ms;
+	dev->acc_skip_cnt = 0;
+
+	status_registers.ctrl_reg6_xl.resume_val = buf[0];
+
+	dev_info(dev->dev, "accelerometer odr set to %d\n", poll_ms);
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer odr failed "
+			"0x%02x: %d\n", buf[0], err);
+
+	return err;
+}
+
+static int lsm9ds1_gyr_update_odr(struct lsm9ds1_acc_gyr_dev *dev,
+				  unsigned int poll_ms)
+{
+	int err = 0;
+	u8 buf[1];
+	u8 val;
+	int i;
+
+	if (atomic_read(&dev->enabled_acc))
+		val = min(poll_ms, dev->pdata_acc->poll_interval);
+	else
+		val = poll_ms;
+
+	for (i = ARRAY_SIZE(lsm9ds1_gyr_odr_table) - 1; i >= 0; i--)
+		if ((lsm9ds1_gyr_odr_table[i].cutoff_ms <= val) || (i == 0))
+			break;
+
+	buf[0] = LSM9DS1_GYR_ODR_MASK & lsm9ds1_gyr_odr_table[i].value;
+	buf[0] |= (~LSM9DS1_GYR_ODR_MASK) &
+		  status_registers.ctrl_reg1_g.resume_val;
+
+	if (atomic_read(&dev->enabled_gyr)) {
+		/* Set ODR value */
+		err = dev->tf->write(dev->dev,
+				     status_registers.ctrl_reg1_g.address,
+				     1, buf);
+		if (err < 0)
+			goto error;
+	}
+
+	dev->gyr_dec_cnt = poll_ms / lsm9ds1_gyr_odr_table[i].cutoff_ms;
+	dev->gyr_skip_cnt = 0;
+
+	status_registers.ctrl_reg1_g.resume_val = buf[0];
+
+	dev_info(dev->dev, "gyro odr set to %d\n", poll_ms);
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer odr failed "
+		"0x%02x: %d\n", buf[0], err);
+
+	return err;
+}
+
+static int lsm9ds1_acc_update_filter(struct lsm9ds1_acc_gyr_dev *dev,
+							u8 new_bandwidth)
+{
+	int err = -1;
+	u8 updated_val;
+	u8 buf[1];
+
+	switch (new_bandwidth) {
+	case LSM9DS1_ACC_BW_50:
+		break;
+	case LSM9DS1_ACC_BW_105:
+		break;
+	case LSM9DS1_ACC_BW_211:
+		break;
+	case LSM9DS1_ACC_BW_408:
+		break;
+	default:
+		dev_err(dev->dev, "invalid accelerometer "
+			"update bandwidth requested: %u\n", new_bandwidth);
+		return -EINVAL;
+	}
+
+	err = dev->tf->read(dev->dev, status_registers.ctrl_reg6_xl.address, 1,
+			    buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = buf[0];
+
+	updated_val = ((LSM9DS1_ACC_BW_MASK & new_bandwidth) |
+		       (~LSM9DS1_ACC_BW_MASK & buf[0]));
+
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg6_xl.address,
+			     1, buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg6_xl.resume_val = updated_val;
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update accelerometer fs range failed "
+		"0x%02x: %d\n", buf[0], err);
+	return err;
+}
+
+static int lsm9ds1_acc_enable(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled_acc, 0, 1)) {
+		int err;
+
+		err = lsm9ds1_acc_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled_acc, 0);
+			dev_err(dev->dev, "enable accelerometer failed");
+			return err;
+		}
+
+		if (dev->irq > 0)
+			enable_irq(dev->irq);
+	}
+
+	return 0;
+}
+
+static int lsm9ds1_gyr_enable(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled_gyr, 0, 1)) {
+		int err;
+
+		if (atomic_read(&dev->enabled_acc) == 0)
+			lsm9ds1_acc_enable(dev);
+
+		err = lsm9ds1_gyr_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled_gyr, 0);
+			return err;
+		}
+	}
+	return 0;
+}
+
+int lsm9ds1_acc_gyr_enable(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+
+	err = lsm9ds1_acc_enable(dev);
+	if (err < 0)
+		return err;
+	return lsm9ds1_gyr_enable(dev);
+}
+EXPORT_SYMBOL(lsm9ds1_acc_gyr_enable);
+
+static int lsm9ds1_acc_get_data(struct lsm9ds1_acc_gyr_dev *dev, int *xyz)
+{
+	int i, err = -1;
+	u8 acc_data[6];
+	s32 hw_d[3];
+
+	err = dev->tf->read(dev->dev, OUT_X_L_XL, 6, acc_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)( (s16)((acc_data[1] << 8) | (acc_data[0]))));
+	hw_d[1] = ((s32)( (s16)((acc_data[3] << 8) | (acc_data[2]))));
+	hw_d[2] = ((s32)( (s16)((acc_data[5] << 8) | (acc_data[4]))));
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(dev->dev, "%s read x=%X %X(regH regL), x=%d(dec) [udps]\n",
+		 LSM9DS1_GYR_DEV_NAME, acc_data[1], acc_data[0], hw_d[0]);
+	dev_info(dev->dev, "%s read y=%X %X(regH regL), y=%d(dec) [udps]\n",
+		 LSM9DS1_GYR_DEV_NAME, acc_data[3], acc_data[2], hw_d[1]);
+	dev_info(dev->dev, "%s read z=%X %X(regH regL), z=%d(dec) [udps]\n",
+		 LSM9DS1_GYR_DEV_NAME, acc_data[5], acc_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * dev->sensitivity_acc;
+	hw_d[1] = hw_d[1] * dev->sensitivity_acc;
+	hw_d[2] = hw_d[2] * dev->sensitivity_acc;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = dev->pdata_main->rot_matrix[0][i] * hw_d[0] +
+				dev->pdata_main->rot_matrix[1][i] * hw_d[1] +
+				dev->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static int lsm9ds1_gyr_get_data(struct lsm9ds1_acc_gyr_dev *dev, int *xyz)
+{
+	int i, err = 1;
+	u8 gyro_data[6];
+	s32 hw_d[3];
+
+	err = dev->tf->read(dev->dev, OUT_X_L_G, 6, gyro_data);
+	if (err < 0)
+		return err;
+
+	hw_d[0] = (s32) ((s16)((gyro_data[1]) << 8) | gyro_data[0]);
+	hw_d[1] = (s32) ((s16)((gyro_data[3]) << 8) | gyro_data[2]);
+	hw_d[2] = (s32) ((s16)((gyro_data[5]) << 8) | gyro_data[4]);
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(dev->dev, "%s read x=%X %X(regH regL), x=%d(dec) [udps]\n",
+		 LSM9DS1_GYR_DEV_NAME, gyro_data[1], gyro_data[0], hw_d[0]);
+	dev_info(dev->dev, "%s read y=%X %X(regH regL), y=%d(dec) [udps]\n",
+		 LSM9DS1_GYR_DEV_NAME, gyro_data[3], gyro_data[2], hw_d[1]);
+	dev_info(dev->dev, "%s read z=%X %X(regH regL), z=%d(dec) [udps]\n",
+		 LSM9DS1_GYR_DEV_NAME, gyro_data[5], gyro_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * dev->sensitivity_gyr;
+	hw_d[1] = hw_d[1] * dev->sensitivity_gyr;
+	hw_d[2] = hw_d[2] * dev->sensitivity_gyr;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = dev->pdata_main->rot_matrix[0][i] * hw_d[0] +
+				dev->pdata_main->rot_matrix[1][i] * hw_d[1] +
+				dev->pdata_main->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static void lsm9ds1_acc_report_values(struct lsm9ds1_acc_gyr_dev *dev,
+				      int *xyz, s64 timestamp)
+{
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(dev->input_dev_acc, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(dev->input_dev_acc);
+}
+
+static void lsm9ds1_gyr_report_values(struct lsm9ds1_acc_gyr_dev *dev,
+				      int *xyz, s64 timestamp)
+{
+	input_event(dev->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_event(dev->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(dev->input_dev_gyr, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(dev->input_dev_gyr);
+}
+
+static int lsm9ds1_acc_input_init(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+
+	dev->input_dev_acc = input_allocate_device();
+	if (!dev->input_dev_acc) {
+		dev_err(dev->dev, "acc input allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev_acc->name = LSM9DS1_ACC_DEV_NAME;
+	dev->input_dev_acc->id.bustype = dev->bus_type;
+	dev->input_dev_acc->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_acc, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev_acc->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_TIME_MSB, dev->input_dev_acc->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, dev->input_dev_acc->mscbit);
+
+	err = input_register_device(dev->input_dev_acc);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register accelerometer input device %s\n",
+			dev->input_dev_acc->name);
+		input_free_device(dev->input_dev_acc);
+	}
+
+	return err;
+}
+
+static int lsm9ds1_gyr_input_init(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	int err;
+
+	dev->input_dev_gyr = input_allocate_device();
+	if (!dev->input_dev_gyr) {
+		dev_err(dev->dev, "input device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev_gyr->name = LSM9DS1_GYR_DEV_NAME;
+	dev->input_dev_gyr->id.bustype = dev->bus_type;
+	dev->input_dev_gyr->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_gyr, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev_gyr->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev_gyr->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev_gyr->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev_gyr->mscbit);
+	set_bit(INPUT_EVENT_TIME_MSB, dev->input_dev_gyr->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, dev->input_dev_gyr->mscbit);
+
+	err = input_register_device(dev->input_dev_gyr);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register input device %s\n",
+			dev->input_dev_gyr->name);
+		input_free_device(dev->input_dev_gyr);
+	}
+
+	return err;
+}
+static void lsm9ds1_input_cleanup(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	input_unregister_device(dev->input_dev_acc);
+	input_free_device(dev->input_dev_acc);
+
+	input_unregister_device(dev->input_dev_gyr);
+	input_free_device(dev->input_dev_gyr);
+}
+
+static ssize_t attr_set_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+						dev->pdata_acc->min_interval);
+
+	mutex_lock(&dev->lock);
+	dev->pdata_acc->poll_interval = (unsigned int)interval_ms;
+	lsm9ds1_acc_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_polling_rate_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_acc->poll_interval;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_get_enable_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+
+	int val = (int)atomic_read(&dev->enabled_acc);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm9ds1_acc_enable(dev);
+	else
+		lsm9ds1_acc_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	u8 val;
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	int range = 2;
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_acc->fs_range ;
+	mutex_unlock(&dev->lock);
+
+	switch (val) {
+	case LSM9DS1_ACC_FS_2G:
+		range = 2;
+		break;
+	case LSM9DS1_ACC_FS_4G:
+		range = 4;
+		break;
+	case LSM9DS1_ACC_FS_8G:
+		range = 8;
+		break;
+	}
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_acc(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 2:
+		range = LSM9DS1_ACC_FS_2G;
+		break;
+	case 4:
+		range = LSM9DS1_ACC_FS_4G;
+		break;
+	case 8:
+		range = LSM9DS1_ACC_FS_8G;
+		break;
+	default:
+		dev_err(dev->dev, "accelerometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds1_acc_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_acc->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	dev_info(dev->dev, "accelerometer range set to %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	u8 val;
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	int frequency = FILTER_408;
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_acc->aa_filter_bandwidth;
+	mutex_unlock(&dev->lock);
+
+	switch (val) {
+	case LSM9DS1_ACC_BW_50:
+		frequency = FILTER_50;
+		break;
+	case LSM9DS1_ACC_BW_105:
+		frequency = FILTER_105;
+		break;
+	case LSM9DS1_ACC_BW_211:
+		frequency = FILTER_211;
+		break;
+	case LSM9DS1_ACC_BW_408:
+		frequency = FILTER_408;
+		break;
+	}
+
+	return sprintf(buf, "%d\n", frequency);
+}
+
+static ssize_t attr_set_aa_filter(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 frequency;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case FILTER_50:
+		frequency = LSM9DS1_ACC_BW_50;
+		break;
+	case FILTER_105:
+		frequency = LSM9DS1_ACC_BW_105;
+		break;
+	case FILTER_211:
+		frequency = LSM9DS1_ACC_BW_211;
+		break;
+	case FILTER_408:
+		frequency = LSM9DS1_ACC_BW_408;
+		break;
+	default:
+		dev_err(dev->dev, "accelerometer invalid filter "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds1_acc_update_filter(dev, frequency);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_acc->aa_filter_bandwidth = frequency;
+	mutex_unlock(&dev->lock);
+
+	dev_info(dev->dev, "accelerometer anti-aliasing filter "
+					"set to: %lu Hz\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_polling_rate_gyr(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	int val;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_gyr->poll_interval;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate_gyr(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	int err;
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	
+	interval_ms = (unsigned int)max((unsigned int)interval_ms,
+					dev->pdata_gyr->min_interval);
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds1_gyr_update_odr(dev, interval_ms);
+	if(err >= 0)
+		dev->pdata_gyr->poll_interval = interval_ms;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_gyr(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	int val = atomic_read(&dev->enabled_gyr);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_gyr(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm9ds1_gyr_enable(dev);
+	else
+		lsm9ds1_gyr_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_range_gyr(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					char *buf)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	int range = 0;
+	u8 val;
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_gyr->fs_range;
+	switch (val) {
+	case LSM9DS1_GYR_FS_245DPS:
+		range = RANGE_245DPS;
+		break;
+	case LSM9DS1_GYR_FS_500DPS:
+		range = RANGE_500DPS;
+		break;
+	case LSM9DS1_GYR_FS_2000DPS:
+		range = RANGE_2000DPS;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_gyr(struct kobject *kobj,
+					struct kobj_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct device *device = to_dev(kobj->parent);
+	struct lsm9ds1_acc_gyr_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 245:
+		range = LSM9DS1_GYR_FS_245DPS;
+		break;
+	case 500:
+		range = LSM9DS1_GYR_FS_500DPS;
+		break;
+	case 2000:
+		range = LSM9DS1_GYR_FS_2000DPS;
+		break;
+	default:
+		dev_err(dev->dev, "invalid range request: %lu,"
+				" discarded\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lsm9ds1_gyr_update_fs_range(dev, range);
+	if (err >= 0)
+		dev->pdata_gyr->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	dev_info(dev->dev, "range set to: %lu dps\n", val);
+
+	return size;
+}
+
+static struct kobj_attribute poll_attr_acc =
+	__ATTR(pollrate_ms, 0664, attr_get_polling_rate_acc, 
+						attr_set_polling_rate_acc);
+static struct kobj_attribute enable_attr_acc =
+	__ATTR(enable_device, 0664, attr_get_enable_acc, attr_set_enable_acc);
+static struct kobj_attribute fs_attr_acc =
+	__ATTR(range, 0664, attr_get_range_acc, attr_set_range_acc);
+static struct kobj_attribute aa_filter_attr  =
+	__ATTR(anti_aliasing_frequency, 0664, attr_get_aa_filter, 
+							attr_set_aa_filter);
+static struct kobj_attribute poll_attr_gyr =
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate_gyr, 
+						attr_set_polling_rate_gyr);
+static struct kobj_attribute enable_attr_gyr =
+	__ATTR(enable_device, 0666, attr_get_enable_gyr, attr_set_enable_gyr);
+static struct kobj_attribute range_attr_gyr =
+	__ATTR(range, 0666, attr_get_range_gyr, attr_set_range_gyr);
+
+static struct attribute *attributes_acc[] = {
+	&poll_attr_acc.attr,
+	&enable_attr_acc.attr,
+	&fs_attr_acc.attr,
+	&aa_filter_attr.attr,
+	NULL,
+};
+
+static struct attribute *attributes_gyr[] = {
+	&poll_attr_gyr.attr,
+	&enable_attr_gyr.attr,
+	&range_attr_gyr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group_acc = {
+	.attrs = attributes_acc,
+};
+
+static struct attribute_group attr_group_gyr = {
+	.attrs = attributes_gyr,
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int err;
+
+	acc_kobj = kobject_create_and_add("accelerometer", &dev->kobj);
+	if(!acc_kobj)
+		return -ENOMEM;
+
+	gyr_kobj = kobject_create_and_add("gyroscope", &dev->kobj);
+	if(!gyr_kobj)
+		return -ENOMEM;
+
+	err = sysfs_create_group(acc_kobj, &attr_group_acc);
+	if (err)
+		kobject_put(acc_kobj);
+
+	err = sysfs_create_group(gyr_kobj, &attr_group_gyr);
+	if (err)
+		kobject_put(gyr_kobj);
+
+	return 0;
+}
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	kobject_put(acc_kobj);
+	kobject_put(gyr_kobj);
+}
+
+#ifdef CONFIG_OF
+static int lsm9ds1_acc_gyr_parse_dt(struct lsm9ds1_acc_gyr_dev *dev,
+				    struct device* device)
+{
+	struct device_node *dn;
+	uint8_t i, j;
+	uint32_t val, vect[9];
+
+	if (of_match_device(dev->acc_gyr_dt_id, device)) {
+		dn = device->of_node;
+		dev->pdata_main->of_node = dn;
+		
+		if (of_property_read_u32_array(dn, "rot-matrix", vect,
+			      ARRAY_SIZE(vect)) >= 0) {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					dev->pdata_main->rot_matrix[i][j] =
+						(short)vect[3 * j + i];
+				}
+			}
+		} else {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					dev->pdata_main->rot_matrix[i][j] =
+			default_lsm9ds1_main_platform_data.rot_matrix[i][j];
+				}
+			}
+		}
+
+		if (!of_property_read_u32(dn, "g-poll-interval", &val)) {
+			dev->pdata_gyr->poll_interval = val;
+		} else {
+			dev->pdata_gyr->poll_interval =
+				LSM9DS1_GYR_POLL_INTERVAL_DEF;
+		}
+
+		if (!of_property_read_u32(dn, "g-min-interval", &val)) {
+			dev->pdata_gyr->min_interval = val;
+		} else {
+			dev->pdata_gyr->min_interval =
+				LSM9DS1_GYR_MIN_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "g-fs-range", &val)) {
+			dev->pdata_gyr->fs_range = val;
+		} else {
+			dev->pdata_gyr->fs_range = LSM9DS1_GYR_FS_245DPS;
+		}
+
+		if (!of_property_read_u32(dn, "x-poll-interval", &val)) {
+			dev->pdata_acc->poll_interval = val;
+		} else {
+			dev->pdata_acc->poll_interval =
+				LSM9DS1_ACC_POLL_INTERVAL_DEF;
+		}
+
+		if (!of_property_read_u32(dn, "x-min-interval", &val)) {
+			dev->pdata_acc->min_interval = val;
+		} else {
+			dev->pdata_acc->min_interval =
+				LSM9DS1_ACC_MIN_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "x-fs-range", &val)) {
+			dev->pdata_acc->fs_range = val;
+		} else {
+			dev->pdata_acc->fs_range = LSM9DS1_ACC_FS_2G;
+		}
+
+		if (!of_property_read_u32(dn, "aa-filter-bw", &val)) {
+			dev->pdata_acc->fs_range = val;
+		} else {
+			dev->pdata_acc->fs_range = LSM9DS1_ACC_BW_408;
+		}
+		return 0;
+	}
+	return -1;
+}
+#endif
+
+static irqreturn_t lsm9ds1_acc_gyr_save_timestamp(int irq, void *private)
+{
+	struct lsm9ds1_acc_gyr_dev *dev;
+
+	dev = (struct lsm9ds1_acc_gyr_dev *)private;
+
+	disable_irq_nosync(irq);
+
+	dev->timestamp = lsm9ds1_get_time_ns();
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t lsm9ds1_acc_gyr_thread_fn(int irq, void *private)
+{
+	u8 data;
+	irqreturn_t ret = IRQ_NONE;
+	struct lsm9ds1_acc_gyr_dev *dev;
+
+	dev = (struct lsm9ds1_acc_gyr_dev *)private;
+
+	if (dev->tf->read(dev->dev, status_registers.status_reg1.address, 1,
+			  &data) < 0)
+		goto out;
+
+	if (data & 0x01) {
+		int xyz[3] = {}, err;
+
+		err = lsm9ds1_acc_get_data(dev, xyz);
+		if (err < 0) {
+			dev_err(dev->dev, "get accelerometer data failed\n");
+		} else if (++dev->acc_skip_cnt >= dev->acc_dec_cnt) {
+			lsm9ds1_acc_report_values(dev, xyz, dev->timestamp);
+			dev->acc_skip_cnt = 0;
+		}
+		ret = IRQ_HANDLED;
+	}
+
+	if (data & 0x02) {
+		int xyz[3] = {}, err;
+
+		err = lsm9ds1_gyr_get_data(dev, xyz);
+		if (err < 0) {
+			dev_err(dev->dev, "get gyroscope data failed.\n");
+		} else if (++dev->gyr_skip_cnt >= dev->gyr_dec_cnt) {
+			lsm9ds1_gyr_report_values(dev, xyz, dev->timestamp);
+			dev->gyr_skip_cnt = 0;
+		}
+		ret = IRQ_HANDLED;
+	}
+
+out:
+	enable_irq(irq);
+	return ret;
+}
+
+int lsm9ds1_acc_gyr_probe(struct lsm9ds1_acc_gyr_dev *dev, int irq)
+{
+	int err;
+
+	mutex_lock(&dev->lock);
+
+	err = lsm9ds1_acc_gyr_check_whoami(dev);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+
+	dev->pdata_main = kzalloc(sizeof(*dev->pdata_main), GFP_KERNEL);
+	dev->pdata_acc = kzalloc(sizeof(*dev->pdata_acc), GFP_KERNEL);
+	dev->pdata_gyr = kzalloc(sizeof(*dev->pdata_gyr), GFP_KERNEL);
+
+	if ((dev->pdata_main == NULL) || (dev->pdata_acc == NULL) ||
+	    (dev->pdata_gyr == NULL)){
+		err = -ENOMEM;
+		dev_err(dev->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+	dev->pdata_main->pdata_acc = dev->pdata_acc;
+	dev->pdata_main->pdata_gyr = dev->pdata_gyr;
+#ifdef CONFIG_OF
+	lsm9ds1_acc_gyr_parse_dt(dev, dev->dev);
+#else
+	if (dev->dev->platform_data == NULL) {
+		memcpy(dev->pdata_main, 
+				&default_lsm9ds1_main_platform_data,
+				sizeof(*dev->pdata_main));
+		memcpy(dev->pdata_acc, &default_lsm9ds1_acc_pdata,
+						sizeof(*dev->pdata_acc));
+		memcpy(dev->pdata_gyr, &default_lsm9ds1_gyr_pdata,
+						sizeof(*dev->pdata_gyr));
+		dev_info(dev->dev, "using default plaform_data for "
+					"accelerometer and gyroscope\n");
+	} else {
+		struct lsm9ds1_acc_gyr_main_platform_data *platform_data;
+		platform_data = dev->dev->platform_data;
+
+		if(platform_data == NULL) {
+			memcpy(dev->pdata_main,
+				&default_lsm9ds1_main_platform_data,
+				sizeof(*dev->pdata_main));
+			dev_info(dev->dev, "using default plaform_data"
+							" for accelerometer\n");
+		} else {
+			memcpy(dev->pdata_main, platform_data,
+						sizeof(*dev->pdata_acc));
+		}
+
+		if(platform_data->pdata_acc == NULL) {
+			memcpy(dev->pdata_acc, &default_lsm9ds1_acc_pdata,
+						sizeof(*dev->pdata_acc));
+			dev_info(dev->dev, "using default plaform_data"
+							" for accelerometer\n");
+		} else {
+			memcpy(dev->pdata_acc, platform_data->pdata_acc,
+						sizeof(*dev->pdata_acc));
+		}
+
+		if(platform_data->pdata_gyr == NULL) {
+			memcpy(dev->pdata_gyr, &default_lsm9ds1_gyr_pdata,
+						sizeof(*dev->pdata_gyr));
+			dev_info(dev->dev, "using default plaform_data"
+							" for gyroscope\n");
+		} else {
+			memcpy(dev->pdata_gyr, platform_data->pdata_gyr,
+						sizeof(*dev->pdata_gyr));
+		}
+	}
+#endif
+
+	err = lsm9ds1_acc_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data for "
+							"accelerometer \n");
+		goto exit_kfree_pdata;
+	}
+
+	err = lsm9ds1_gyr_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate platform data for "
+							"gyroscope\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (dev->pdata_acc->init) {
+		err = dev->pdata_acc->init();
+		if (err < 0) {
+			dev_err(dev->dev, "accelerometer init failed: "
+								"%d\n", err);
+			goto err_pdata_acc_init;
+		}
+	}
+	if (dev->pdata_gyr->init) {
+		err = dev->pdata_gyr->init();
+		if (err < 0) {
+			dev_err(dev->dev, "magnetometer init failed: "
+								"%d\n", err);
+			goto err_pdata_gyr_init;
+		}
+	}
+
+	err = lsm9ds1_acc_gyr_hw_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm9ds1_acc_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "accelerometer power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm9ds1_gyr_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "gyroscope power on failed: "
+								"%d\n", err);
+		goto err_pdata_init;
+	}
+
+	err = lsm9ds1_acc_update_fs_range(dev, dev->pdata_acc->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update accelerometer full scale range "
+								"failed\n");
+		goto  err_power_off_acc;
+	}
+
+	err = lsm9ds1_gyr_update_fs_range(dev, dev->pdata_gyr->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update gyroscope full scale range "
+								"failed\n");
+		goto  err_power_off_gyr;
+	}
+
+	err = lsm9ds1_acc_update_odr(dev, dev->pdata_acc->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update accelerometer ODR failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds1_gyr_update_odr(dev, dev->pdata_gyr->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update gyroscope ODR failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds1_acc_update_filter(dev, 
+					dev->pdata_acc->aa_filter_bandwidth);
+	if (err < 0) {
+		dev_err(dev->dev, "update accelerometer filter "
+								"failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds1_acc_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "accelerometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = lsm9ds1_gyr_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "gyroscope input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "device %s sysfs register failed\n",
+			LSM9DS1_ACC_GYR_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lsm9ds1_acc_device_power_off(dev);
+	lsm9ds1_gyr_device_power_off(dev);
+
+	if (irq > 0) {
+		dev->irq = irq;
+		err = request_threaded_irq(irq, lsm9ds1_acc_gyr_save_timestamp,
+					   lsm9ds1_acc_gyr_thread_fn,
+					   IRQF_TRIGGER_HIGH, dev->name, dev);
+		if (err)
+			return err;
+
+		disable_irq(irq);
+	} else {
+		dev_err(dev->dev, "%s: missing IRQ line\n", __func__);
+		err = -EINVAL;
+		goto err_input_cleanup;
+	}
+
+	mutex_unlock(&dev->lock);
+
+	dev_info(dev->dev, "%s: probed\n", LSM9DS1_ACC_GYR_DEV_NAME);
+	return 0;
+
+err_input_cleanup:
+	lsm9ds1_input_cleanup(dev);
+err_power_off:
+err_power_off_gyr:
+	lsm9ds1_gyr_device_power_off(dev);
+err_power_off_acc:
+	lsm9ds1_acc_device_power_off(dev);
+err_hw_init:
+err_pdata_init:
+err_pdata_gyr_init:
+	if (dev->pdata_gyr->exit)
+		dev->pdata_gyr->exit();
+err_pdata_acc_init:
+	if (dev->pdata_acc->exit)
+		dev->pdata_acc->exit();
+exit_kfree_pdata:
+	kfree(dev->pdata_acc);
+	kfree(dev->pdata_gyr);
+err_mutexunlock:
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm9ds1_acc_gyr_probe);
+
+int lsm9ds1_acc_gyr_remove(struct lsm9ds1_acc_gyr_dev *dev)
+{
+	if (atomic_read(&dev->enabled_gyr)) {
+		lsm9ds1_gyr_disable(dev);
+		lsm9ds1_gyr_input_cleanup(dev);
+
+		if (dev->pdata_gyr->exit)
+			dev->pdata_gyr->exit();
+	}
+
+	lsm9ds1_acc_disable(dev);
+	lsm9ds1_acc_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (dev->pdata_acc->exit)
+		dev->pdata_acc->exit();
+
+	kfree(dev->pdata_acc);
+	kfree(dev->pdata_gyr);
+	kfree(dev->pdata_main);
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm9ds1_acc_gyr_remove);
+
+MODULE_DESCRIPTION("lsm9ds1 accelerometer and gyroscope driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_i2c.c b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_i2c.c
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,179 @@
+/*
+ * STMicroelectronics lsm9ds1_acc_gyr_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm9ds1.h"
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_acc_gyr_i2c_read(struct device *dev, u8 addr, int len,
+				    u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_acc_gyr_i2c_write(struct device *dev, u8 addr, int len,
+				     u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm9ds1_transfer_function lsm9ds1_acc_gyr_i2c_tf = {
+	.write = lsm9ds1_acc_gyr_i2c_write,
+	.read = lsm9ds1_acc_gyr_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds1_acc_gyr_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds1_acc_gyr_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds1_acc_gyr_enable(dev);
+}
+
+static int lsm9ds1_acc_gyr_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds1_acc_gyr_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds1_acc_gyr_disable(dev);
+}
+
+static const struct dev_pm_ops lsm9ds1_acc_gyr_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds1_acc_gyr_i2c_suspend,
+				lsm9ds1_acc_gyr_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds1_acc_gyr_i2c_id_table[] = {
+	{ .compatible = "st,lsm9ds1_acc_gyr", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds1_acc_gyr_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm9ds1_acc_gyr_i2c_probe(struct i2c_client *client,
+				     const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm9ds1_acc_gyr_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds1_acc_gyr_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm9ds1_acc_gyr_i2c_tf;
+	dev->acc_gyr_dt_id = lsm9ds1_acc_gyr_i2c_id_table;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds1_acc_gyr_probe(dev, client->irq);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds1_acc_gyr_i2c_remove(struct i2c_client *client)
+{
+	struct lsm9ds1_acc_gyr_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds1_acc_gyr_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm9ds1_acc_gyr_i2c_id[] = {
+	{ "lsm9ds1_acc_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm9ds1_acc_gyr_i2c_id);
+
+static struct i2c_driver lsm9ds1_acc_gyr_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds1_acc_gyr_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds1_acc_gyr_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds1_acc_gyr_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds1_acc_gyr_i2c_probe,
+	.remove = lsm9ds1_acc_gyr_i2c_remove,
+	.id_table = lsm9ds1_acc_gyr_i2c_id,
+};
+
+module_i2c_driver(lsm9ds1_acc_gyr_i2c_driver);
+
+MODULE_DESCRIPTION("lsm9ds1 acc-gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_spi.c b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_spi.c
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_acc_gyr_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,195 @@
+/*
+ * STMicroelectronics lsm9ds1_acc_gyr_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm9ds1.h"
+
+#define SENSORS_SPI_READ	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_acc_gyr_spi_read(struct device *device, u8 addr, int len,
+				    u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_acc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_acc_gyr_spi_write(struct device *device, u8 addr, int len,
+				     u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_acc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM9DS1_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm9ds1_transfer_function lsm9ds1_acc_gyr_spi_tf = {
+	.write = lsm9ds1_acc_gyr_spi_write,
+	.read = lsm9ds1_acc_gyr_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds1_acc_gyr_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_acc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds1_acc_gyr_enable(dev);
+}
+
+static int lsm9ds1_acc_gyr_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_acc_gyr_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds1_acc_gyr_disable(dev);
+}
+
+static const struct dev_pm_ops lsm9ds1_acc_gyr_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds1_acc_gyr_spi_suspend,
+				lsm9ds1_acc_gyr_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds1_acc_gyr_spi_id_table[] = {
+	{ .compatible = "st,lsm9ds1_acc_gyr" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds1_acc_gyr_spi_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm9ds1_acc_gyr_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm9ds1_acc_gyr_dev *dev;
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds1_acc_gyr_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm9ds1_acc_gyr_spi_tf;
+	dev->dev = &spi->dev;
+	dev->acc_gyr_dt_id = lsm9ds1_acc_gyr_spi_id_table;
+
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds1_acc_gyr_probe(dev, spi->irq);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds1_acc_gyr_spi_remove(struct spi_device *spi)
+{
+	struct lsm9ds1_acc_gyr_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds1_acc_gyr_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm9ds1_acc_gyr_spi_id[] = {
+	{ "lsm9ds1_acc_gyr", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm9ds1_acc_gyr_spi_id);
+
+static struct spi_driver lsm9ds1_acc_gyr_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds1_acc_gyr_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds1_acc_gyr_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds1_acc_gyr_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds1_acc_gyr_spi_probe,
+	.remove = lsm9ds1_acc_gyr_spi_remove,
+	.id_table = lsm9ds1_acc_gyr_spi_id,
+};
+
+module_spi_driver(lsm9ds1_acc_gyr_spi_driver);
+
+MODULE_DESCRIPTION("lsm9ds1 acc-gyr spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1.h b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1.h
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,289 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm9ds1.h
+* Authors	     : AMS - Motion Mems Division - Application Team
+*		     : Giuseppe Barba (giuseppe.barba@st.com)
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+*		     : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+* Version            : V.1.0.0
+* Date               : 2016/May/13
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#ifndef __LSM9DS1_H__
+#define __LSM9DS1_H__
+
+#define LSM9DS1_ACC_GYR_DEV_NAME	"lsm9ds1_acc_gyr"
+#define LSM9DS1_MAG_DEV_NAME		"lsm9ds1_mag"
+#define LSM9DS1_ACC_DEV_NAME		"lsm9ds1_acc"
+#define LSM9DS1_GYR_DEV_NAME    	"lsm9ds1_gyr"
+
+
+/************************************************/
+/* 	Magnetometer Section  		        */
+/************************************************/
+/* Magnetometer Sensor Full Scale */
+#define LSM9DS1_MAG_FS_MASK		0x60
+#define LSM9DS1_MAG_FS_4G		0x00	/* Full scale 4 Gauss */
+#define LSM9DS1_MAG_FS_8G		0x20	/* Full scale 8 Gauss */
+#define LSM9DS1_MAG_FS_12G		0x40	/* Full scale 10 Gauss */
+#define LSM9DS1_MAG_FS_16G		0x60	/* Full scale 16 Gauss */
+
+/* ODR */
+#define ODR_MAG_MASK			0x1C	/* Mask for odr change on mag */
+#define LSM9DS1_MAG_ODR0_625		0x00	/* 0.625Hz output data rate */
+#define LSM9DS1_MAG_ODR1_25		0x04	/* 1.25Hz output data rate */
+#define LSM9DS1_MAG_ODR2_5		0x08	/* 2.5Hz output data rate */
+#define LSM9DS1_MAG_ODR5		0x0C	/* 5Hz output data rate */
+#define LSM9DS1_MAG_ODR10		0x10	/* 10Hz output data rate */
+#define LSM9DS1_MAG_ODR20		0x14	/* 20Hz output data rate */
+#define LSM9DS1_MAG_ODR40		0x18	/* 40Hz output data rate */
+#define LSM9DS1_MAG_ODR80		0x1C	/* 80Hz output data rate */
+
+#define MAG_ENABLE_ON_INPUT_OPEN 	0
+#define LSM9DS1_MAG_MIN_POLL_PERIOD_MS	13
+#define LSM9DS1_INT_M_GPIO_DEF		-EINVAL
+#define LSM9DS1_M_POLL_INTERVAL_DEF	100
+
+
+/************************************************/
+/* 	Accelerometer section defines	        */
+/************************************************/
+#define LSM9DS1_ACC_MIN_POLL_PERIOD_MS	1
+
+/* Accelerometer Sensor Full Scale */
+#define LSM9DS1_ACC_FS_MASK		0x18
+#define LSM9DS1_ACC_FS_2G 		0x00	/* Full scale 2g */
+#define LSM9DS1_ACC_FS_4G 		0x10	/* Full scale 4g */
+#define LSM9DS1_ACC_FS_8G 		0x18	/* Full scale 8g */
+
+/* Accelerometer Anti-Aliasing Filter */
+#define LSM9DS1_ACC_BW_408		0X00
+#define LSM9DS1_ACC_BW_211		0X01
+#define LSM9DS1_ACC_BW_105		0X02
+#define LSM9DS1_ACC_BW_50		0X03
+#define LSM9DS1_ACC_BW_MASK		0X03
+
+#define LSM9DS1_INT1_GPIO_DEF		-EINVAL
+#define LSM9DS1_INT2_GPIO_DEF		-EINVAL
+
+#define LSM9DS1_ACC_ODR_OFF		0x00
+#define LSM9DS1_ACC_ODR_MASK		0xE0
+#define LSM9DS1_ACC_ODR_10		0x20
+#define LSM9DS1_ACC_ODR_50		0x40
+#define LSM9DS1_ACC_ODR_119		0x60
+#define LSM9DS1_ACC_ODR_238		0x80
+#define LSM9DS1_ACC_ODR_476		0xA0
+#define LSM9DS1_ACC_ODR_952		0xC0
+
+/************************************************/
+/* 	Gyroscope section defines	 	*/
+/************************************************/
+#define LSM9DS1_GYR_MIN_POLL_PERIOD_MS	1
+
+#define LSM9DS1_GYR_FS_MASK		0x18
+#define LSM9DS1_GYR_FS_245DPS		0x00
+#define LSM9DS1_GYR_FS_500DPS		0x08
+#define LSM9DS1_GYR_FS_2000DPS		0x18
+
+#define LSM9DS1_GYR_ODR_OFF		0x00
+#define LSM9DS1_GYR_ODR_MASK		0xE0
+#define LSM9DS1_GYR_ODR_14_9		0x20
+#define LSM9DS1_GYR_ODR_59_5		0x40
+#define LSM9DS1_GYR_ODR_119		0x60
+#define LSM9DS1_GYR_ODR_238		0x80
+#define LSM9DS1_GYR_ODR_476		0xA0
+#define LSM9DS1_GYR_ODR_952		0xC0
+
+#define LSM9DS1_GYR_BW_0		0x00
+#define LSM9DS1_GYR_BW_1		0x01
+#define LSM9DS1_GYR_BW_2		0x02
+#define LSM9DS1_GYR_BW_3		0x03
+
+#define LSM9DS1_GYR_POLL_INTERVAL_DEF	100
+#define LSM9DS1_ACC_POLL_INTERVAL_DEF	100
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+
+#if defined(CONFIG_INPUT_LSM9DS1_SPI) || \
+    defined(CONFIG_INPUT_LSM9DS1_SPI_MODULE)
+#define LSM9DS1_RX_MAX_LENGTH		500
+#define LSM9DS1_TX_MAX_LENGTH		500
+
+struct lsm9ds1_transfer_buffer {
+	u8 rx_buf[LSM9DS1_RX_MAX_LENGTH];
+	u8 tx_buf[LSM9DS1_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LSMDS1_SPI */
+
+struct lsm9ds1_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+struct lsm9ds1_mag_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+	u8 fs_range;
+	short rot_matrix[3][3];
+	int gpio_int_m;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+#ifdef CONFIG_OF
+	struct device_node	*of_node;
+#endif
+};
+
+struct lsm9ds1_mag_dev {
+	const char *name;
+	u16 bus_type;
+	struct device *dev;
+	const struct of_device_id *mag_dt_id;
+	struct lsm9ds1_mag_platform_data *pdata_mag;
+
+	struct mutex lock;
+	struct work_struct input_work_mag;
+	struct workqueue_struct *mag_workqueue;
+
+	struct hrtimer hr_timer_mag;
+	ktime_t ktime_mag;
+
+	struct input_dev *input_dev_mag;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+
+	atomic_t enabled_mag;
+
+	u32 sensitivity_mag;
+
+	u8 xy_mode;
+	u8 z_mode;
+	struct lsm9ds1_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM9DS1_SPI) || \
+    defined(CONFIG_INPUT_LSM9DS1_SPI_MODULE)
+	struct lsm9ds1_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSMDS1_SPI */
+};
+
+struct lsm9ds1_acc_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+	u8 fs_range;
+	u8 aa_filter_bandwidth;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm9ds1_gyr_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+	u8 fs_range;
+
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+};
+
+struct lsm9ds1_acc_gyr_dev {
+	const char *name;
+	u16 bus_type;
+	const struct of_device_id *acc_gyr_dt_id;
+	struct device *dev;
+	struct lsm9ds1_acc_gyr_main_platform_data *pdata_main;
+	struct lsm9ds1_acc_platform_data *pdata_acc;
+	struct lsm9ds1_gyr_platform_data *pdata_gyr;
+
+	struct mutex lock;
+
+	int irq;
+	s64 timestamp;
+
+	u16 acc_skip_cnt, acc_dec_cnt;
+	u16 gyr_skip_cnt, gyr_dec_cnt;
+
+	ktime_t ktime_acc;
+
+	struct input_dev *input_dev_acc;
+	struct input_dev *input_dev_gyr;
+	//struct input_dev *input_dev_temp;
+
+	atomic_t enabled_acc;
+        atomic_t enabled_gyr;
+        atomic_t enabled_temp;
+
+	int32_t temp_value_dec;
+	uint32_t temp_value_flo;
+
+	int32_t sensitivity_acc;
+	int32_t sensitivity_gyr;
+
+	struct lsm9ds1_transfer_function *tf;
+#if defined(CONFIG_INPUT_LSM9DS1_SPI) || \
+    defined(CONFIG_INPUT_LSM9DS1_SPI_MODULE)
+	struct lsm9ds1_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LSMDS1_SPI */
+};
+
+struct lsm9ds1_acc_gyr_main_platform_data {
+	short rot_matrix[3][3];
+	struct lsm9ds1_acc_platform_data *pdata_acc;
+	struct lsm9ds1_gyr_platform_data *pdata_gyr;
+#ifdef CONFIG_OF
+	struct device_node	*of_node;
+#endif
+};
+
+static inline s64 lsm9ds1_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+int lsm9ds1_acc_gyr_probe(struct lsm9ds1_acc_gyr_dev *dev, int irq);
+int lsm9ds1_acc_gyr_remove(struct lsm9ds1_acc_gyr_dev *dev);
+int lsm9ds1_acc_gyr_enable(struct lsm9ds1_acc_gyr_dev *dev);
+int lsm9ds1_acc_gyr_disable(struct lsm9ds1_acc_gyr_dev *dev);
+
+int lsm9ds1_mag_probe(struct lsm9ds1_mag_dev *dev);
+int lsm9ds1_mag_remove(struct lsm9ds1_mag_dev *dev);
+int lsm9ds1_mag_enable(struct lsm9ds1_mag_dev *dev);
+int lsm9ds1_mag_disable(struct lsm9ds1_mag_dev *dev);
+
+#endif	/* __LSM9DS1_H__ */
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag.c b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag.c
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1160 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lsm9ds1_mag.c
+* Authors            : MSH - C&I BU - Application Team
+*		     : Giuseppe Barba (giuseppe.barba@st.com)
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+*		     : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*		     : Authors are willing to be considered the contact
+*		     : and update points for the driver.
+* Version            : V.1.0.0
+* Date               : 2016/May/13
+* Description        : LSM9DS1 magnetometer driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lsm9ds1.h"
+
+#define MS_TO_NS(x)			((x) * 1000000L)
+
+/* Address registers */
+#define REG_WHOAMI_ADDR			0x0F
+#define CTRL_REG1_M			0x20
+#define CTRL_REG2_M			0x21
+#define CTRL_REG3_M			0x22
+#define CTRL_REG4_M			0x23
+#define CTRL_REG5_M			0x24
+#define INT_CFG_M			0x30
+#define INT_THS_L			0x32
+#define INT_THS_H			0x33
+
+#define REG_MAG_DATA_ADDR		0x28 /** Mag. data low address register */
+
+/* Sensitivity [ugauss/LSB] */
+#define SENSITIVITY_MAG_4G		146
+#define SENSITIVITY_MAG_8G		292
+#define SENSITIVITY_MAG_12G		430
+#define SENSITIVITY_MAG_16G		584
+
+/* Magnetic sensor mode */
+#define CTRL_REG3_M_MD_MASK		0x03
+#define CTRL_REG3_M_MD_OFF		0x02
+#define CTRL_REG3_M_MD_CONTINUOUS	0x00
+#define CTRL_REG3_M_MD_SINGLE		0x01
+
+/* X and Y axis operative mode selection */
+#define X_Y_PERFORMANCE_MASK		0x60
+#define X_Y_LOW_PERFORMANCE		0x00
+#define X_Y_MEDIUM_PERFORMANCE		0x20
+#define X_Y_HIGH_PERFORMANCE		0x40
+#define X_Y_ULTRA_HIGH_PERFORMANCE	0x60
+
+/* Z axis operative mode selection */
+#define Z_PERFORMANCE_MASK		0x0c
+#define Z_LOW_PERFORMANCE		0x00
+#define Z_MEDIUM_PERFORMANCE		0x04
+#define Z_HIGH_PERFORMANCE		0x08
+#define Z_ULTRA_HIGH_PERFORMANCE	0x0c
+
+/* Default values loaded in probe function */
+#define DEF_ZERO			0x00
+
+#define WHOIAM_VALUE			0x3D
+#define CTRL_REG1_M_DEF			0x60
+#define CTRL_REG2_M_DEF			DEF_ZERO
+#define CTRL_REG3_M_DEF			CTRL_REG3_M_MD_CONTINUOUS
+#define CTRL_REG4_M_DEF			DEF_ZERO
+#define CTRL_REG5_M_DEF			0x40
+#define INT_CFG_M_DEF			DEF_ZERO
+#define INT_THS_H_DEF			DEF_ZERO
+#define INT_THS_L_DEF			DEF_ZERO
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lsm9ds1_mag_odr_table[] = {
+	{   12, LSM9DS1_MAG_ODR80 },
+	{   25, LSM9DS1_MAG_ODR40 },
+	{   50, LSM9DS1_MAG_ODR20 },
+	{  100, LSM9DS1_MAG_ODR10 },
+	{  200, LSM9DS1_MAG_ODR5 },
+	{  400, LSM9DS1_MAG_ODR2_5 },
+	{  800, LSM9DS1_MAG_ODR1_25 },
+	{ 1600, LSM9DS1_MAG_ODR0_625 },
+};
+
+struct interrupt_enable {
+	atomic_t enable;
+	u8 address;
+	u8 mask;
+};
+
+struct interrupt_value {
+	int value;
+	u8 address;
+};
+
+static const struct lsm9ds1_mag_platform_data default_lsm9ds1_mag_pdata = {
+	.poll_interval = 100,
+	.min_interval = LSM9DS1_MAG_MIN_POLL_PERIOD_MS,
+	.fs_range = LSM9DS1_MAG_FS_4G,
+	.rot_matrix = {
+		{1, 0, 0},
+		{0, 1, 0},
+		{0, 0, 1},
+	},
+};
+
+struct reg_rw {
+	u8 address;
+	u8 default_value;
+	u8 resume_value;
+};
+
+struct reg_r {
+	u8 address;
+	u8 value;
+};
+
+static struct status_registers {
+	struct reg_r who_am_i;
+	struct reg_rw ctrl_reg1_m;
+	struct reg_rw ctrl_reg2_m;
+	struct reg_rw ctrl_reg3_m;
+	struct reg_rw ctrl_reg4_m;
+	struct reg_rw ctrl_reg5_m;
+	struct reg_rw int_cfg_m;
+	struct reg_rw int_ths_l;
+	struct reg_rw int_ths_h;
+} status_registers = {
+	.who_am_i = {.address = REG_WHOAMI_ADDR, .value = WHOIAM_VALUE,},
+	.ctrl_reg1_m = {.address = CTRL_REG1_M, .default_value = CTRL_REG1_M_DEF,},
+	.ctrl_reg2_m = {.address = CTRL_REG2_M, .default_value = CTRL_REG2_M_DEF,},
+	.ctrl_reg3_m = {.address = CTRL_REG3_M, .default_value = CTRL_REG3_M_DEF,},
+	.ctrl_reg4_m = {.address = CTRL_REG4_M, .default_value = CTRL_REG4_M_DEF,},
+	.ctrl_reg5_m = {.address = CTRL_REG5_M, .default_value = CTRL_REG5_M_DEF,},
+	.int_cfg_m = {.address = INT_CFG_M, .default_value = INT_CFG_M_DEF,},
+	.int_ths_h = {.address = INT_THS_H, .default_value = INT_THS_H_DEF,},
+	.int_ths_l = {.address = INT_THS_L, .default_value = INT_THS_L_DEF,},
+};
+
+static int lsm9ds1_hw_init(struct lsm9ds1_mag_dev *dev)
+{
+	int err = -1;
+	u8 buf[1];
+
+#ifdef LSM9DS1_DEBUG
+	pr_info("%s: hw init start\n", LSM9DS1_MAG_DEV_NAME);
+#endif
+
+	err = dev->tf->read(dev->dev, status_registers.who_am_i.address, 1,
+			    buf);
+	if (err < 0) {
+		dev_warn(dev->dev, "Error reading WHO_AM_I\n");
+		goto err_firstread;
+	} else {
+		dev->hw_working = 1;
+	}
+
+	if (buf[0] != status_registers.who_am_i.value) {
+		dev_err(dev->dev,
+			"device unknown 0x%02x-0x%02x\n",
+			status_registers.who_am_i.value, buf[0]);
+			err = -1;
+		goto err_unknown_device;
+	}
+
+	status_registers.ctrl_reg1_m.resume_value =
+				status_registers.ctrl_reg1_m.default_value;
+	status_registers.ctrl_reg2_m.resume_value =
+				status_registers.ctrl_reg2_m.default_value;
+	status_registers.ctrl_reg3_m.resume_value =
+				status_registers.ctrl_reg3_m.default_value;
+	status_registers.ctrl_reg4_m.resume_value =
+				status_registers.ctrl_reg4_m.default_value;
+	status_registers.ctrl_reg5_m.resume_value =
+				status_registers.ctrl_reg5_m.default_value;
+	status_registers.int_cfg_m.resume_value =
+				status_registers.int_cfg_m.default_value;
+	status_registers.int_ths_h.resume_value =
+				status_registers.int_ths_h.default_value;
+	status_registers.int_ths_l.resume_value =
+				status_registers.int_ths_l.default_value;
+
+	dev->xy_mode = X_Y_ULTRA_HIGH_PERFORMANCE;
+	dev->z_mode = Z_ULTRA_HIGH_PERFORMANCE;
+	dev->hw_initialized = 1;
+
+#ifdef LSM9DS1_DEBUG
+	pr_info("%s: hw init done\n", LSM9DS1_MAG_DEV_NAME);
+#endif
+
+	return 0;
+
+err_unknown_device:
+err_firstread:
+	dev->hw_working = 0;
+	dev->hw_initialized = 0;
+	return err;
+}
+
+static int lsm9ds1_mag_device_power_off(struct lsm9ds1_mag_dev *dev)
+{
+	int err;
+	u8 buf[1];
+
+	buf[0] = ((CTRL_REG3_M_MD_MASK & CTRL_REG3_M_MD_OFF) |
+		  (~CTRL_REG3_M_MD_MASK &
+		   status_registers.ctrl_reg3_m.resume_value));
+
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg3_m.address, 1,
+			     buf);
+	if (err < 0)
+		dev_err(dev->dev, "magnetometer soft power off failed: %d\n",
+			err);
+
+	if (dev->pdata_mag->power_off)
+		dev->pdata_mag->power_off();
+
+	atomic_set(&dev->enabled_mag, 0);
+
+	return 0;
+}
+
+static int lsm9ds1_mag_device_power_on(struct lsm9ds1_mag_dev *dev)
+{
+	int err = -1;
+	u8 buf[5];
+
+	if (dev->pdata_mag->power_on) {
+		err = dev->pdata_mag->power_on();
+		if (err < 0) {
+			dev_err(dev->dev, "magnetometer power_on failed: %d\n",
+				err);
+			return err;
+		}
+	}
+	
+	
+	buf[0] = status_registers.ctrl_reg1_m.resume_value;
+	buf[1] = status_registers.ctrl_reg2_m.resume_value;
+	buf[2] = status_registers.ctrl_reg3_m.resume_value;
+	buf[3] = status_registers.ctrl_reg4_m.resume_value;
+	buf[4] = status_registers.ctrl_reg5_m.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg1_m.address, 5,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = status_registers.int_cfg_m.resume_value;
+	buf[1] = status_registers.int_ths_h.resume_value;
+	buf[2] = status_registers.int_ths_l.resume_value;
+	err = dev->tf->write(dev->dev, status_registers.int_cfg_m.address, 5,
+			     buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_mag, 1);
+
+	return 0;
+
+err_resume_state:
+	atomic_set(&dev->enabled_mag, 0);
+	dev_err(dev->dev, "magnetometer hw power on error "
+				"0x%02x,0x%02x: %d\n", buf[0], buf[1], err);
+	return err;
+}
+
+static int lsm9ds1_mag_update_fs_range(struct lsm9ds1_mag_dev *dev,
+				       u8 new_fs_range)
+{
+	int err;
+	u32 sensitivity, updated_val;
+	u8 buf[1];
+
+	switch (new_fs_range) {
+	case LSM9DS1_MAG_FS_4G:
+		sensitivity = SENSITIVITY_MAG_4G;
+		break;
+	case LSM9DS1_MAG_FS_8G:
+		sensitivity = SENSITIVITY_MAG_8G;
+		break;
+	case LSM9DS1_MAG_FS_12G:
+		sensitivity = SENSITIVITY_MAG_12G;
+		break;
+	case LSM9DS1_MAG_FS_16G:
+		sensitivity = SENSITIVITY_MAG_16G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid magn fs range requested: %u\n",
+			new_fs_range);
+		return -EINVAL;
+	}
+
+	err = dev->tf->read(dev->dev, status_registers.ctrl_reg2_m.address, 1,
+			    buf);
+	if (err < 0)
+		goto error;
+
+	status_registers.ctrl_reg2_m.resume_value = buf[0];
+	updated_val = (LSM9DS1_MAG_FS_MASK & new_fs_range);
+	buf[0] = updated_val;
+
+	err = dev->tf->write(dev->dev, status_registers.ctrl_reg2_m.address, 1,
+			     buf);
+	if (err < 0)
+		goto error;
+	status_registers.ctrl_reg2_m.resume_value = updated_val;
+	dev->sensitivity_mag = sensitivity;
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update magn fs range failed 0x%02x: %d\n",
+		buf[0], err);
+	return err;
+}
+
+static int lsm9ds1_mag_update_odr(struct lsm9ds1_mag_dev *dev,
+				  unsigned int poll_ms)
+{
+	int i, err = -1;
+	u8 data;
+
+	for (i = ARRAY_SIZE(lsm9ds1_mag_odr_table) - 1; i >= 0; i--) {
+		if ((lsm9ds1_mag_odr_table[i].cutoff_us <= poll_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	data = ((ODR_MAG_MASK & lsm9ds1_mag_odr_table[i].value) |
+	        (~ODR_MAG_MASK & status_registers.ctrl_reg1_m.resume_value));
+
+	if (atomic_read(&dev->enabled_mag)) {
+		err = dev->tf->write(dev->dev,
+				     status_registers.ctrl_reg1_m.address,
+				     1, &data);
+		if (err < 0)
+			goto error;
+	}
+	status_registers.ctrl_reg1_m.resume_value = data;
+	dev->ktime_mag = ktime_set(0, MS_TO_NS(poll_ms));
+
+	return err;
+
+error:
+	dev_err(dev->dev, "update magnetometer odr failed 0x%02x: %d\n",
+		data, err);
+
+	return err;
+}
+
+static int lsm9ds1_mag_update_operative_mode(struct lsm9ds1_mag_dev *dev,
+					     int axis, u8 value)
+{
+	int err;
+	u8 raddr, waddr, data, mask;
+
+	if (axis == 0) {
+		raddr = CTRL_REG1_M;
+		mask = X_Y_PERFORMANCE_MASK;
+		waddr = CTRL_REG1_M;
+	} else {
+		raddr = CTRL_REG4_M;
+		mask = Z_PERFORMANCE_MASK;
+		waddr = CTRL_REG4_M;
+	}
+
+	mutex_lock(&dev->lock);
+
+	err = dev->tf->read(dev->dev, raddr, 1, &data);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+
+	data = ((mask & value) | (~mask & data));
+
+	err = dev->tf->write(dev->dev, waddr, 1, &data);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+
+	if (axis == 0)
+		dev->xy_mode = value;
+	else
+		dev->z_mode = value;
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+}
+
+static int lsm9ds1_mag_validate_pdata(struct lsm9ds1_mag_dev *dev)
+{
+	dev->pdata_mag->min_interval = 
+			    max((unsigned int)LSM9DS1_MAG_MIN_POLL_PERIOD_MS,
+				dev->pdata_mag->min_interval);
+	dev->pdata_mag->poll_interval = max(dev->pdata_mag->poll_interval,
+					    dev->pdata_mag->min_interval);
+
+	return 0;
+}
+
+int lsm9ds1_mag_enable(struct lsm9ds1_mag_dev *dev)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&dev->enabled_mag, 0, 1)) {
+		mutex_lock(&dev->lock);
+		err = lsm9ds1_mag_device_power_on(dev);
+		if (err < 0) {
+			atomic_set(&dev->enabled_mag, 0);
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag,
+			      HRTIMER_MODE_REL);
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm9ds1_mag_enable);
+
+int lsm9ds1_mag_disable(struct lsm9ds1_mag_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_mag, 1, 0)) {
+		cancel_work_sync(&dev->input_work_mag);
+		hrtimer_cancel(&dev->hr_timer_mag);
+
+		mutex_lock(&dev->lock);
+		lsm9ds1_mag_device_power_off(dev);
+		mutex_unlock(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lsm9ds1_mag_disable);
+
+static void lsm9ds1_mag_input_cleanup(struct lsm9ds1_mag_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static ssize_t attr_get_polling_rate_mag(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	unsigned int val;
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+	mutex_lock(&dev->lock);
+	val = dev->pdata_mag->poll_interval;
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate_mag(struct device *device,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+			    dev->pdata_mag->min_interval);
+	mutex_lock(&dev->lock);
+	dev->pdata_mag->poll_interval = (unsigned int)interval_ms;
+	lsm9ds1_mag_update_odr(dev, interval_ms);
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_mag(struct device *device,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", (int)atomic_read(&dev->enabled_mag));
+}
+
+static ssize_t attr_set_enable_mag(struct device *device,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lsm9ds1_mag_enable(dev);
+	else
+		lsm9ds1_mag_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_range_mag(struct device *device,
+					struct device_attribute *attr,
+					char *buf)
+{
+	u8 val;
+	int range = 2;
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->pdata_mag->fs_range;
+	switch (val) {
+	case LSM9DS1_MAG_FS_4G:
+		range = 4;
+		break;
+	case LSM9DS1_MAG_FS_8G:
+		range = 8;
+		break;
+	case LSM9DS1_MAG_FS_12G:
+		range = 10;
+		break;
+	case LSM9DS1_MAG_FS_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_mag(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+	unsigned long val;
+	u8 range;
+	int err;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	switch (val) {
+	case 4:
+		range = LSM9DS1_MAG_FS_4G;
+		break;
+	case 8:
+		range = LSM9DS1_MAG_FS_8G;
+		break;
+	case 10:
+		range = LSM9DS1_MAG_FS_12G;
+		break;
+	case 16:
+		range = LSM9DS1_MAG_FS_16G;
+		break;
+	default:
+		dev_err(dev->dev, "magnetometer invalid range "
+					"request: %lu, discarded\n", val);
+		return -EINVAL;
+	}
+	mutex_lock(&dev->lock);
+	err = lsm9ds1_mag_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->pdata_mag->fs_range = range;
+	mutex_unlock(&dev->lock);
+	dev_info(dev->dev, "magnetometer range set to:"
+							" %lu g\n", val);
+
+	return size;
+}
+
+static ssize_t attr_get_xy_mode(struct device *device,
+				struct device_attribute *attr,
+				char *buf)
+{
+	u8 val;
+	char mode[13];
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->xy_mode;
+	switch (val) {
+	case X_Y_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "high");
+		break;
+	case X_Y_LOW_PERFORMANCE:
+		strcpy(&(mode[0]), "low");
+		break;
+	case X_Y_MEDIUM_PERFORMANCE:
+		strcpy(&(mode[0]), "medium");
+		break;
+	case X_Y_ULTRA_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "ultra_high");
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%s\n", mode);
+}
+
+static ssize_t attr_set_xy_mode(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+	u8 mode;
+	int err;
+
+	err = strncmp(buf, "high", 4);
+	if (err==0) {
+		mode = X_Y_HIGH_PERFORMANCE;
+		goto valid;
+	}
+
+	err = strncmp(buf, "low", 3);
+	if (err == 0) {
+		mode = X_Y_LOW_PERFORMANCE;
+		goto valid;
+	}
+
+	err = strncmp(buf, "medium", 6);
+	if (err == 0) {
+		mode = X_Y_MEDIUM_PERFORMANCE;
+		goto valid;
+	}
+
+	err = strncmp(buf, "ultra_high", 10);
+	if (err == 0) {
+		mode = X_Y_ULTRA_HIGH_PERFORMANCE;
+		goto valid;
+	}
+	goto error;
+
+valid:
+	err = lsm9ds1_mag_update_operative_mode(dev,0,mode);
+	if(err<0)
+		goto error;
+
+	dev_info(dev->dev, "magnetometer x_y op. mode set to: %s", buf);
+	return size;
+
+error:
+	dev_err(dev->dev, "magnetometer invalid value request: %s\n", buf);
+	return -EINVAL;
+}
+
+static ssize_t attr_get_z_mode(struct device *device,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	u8 val;
+	char mode[13];
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->z_mode;
+	switch (val) {
+	case Z_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "high");
+		break;
+	case Z_LOW_PERFORMANCE:
+		strcpy(&(mode[0]), "low");
+		break;
+	case Z_MEDIUM_PERFORMANCE:
+		strcpy(&(mode[0]), "medium");
+		break;
+	case Z_ULTRA_HIGH_PERFORMANCE:
+		strcpy(&(mode[0]), "ultra_high");
+		break;
+	}
+	mutex_unlock(&dev->lock);
+	return sprintf(buf, "%s\n", mode);
+}
+
+static ssize_t attr_set_z_mode(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lsm9ds1_mag_dev *dev = dev_get_drvdata(device);
+	u8 mode;
+	int err;
+
+	err = strncmp(buf, "high", 4);
+	if (err == 0) {
+		mode = Z_HIGH_PERFORMANCE;
+		goto valid;
+	}
+
+	err = strncmp(buf, "low", 3);
+	if (err == 0) {
+		mode = Z_LOW_PERFORMANCE;
+		goto valid;
+	}
+
+	err = strncmp(buf, "medium", 6);
+	if (err == 0) {
+		mode = Z_MEDIUM_PERFORMANCE;
+		goto valid;
+	}
+
+	err = strncmp(buf, "ultra_high", 10);
+	if (err == 0) {
+		mode = Z_ULTRA_HIGH_PERFORMANCE;
+		goto valid;
+	}
+	goto error;
+
+valid:
+	err = lsm9ds1_mag_update_operative_mode(dev,1,mode);
+	if (err < 0)
+		goto error;
+	dev_info(dev->dev, "magnetometer z op. mode set to: %s", buf);
+	return size;
+
+error:
+	dev_err(dev->dev, "magnetometer invalid value request: %s\n", buf);
+	return -EINVAL;
+}
+
+#ifdef LSM9DS1_DEBUG
+static int write_bit_on_register(struct lsm9ds1_mag_dev *dev, u8 address,
+				 u8 *resume_value, u8 mask, int value)
+{
+	int err;
+	u8 updated_val, buf[1], val = 0;
+
+	mutex_lock(&dev->lock);
+
+	err = dev->tf->read(dev->dev, address, 1, buf);
+	if (err < 0) {
+		err = -1;
+		goto out;
+	}
+
+	if (resume_value != NULL)
+		*resume_value = buf[0];
+
+	if (mask == 0) {
+		updated_val = (u8)value;
+	} else {
+		if (value > 0)
+			val = 0xFF;
+		updated_val = (mask & val) | (~mask & buf[0]);
+	}
+
+	buf[0] = updated_val;
+	err = dev->tf->write(dev->dev, address, 1, buf);
+	if (err < 0) {
+		err = -1;
+		goto out;
+	}
+
+	if (resume_value != NULL)
+		*resume_value = updated_val;
+
+out:
+	mutex_unlock(&dev->lock);
+	return err;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate_mag,
+						attr_set_polling_rate_mag),
+	__ATTR(range, 0666, attr_get_range_mag, attr_set_range_mag),
+	__ATTR(enable_device, 0666, attr_get_enable_mag, attr_set_enable_mag),
+	__ATTR(x_y_opearative_mode, 0666, attr_get_xy_mode, attr_set_xy_mode),
+	__ATTR(z_opearative_mode, 0666, attr_get_z_mode, attr_set_z_mode),
+
+};
+
+static int create_sysfs_interfaces(struct device *device)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(device, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(device, attributes + i);
+	dev_err(device, "%s:Unable to create interface\n", __func__);
+	return -1;
+}
+
+static void remove_sysfs_interfaces(struct device *device)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(device, attributes + i);
+}
+
+static int lsm9ds1_mag_get_data(struct lsm9ds1_mag_dev *dev, int *xyz)
+{
+	int i, err;
+	u8 mag_data[6];
+	s32 hw_d[3];
+
+	mutex_lock(&dev->lock);
+	err = dev->tf->read(dev->dev, REG_MAG_DATA_ADDR, 6, mag_data);
+	mutex_unlock(&dev->lock);
+
+	if (err < 0)
+		return err;
+
+	hw_d[0] = ((s32)((s16)((mag_data[1] << 8) | (mag_data[0]))));
+	hw_d[1] = ((s32)((s16)((mag_data[3] << 8) | (mag_data[2]))));
+	hw_d[2] = ((s32)((s16)((mag_data[5] << 8) | (mag_data[4]))));
+
+#ifdef LSM9DS1_DEBUG
+	pr_debug("%s read x=0x%02x 0x%02x (regH regL), x=%d (dec) [LSB]\n",
+		 LSM9DS1_MAG_DEV_NAME, mag_data[1], mag_data[0], hw_d[0]);
+	pr_debug("%s read y=0x%02x 0x%02x (regH regL), y=%d (dec) [LSB]\n",
+		 LSM9DS1_MAG_DEV_NAME, mag_data[3], mag_data[2], hw_d[1]);
+	pr_debug("%s read z=0x%02x 0x%02x (regH regL), z=%d (dec) [LSB]\n",
+		 LSM9DS1_MAG_DEV_NAME, mag_data[5], mag_data[4], hw_d[2]);
+#endif
+
+	hw_d[0] = hw_d[0] * dev->sensitivity_mag;
+	hw_d[1] = hw_d[1] * dev->sensitivity_mag;
+	hw_d[2] = hw_d[2] * dev->sensitivity_mag;
+
+	for (i = 0; i < 3; i++) {
+		xyz[i] = dev->pdata_mag->rot_matrix[0][i] * hw_d[0] +
+			 dev->pdata_mag->rot_matrix[1][i] * hw_d[1] +
+			 dev->pdata_mag->rot_matrix[2][i] * hw_d[2];
+	}
+
+	return err;
+}
+
+static void lsm9ds1_mag_report_values(struct lsm9ds1_mag_dev *dev, int *xyz,
+				      s64 timestamp)
+{
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(dev->input_dev_mag);
+}
+
+static int lsm9ds1_mag_input_init(struct lsm9ds1_mag_dev *dev)
+{
+	int err;
+
+	dev->input_dev_mag = input_allocate_device();
+	if (!dev->input_dev_mag) {
+		dev_err(dev->dev, "acc input dev allocation failed\n");
+		return -ENOMEM;
+	}
+
+	dev->input_dev_mag->name = LSM9DS1_MAG_DEV_NAME;
+	dev->input_dev_mag->id.bustype = dev->bus_type;
+	dev->input_dev_mag->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_mag, dev);
+
+	set_bit(INPUT_EVENT_TYPE, dev->input_dev_mag->evbit);
+	set_bit(INPUT_EVENT_X, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Y, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_Z, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_TIME_MSB, dev->input_dev_mag->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, dev->input_dev_mag->mscbit);
+
+	err = input_register_device(dev->input_dev_mag);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register magnetometer input device %s\n",
+			dev->input_dev_mag->name);
+		input_free_device(dev->input_dev_mag);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lsm9ds1_input_cleanup(struct lsm9ds1_mag_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static void poll_function_work_mag(struct work_struct *input_work_mag)
+{
+	struct lsm9ds1_mag_dev *dev;
+	int xyz[3] = { 0 };
+	int err;
+
+	dev = container_of((struct work_struct *)input_work_mag,
+			   struct lsm9ds1_mag_dev, input_work_mag);
+
+	if (atomic_read(&dev->enabled_mag)) {
+		err = lsm9ds1_mag_get_data(dev, xyz);
+		if (err < 0)
+			dev_err(dev->dev, "get_magnetometer_data failed\n");
+		else
+			lsm9ds1_mag_report_values(dev, xyz,
+						  lsm9ds1_get_time_ns());
+	}
+
+	hrtimer_start(&dev->hr_timer_mag, dev->ktime_mag, HRTIMER_MODE_REL);
+}
+
+static enum hrtimer_restart poll_function_read_mag(struct hrtimer *timer)
+{
+	struct lsm9ds1_mag_dev *dev;
+
+	dev = container_of((struct hrtimer *)timer,
+			   struct lsm9ds1_mag_dev, hr_timer_mag);
+	queue_work(dev->mag_workqueue, &dev->input_work_mag);
+
+	return HRTIMER_NORESTART;
+}
+
+#ifdef CONFIG_OF
+static int lsm9ds1_mag_parse_dt(struct lsm9ds1_mag_dev *dev,
+			        struct device* device)
+{
+	u8 i, j;
+	u32 val, vect[9];
+	struct device_node *dn;
+
+	if (of_match_device(dev->mag_dt_id, device)) {
+		dn = device->of_node;
+		dev->pdata_mag->of_node = dn;
+		
+		dev->pdata_mag->gpio_int_m = of_get_gpio(dn, 0);
+		if (!gpio_is_valid(dev->pdata_mag->gpio_int_m)) {
+			dev_err(dev->dev, "failed to get gpio_int_m\n");
+			dev->pdata_mag->gpio_int_m = LSM9DS1_INT_M_GPIO_DEF;
+		}
+
+		if (of_property_read_u32_array(dn, "rot-matrix", vect,
+					       ARRAY_SIZE(vect)) >= 0) {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					dev->pdata_mag->rot_matrix[i][j] =
+						(short)vect[3 * j + i];
+				}
+			}
+		} else {
+			for (j = 0; j < 3; j++) {
+				for (i = 0; i < 3; i++) {
+					dev->pdata_mag->rot_matrix[i][j] =
+				default_lsm9ds1_mag_pdata.rot_matrix[i][j];
+				}
+			}
+		}
+
+		if (!of_property_read_u32(dn, "poll-interval", &val)) {
+			dev->pdata_mag->poll_interval = val;
+		} else {
+			dev->pdata_mag->poll_interval =
+				LSM9DS1_M_POLL_INTERVAL_DEF;
+		}
+
+		if (!of_property_read_u32(dn, "min-interval", &val)) {
+			dev->pdata_mag->min_interval = val;
+		} else {
+			dev->pdata_mag->min_interval =
+				LSM9DS1_MAG_MIN_POLL_PERIOD_MS;
+		}
+
+		if (!of_property_read_u32(dn, "fs-range", &val)) {
+			dev->pdata_mag->fs_range = val;
+		} else {
+			dev->pdata_mag->fs_range = LSM9DS1_MAG_FS_4G;
+		}
+		return 0;
+	}
+	return -1;
+}
+#endif
+
+int lsm9ds1_mag_probe(struct lsm9ds1_mag_dev *dev)
+{
+	int err = -1;
+
+	mutex_lock(&dev->lock);
+
+	dev->pdata_mag = kzalloc(sizeof(*dev->pdata_mag), GFP_KERNEL);
+	if(dev->pdata_mag == NULL) {
+		err = -ENOMEM;
+		dev_err(dev->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+#ifdef CONFIG_OF
+	lsm9ds1_mag_parse_dt(dev, dev->dev);
+#else
+	if (dev->dev->platform_data == NULL) {
+		memcpy(dev->pdata_mag, &default_lsm9ds1_mag_pdata,
+		       sizeof(*dev->pdata_mag));
+	}
+	else {
+		memcpy(dev->pdata_mag, dev->dev->platform_data,
+		       sizeof(*dev->pdata_mag));
+	}
+#endif
+
+	err = lsm9ds1_mag_validate_pdata(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "failed to validate pdata for magn\n");
+		goto exit_kfree_pdata;
+	}
+
+	if (dev->pdata_mag->init) {
+		err = dev->pdata_mag->init();
+		if (err < 0) {
+			dev_err(dev->dev, "magnetometer init failed: %d\n",
+				err);
+			goto err_pdata_mag_init;
+		}
+	}
+
+	err = lsm9ds1_hw_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto err_hw_init;
+	}
+
+	err = lsm9ds1_mag_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer power on failed: %d\n",
+			err);
+		goto err_pdata_init;
+	}
+
+	err = lsm9ds1_mag_update_fs_range(dev, dev->pdata_mag->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range on magnetometer failed\n");
+		goto  err_power_off_mag;
+	}
+
+	err = lsm9ds1_mag_update_odr(dev, dev->pdata_mag->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr on magnetometer failed\n");
+		goto  err_power_off;
+	}
+
+	err = lsm9ds1_mag_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "magnetometer input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "device %s sysfs register failed\n",
+			LSM9DS1_MAG_DEV_NAME);
+		goto err_input_cleanup;
+	}
+
+	lsm9ds1_mag_device_power_off(dev);
+
+	dev->mag_workqueue = create_workqueue("lsm9ds1_workqueue");
+
+	if (!dev->mag_workqueue)
+		goto err_input_cleanup;
+
+	hrtimer_init(&dev->hr_timer_mag, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer_mag.function = &poll_function_read_mag;
+	INIT_WORK(&dev->input_work_mag, poll_function_work_mag);
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err_input_cleanup:
+	lsm9ds1_input_cleanup(dev);
+err_power_off:
+err_power_off_mag:
+	lsm9ds1_mag_device_power_off(dev);
+err_hw_init:
+err_pdata_init:
+err_pdata_mag_init:
+	if (dev->pdata_mag->exit)
+		dev->pdata_mag->exit();
+exit_kfree_pdata:
+	kfree(dev->pdata_mag);
+err_mutexunlock:
+	mutex_unlock(&dev->lock);
+	if (dev->mag_workqueue)
+		destroy_workqueue(dev->mag_workqueue);
+
+	return err;
+}
+EXPORT_SYMBOL(lsm9ds1_mag_probe);
+
+int lsm9ds1_mag_remove(struct lsm9ds1_mag_dev *dev)
+{
+	lsm9ds1_mag_disable(dev);
+	lsm9ds1_mag_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (dev->pdata_mag->exit)
+		dev->pdata_mag->exit();
+
+	if (dev->mag_workqueue)
+		destroy_workqueue(dev->mag_workqueue);
+
+	kfree(dev->pdata_mag);
+	return 0;
+}
+EXPORT_SYMBOL(lsm9ds1_mag_remove);
+
+MODULE_DESCRIPTION("lsm9ds1 magnetometer driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_i2c.c b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_i2c.c
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,179 @@
+/*
+ * STMicroelectronics lsm9ds1_mag_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lsm9ds1.h"
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_mag_i2c_read(struct device *dev, u8 addr, int len,
+				u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_mag_i2c_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lsm9ds1_transfer_function lsm9ds1_mag_i2c_tf = {
+	.write = lsm9ds1_mag_i2c_write,
+	.read = lsm9ds1_mag_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds1_mag_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds1_mag_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds1_mag_enable(dev);
+}
+
+static int lsm9ds1_mag_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lsm9ds1_mag_dev *dev = i2c_get_clientdata(client);
+
+	return lsm9ds1_mag_disable(dev);
+}
+
+static const struct dev_pm_ops lsm9ds1_mag_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds1_mag_i2c_suspend,
+				lsm9ds1_mag_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds1_mag_i2c_id_table[] = {
+	{ .compatible = "st,lsm9ds1_mag", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds1_mag_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm9ds1_mag_i2c_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	int err;
+	struct lsm9ds1_mag_dev *dev;
+
+#ifdef LSM303D_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds1_mag_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->dev = &client->dev;
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lsm9ds1_mag_i2c_tf;
+	dev->mag_dt_id = lsm9ds1_mag_i2c_id_table;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds1_mag_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds1_mag_i2c_remove(struct i2c_client *client)
+{
+	struct lsm9ds1_mag_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LSM303D_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds1_mag_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lsm9ds1_mag_i2c_id[] = {
+	{ "lsm9ds1_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm9ds1_mag_i2c_id);
+
+static struct i2c_driver lsm9ds1_mag_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds1_mag_i2c",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds1_mag_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds1_mag_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds1_mag_i2c_probe,
+	.remove = lsm9ds1_mag_i2c_remove,
+	.id_table = lsm9ds1_mag_i2c_id,
+};
+
+module_i2c_driver(lsm9ds1_mag_i2c_driver);
+
+MODULE_DESCRIPTION("lsm9ds0 gyro i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_spi.c b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_spi.c
--- a/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/lsm9ds1_mag_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,201 @@
+/*
+ * STMicroelectronics lsm9ds1_mag_spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/module.h>
+
+#include "lsm9ds1.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_mag_spi_read(struct device *device, u8 addr, int len,
+				u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_mag_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold dev->lock */
+static int lsm9ds1_mag_spi_write(struct device *device, u8 addr, int len,
+				 u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_mag_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LSM9DS1_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lsm9ds1_transfer_function lsm9ds1_mag_spi_tf = {
+	.write = lsm9ds1_mag_spi_write,
+	.read = lsm9ds1_mag_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lsm9ds1_mag_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_mag_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds1_mag_enable(dev);
+}
+
+static int lsm9ds1_mag_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lsm9ds1_mag_dev *dev = spi_get_drvdata(spi);
+
+	return lsm9ds1_mag_disable(dev);
+}
+
+static const struct dev_pm_ops lsm9ds1_mag_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lsm9ds1_mag_spi_suspend,
+				lsm9ds1_mag_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lsm9ds1_mag_spi_id_table[] = {
+	{ .compatible = "st,lsm9ds1_mag" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lsm9ds1_mag_spi_id_table);
+#endif /* CONFIG_OF */
+
+static int lsm9ds1_mag_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lsm9ds1_mag_dev *dev;
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lsm9ds1_mag_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lsm9ds1_mag_spi_tf;
+	dev->dev = &spi->dev;
+	dev->mag_dt_id = lsm9ds1_mag_spi_id_table;
+
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lsm9ds1_mag_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lsm9ds1_mag_spi_remove(struct spi_device *spi)
+{
+	struct lsm9ds1_mag_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LSM9DS1_DEBUG
+	dev_info(dev->dev, "driver removing\n");
+#endif
+
+	lsm9ds1_mag_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lsm9ds1_mag_spi_id[] = {
+	{ "lsm9ds1_mag", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lsm9ds1_mag_spi_id);
+
+static struct spi_driver lsm9ds1_mag_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lsm9ds1_mag_spi",
+#ifdef CONFIG_PM
+		.pm = &lsm9ds1_mag_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lsm9ds1_mag_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lsm9ds1_mag_spi_probe,
+	.remove = lsm9ds1_mag_spi_remove,
+	.id_table = lsm9ds1_mag_spi_id,
+};
+
+module_spi_driver(lsm9ds1_mag_spi_driver);
+
+MODULE_DESCRIPTION("lsm9ds1 mag spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/imu/lsm9ds1/Makefile b/drivers/input/misc/st/imu/lsm9ds1/Makefile
--- a/drivers/input/misc/st/imu/lsm9ds1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/lsm9ds1/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the input misc STM imu lsm9ds1 driver
+#
+obj-$(CONFIG_INPUT_LSM9DS1) += lsm9ds1_mag.o lsm9ds1_acc_gyr.o
+obj-$(CONFIG_INPUT_LSM9DS1_I2C) += lsm9ds1_mag_i2c.o lsm9ds1_acc_gyr_i2c.o
+obj-$(CONFIG_INPUT_LSM9DS1_SPI) += lsm9ds1_mag_spi.o lsm9ds1_acc_gyr_spi.o
+
+# ccflags-y += -DLSM9DS1_DEBUG
diff -uNr a/drivers/input/misc/st/imu/Makefile b/drivers/input/misc/st/imu/Makefile
--- a/drivers/input/misc/st/imu/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/imu/Makefile	2017-07-06 19:48:50.150213000 +0200
@@ -0,0 +1,15 @@
+#
+# Makefile for the input misc STM imu drivers.
+#
+
+obj-$(CONFIG_INPUT_LSM6DS3) += lsm6ds3/
+obj-$(CONFIG_INPUT_LSM6DSM) += lsm6dsm/
+obj-$(CONFIG_INPUT_LSM6DSL) += lsm6dsl/
+obj-$(CONFIG_INPUT_LSM9DS0) += lsm9ds0/
+obj-$(CONFIG_INPUT_LSM9DS1) += lsm9ds1/
+obj-$(CONFIG_INPUT_LSM330DLC) += lsm330dlc/
+obj-$(CONFIG_INPUT_LSM6DS0) += lsm6ds0/
+obj-$(CONFIG_INPUT_LSM6DL0) += lsm6dl0/
+obj-$(CONFIG_INPUT_LSM330) += lsm330/
+obj-$(CONFIG_INPUT_ASM330LXH) += asm330lxh/
+
diff -uNr a/drivers/input/misc/st/Kconfig b/drivers/input/misc/st/Kconfig
--- a/drivers/input/misc/st/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/Kconfig	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,16 @@
+
+menuconfig INPUT_ST
+	tristate "STM MEMs Device Drivers"
+
+if INPUT_ST
+
+source "drivers/input/misc/st/imu/Kconfig"
+source "drivers/input/misc/st/ecompass/Kconfig"
+source "drivers/input/misc/st/acc/Kconfig"
+source "drivers/input/misc/st/humidity/Kconfig"
+source "drivers/input/misc/st/gyro/Kconfig"
+source "drivers/input/misc/st/magnetometer/Kconfig"
+source "drivers/input/misc/st/pressure/Kconfig"
+source "drivers/input/misc/st/uv/Kconfig"
+
+endif # INPUT_ST
diff -uNr a/drivers/input/misc/st/magnetometer/Kconfig b/drivers/input/misc/st/magnetometer/Kconfig
--- a/drivers/input/misc/st/magnetometer/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,10 @@
+
+menuconfig INPUT_MAGN
+	tristate "magnetometer"
+
+if INPUT_MAGN
+
+source "drivers/input/misc/st/magnetometer/lis3mdl/Kconfig"
+source "drivers/input/misc/st/magnetometer/lis2mdl/Kconfig"
+
+endif # INPUT_MAGN
diff -uNr a/drivers/input/misc/st/magnetometer/lis2mdl/Kconfig b/drivers/input/misc/st/magnetometer/lis2mdl/Kconfig
--- a/drivers/input/misc/st/magnetometer/lis2mdl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis2mdl/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,18 @@
+config INPUT_LIS2MDL
+         tristate "STM LIS2MDL sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LIS2MDL_I2C if (I2C)
+	 select INPUT_LIS2MDL_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics LIS2MDL sensor.
+
+config INPUT_LIS2MDL_I2C
+         tristate
+         depends on INPUT_LIS2MDL
+         depends on I2C
+
+config INPUT_LIS2MDL_SPI
+         tristate
+         depends on INPUT_LIS2MDL
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.c b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.c
--- a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,467 @@
+/*
+ * STMicroelectronics lis2mdl.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include "lis2mdl.h"
+
+static enum hrtimer_restart lis2mdl_poll_function(struct hrtimer *timer);
+static int lis2mdl_input_init(struct lis2mdl_data *sdata, const char* description,
+								bool is_3_axis);
+static int lis2mdl_write_data(struct st_common_data *cdata, u8 reg_addr,
+							u8 mask, u8 data);
+static void lis2mdl_input_cleanup(struct lis2mdl_data *sdata);
+static void lis2mdl_report_3axes_event(struct lis2mdl_data *sdata, s32 *xyz,
+								s64 timestamp);
+
+static ssize_t lis2mdl_get_enable(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf);
+static ssize_t lis2mdl_set_enable(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count);
+static ssize_t lis2mdl_get_polling_rate(struct device *dev,
+				   struct device_attribute *attr, char *buf);
+static ssize_t lis2mdl_set_polling_rate(struct device *dev,
+				   struct device_attribute *attr, const char *buf,
+				   size_t count);
+
+/* DEVICE REGISTERS */
+#define LIS2MDL_WHO_AM_I_ADDR		(0x4F)
+#define LIS2MDL_WHO_AM_I_VAL		(0x40)
+#define LIS2MDL_CFG_REG_A			(0x60)
+#define LIS2MDL_CFG_REG_B			(0x61)
+#define LIS2MDL_CFG_REG_B_OFF_CANC_MASK	(0x02)
+#define LIS2MDL_CFG_REG_C			(0x62)
+#define LIS2MDL_CFG_REG_C_BDU_MASK		(0x10)
+#define LIS2MDL_OUT_L_ADDR			(0x68)
+
+/* Device operating modes */
+#define LIS2MDL_MD_CONTINUOS_MODE		0x00
+#define LIS2MDL_MD_SINGLE_MODE		0x01
+#define LIS2MDL_MD_IDLE_MODE		0x03
+#define LIS2MDL_MODE_MASK			0x03
+
+/* Device ODRs */
+#define LIS2MDL_ODR_10HZ			0x00
+#define LIS2MDL_ODR_20HZ			0x01
+#define LIS2MDL_ODR_50HZ			0x02
+#define LIS2MDL_ODR_100HZ			0x03
+#define LIS2MDL_ODR_MASK			0x0C
+#define LIS2MDL_BYTE_FOR_SAMPLE		6
+#define LIS2MDL_ODR_LIST_NUM		4
+#define LIS2MDL_DEV_DESCRIPTION		"ST LIS2MDL Magnetometer Sensor"
+#define LIS2MDL_SENSOR_NAME			"magn"
+#define LIS2MDL_SCALE			1500
+
+struct lis2mdl_odr_reg {
+	u32 hz;
+	u8 value;
+} lis2mdl_odr_table_t[] = {
+	[0] = { .hz = 10, 	.value = LIS2MDL_ODR_10HZ },
+	[1] = { .hz = 20, 	.value = LIS2MDL_ODR_20HZ },
+	[2] = { .hz = 50, 	.value = LIS2MDL_ODR_50HZ },
+	[3] = { .hz = 100, 	.value = LIS2MDL_ODR_100HZ },
+};
+
+static void lis2mdl_poll_wk(struct work_struct *input_work)
+{
+	struct lis2mdl_data *sdata;
+	int xyz[3] = { 0 };
+	u8 data[6];
+	int err;
+
+	sdata = container_of((struct work_struct *)input_work,
+			     struct lis2mdl_data, input_work);
+
+	hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+
+	err = sdata->cdata->tf->read(sdata->cdata, LIS2MDL_OUT_L_ADDR,
+						LIS2MDL_BYTE_FOR_SAMPLE,
+						data);
+	if (err < 0)
+		dev_err(sdata->cdata->dev, "get %s data failed %d\n",
+			sdata->name, err);
+	else {
+		xyz[0] = (s32)((s16)(data[0] | data[1] << 8));
+		xyz[1] = (s32)((s16)(data[2] | data[3] << 8));
+		xyz[2] = (s32)((s16)(data[4] | data[5] << 8));
+
+		xyz[0] *= sdata->c_gain;
+		xyz[1] *= sdata->c_gain;
+		xyz[2] *= sdata->c_gain;
+		lis2mdl_report_3axes_event(sdata, xyz, sdata->timestamp);
+	}
+}
+
+int lis2mdl_write_odr(struct lis2mdl_data *sdata) {
+	int i;
+
+	for (i = 0; i < LIS2MDL_ODR_LIST_NUM; i++) {
+		if (lis2mdl_odr_table_t[i].hz >= sdata->c_odr)
+				break;
+	}
+	if (i == LIS2MDL_ODR_LIST_NUM)
+		return -EINVAL;
+
+	return lis2mdl_write_data(sdata->cdata,
+				LIS2MDL_CFG_REG_A,
+				LIS2MDL_ODR_MASK,
+				lis2mdl_odr_table_t[i].value);
+}
+
+int lis2mdl_enable_sensors(struct lis2mdl_data *sdata)
+{
+	int err;
+
+	if (sdata->enabled)
+		return 0;
+
+	err = lis2mdl_write_data(sdata->cdata, LIS2MDL_CFG_REG_A,
+						LIS2MDL_MODE_MASK,
+						LIS2MDL_MD_CONTINUOS_MODE);
+	if (err < 0)
+		return err;
+
+	hrtimer_start(&sdata->hr_timer, sdata->ktime, HRTIMER_MODE_REL);
+	sdata->enabled = true;
+
+	return 0;
+}
+
+int lis2mdl_disable_sensor(struct lis2mdl_data *sdata)
+{
+	int err;
+
+	if (!sdata->enabled)
+		return 0;
+
+	err = lis2mdl_write_data(sdata->cdata, LIS2MDL_CFG_REG_A,
+						LIS2MDL_MODE_MASK,
+						LIS2MDL_MD_IDLE_MODE);
+	if (err < 0)
+		return err;
+
+	cancel_work_sync(&sdata->input_work);
+	hrtimer_cancel(&sdata->hr_timer);
+	sdata->enabled = false;
+
+	return 0;
+}
+
+ssize_t lis2mdl_get_scale_avail(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "50\n");
+}
+
+int lis2mdl_init_sensor(struct st_common_data *cdata)
+{
+	int err;
+	struct lis2mdl_data *sdata = cdata->sensors;
+
+	INIT_WORK(&cdata->sensors->input_work, lis2mdl_poll_wk);
+	hrtimer_init(&cdata->sensors->hr_timer, CLOCK_MONOTONIC,
+					HRTIMER_MODE_REL);
+
+	err = lis2mdl_disable_sensor(sdata);
+	if (err < 0)
+		return err;
+
+	cdata->sensors->hr_timer.function = &lis2mdl_poll_function;
+
+	/*
+	* Enable offset cancellation
+	*/
+	err = lis2mdl_write_data(cdata, LIS2MDL_CFG_REG_B,
+					LIS2MDL_CFG_REG_B_OFF_CANC_MASK,
+					LIS2MDL_EN_BIT);
+	if (err < 0)
+		return err;
+
+
+	/*
+	 * Enable block data update feature.
+	 */
+	return lis2mdl_write_data(cdata, LIS2MDL_CFG_REG_C,
+					LIS2MDL_CFG_REG_C_BDU_MASK,
+					LIS2MDL_EN_BIT);
+}
+
+ADD_DEVICE_ENABLE_ATTR;
+ADD_DEVICE_POLLING_ATTR;
+
+static DEVICE_ATTR(scale_avail, S_IRUGO,
+				lis2mdl_get_scale_avail,
+				NULL);
+
+static struct attribute *lis2mdl_attribute[] = {
+	&dev_attr_enable.attr,
+	&dev_attr_polling_rate.attr,
+	&dev_attr_scale_avail.attr,
+	NULL,
+};
+
+static const struct attribute_group lis2mdl_attribute_groups = {
+	.attrs = lis2mdl_attribute,
+	.name = LIS2MDL_SENSOR_NAME,
+};
+
+int lis2mdl_data_init(struct st_common_data *cdata)
+{
+	struct lis2mdl_data *sdata = cdata->sensors;
+
+	sdata->enabled = false;
+	sdata->cdata = cdata;
+	sdata->sindex = 0;
+	sdata->c_gain = LIS2MDL_SCALE;
+	sdata->name = LIS2MDL_SENSOR_NAME;
+	sdata->c_odr = lis2mdl_odr_table_t[0].hz;
+	sdata->ktime = ktime_set(0, HZ_TO_NSEC(sdata->c_odr));
+
+	lis2mdl_input_init(sdata, LIS2MDL_DEV_DESCRIPTION, true);
+
+	if (sysfs_create_group(&sdata->input_dev->dev.kobj,
+					&lis2mdl_attribute_groups)) {
+		dev_err(cdata->dev, "failed to create sysfs group for sensor %s",
+					sdata->name);
+		return -EINVAL;
+	}
+
+	sdata->write_odr = lis2mdl_write_odr;
+	sdata->enable = lis2mdl_enable_sensors;
+	sdata->disable = lis2mdl_disable_sensor;
+
+	return 0;
+}
+
+static int lis2mdl_write_data(struct st_common_data *cdata, u8 reg_addr,
+			 u8 mask, u8 data)
+{
+	int err;
+	u8 new_data = 0x00, old_data = 0x00;
+
+	err = cdata->tf->read(cdata, reg_addr, 1, &old_data);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & (~mask)) | ((data << __ffs(mask)) & mask));
+
+	if (new_data == old_data)
+		return 1;
+
+	return cdata->tf->write(cdata, reg_addr, 1, &new_data);
+}
+
+static int lis2mdl_input_init(struct lis2mdl_data *sdata, const char* description,
+							bool is_3_axis)
+{
+	int err = 0;
+
+	sdata->input_dev = input_allocate_device();
+	if (!sdata->input_dev) {
+		dev_err(sdata->cdata->dev, "failed to allocate input device");
+		return -ENOMEM;
+	}
+
+	sdata->input_dev->name = description;
+	sdata->input_dev->id.bustype = sdata->cdata->bus_type;
+	sdata->input_dev->dev.parent = sdata->cdata->dev;
+	input_set_drvdata(sdata->input_dev, sdata);
+
+	__set_bit(INPUT_EVENT_TYPE, sdata->input_dev->evbit );
+	__set_bit(INPUT_EVENT_TIME_MSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, sdata->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_X, sdata->input_dev->mscbit);
+
+	if (is_3_axis) {
+		__set_bit(INPUT_EVENT_Y, sdata->input_dev->mscbit);
+		__set_bit(INPUT_EVENT_Z, sdata->input_dev->mscbit);
+	}
+
+	err = input_register_device(sdata->input_dev);
+	if (err) {
+		dev_err(sdata->cdata->dev, "unable to register sensor %s\n",
+								sdata->name);
+		input_free_device(sdata->input_dev);
+	}
+
+	return err;
+}
+
+static void lis2mdl_input_cleanup(struct lis2mdl_data *sdata)
+{
+	input_unregister_device(sdata->input_dev);
+	input_free_device(sdata->input_dev);
+}
+
+static void lis2mdl_report_3axes_event(struct lis2mdl_data *sdata, s32 *xyz,
+								s64 timestamp)
+{
+	struct input_dev *input = sdata->input_dev;
+
+	if (!sdata->enabled)
+		return;
+
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_X, xyz[0]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Y, xyz[1]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_Z, xyz[2]);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+							timestamp >> 32);
+	input_event(input, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+							timestamp & 0xffffffff);
+	input_sync(input);
+}
+
+static enum hrtimer_restart lis2mdl_poll_function(struct hrtimer *timer)
+{
+	struct lis2mdl_data *sdata;
+
+	sdata = container_of((struct hrtimer *)timer, struct lis2mdl_data,
+							hr_timer);
+
+	sdata->timestamp = lis2mdl_get_time_ns();
+	queue_work(sdata->cdata->workqueue, &sdata->input_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static ssize_t lis2mdl_get_enable(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct lis2mdl_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", sdata->enabled);
+}
+
+static ssize_t lis2mdl_set_enable(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	int err;
+	struct lis2mdl_data *sdata = dev_get_drvdata(dev);
+	unsigned long enable;
+
+	if (kstrtoul(buf, 10, &enable))
+		return -EINVAL;
+
+	if (enable)
+		err = sdata->enable(sdata);
+	else
+		err = sdata->disable(sdata);
+
+	return (err < 0) ? err : count;
+}
+
+static ssize_t lis2mdl_get_polling_rate(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct lis2mdl_data *sdata = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", 1000 / sdata->c_odr);
+}
+
+static ssize_t lis2mdl_set_polling_rate(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	int err;
+	u32 c_odr_tmp;
+	ktime_t ktime_tmp;
+	unsigned int polling_rate;
+	struct lis2mdl_data *sdata = dev_get_drvdata(dev);
+
+	err = kstrtoint(buf, 10, &polling_rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&sdata->input_dev->mutex);
+	c_odr_tmp = sdata->c_odr;
+	ktime_tmp = sdata->ktime;
+	sdata->c_odr = 1000 / polling_rate;
+	sdata->ktime = ktime_set(0, MS_TO_NS(polling_rate));
+	mutex_unlock(&sdata->input_dev->mutex);
+
+	err = sdata->write_odr(sdata);
+	if (err < 0) {
+		sdata->c_odr = c_odr_tmp;
+		sdata->ktime = ktime_tmp;
+		return err;
+	}
+
+	return count;
+}
+
+int lis2mdl_probe(struct st_common_data *cdata)
+{
+	int err;
+	u8 wai = 0;
+
+	err = cdata->tf->read(cdata, cdata->wai_addr, 1, &wai);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register 0x%x.\n",
+								cdata->wai_addr);
+		return err;
+	}
+	if (wai != cdata->wai_val) {
+		dev_err(cdata->dev, "Who-Am-I value not valid. (expected 0x%x, \
+			readed 0x%x))\n", cdata->wai_val, wai);
+		return -ENODEV;
+	}
+
+	cdata->workqueue = create_workqueue(cdata->name);
+
+	err = lis2mdl_data_init(cdata);
+	if (err < 0)
+		return err;
+
+	err = lis2mdl_init_sensor(cdata);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2mdl_probe);
+
+int lis2mdl_remove(struct st_common_data *cdata)
+{
+	lis2mdl_disable_sensor(cdata->sensors);
+	lis2mdl_input_cleanup(cdata->sensors);
+
+	return 0;
+}
+EXPORT_SYMBOL(lis2mdl_remove);
+
+int lis2mdl_enable(struct st_common_data *cdata)
+{
+	return lis2mdl_enable_sensors(cdata->sensors);
+}
+EXPORT_SYMBOL(lis2mdl_enable);
+
+int lis2mdl_disable(struct st_common_data *cdata)
+{
+	return lis2mdl_disable_sensor(cdata->sensors);
+}
+EXPORT_SYMBOL(lis2mdl_disable);
+
+MODULE_DESCRIPTION("STMicroelectronics lis2mdl i2c driver");
+MODULE_AUTHOR("Armando Visconti");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.h b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.h
--- a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,152 @@
+/*
+ * STMicroelectronics lis2mdl.h driver
+ *
+ * Copyright 2015 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ * Giuseppe Barba <giuseppe.barba@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef DRIVERS_INPUT_MISC_LIS2MDL_CORE_H_
+#define DRIVERS_INPUT_MISC_LIS2MDL_CORE_H_
+
+#include <linux/types.h>
+
+#define LIS2MDL_OUT_XYZ_SIZE		8
+
+#define HZ_TO_NSEC(hz)			(1000 * 1000 * 1000 / ((u32)(hz)))
+#define HZ_TO_MSEC(hz)			(1000 / ((u32)x))
+#define MS_TO_US(x)			({ typeof(x) _x = (x); ((_x) * \
+							((typeof(x)) 1000));})
+#define US_TO_NS(x)			(MS_TO_US(x))
+#define MS_TO_NS(x)			(US_TO_NS(MS_TO_US(x)))
+#define US_TO_MS(x)			({ typeof(x) _x = (x); ((_x) / \
+							((typeof(x)) 1000));})
+#define NS_TO_US(x)			(US_TO_MS(x))
+#define NS_TO_MS(x)			(US_TO_MS(NS_TO_US(x)))
+#define DEF_ZERO			(0x00)
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+#define LIS2MDL_EN_BIT			0x01
+#define LIS2MDL_DIS_BIT		0x00
+
+#define LIS2MDL_RX_MAX_LENGTH		(500)
+#define LIS2MDL_TX_MAX_LENGTH		(500)
+
+#define ADD_DEVICE_ENABLE_ATTR		static \
+					DEVICE_ATTR(enable, \
+						S_IWUSR | S_IRUGO, \
+						lis2mdl_get_enable, \
+						lis2mdl_set_enable);
+
+#define ADD_DEVICE_POLLING_ATTR		static \
+						DEVICE_ATTR(polling_rate, \
+						S_IWUSR | S_IRUGO, \
+						lis2mdl_get_polling_rate, \
+						lis2mdl_set_polling_rate);
+#define LIS2MDL_CONCAT(a, b)		(a b)
+
+#define to_dev(obj) container_of(obj, struct device, kobj)
+
+#define LIS2MDL_DEV_NAME			"lis2mdl"
+#define LIS2MDL_I2C_ADDR			0x1e
+
+struct lis2mdl_platform_data {
+	u8 drdy_int_pin;
+};
+
+struct reg_rw {
+	u8 const address;
+	u8 const init_val;
+	u8 resume_val;
+};
+
+struct reg_r {
+	const u8 address;
+	const u8 init_val;
+};
+
+struct lis2mdl_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LIS2MDL_RX_MAX_LENGTH];
+	u8 tx_buf[LIS2MDL_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct st_common_data;
+
+struct lis2mdl_transfer_function {
+	int (*write) (struct st_common_data *cdata, u8 addr, int len, u8 *data);
+	int (*read) (struct st_common_data *cdata, u8 addr, int len, u8 *data);
+};
+
+typedef struct {
+	u8 power_mode;
+	u8 enabled_sensor;
+	u32 common_odr;
+	s64 timestamp;
+	struct work_struct irq_work;
+	struct st_common_data *cdata; /* link back to common data */
+} priv_data_t;
+
+struct lis2mdl_data {
+	struct st_common_data *cdata;
+	const char* name;
+	s64 timestamp;
+	u8 enabled;
+	u32 c_odr;
+	u32 c_gain;
+	u8 sindex;
+	u8 sample_to_discard;
+
+	struct input_dev *input_dev;
+	struct hrtimer hr_timer;
+	struct work_struct input_work;
+	ktime_t ktime;
+	int (*enable)(struct lis2mdl_data *sdata);
+	int (*disable)(struct lis2mdl_data *sdata);
+	int (*write_odr)(struct lis2mdl_data *sdata);
+};
+
+struct st_common_data {
+	const char *name;
+	u16 bus_type;
+	u8 drdy_int_pin;
+	u8 wai_addr;
+	u8 wai_val;
+	int irq;
+	uint32_t sensors_count;
+
+	void *priv_data;
+
+	struct mutex lock;
+	struct workqueue_struct *workqueue;
+	struct device *dev;
+	struct lis2mdl_data *sensors;
+	const struct lis2mdl_transfer_function *tf;
+	struct lis2mdl_transfer_buffer tb;
+};
+
+static inline s64 lis2mdl_get_time_ns(void) {
+	struct timespec ts;
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+int lis2mdl_enable(struct st_common_data *cdata);
+int lis2mdl_disable(struct st_common_data *cdata);
+int lis2mdl_probe(struct st_common_data *cdata);
+int lis2mdl_remove(struct st_common_data *cdata);
+
+#endif /* DRIVERS_INPUT_MISC_LIS2MDL_CORE_H_ */
diff -uNr a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_i2c.c b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_i2c.c
--- a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,195 @@
+/*
+ * STMicroelectronics lis2mdl_i2c.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lis2mdl.h"
+
+#define LIS2MDL_WHO_AM_I_ADDR		(0x4F)
+#define LIS2MDL_WHO_AM_I_VAL		(0x40)
+
+/* XXX: caller must hold cdata->lock */
+static int lis2mdl_i2c_read(struct st_common_data *cdata,
+				 u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lis2mdl_i2c_write(struct st_common_data *cdata,
+				  u8 addr, int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static struct lis2mdl_transfer_function lis2mdl_i2c_tf = {
+	.write = lis2mdl_i2c_write,
+	.read = lis2mdl_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lis2mdl_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+	return lis2mdl_enable(cdata);
+}
+
+static int lis2mdl_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+	return lis2mdl_disable(cdata);
+}
+
+static const struct dev_pm_ops lis2mdl_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2mdl_i2c_suspend, lis2mdl_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2mdl_i2c_id_table[] = {
+	{ .compatible = "st,lis2mdl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2mdl_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static int lis2mdl_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct st_common_data *cdata;
+
+#ifdef LIS2MDL_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct st_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensors = (struct lis2mdl_data *) kmalloc(
+						sizeof(struct lis2mdl_data),
+						GFP_KERNEL);
+	if (!cdata->sensors)
+		return -ENOMEM;
+
+	cdata->priv_data = (priv_data_t *) kmalloc(sizeof(priv_data_t),
+						   GFP_KERNEL);
+	if (!cdata->priv_data)
+		return -ENOMEM;
+
+	cdata->irq = client->irq;
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bus_type = BUS_I2C;
+	cdata->tf = &lis2mdl_i2c_tf;
+	cdata->wai_addr = LIS2MDL_WHO_AM_I_ADDR;
+	cdata->wai_val = LIS2MDL_WHO_AM_I_VAL;
+
+	mutex_init(&cdata->lock);
+
+	i2c_set_clientdata(client, cdata);
+
+	err = lis2mdl_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lis2mdl_i2c_remove(struct i2c_client *client)
+{
+	struct st_common_data *cdata = i2c_get_clientdata(client);
+
+#ifdef LIS2MDL_DEBUG
+	dev_info(cdata->dev, "driver removing\n");
+#endif
+
+	lis2mdl_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct i2c_device_id lis2mdl_i2c_id[] = {
+	{ "lis2mdl", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lis2mdl_i2c_id);
+
+static struct i2c_driver lis2mdl_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2MDL_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = &lis2mdl_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lis2mdl_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lis2mdl_i2c_probe,
+	.remove = lis2mdl_i2c_remove,
+	.id_table = lis2mdl_i2c_id,
+};
+
+module_i2c_driver(lis2mdl_i2c_driver);
+
+MODULE_DESCRIPTION("lis2mdl i2c driver");
+MODULE_AUTHOR("Armando Visconti");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_spi.c b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_spi.c
--- a/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis2mdl/lis2mdl_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,217 @@
+/*
+ * STMicroelectronics lis2mdl_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Armando Visconti <armando.visconti@st.com>
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+
+#include "lis2mdl.h"
+
+#define LIS2MDL_WHO_AM_I_ADDR		(0x4F)
+#define LIS2MDL_WHO_AM_I_VAL		(0x40)
+
+#define SENSORS_SPI_READ	0x80
+
+/* XXX: caller must hold cdata->lock */
+static int lis2mdl_spi_read(struct st_common_data *cdata,
+				 u8 addr, int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(cdata->dev);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	cdata->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold cdata->lock */
+static int lis2mdl_spi_write(struct st_common_data *cdata,
+				  u8 addr, int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(cdata->dev);
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LIS2MDL_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	cdata->tb.tx_buf[0] = addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static struct lis2mdl_transfer_function lis2mdl_spi_tf = {
+	.write = lis2mdl_spi_write,
+	.read = lis2mdl_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lis2mdl_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+	return lis2mdl_enable(cdata);
+}
+
+static int lis2mdl_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+	return lis2mdl_disable(cdata);
+}
+
+static const struct dev_pm_ops lis2mdl_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis2mdl_spi_suspend,
+				lis2mdl_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis2mdl_spi_id_table[] = {
+	{ .compatible = "st,lis2mdl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis2mdl_spi_id_table);
+#endif /* CONFIG_OF */
+
+static int lis2mdl_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct st_common_data *cdata;
+
+#ifdef LIS2MDL_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct st_common_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&spi->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	cdata->sensors = (struct lis2mdl_data *) kmalloc(
+						sizeof(struct lis2mdl_data),
+						GFP_KERNEL);
+	if (!cdata->sensors)
+		return -ENOMEM;
+
+	cdata->priv_data = (priv_data_t *) kmalloc(sizeof(priv_data_t),
+						   GFP_KERNEL);
+	if (!cdata->priv_data)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->irq = spi->irq;
+	cdata->bus_type = BUS_SPI;
+	cdata->tf = &lis2mdl_spi_tf;
+	cdata->wai_addr = LIS2MDL_WHO_AM_I_ADDR;
+	cdata->wai_val = LIS2MDL_WHO_AM_I_VAL;
+
+	mutex_init(&cdata->lock);
+
+	spi_set_drvdata(spi, cdata);
+
+	err = lis2mdl_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int lis2mdl_spi_remove(struct spi_device *spi)
+{
+	struct st_common_data *cdata = spi_get_drvdata(spi);
+
+#ifdef LIS2MDL_DEBUG
+	dev_info(cdata->dev, "driver removing\n");
+#endif
+
+	lis2mdl_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct spi_device_id lis2mdl_spi_id[] = {
+	{ "lis2mdl", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, lis2mdl_spi_id);
+
+static struct spi_driver lis2mdl_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LIS2MDL_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = &lis2mdl_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lis2mdl_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lis2mdl_spi_probe,
+	.remove = lis2mdl_spi_remove,
+	.id_table = lis2mdl_spi_id,
+};
+
+module_spi_driver(lis2mdl_spi_driver);
+
+MODULE_DESCRIPTION("lis2mdl spi driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis2mdl/Makefile b/drivers/input/misc/st/magnetometer/lis2mdl/Makefile
--- a/drivers/input/misc/st/magnetometer/lis2mdl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis2mdl/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_INPUT_LIS2MDL) += lis2mdl.o
+obj-$(CONFIG_INPUT_LIS2MDL_I2C) += lis2mdl_i2c.o
+obj-$(CONFIG_INPUT_LIS2MDL_SPI) += lis2mdl_spi.o
diff -uNr a/drivers/input/misc/st/magnetometer/lis3mdl/Kconfig b/drivers/input/misc/st/magnetometer/lis3mdl/Kconfig
--- a/drivers/input/misc/st/magnetometer/lis3mdl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis3mdl/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,22 @@
+
+config INPUT_LIS3MDL
+         tristate "STM LIS3MDL sensor"
+         depends on (I2C || SPI) && SYSFS
+	 select INPUT_LIS3MDL_I2C if (I2C)
+	 select INPUT_LIS3MDL_SPI if (SPI)
+         help
+           This driver support the STMicroelectronics LIS3MDL sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lis3mdl.
+
+config INPUT_LIS3MDL_I2C
+         tristate
+         depends on INPUT_LIS3MDL
+         depends on I2C
+
+config INPUT_LIS3MDL_SPI
+         tristate
+         depends on INPUT_LIS3MDL
+         depends on SPI
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl.h b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl.h
--- a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,82 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lis3mdl.h
+* Authors	: AMS - Motion Mems Division - Application Team
+*		: Matteo Dameno (matteo.dameno@st.com)
+*		: Denis Ciocca (denis.ciocca@st.com)
+*		: Lorenzo Bianconi (lorenzo.bianconi@st.com)
+* Version	: V.1.0.2
+* Date		: 2016/May/2
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#ifndef __LIS3MDL_H__
+#define __LIS3MDL_H__
+
+#include <linux/module.h>
+#include <linux/version.h>
+
+struct lis3mdl_transfer_function {
+	int (*write) (struct device *dev, u8 addr, int len, u8 *data);
+	int (*read) (struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#if defined(CONFIG_INPUT_LIS3MDL_SPI) || \
+    defined(CONFIG_INPUT_LIS3MDL_SPI_MODULE)
+#define LIS3MDL_RX_MAX_LENGTH		500
+#define LIS3MDL_TX_MAX_LENGTH		500
+
+struct lis3mdl_transfer_buffer {
+	u8 rx_buf[LIS3MDL_RX_MAX_LENGTH];
+	u8 tx_buf[LIS3MDL_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+#endif /* CONFIG_INPUT_LIS3MDL_SPI */
+
+struct lis3mdl_dev {
+	const char *name;
+	struct device *dev;
+	struct mutex lock;
+	u16 bus_type;
+	struct work_struct input_work_mag;
+
+	struct hrtimer hr_timer_mag;
+	ktime_t ktime;
+
+	struct input_dev *input_dev_mag;
+
+	atomic_t enabled_mag;
+	int64_t timestamp;
+
+	u32 sensitivity_mag;
+	u32 poll_interval;
+
+	u8 xy_mode;
+	u8 z_mode;
+	u8 fs_range;
+
+	const struct lis3mdl_transfer_function *tf;
+#if defined(CONFIG_INPUT_LIS3MDL_SPI) || \
+    defined(CONFIG_INPUT_LIS3MDL_SPI_MODULE)
+	struct lis3mdl_transfer_buffer tb;
+#endif /* CONFIG_INPUT_LIS3MDL_SPI */
+};
+
+int lis3mdl_mag_enable(struct lis3mdl_dev *dev);
+int lis3mdl_mag_disable(struct lis3mdl_dev *dev);
+int lis3mdl_mag_probe(struct lis3mdl_dev *dev);
+int lis3mdl_mag_remove(struct lis3mdl_dev *dev);
+#endif	/* __LIS3MDL_H__ */
diff -uNr a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_i2c.c b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_i2c.c
--- a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,173 @@
+/*
+ * STMicroelectronics lis3mdl_i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+
+#include "lis3mdl.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+/* XXX: caller must hold dev->lock */
+static int lis3mdl_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/* XXX: caller must hold dev->lock */
+static int lis3mdl_i2c_write(struct device *dev, u8 addr, int len, u8 *data)
+{
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (len > 1)
+		addr |= I2C_AUTO_INCREMENT;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len + 1;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct lis3mdl_transfer_function lis3mdl_i2c_tf = {
+	.write = lis3mdl_i2c_write,
+	.read = lis3mdl_i2c_read,
+};
+
+#ifdef CONFIG_PM
+static int lis3mdl_i2c_resume(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lis3mdl_dev *dev = i2c_get_clientdata(client);
+
+	return lis3mdl_mag_enable(dev);
+}
+
+static int lis3mdl_i2c_suspend(struct device *device)
+{
+	struct i2c_client *client = to_i2c_client(device);
+	struct lis3mdl_dev *dev = i2c_get_clientdata(client);
+
+	return lis3mdl_mag_disable(dev);
+}
+
+static const struct dev_pm_ops lis3mdl_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3mdl_i2c_suspend,
+				lis3mdl_i2c_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lis3mdl_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct lis3mdl_dev *dev;
+
+#ifdef LIS3MDL_DEBUG
+	dev_info(&client->dev, "probe start.\n");
+#endif
+
+	/* Alloc Common data structure */
+	dev = kzalloc(sizeof(struct lis3mdl_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "failed to allocate module data\n");
+		return -ENOMEM;
+	}
+
+	dev->name = client->name;
+	dev->bus_type = BUS_I2C;
+	dev->tf = &lis3mdl_i2c_tf;
+	dev->dev = &client->dev;
+
+	i2c_set_clientdata(client, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lis3mdl_mag_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+int lis3mdl_i2c_remove(struct i2c_client *client)
+{
+	struct lis3mdl_dev *dev = i2c_get_clientdata(client);
+
+#ifdef LIS3MDL_DEBUG
+	dev_info(&client->dev, "driver removing\n");
+#endif
+
+	lis3mdl_mag_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id lis3mdl_i2c_id[] = {
+	{ "lis3mdl", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lis3mdl_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3mdl_i2c_id_table[] = {
+	{ .compatible = "st,lis3mdl" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3mdl_i2c_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver lis3mdl_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lis3mdl_i2c",
+#ifdef CONFIG_PM
+		.pm = &lis3mdl_i2c_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lis3mdl_i2c_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe = lis3mdl_i2c_probe,
+	.remove = lis3mdl_i2c_remove,
+	.id_table = lis3mdl_i2c_id,
+};
+
+module_i2c_driver(lis3mdl_i2c_driver);
+
+MODULE_DESCRIPTION("lis3mdl i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_mag.c b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_mag.c
--- a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_mag.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_mag.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,937 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name          : lis3mdl_mag.c
+* Authors            : MSH - C&I BU - Application Team
+*		     : Matteo Dameno (matteo.dameno@st.com)
+*		     : Denis Ciocca (denis.ciocca@st.com)
+*		     : Lorenzo Bianconi (lorenzo.bianconi@st.com)
+*		     : Authors are willing to be considered the contact
+*		     : and update points for the driver.
+* Version            : V.1.0.2
+* Date               : 2016/May/2
+* Description        : LIS3MDL magnetometer driver
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#endif
+
+#include "lis3mdl.h"
+
+#define MS_TO_NS(x)		((x) * 1000000L)
+
+#define LIS3MDL_DEV_NAME	"lis3mdl_mag"
+
+#define LIS3MDL_MAG_MIN_POLL_PERIOD_MS	10
+
+/* Address registers */
+#define REG_WHOAMI_ADDR		0x0F /* Who am i address register */
+#define REG_CNTRL1_ADDR		0x20 /* CNTRL1 address register */
+#define REG_CNTRL2_ADDR		0x21 /* CNTRL2 address register */
+#define REG_CNTRL3_ADDR		0x22 /* CNTRL3 address register */
+#define REG_CNTRL4_ADDR		0x23 /* CNTRL4 address register */
+#define REG_CNTRL5_ADDR		0x24 /* CNTRL5 address register */
+
+#define REG_MAG_DATA_ADDR	0x28 /* Mag. data low address register */
+
+/* Sensitivity [uGauss/LSB] */
+#define SENSITIVITY_MAG_4G	146
+#define SENSITIVITY_MAG_8G	292
+#define SENSITIVITY_MAG_12G	438
+#define SENSITIVITY_MAG_16G	584
+
+/* ODR */
+#define ODR_MAG_MASK		0x1C /* Mask for odr change on mag */
+#define LIS3MDL_MAG_ODR0_625	0x00 /* 0.625Hz output data rate */
+#define LIS3MDL_MAG_ODR1_25	0x04 /* 1.25Hz output data rate */
+#define LIS3MDL_MAG_ODR2_5	0x08 /* 2.5Hz output data rate */
+#define LIS3MDL_MAG_ODR5	0x0C /* 5Hz output data rate */
+#define LIS3MDL_MAG_ODR10	0x10 /* 10Hz output data rate */
+#define LIS3MDL_MAG_ODR20	0x14 /* 20Hz output data rate */
+#define LIS3MDL_MAG_ODR40	0x18 /* 40Hz output data rate */
+#define LIS3MDL_MAG_ODR80	0x1C /* 80Hz output data rate */
+
+/* Magnetic sensor mode */
+#define MSMS_MASK		0x03 /* Mask magnetic sensor mode */
+#define POWEROFF_MAG		0x02 /* Power Down */
+#define CONTINUOS_CONVERSION	0x00 /* Continuos Conversion */
+
+/* X and Y axis operative mode selection */
+#define X_Y_PERFORMANCE_MASK		0x60
+#define X_Y_LOW_PERFORMANCE		0x00
+#define X_Y_MEDIUM_PERFORMANCE		0x20
+#define X_Y_HIGH_PERFORMANCE		0x40
+#define X_Y_ULTRA_HIGH_PERFORMANCE	0x60
+
+/* Z axis operative mode selection */
+#define Z_PERFORMANCE_MASK		0x0c
+#define Z_LOW_PERFORMANCE		0x00
+#define Z_MEDIUM_PERFORMANCE		0x04
+#define Z_HIGH_PERFORMANCE		0x08
+#define Z_ULTRA_HIGH_PERFORMANCE	0x0c
+
+/* Default values loaded in probe function */
+#define WHOIAM_VALUE		0x3d /* Who Am I default value */
+#define REG_DEF_CNTRL1		0x60 /* CNTRL1 default value */
+#define REG_DEF_CNTRL2		0x00 /* CNTRL2 default value */
+#define REG_DEF_CNTRL3		0x03 /* CNTRL3 default value */
+#define REG_DEF_CNTRL4		0x0c /* CNTRL4 default value */
+#define REG_DEF_CNTRL5		0x40 /* CNTRL5 default value */
+
+#define REG_DEF_ALL_ZEROS	0x00
+
+/* Magnetometer Sensor Full Scale */
+#define LIS3MDL_MAG_FS_MASK	0x60
+#define LIS3MDL_MAG_FS_4G	0x00 /* Full scale 4 Gauss */
+#define LIS3MDL_MAG_FS_8G	0x20 /* Full scale 8 Gauss */
+#define LIS3MDL_MAG_FS_12G	0x40 /* Full scale 12 Gauss */
+#define LIS3MDL_MAG_FS_16G	0x60 /* Full scale 16 Gauss */
+
+
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_X			MSC_SERIAL
+#define INPUT_EVENT_Y			MSC_PULSELED
+#define INPUT_EVENT_Z			MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+static struct workqueue_struct *lis3mdl_workqueue;
+
+struct {
+	unsigned int cutoff_us;
+	u8 value;
+} lis3mdl_mag_odr_table[] = {
+	{ 12, LIS3MDL_MAG_ODR80 },
+	{ 25, LIS3MDL_MAG_ODR40 },
+	{ 50, LIS3MDL_MAG_ODR20 },
+	{ 100, LIS3MDL_MAG_ODR10 },
+	{ 200, LIS3MDL_MAG_ODR5 },
+	{ 400, LIS3MDL_MAG_ODR2_5 },
+	{ 800, LIS3MDL_MAG_ODR1_25 },
+	{ 1600, LIS3MDL_MAG_ODR0_625 },
+};
+
+static inline int64_t lis3mdl_get_time_ns(void)
+{
+	struct timespec ts;
+
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int lis3mdl_write_data_with_mask(struct lis3mdl_dev *dev,
+					u8 addr, u8 mask, u8 data)
+{
+	int err;
+	u8 old_data, new_data;
+
+	err = dev->tf->read(dev->dev, addr, 1, &old_data);
+	if (err < 0)
+		return err;
+
+	new_data = ((old_data & ~mask) | (data & mask));
+	if (old_data == new_data)
+		return 1;
+
+	return dev->tf->write(dev->dev, addr, 1, &new_data);
+}
+
+static int lis3mdl_hw_init(struct lis3mdl_dev *dev)
+{
+	int err;
+	u8 data;
+
+	err = dev->tf->read(dev->dev, REG_WHOAMI_ADDR, 1, &data);
+	if (err < 0) {
+		dev_err(dev->dev, "Error reading WHO_AM_I\n");
+		return err;
+	}
+
+	if (data != WHOIAM_VALUE) {
+		dev_err(dev->dev, "device unknown {0x%02x-0x%02x}\n",
+			WHOIAM_VALUE, data);
+		return -ENODEV;
+	}
+
+	data = REG_DEF_CNTRL1;
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	data = REG_DEF_CNTRL2;
+	err = dev->tf->write(dev->dev, REG_CNTRL2_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	data = REG_DEF_CNTRL3;
+	err = dev->tf->write(dev->dev, REG_CNTRL3_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	data = REG_DEF_CNTRL4;
+	err = dev->tf->write(dev->dev, REG_CNTRL4_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	data = REG_DEF_CNTRL5;
+	err = dev->tf->write(dev->dev, REG_CNTRL5_ADDR, 1, &data);
+	if (err < 0)
+		return err;
+
+	dev->xy_mode = X_Y_ULTRA_HIGH_PERFORMANCE;
+	dev->z_mode = Z_ULTRA_HIGH_PERFORMANCE;
+
+	return 0;
+}
+
+static int lis3mdl_mag_device_power_off(struct lis3mdl_dev *dev)
+{
+	int err;
+
+	err = lis3mdl_write_data_with_mask(dev, REG_CNTRL3_ADDR, MSMS_MASK,
+					   POWEROFF_MAG);
+	if (err < 0)
+		dev_err(dev->dev, "power off failed: %d\n", err);
+
+	atomic_set(&dev->enabled_mag, 0);
+
+	return 0;
+}
+
+static int lis3mdl_mag_device_power_on(struct lis3mdl_dev *dev)
+{
+	int err;
+	u8 data = REG_DEF_CNTRL1;
+
+	err = dev->tf->write(dev->dev, REG_CNTRL1_ADDR, 1, &data);
+	if (err < 0)
+		goto err_resume_state;
+
+	err = lis3mdl_write_data_with_mask(dev, REG_CNTRL3_ADDR, MSMS_MASK,
+					   CONTINUOS_CONVERSION);
+	if (err < 0)
+		goto err_resume_state;
+
+	atomic_set(&dev->enabled_mag, 1);
+
+	return 0;
+
+err_resume_state:
+	dev_err(dev->dev, "hw power on error: %d\n", err);
+
+	return err;
+}
+
+static int lis3mdl_mag_update_fs_range(struct lis3mdl_dev *dev, u8 new_range)
+{
+	int err;
+	u32 sensitivity;
+	u8 data = LIS3MDL_MAG_FS_MASK & new_range;
+
+	switch (new_range) {
+	case LIS3MDL_MAG_FS_4G:
+		sensitivity = SENSITIVITY_MAG_4G;
+		break;
+	case LIS3MDL_MAG_FS_8G:
+		sensitivity = SENSITIVITY_MAG_8G;
+		break;
+	case LIS3MDL_MAG_FS_12G:
+		sensitivity = SENSITIVITY_MAG_12G;
+		break;
+	case LIS3MDL_MAG_FS_16G:
+		sensitivity = SENSITIVITY_MAG_16G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid fs range: %u\n", new_range);
+		return -EINVAL;
+	}
+
+	err = dev->tf->write(dev->dev, REG_CNTRL2_ADDR, 1, &data);
+	if (err < 0) {
+		dev_err(dev->dev, "update fs range failed: %d\n", err);
+		return err;
+	}
+	dev->sensitivity_mag = sensitivity;
+
+	return 0;
+}
+
+static int lis3mdl_mag_update_odr(struct lis3mdl_dev *dev, u32 poll_interval)
+{
+	int i, err;
+
+	if (atomic_read(&dev->enabled_mag) == 0)
+		return -1;
+
+	for (i = ARRAY_SIZE(lis3mdl_mag_odr_table) - 1; i >= 0; i--) {
+		if ((lis3mdl_mag_odr_table[i].cutoff_us <= poll_interval) ||
+		    (i == 0))
+			break;
+	}
+
+	err = lis3mdl_write_data_with_mask(dev, REG_CNTRL1_ADDR, ODR_MAG_MASK,
+					   lis3mdl_mag_odr_table[i].value);
+	if (err < 0) {
+		dev_err(dev->dev, "update odr failed %d\n", err);
+		return err;
+	}
+
+	dev->ktime = ktime_set(0, MS_TO_NS(poll_interval));
+
+	return err;
+}
+
+static int lis3mdl_mag_update_operative_mode(struct lis3mdl_dev *dev, int axis,
+					     u8 value)
+{
+	int err;
+	u8 mask, addr, *mode;
+
+	if (axis == 0) {
+		addr = REG_CNTRL1_ADDR;
+		mask = X_Y_PERFORMANCE_MASK;
+		mode = &dev->xy_mode;
+	} else {
+		addr = REG_CNTRL4_ADDR;
+		mask = Z_PERFORMANCE_MASK;
+		mode = &dev->z_mode;
+	}
+
+	
+	mutex_lock(&dev->lock);
+	err = lis3mdl_write_data_with_mask(dev, addr, mask, value);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		dev_err(dev->dev, "update operative mode failed: %d\n", err);
+		return err;
+	}
+	mutex_unlock(&dev->lock);
+	*mode = value;
+
+	return 0;
+}
+
+int lis3mdl_mag_enable(struct lis3mdl_dev *dev)
+{
+	if (!atomic_cmpxchg(&dev->enabled_mag, 0, 1)) {
+		int err;
+
+		mutex_lock(&dev->lock);
+		err = lis3mdl_mag_device_power_on(dev);
+		if (err < 0) {
+			mutex_unlock(&dev->lock);
+			return err;
+		}
+		lis3mdl_mag_update_odr(dev, dev->poll_interval);
+		mutex_unlock(&dev->lock);
+
+		hrtimer_start(&dev->hr_timer_mag, dev->ktime, HRTIMER_MODE_REL);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lis3mdl_mag_enable);
+
+int lis3mdl_mag_disable(struct lis3mdl_dev *dev)
+{
+	if (atomic_cmpxchg(&dev->enabled_mag, 1, 0)) {
+		cancel_work_sync(&dev->input_work_mag);
+		hrtimer_cancel(&dev->hr_timer_mag);
+
+		mutex_lock(&dev->lock);
+		lis3mdl_mag_device_power_off(dev);
+		mutex_unlock(&dev->lock);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(lis3mdl_mag_disable);
+
+static void lis3mdl_mag_input_cleanup(struct lis3mdl_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static ssize_t attr_get_polling_rate_mag(struct device *device,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	u32 val;
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	val = dev->poll_interval;
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%u\n", val);
+}
+
+static ssize_t attr_set_polling_rate_mag(struct device *device,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	unsigned long interval_ms;
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &interval_ms) || !interval_ms)
+		return -EINVAL;
+
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+			    LIS3MDL_MAG_MIN_POLL_PERIOD_MS);
+	mutex_lock(&dev->lock);
+
+	dev->poll_interval = (u32)interval_ms;
+	lis3mdl_mag_update_odr(dev, dev->poll_interval);
+
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_mag(struct device *device,
+				   struct device_attribute *attr, char *buf)
+{
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+	int val = atomic_read(&dev->enabled_mag);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable_mag(struct device *device,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	unsigned long val;
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lis3mdl_mag_enable(dev);
+	else
+		lis3mdl_mag_disable(dev);
+
+	return size;
+}
+
+static ssize_t attr_get_range_mag(struct device *device,
+				  struct device_attribute *attr, char *buf)
+{
+	int range = 2;
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	switch (dev->fs_range) {
+	case LIS3MDL_MAG_FS_4G:
+		range = 4;
+		break;
+	case LIS3MDL_MAG_FS_8G:
+		range = 8;
+		break;
+	case LIS3MDL_MAG_FS_12G:
+		range = 12;
+		break;
+	case LIS3MDL_MAG_FS_16G:
+		range = 16;
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%d\n", range);
+}
+
+static ssize_t attr_set_range_mag(struct device *device,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	int err;
+	u8 range;
+	unsigned long val;
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	switch (val) {
+	case 4:
+		range = LIS3MDL_MAG_FS_4G;
+		break;
+	case 8:
+		range = LIS3MDL_MAG_FS_8G;
+		break;
+	case 12:
+		range = LIS3MDL_MAG_FS_12G;
+		break;
+	case 16:
+		range = LIS3MDL_MAG_FS_16G;
+		break;
+	default:
+		dev_err(dev->dev, "invalid range request: %lu\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->lock);
+	err = lis3mdl_mag_update_fs_range(dev, range);
+	if (err < 0) {
+		mutex_unlock(&dev->lock);
+		return err;
+	}
+	dev->fs_range = range;
+	mutex_unlock(&dev->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_xy_mode(struct device *device,
+				struct device_attribute *attr, char *buf)
+{
+	char mode[13];
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	switch (dev->xy_mode) {
+	case X_Y_HIGH_PERFORMANCE:
+		strcpy(mode, "high");
+		break;
+	case X_Y_LOW_PERFORMANCE:
+		strcpy(mode, "low");
+		break;
+	case X_Y_MEDIUM_PERFORMANCE:
+		strcpy(mode, "medium");
+		break;
+	case X_Y_ULTRA_HIGH_PERFORMANCE:
+		strcpy(mode, "ultra_high");
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%s\n", mode);
+}
+
+static ssize_t attr_set_xy_mode(struct device *device,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	int err;
+	u8 mode;
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	if (!strncmp(buf, "high", 4)) {
+		mode = X_Y_HIGH_PERFORMANCE;
+	} else if (!strncmp(buf, "low", 3)) {
+		mode = X_Y_LOW_PERFORMANCE;
+	} else if (!strncmp(buf, "medium", 6)) {
+		mode = X_Y_MEDIUM_PERFORMANCE;
+	} else if (!strncmp(buf, "ultra_high", 10)) {
+		mode = X_Y_ULTRA_HIGH_PERFORMANCE;
+	} else {
+		dev_err(dev->dev, "invalid value request: %s\n", buf);
+		return -EINVAL;
+	}
+
+	err = lis3mdl_mag_update_operative_mode(dev, 0, mode);
+	if (err < 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static ssize_t attr_get_z_mode(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	char mode[13];
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+
+	mutex_lock(&dev->lock);
+	switch (dev->z_mode) {
+	case Z_HIGH_PERFORMANCE:
+		strcpy(mode, "high");
+		break;
+	case Z_LOW_PERFORMANCE:
+		strcpy(mode, "low");
+		break;
+	case Z_MEDIUM_PERFORMANCE:
+		strcpy(mode, "medium");
+		break;
+	case Z_ULTRA_HIGH_PERFORMANCE:
+		strcpy(mode, "ultra_high");
+		break;
+	}
+	mutex_unlock(&dev->lock);
+
+	return sprintf(buf, "%s\n", mode);
+}
+
+static ssize_t attr_set_z_mode(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lis3mdl_dev *dev = dev_get_drvdata(device);
+	u8 mode;
+	int err;
+
+	if (!strncmp(buf, "high", 4)) {
+		mode = Z_HIGH_PERFORMANCE;
+	} else if (!strncmp(buf, "low", 3)) {
+		mode = Z_LOW_PERFORMANCE;
+	} else if (!strncmp(buf, "medium", 6)) {
+		mode = Z_MEDIUM_PERFORMANCE;
+	} else if (!strncmp(buf, "ultra_high", 10)) {
+		mode = Z_ULTRA_HIGH_PERFORMANCE;
+	} else {
+		dev_err(dev->dev, "invalid value request: %s\n", buf);
+		return -EINVAL;
+	}
+
+	err = lis3mdl_mag_update_operative_mode(dev, 1, mode);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+#ifdef LIS3MDL_DEBUG
+static int write_bit_on_register(struct lis3mdl_dev *dev,
+				 u8 addr, u8 *resume_value,
+				 u8 mask, int value)
+{
+	int err;
+	u8 updated_val, data;
+	u8 buf[2];
+	u8 val = 0x00;
+
+	mutex_lock(&dev->lock);
+
+	err = dev->tf->read(dev->dev, addr, 1, &data);
+	if (err < 0)
+		goto unlock;
+
+	if (resume_value)
+		*resume_value = data;
+
+	if (!mask) {
+		updated_val = value;
+	} else {
+		if (value > 0)
+			val = 0xff;
+		updated_val = (mask & val) | (~mask & data);
+	}
+	err = dev->tf->write(dev->dev, addr, 1, &updated_val);
+	if (err < 0)
+		goto unlock;
+
+	if (resume_value != NULL)
+		*resume_value = buf[0];
+
+	if (resume_value)
+		*resume_value = updated_val;
+
+unlock:
+	mutex_unlock(&dev->lock);
+
+	return err;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms, 0666, attr_get_polling_rate_mag,
+	       attr_set_polling_rate_mag),
+	__ATTR(full_scale, 0666, attr_get_range_mag, attr_set_range_mag),
+	__ATTR(enable_device, 0666, attr_get_enable_mag, attr_set_enable_mag),
+	__ATTR(x_y_opearative_mode, 0666, attr_get_xy_mode, attr_set_xy_mode),
+	__ATTR(z_opearative_mode, 0666, attr_get_z_mode, attr_set_z_mode),
+
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s: unable to create interface\n", __func__);
+	return -1;
+}
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static int lis3mdl_mag_get_data(struct lis3mdl_dev *dev, int *xyz)
+{
+	int err;
+	u8 mag_data[6];
+
+	err = dev->tf->read(dev->dev, REG_MAG_DATA_ADDR, 6, mag_data);
+	if (err < 0)
+		return err;
+
+	xyz[0] = ((s32)((s16)((mag_data[1] << 8) | (mag_data[0]))));
+	xyz[1] = ((s32)((s16)((mag_data[3] << 8) | (mag_data[2]))));
+	xyz[2] = ((s32)((s16)((mag_data[5] << 8) | (mag_data[4]))));
+
+	xyz[0] *= dev->sensitivity_mag;
+	xyz[1] *= dev->sensitivity_mag;
+	xyz[2] *= dev->sensitivity_mag;
+
+#ifdef LIS3MDL_DEBUG
+	dev_info(dev->dev, "x=%d\ty=%d\tz=%d\n",  xyz[0],  xyz[1],  xyz[2]);
+#endif
+
+	return err;
+}
+
+static void lis3mdl_mag_report_values(struct lis3mdl_dev *dev, int *xyz)
+{
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    xyz[0]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    xyz[1]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_Z,
+		    xyz[2]);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    dev->timestamp >> 32);
+	input_event(dev->input_dev_mag, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    dev->timestamp & 0xffffffff);
+	input_sync(dev->input_dev_mag);
+}
+
+int lis3mdl_mag_input_init(struct lis3mdl_dev *dev)
+{
+	int err;
+
+	dev->input_dev_mag = input_allocate_device();
+	if (!dev->input_dev_mag) {
+		dev_err(dev->dev, "input device allocation failed\n");
+
+		return -ENOMEM;
+	}
+
+	dev->input_dev_mag->name = LIS3MDL_DEV_NAME;
+	dev->input_dev_mag->id.bustype = dev->bus_type;
+	dev->input_dev_mag->dev.parent = dev->dev;
+
+	input_set_drvdata(dev->input_dev_mag, dev);
+
+	__set_bit(INPUT_EVENT_TYPE, dev->input_dev_mag->evbit);
+	__set_bit(INPUT_EVENT_TIME_MSB, dev->input_dev_mag->mscbit);
+	__set_bit(INPUT_EVENT_TIME_LSB, dev->input_dev_mag->mscbit);
+	__set_bit(INPUT_EVENT_X, dev->input_dev_mag->mscbit);
+	__set_bit(INPUT_EVENT_Y, dev->input_dev_mag->mscbit);
+	__set_bit(INPUT_EVENT_Z, dev->input_dev_mag->mscbit);
+
+	err = input_register_device(dev->input_dev_mag);
+	if (err) {
+		dev_err(dev->dev,
+			"unable to register magnetometer input device %s\n",
+			dev->input_dev_mag->name);
+		input_free_device(dev->input_dev_mag);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lis3mdl_input_cleanup(struct lis3mdl_dev *dev)
+{
+	input_unregister_device(dev->input_dev_mag);
+	input_free_device(dev->input_dev_mag);
+}
+
+static void poll_function_work_mag(struct work_struct *input_work_mag)
+{
+	struct lis3mdl_dev *dev;
+
+	dev = container_of((struct work_struct *)input_work_mag,
+			    struct lis3mdl_dev, input_work_mag);
+
+	hrtimer_start(&dev->hr_timer_mag, dev->ktime, HRTIMER_MODE_REL);
+
+	mutex_lock(&dev->lock);
+
+	if (atomic_read(&dev->enabled_mag)) {
+		int xyz[3] = {};
+
+		if (lis3mdl_mag_get_data(dev, xyz) < 0)
+			dev_err(dev->dev, "get_magnetometer_data failed\n");
+		else
+			lis3mdl_mag_report_values(dev, xyz);
+	}
+
+	mutex_unlock(&dev->lock);
+}
+
+static enum hrtimer_restart poll_function_read_mag(struct hrtimer *timer)
+{
+	struct lis3mdl_dev *dev;
+
+	dev = container_of((struct hrtimer *)timer,
+			    struct lis3mdl_dev, hr_timer_mag);
+
+	dev->timestamp = lis3mdl_get_time_ns();
+	queue_work(lis3mdl_workqueue, &dev->input_work_mag);
+
+	return HRTIMER_NORESTART;
+}
+
+#ifdef CONFIG_OF
+static u32 lis3mdl_parse_dt(struct lis3mdl_dev *dev, struct device *device)
+{
+	u32 val;
+	struct device_node *np;
+
+	np = device->of_node;
+	if (!np)
+		return -EINVAL;
+
+	if (!of_property_read_u32(np, "poll-interval", &val))
+		dev->poll_interval = val;
+	else
+		dev->poll_interval = 10;
+
+	if (!of_property_read_u32(np, "fs-range", &val))
+		dev->fs_range = val;
+	else
+		dev->fs_range = LIS3MDL_MAG_FS_4G;
+
+	return 0;
+}
+#endif
+
+int lis3mdl_mag_probe(struct lis3mdl_dev *dev)
+{
+	int err;
+
+	if (lis3mdl_workqueue == 0)
+		lis3mdl_workqueue = create_workqueue("lis3mdl_workqueue");
+
+	hrtimer_init(&dev->hr_timer_mag, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	dev->hr_timer_mag.function = &poll_function_read_mag;
+
+	mutex_lock(&dev->lock);
+
+#ifdef CONFIG_OF
+	lis3mdl_parse_dt(dev, dev->dev);
+#endif
+
+	err = lis3mdl_hw_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "hw init failed: %d\n", err);
+		goto err_unlock;
+	}
+
+	err = lis3mdl_mag_device_power_on(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "power on failed: %d\n", err);
+		goto err_unlock;
+	}
+
+	err = lis3mdl_mag_update_fs_range(dev, dev->fs_range);
+	if (err < 0) {
+		dev_err(dev->dev, "update_fs_range failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3mdl_mag_update_odr(dev, dev->poll_interval);
+	if (err < 0) {
+		dev_err(dev->dev, "update_odr failed\n");
+		goto  err_power_off;
+	}
+
+	err = lis3mdl_mag_input_init(dev);
+	if (err < 0) {
+		dev_err(dev->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(dev->dev);
+	if (err < 0) {
+		dev_err(dev->dev, "sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lis3mdl_mag_device_power_off(dev);
+
+	INIT_WORK(&dev->input_work_mag, poll_function_work_mag);
+
+	mutex_unlock(&dev->lock);
+
+	return 0;
+
+err_input_cleanup:
+	lis3mdl_input_cleanup(dev);
+err_power_off:
+	lis3mdl_mag_device_power_off(dev);
+err_unlock:
+	mutex_unlock(&dev->lock);
+	if (lis3mdl_workqueue) {
+		flush_workqueue(lis3mdl_workqueue);
+		destroy_workqueue(lis3mdl_workqueue);
+	}
+
+	return err;
+}
+EXPORT_SYMBOL(lis3mdl_mag_probe);
+
+int lis3mdl_mag_remove(struct lis3mdl_dev *dev)
+{
+	lis3mdl_mag_disable(dev);
+	lis3mdl_mag_input_cleanup(dev);
+
+	remove_sysfs_interfaces(dev->dev);
+
+	if (lis3mdl_workqueue) {
+		flush_workqueue(lis3mdl_workqueue);
+		destroy_workqueue(lis3mdl_workqueue);
+		lis3mdl_workqueue = NULL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(lis3mdl_mag_remove);
+
+MODULE_DESCRIPTION("lis3mdl magnetometer driver");
+MODULE_AUTHOR("Matteo Dameno");
+MODULE_AUTHOR("Denis Ciocca");
+MODULE_AUTHOR("Lorenzo Bianconi");
+MODULE_AUTHOR("STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_spi.c b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_spi.c
--- a/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis3mdl/lis3mdl_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,201 @@
+/*
+ * STMicroelectronics lis3mdl_spi.c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/input.h>
+
+#include "lis3mdl.h"
+
+#define SENSORS_SPI_READ	0x80
+#define SPI_AUTO_INCREMENT	0x40
+
+/* XXX: caller must hold dev->lock */
+static int lis3mdl_spi_read(struct device *device, u8 addr, int len, u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lis3mdl_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = dev->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = dev->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(spi, &msg);
+	if (err)
+		return err;
+
+	memcpy(data, dev->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+/* XXX: caller must hold dev->lock */
+static int lis3mdl_spi_write(struct device *device, u8 addr, int len, u8 *data)
+{
+	struct spi_message msg;
+	struct spi_device *spi = to_spi_device(device);
+	struct lis3mdl_dev *dev = spi_get_drvdata(spi);
+
+	struct spi_transfer xfers = {
+		.tx_buf = dev->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LIS3MDL_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	if (len > 1)
+		addr |= SPI_AUTO_INCREMENT;
+
+	dev->tb.tx_buf[0] = addr;
+
+	memcpy(&dev->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	return spi_sync(spi, &msg);
+}
+
+static const struct lis3mdl_transfer_function lis3mdl_spi_tf = {
+	.write = lis3mdl_spi_write,
+	.read = lis3mdl_spi_read,
+};
+
+#ifdef CONFIG_PM
+static int lis3mdl_spi_suspend(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lis3mdl_dev *dev = spi_get_drvdata(spi);
+
+	return lis3mdl_mag_disable(dev);
+}
+
+static int lis3mdl_spi_resume(struct device *device)
+{
+	struct spi_device *spi = to_spi_device(device);
+	struct lis3mdl_dev *dev = spi_get_drvdata(spi);
+
+	return lis3mdl_mag_enable(dev);
+}
+
+static const struct dev_pm_ops lis3mdl_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lis3mdl_spi_suspend,
+				lis3mdl_spi_resume)
+};
+#endif /* CONFIG_PM */
+
+static int lis3mdl_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lis3mdl_dev *dev;
+
+#ifdef LIS3MDL_DEBUG
+	dev_info(&spi->dev, "probe start.\n");
+#endif
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->dev = &spi->dev;
+	dev->name = spi->modalias;
+	dev->bus_type = BUS_SPI;
+	dev->tf = &lis3mdl_spi_tf;
+	spi_set_drvdata(spi, dev);
+
+	mutex_init(&dev->lock);
+
+	err = lis3mdl_mag_probe(dev);
+	if (err < 0) {
+		kfree(dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static int lis3mdl_spi_remove(struct spi_device *spi)
+{
+	struct lis3mdl_dev *dev = spi_get_drvdata(spi);
+
+#ifdef LIS3MDL_DEBUG
+	dev_info(&spi->dev, "driver removing\n");
+#endif
+
+	lis3mdl_mag_remove(dev);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct spi_device_id lis3mdl_spi_ids[] = {
+	{ "lis3mdl", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lis3mdl_spi_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lis3mdl_spi_id_table[] = {
+	{ .compatible = "st,lis3mdl", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lis3mdl_spi_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver lis3mdl_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "lis3mdl_spi",
+#ifdef CONFIG_PM
+		.pm = &lis3mdl_spi_pm_ops,
+#endif /* CONFIG_PM */
+#ifdef CONFIG_OF
+		.of_match_table = lis3mdl_spi_id_table,
+#endif /* CONFIG_OF */
+	},
+	.probe    = lis3mdl_spi_probe,
+	.remove   = lis3mdl_spi_remove,
+	.id_table = lis3mdl_spi_ids,
+};
+
+module_spi_driver(lis3mdl_spi_driver);
+
+MODULE_DESCRIPTION("lis3mdl i2c driver");
+MODULE_AUTHOR("Lorenzo Bianconi <lorenzo.bianconi@st.com>");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/magnetometer/lis3mdl/Makefile b/drivers/input/misc/st/magnetometer/lis3mdl/Makefile
--- a/drivers/input/misc/st/magnetometer/lis3mdl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/lis3mdl/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,12 @@
+#
+# Makefile for the input misc lis3mdl driver.
+#
+
+# Each configuration option enables a list of files.
+
+lis3mdl-y += lis3mdl_mag.o
+obj-$(CONFIG_INPUT_LIS3MDL) += lis3mdl.o
+obj-$(CONFIG_INPUT_LIS3MDL_I2C) += lis3mdl_i2c.o
+obj-$(CONFIG_INPUT_LIS3MDL_SPI) += lis3mdl_spi.o
+
+# ccflags-y += -DLIS3MDL_DEBUG
diff -uNr a/drivers/input/misc/st/magnetometer/Makefile b/drivers/input/misc/st/magnetometer/Makefile
--- a/drivers/input/misc/st/magnetometer/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/magnetometer/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,6 @@
+#
+# Makefile for the input misc STM magnetometer drivers.
+#
+
+obj-$(CONFIG_INPUT_LIS3MDL) += lis3mdl/
+obj-$(CONFIG_INPUT_LIS2MDL) += lis2mdl/
diff -uNr a/drivers/input/misc/st/Makefile b/drivers/input/misc/st/Makefile
--- a/drivers/input/misc/st/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/Makefile	2017-07-06 19:48:50.142213000 +0200
@@ -0,0 +1,8 @@
+obj-$(CONFIG_INPUT_ECOMPASS) += ecompass/
+obj-$(CONFIG_INPUT_IMU) += imu/
+obj-$(CONFIG_INPUT_ACC) += acc/
+obj-$(CONFIG_INPUT_HUMIDITY) += humidity/
+obj-$(CONFIG_INPUT_GYRO) += gyro/
+obj-$(CONFIG_INPUT_MAGN) += magnetometer/
+obj-$(CONFIG_INPUT_PRESSURE) += pressure/
+obj-$(CONFIG_INPUT_UV) += uv/
diff -uNr a/drivers/input/misc/st/pressure/Kconfig b/drivers/input/misc/st/pressure/Kconfig
--- a/drivers/input/misc/st/pressure/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,9 @@
+menuconfig INPUT_PRESSURE
+	tristate "Pressure"
+
+if INPUT_PRESSURE
+
+source "drivers/input/misc/st/pressure/lps22hb/Kconfig"
+source "drivers/input/misc/st/pressure/lps25h/Kconfig"
+
+endif # INPUT_PRESSURE
diff -uNr a/drivers/input/misc/st/pressure/lps22hb/Kconfig b/drivers/input/misc/st/pressure/lps22hb/Kconfig
--- a/drivers/input/misc/st/pressure/lps22hb/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps22hb/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,22 @@
+
+config INPUT_LPS22HB
+	tristate "STMicroelectronics LPS22HB sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LPS22HB_I2C if (I2C)
+	select INPUT_LPS22HB_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LPS22HB sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lps22hb.
+
+config INPUT_LPS22HB_I2C
+	tristate
+	depends on INPUT_LPS22HB
+	depends on I2C
+
+config INPUT_LPS22HB_SPI
+	tristate
+	depends on INPUT_LPS22HB
+	depends on SPI
+
diff -uNr a/drivers/input/misc/st/pressure/lps22hb/lps22hb_core.c b/drivers/input/misc/st/pressure/lps22hb/lps22hb_core.c
--- a/drivers/input/misc/st/pressure/lps22hb/lps22hb_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps22hb/lps22hb_core.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,1791 @@
+/*
+* STMicroelectronics lps22hb driver
+*
+* Copyright 2016 STMicroelectronics Inc.
+*
+* Authors: HESA BU - Application Team
+*        : Adalberto Muhuho (adalberto.muhuho@st.com)
+*        : Mario Tesi (mario.tesi@st.com)
+* 
+* The structure of this driver is based on reference code previously
+* delivered by Lorenzo Sarchi
+*
+* Version: 0.0.3
+* Date: 2016/May/16
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+********************************************************************************
+*
+* Read pressures and temperatures output can be converted in units of
+* measurement by dividing them respectively for SENSITIVITY_P and SENSITIVITY_T.
+* Temperature values must then be added by the constant float TEMPERATURE_OFFSET
+* expressed as Celsius degrees.
+*
+* Obtained values are then expessed as
+* mbar (=0.1 kPa) and Celsius degrees.
+*
+*/
+/******************************************************************************
+ Revision history:
+
+ Revision 0.0.1 2015/Dec/11: 1st beta version
+
+ Revision 0.0.2 2016/Apr/19:
+	Revision 0.0.2 downgrades previous License to GPLv2
+
+ Revision 0.0.2 2016/May/16:
+	Added SPI support
+******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/hrtimer.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/pm.h>
+
+#include "lps22hb.h"
+
+#define	PR_ABS_MAX	8388607		/* 24 bit 2'compl */
+#define	PR_ABS_MIN	-8388608
+#ifdef SHRT_MAX
+#define	TEMP_MAX	SHRT_MAX
+#define TEMP_MIN	SHRT_MIN
+#else
+#define	TEMP_MAX	SHORT_MAX
+#define TEMP_MIN	SHORT_MIN
+#endif
+
+/* Device ID */
+#define	WHOAMI_LPS22_PRS	0xB1
+
+/*	REGISTERS */
+#define	INT_CFG_REG		0x0B	/* interrupt config reg */
+#define	THS_P_L			0x0C	/* pressure threshold */
+#define	THS_P_H			0x0D	/* pressure threshold */
+#define	WHO_AM_I		0x0F	/* Device ID register */
+#define	CTRL_REG1		0x10	/* Control register 1 */
+#define	CTRL_REG2		0x11	/* Control register 2 */
+#define	CTRL_REG3		0x12	/* Control register 3 */
+#define	FIFO_CTRL		0x14	/* Fifo control register */
+#define	REF_P_XL		0x15	/* pressure reference */
+#define	REF_P_L			0x16	/* pressure reference */
+#define	REF_P_H			0x17	/* pressure reference */
+#define	RPDS_TRM_L		0x18	/* NEW */
+#define	RPDS_TRM_H		0x19	/* NEW */
+#define	RESOL_CONF		0x1A	/* Resolution configuration */
+#define	CTRL_REG4		0x23	/* Control register 4 */
+#define	INT_SRC_REG		0x25	/* interrupt source reg	*/
+#define	FIFO_STATUS		0x26	/* Fifo Status reg */
+#define	STATUS_REG		0X27	/* Status reg */
+#define	PRESS_OUT_XL		0x28	/* press output (3 regs) */
+#define	TEMP_OUT_L		0x2B	/* temper output (2 regs) */
+
+/*	REGISTERS ALIASES	*/
+#define	P_REF_INDATA_REG	REF_P_XL
+#define	P_THS_INDATA_REG	THS_P_L
+#define	P_OUTDATA_REG		PRESS_OUT_XL
+#define	T_OUTDATA_REG		TEMP_OUT_L
+#define	OUTDATA_REG		PRESS_OUT_XL
+
+/* Bitmasks */
+#define	ODR_MASK		0x70
+#define	DIFF_MASK		0x08
+#define	BDU_MASK		0x02
+#define	RESET_AZ_MASK		0x10
+#define	LC_EN_MASK   		0x01
+#define EN_LPFP_MASK    	0x08
+#define LPF_CFG_MASK    	0x04
+#define RESET_ARP_MASK  	0x40
+#define DIFF_EN_MASK    	0x08
+#define PLE_MASK		0x02
+#define PHE_MASK		0x01
+#define FIFO_EN_MASK    	0x40
+#define FIFO_MODE_MASK		0xE0
+#define FIFO_SAMPLE_MASK	0x1F
+#define	AUTOZ_MASK		0x20
+#define	AUTOZ_OFF		0x00
+#define	AUTORIFP_MASK		0x80
+#define STOP_ON_FTH_MASK	0x20
+#define SW_RESET_MASK		0x04
+
+/* Barometer and Termometer output data rate ODR */
+#define	ODR_ONESH	0x00	/* one shot both */
+#define	ODR_1_1		0x10	/*  1  Hz baro,  1  Hz term ODR	*/
+#define	ODR_10_10	0x20	/* 10  Hz baro, 10  Hz term ODR	*/
+#define	ODR_25_25	0x30	/* 25  Hz baro, 25  Hz term ODR	*/
+#define	ODR_50_50	0x40	/* 50  Hz baro, 50  Hz term ODR	*/
+#define	ODR_75_75	0x50	/* 75  Hz baro, 75  Hz term ODR	*/
+
+/* Additional operating modes defines */
+#define	AUTOZ_ENABLE	1
+#define	AUTOZ_DISABLE	0
+#define RES_MAX 	0
+#define	FUZZ		0
+#define	FLAT		0
+
+/* RESUME STATE INDICES */
+#define	RES_REF_P_XL	0
+#define	RES_REF_P_L	1
+#define	RES_REF_P_H	2
+#define	RES_REFT_L	3
+#define	RES_REFT_H	4
+#define	RES_RESOL_CONF	5
+#define	RES_CTRL_REG1	6
+#define	RES_CTRL_REG2	7
+#define	RES_CTRL_REG3	8
+#define	RES_CTRL_REG4	9
+#define	RES_INT_CFG_REG	10
+#define	RES_FIFO_CTRL	11
+#define	RES_THS_P_L	12
+#define	RES_THS_P_H	13
+#define	RES_RPSD_TRIM_L	14
+#define	RES_RPSD_TRIM_H	15
+
+/* end RESUME STATE INDICES */
+
+u8 decimator_count = 0;
+u8 logout_decimation = 1;
+u8 hex_measr_logging = 0;
+
+static const struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lps22_prs_odr_table[] = {
+	{ 13, ODR_75_75 },
+	{ 20, ODR_50_50 },
+	{ 40, ODR_25_25 },
+	{ 100, ODR_10_10 },
+	{ 1000, ODR_1_1 },
+};
+
+struct outputdata {
+	s32 press;
+	s16 temperature;
+};
+
+static const struct lps22_prs_platform_data default_lps22_pdata = {
+	.poll_interval = 1000,
+	.min_interval = LPS22_PRS_MIN_POLL_PERIOD_MS,
+};
+
+u8 snsdata[3];
+
+static int lps22_prs_hw_init(struct lps22_prs_data *prs)
+{
+	int err;
+	u8 buf[6];
+
+	pr_info("%s: hw init start\n", LPS22_PRS_DEV_NAME);
+	dev_dbg(prs->dev,"%s: hw init start\n", LPS22_PRS_DEV_NAME);
+
+	buf[0] = prs->resume_state[RES_REF_P_XL];
+	buf[1] = prs->resume_state[RES_REF_P_L];
+	buf[2] = prs->resume_state[RES_REF_P_H];
+
+	err = prs->tf->write(prs, P_REF_INDATA_REG, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+		
+	printk("hw_init: REF_P pass \r\n");
+	buf[0] = prs->resume_state[RES_RESOL_CONF];
+	err = prs->tf->write(prs, RESOL_CONF, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	printk("hw_init: RESOL_CONF pass \r\n");
+	buf[0] = prs->resume_state[RES_THS_P_L];
+	buf[1] = prs->resume_state[RES_THS_P_H];
+	err = prs->tf->write(prs, P_THS_INDATA_REG, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+#ifdef DEBUG
+	printk("hw_init: P_THS_INDATA_REG pass \r\n");
+#endif
+
+ 	buf[0] = (prs->resume_state[RES_CTRL_REG2]) | 0x10;
+	buf[1] = prs->resume_state[RES_CTRL_REG3];
+
+	err = prs->tf->write(prs, CTRL_REG2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+#ifdef DEBUG
+	printk("hw_init: P_CTRL_REGS23 pass \r\n");
+#endif
+
+	buf[0] = prs->resume_state[RES_INT_CFG_REG];
+	err = prs->tf->write(prs, INT_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+#ifdef DEBUG
+	printk("hw_init: INT_CFG_REG pass \r\n");
+#endif
+
+	buf[0] = prs->resume_state[RES_CTRL_REG1];
+	err = prs->tf->write(prs, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+#ifdef DEBUG
+	printk("hw_init: CTRL_REG1 pass \r\n");
+#endif
+
+	prs->hw_initialized = 1;
+
+	pr_info("%s: hw init done\n", LPS22_PRS_DEV_NAME);
+	dev_dbg(prs->dev, "%s: hw init done\n", LPS22_PRS_DEV_NAME);
+
+	return 0;
+
+err_resume_state:
+	prs->hw_initialized = 0;
+	dev_err(prs->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+		buf[1], err);
+	return err;
+}
+
+static void lps22_prs_device_power_off(struct lps22_prs_data *prs)
+{
+	int err;
+	u8 buf[5];
+
+	// Power Down
+	buf[0] = 0x00;
+	err = prs->tf->write(prs, CTRL_REG1, 1, buf);
+	if (err < 0)
+		dev_err(prs->dev, "soft power off failed: %d\n", err);
+
+	// Sofware Reset
+	buf[0] = SW_RESET_MASK;
+	err = prs->tf->write(prs, CTRL_REG2, 1, buf);
+	if (err < 0)
+		dev_err(prs->dev, "soft power off failed: %d\n", err);
+
+	// Give time to exit reset on the device (1us target, 2us upper bound)
+	udelay(2);
+
+	// Restart from consistent status
+	err = prs->tf->read(prs, INT_SRC_REG, 1, buf);
+	if (err < 0)
+		dev_err(prs->dev, "status reset 1 failed: %d\n", err);
+
+	// Dummy measurement read for status_reg reset and update blocking due to BDU
+	err = prs->tf->read(prs, P_REF_INDATA_REG, 5, buf);
+	if (err < 0)
+		dev_err(prs->dev, "status reset 2 failed: %d\n", err);
+
+	if (prs->pdata->power_off)
+		prs->pdata->power_off();
+
+	prs->hw_initialized = 0;
+}
+
+int lps22_prs_update_odr(struct lps22_prs_data *prs, int poll_period_ms)
+{
+	int err = -1;
+	int i;
+	u8 buf[2];
+	u8 init_val, updated_val;
+	u8 curr_val, new_val;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (longest period) backward (shortest
+	 * period), to support the poll_interval requested by the system.
+	 * It must be the longest period shorter then the set poll period.*/
+	for (i = ARRAY_SIZE(lps22_prs_odr_table) - 1; i >= 0; i--) {
+#ifdef DEBUG
+		printk("poll period tab index %d \r\n",i);
+		printk("poll period tab cutoff %d \r\n",lps22_prs_odr_table[i].cutoff_ms);
+		printk("poll period tab mask %02x \r\n",lps22_prs_odr_table[i].mask);
+#endif
+		if ((lps22_prs_odr_table[i].cutoff_ms <= poll_period_ms) ||
+		    (i == 0))
+			break;
+	}
+
+#ifdef DEBUG
+	printk("\r\n");
+	printk("new poll period setting: %d \r\n",poll_period_ms);
+#endif
+
+	new_val = lps22_prs_odr_table[i].mask;
+
+#ifdef DEBUG
+	printk("new ODR bits: %02x \r\n",new_val);
+#endif
+
+	/* before to change the ODR it is mandatory to power down
+	the device */
+	err = prs->tf->read(prs, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto error;
+	/* work on all but ENABLE bits */
+	/* power down */
+	init_val = buf[0];
+	prs->resume_state[RES_CTRL_REG1] = init_val ;
+	curr_val = init_val & 0x0F;
+
+	buf[0] = curr_val;
+	err = prs->tf->write(prs, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto error;
+
+	/* set new ODR*/
+	buf[0] = CTRL_REG1;
+	updated_val = ((ODR_MASK & new_val) | ((~ODR_MASK) & curr_val) | BDU_MASK);
+
+	err = prs->tf->write(prs, CTRL_REG1, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	prs->resume_state[RES_CTRL_REG1] = updated_val;
+
+	prs->delta_ts = ktime_set(0, 1000000 * lps22_prs_odr_table[i].cutoff_ms);
+
+	return err;
+
+error:
+	dev_err(prs->dev, "update odr failed 0x%02x,0x%02x: %d\n",
+		buf[0], buf[1], err);
+
+	return err;
+}
+
+static int lps22_prs_device_power_on(struct lps22_prs_data *prs)
+{
+	int err = -1;
+
+	if (prs->pdata->power_on) {
+		err = prs->pdata->power_on();
+		if (err < 0) {
+			dev_err(prs->dev,
+				"power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	if (!prs->hw_initialized) {
+		err = lps22_prs_hw_init(prs);
+		lps22_prs_update_odr(prs, prs->pdata->poll_interval);
+		if (prs->hw_working == 1 && err < 0) {
+			lps22_prs_device_power_off(prs);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int lps22_prs_set_press_reference(struct lps22_prs_data *prs,
+					 s32 new_reference)
+{
+	int err;
+	u8 bit_valuesXL,bit_valuesL, bit_valuesH;
+	u8 buf[4];
+
+	bit_valuesXL = (u8) (new_reference & 0x0000FF);
+	bit_valuesL = (u8)((new_reference & 0x00FF00) >> 8);
+	bit_valuesH = (u8)((new_reference & 0xFF0000) >> 16);
+
+	buf[0] = bit_valuesXL;
+	buf[1] = bit_valuesL;
+	buf[2] = bit_valuesH;
+
+	err = prs->tf->write(prs, P_REF_INDATA_REG, 3, buf);
+	if (err < 0)
+		return err;
+
+	prs->resume_state[RES_REF_P_XL] = bit_valuesXL;
+	prs->resume_state[RES_REF_P_L] = bit_valuesL;
+	prs->resume_state[RES_REF_P_H] = bit_valuesH;
+
+#ifdef DEBUG
+	printk("LPS22HB new reference pressure setting : %d \r\n",
+	       (((u32)bit_valuesH) << 16) +
+	       (((u32)bit_valuesL) << 8) + ((u32)(bit_valuesXL)));
+#endif
+
+	return err;
+}
+
+static int lps22_prs_get_press_reference(struct lps22_prs_data *prs,
+					 s32 *buf32)
+{
+	int err;
+	u8 bit_valuesXL, bit_valuesL, bit_valuesH;
+	u8 buf[3];
+	u16 temp = 0;
+
+	err = prs->tf->read(prs, P_REF_INDATA_REG, 3, buf);
+	if (err < 0)
+		return err;
+	bit_valuesXL = buf[0];
+	bit_valuesL = buf[1];
+	bit_valuesH = buf[2];
+
+
+	temp = (bit_valuesH << 8 ) | bit_valuesL;
+	*buf32 = (s32)((((s16)temp) << 8) | bit_valuesXL);
+#ifdef DEBUG
+	dev_dbg(prs->dev,"%s val: %+d", LPS22_PRS_DEV_NAME, *buf32 );
+#endif
+	return err;
+}
+
+static int lps22_prs_get_presstemp_data(struct lps22_prs_data *prs,
+					struct outputdata *out)
+{
+	int err;
+	/* Data bytes from hardware PRESS_OUT_XL,PRESS_OUT_L,PRESS_OUT_H,
+	   TEMP_OUT_L, TEMP_OUT_H */
+	u8 prs_data[5];
+	s32 pressure;
+	s16 temperature;
+
+	err = prs->tf->read(prs, OUTDATA_REG, 5, prs_data);
+	if (err < 0)
+		return err;
+
+#ifdef DEBUG
+    if (hex_measr_logging)
+		printk("temp out tH = 0x%02x, tL = 0x%02x,"
+			"press_out: pH = 0x%02x, pL = 0x%02x, pXL= 0x%02x\n",
+			prs_data[4], prs_data[3], prs_data[2], prs_data[1],
+			prs_data[0]);
+#endif
+
+	pressure = (s32)((((s8)prs_data[2]) << 16) | (prs_data[1] << 8) |
+			 prs_data[0]);
+	temperature = (s16)((((s8)prs_data[4]) << 8) | prs_data[3]);
+
+#ifdef DEBUG
+	if ((decimator_count%logout_decimation) == 0)
+		printk("%d \n", (int32_t)pressure);
+	decimator_count++;
+#endif
+
+	out->press = pressure;
+	out->temperature = temperature;
+
+	return err;
+}
+
+static void lps22_prs_report_values(struct lps22_prs_data *prs,
+				    struct outputdata *out)
+{
+	input_event(prs->input_dev_pres, INPUT_EVENT_TYPE, INPUT_EVENT_X, out->press);
+	input_event(prs->input_dev_pres, INPUT_EVENT_TYPE, INPUT_EVENT_Y, out->temperature);
+	input_sync(prs->input_dev_pres);
+}
+
+static int lps22_prs_enable(struct lps22_prs_data *prs)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&prs->enabled, 0, 1)) {
+		err = lps22_prs_device_power_on(prs);
+		if (err < 0) {
+			atomic_set(&prs->enabled, 0);
+			return err;
+		}
+
+		hrtimer_start(&prs->hr_timer, prs->delta_ts, HRTIMER_MODE_REL);
+	}
+
+	return 0;
+}
+
+static int lps22_prs_disable(struct lps22_prs_data *prs)
+{
+	if (atomic_cmpxchg(&prs->enabled, 1, 0)) {
+		hrtimer_cancel(&prs->hr_timer);
+		lps22_prs_device_power_off(prs);
+	}
+
+	return 0;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+
+	mutex_lock(&prs->lock);
+	val = prs->pdata->poll_interval;
+	mutex_unlock(&prs->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+	interval_ms = max((unsigned int)interval_ms,prs->pdata->min_interval);
+
+	mutex_lock(&prs->lock);
+	prs->pdata->poll_interval = interval_ms;
+	lps22_prs_update_odr(prs, interval_ms);
+	mutex_unlock(&prs->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	int val = atomic_read(&prs->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+
+#ifdef DEBUG
+	pr_info("\n%s Value= \"%s\" \n", LPS22_PRS_DEV_NAME, buf);
+#endif
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+#ifdef DEBUG
+	pr_info("\n%s Valid val: %lu ", LPS22_PRS_DEV_NAME, val);
+#endif
+
+	if (val)
+		lps22_prs_enable(prs);
+	else
+		lps22_prs_disable(prs);
+
+	return size;
+}
+
+static ssize_t attr_get_press_ref(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	s32 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = lps22_prs_get_press_reference(prs, &val);
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_press_ref(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	int err = -1;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	long val = 0;
+
+	if (kstrtol(buf, 10, &val))
+		return -EINVAL;
+
+	if (val < PR_ABS_MIN || val > PR_ABS_MAX)
+		return -EINVAL;
+
+	mutex_lock(&prs->lock);
+	err = lps22_prs_set_press_reference(prs, val);
+	mutex_unlock(&prs->lock);
+
+	if (err < 0)
+		return err;
+	return size;
+}
+
+static ssize_t attr_set_autozero(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val, updated_val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, INT_CFG_REG, 1, &init_val);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	prs->resume_state[RES_INT_CFG_REG] = init_val;
+	updated_val = ((AUTOZ_MASK & (((u8)val) << 5)) |
+		       ((~AUTOZ_MASK) & init_val));
+	err = prs->tf->write(prs, INT_CFG_REG, 1, &updated_val);
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+exit :
+	return size;
+}
+
+static ssize_t attr_reset_autozero(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, INT_CFG_REG, 1, snsdata);
+	if (err < 0) {
+        mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_INT_CFG_REG] = init_val;
+
+	updated_val = ((RESET_AZ_MASK & (((u8)val)<<4)) |
+		       ((~RESET_AZ_MASK) & init_val));
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, INT_CFG_REG, 1, snsdata);
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+exit:
+	return size;
+}
+
+static ssize_t attr_set_autorifp(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val, updated_val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, INT_CFG_REG, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_INT_CFG_REG] = init_val;
+	updated_val = ((AUTORIFP_MASK & (((u8)val) << 7)) |
+		       ((~AUTORIFP_MASK) & init_val));
+	err = prs->tf->write(prs, INT_CFG_REG, 1, &updated_val);
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+exit :
+	return size;
+}
+
+static ssize_t attr_reset_autorifp(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+
+	err = prs->tf->read(prs, INT_CFG_REG, 1, snsdata);
+	if (err < 0) {
+        mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_INT_CFG_REG] = init_val;
+
+	updated_val = ((RESET_ARP_MASK & (((u8)val) << 6)) |
+		       ((~RESET_ARP_MASK) & init_val));
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, INT_CFG_REG, 1, snsdata);
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+exit:
+	return size;
+}
+
+static ssize_t attr_set_pthreshold(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&prs->lock);
+
+	snsdata[0] = ((u16)val) & 0xFF;
+	snsdata[1] = (((u16)val) >> 8) & 0xFF;
+	err = prs->tf->write(prs, THS_P_L, 2, snsdata);
+
+	if (err >= 0) {
+		prs->resume_state[RES_THS_P_L] = snsdata[0];
+		prs->resume_state[RES_THS_P_H] = snsdata[1];
+	}
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+#ifdef DEBUG
+	printk("LPS22HB new pressure threshold setting : %d \r\n",
+	       (((u16)snsdata[1]) << 8) + (u16)(snsdata[0]));
+#endif
+
+	return size;
+}
+
+static ssize_t attr_get_pthreshold(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u16 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, THS_P_L, 2, snsdata);
+	val = ((u16)snsdata[1] << 8) + snsdata[0];
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_pthreshold_enable(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+	u8 mask = ((u8)(DIFF_EN_MASK | PLE_MASK | PHE_MASK));
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, INT_CFG_REG, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_INT_CFG_REG] = init_val;
+
+	updated_val = ((~mask) & init_val);
+	if (val == 1)
+		updated_val |= mask;
+
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, INT_CFG_REG, 1, snsdata);
+	if (err >= 0)
+		prs->resume_state[RES_INT_CFG_REG] = updated_val;
+
+	mutex_unlock(&prs->lock);
+	
+	if (err < 0)
+		return err;
+exit:
+	return size;
+}
+
+static ssize_t attr_get_pthreshold_enable(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+	u8 mask = ((u8)(DIFF_EN_MASK | PLE_MASK | PHE_MASK));
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, INT_CFG_REG, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	val = snsdata[0] & mask;
+	mutex_unlock(&prs->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_watermark_enable(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+
+	err = prs->tf->read(prs, CTRL_REG2, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_CTRL_REG2] = init_val;
+
+	updated_val = ((STOP_ON_FTH_MASK & ((u8)val) << 5) |
+		       ((~STOP_ON_FTH_MASK) & init_val));
+
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, CTRL_REG2, 1, snsdata);
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+	else
+		prs->resume_state[RES_CTRL_REG2] = updated_val;
+exit:
+	return size;
+}
+
+static ssize_t attr_get_watermark_enable(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, CTRL_REG2, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	val = ((snsdata[0] & 0x20)>>5);
+	mutex_unlock(&prs->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_lc_mode_enable(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+
+	err = prs->tf->read(prs, RESOL_CONF, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_RESOL_CONF] = init_val;
+	updated_val = ((LC_EN_MASK & ((u8)val)) | ((~LC_EN_MASK) & init_val));
+
+	/* power down the device before going ahead with LC enable update */
+	snsdata[0] = prs->resume_state[RES_CTRL_REG1] & 0x0F;
+	err = prs->tf->write(prs, CTRL_REG1, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+	/* power down transaction end */
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, RESOL_CONF, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	} else
+		prs->resume_state[RES_RESOL_CONF] = updated_val;
+
+	/* power up the device or at least get CTRL_REG1 back to its previous state */
+	snsdata[0] = prs->resume_state[RES_CTRL_REG1] & 0x7F;
+	err = prs->tf->write(prs, CTRL_REG1, 1, snsdata);
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+exit:
+	return size;
+}
+
+static ssize_t attr_get_lc_mode_enable(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, RESOL_CONF, 1, snsdata);
+	val = snsdata[1] & 0x1;
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_lpf_enable(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+	u8 const mask = EN_LPFP_MASK;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	if ((val != 0) & (val != 1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+
+	err = prs->tf->read(prs, CTRL_REG1, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_CTRL_REG1] = init_val;
+
+	updated_val = ((mask & ((u8)val)<<3) | ((~mask) & init_val));
+
+	snsdata[0] = updated_val;
+	err =  prs->tf->write(prs, CTRL_REG1, 1, snsdata);
+
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+	else
+		prs->resume_state[RES_CTRL_REG1] = updated_val;
+exit:
+	return size;
+}
+
+static ssize_t attr_get_lpf_enable(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, CTRL_REG1, 1, snsdata);
+	val = ((snsdata[1] & 0x08) >> 3);
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_set_lpf_cutoff_freq(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+	u8 const mask = LPF_CFG_MASK;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	if ((val!=0) && (val!=1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+
+	err = prs->tf->read(prs, CTRL_REG1, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_CTRL_REG1] = init_val;
+
+	updated_val = (((mask) & (((u8)val)<<2)) | ((~mask) & init_val));
+
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, CTRL_REG1, 1, snsdata);
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+	else
+		prs->resume_state[RES_CTRL_REG1] = updated_val;
+
+exit:
+	return size;
+}
+
+static ssize_t attr_get_lpf_cutoff_freq(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, CTRL_REG1, 1, snsdata);
+	val = ((snsdata[0] & LPF_CFG_MASK) >> 2) & 0x1;
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_get_fifo_status(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, FIFO_STATUS, 1, snsdata);
+	val = snsdata[0];
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_get_status(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, STATUS_REG, 1, snsdata);
+	val = snsdata[0];
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_get_interrupt_source(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int err;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 val = 0;
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, INT_SRC_REG, 1, snsdata);
+	val = snsdata[0];
+	mutex_unlock(&prs->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t attr_set_fifo(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	int err = -1;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+	static u8 init_val,updated_val;
+
+#ifdef DEBUG
+	pr_info("\n%s Value= \"%s\" \n", LPS22_PRS_DEV_NAME, buf);
+#endif
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	if ((val != 0) && (val != 1))
+		goto exit;
+
+#ifdef DEBUG
+	pr_info("\n%s Valid val to put in reg2: %lu \r\n", LPS22_PRS_DEV_NAME, val);
+#endif
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, CTRL_REG2, 1, snsdata);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	init_val = snsdata[0];
+	prs->resume_state[RES_CTRL_REG2] = init_val;
+	updated_val = (((FIFO_EN_MASK) & (((u8)val)<<6)) | ((~FIFO_EN_MASK) & (init_val)));
+
+	snsdata[0] = updated_val;
+	err = prs->tf->write(prs, CTRL_REG2, 1, snsdata);
+
+	mutex_unlock(&prs->lock);
+
+	if (err < 0)
+		return err;
+	else
+		prs->resume_state[RES_CTRL_REG2] = updated_val;
+
+exit:
+	return size;
+}
+
+static ssize_t attr_fifo_mode(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	int err = -1;
+	u8 new_val;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+#ifdef DEBUG
+	pr_info("\n%s Valid val: %lu ", LPS22_PRS_DEV_NAME, val);
+#endif
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+#ifdef DEBUG
+	pr_info("\n%s Valid val: %lu ", LPS22_PRS_DEV_NAME, val);
+#endif
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, FIFO_CTRL, 1, &x);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	new_val = ( ((u8)val << 5) | (x & ~FIFO_MODE_MASK) );
+	err = prs->tf->write(prs, FIFO_CTRL, 1, &new_val);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	} else
+		prs->resume_state[RES_FIFO_CTRL] = new_val;
+
+	mutex_unlock(&prs->lock);
+
+	return size;
+}
+
+static ssize_t attr_set_samples_fifo(struct device *dev, struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int err= -1;
+	u8 new_val;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 x;
+	unsigned long val;
+
+#ifdef DEBUG
+	pr_info("\n%s Valid val: %lu ", LPS22_PRS_DEV_NAME, val);
+#endif
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+#ifdef DEBUG
+	pr_info("\n%s Valid val: %lu ", LPS22_PRS_DEV_NAME, val);
+#endif
+
+	mutex_lock(&prs->lock);
+	err = prs->tf->read(prs, FIFO_CTRL, 1, &x);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	}
+
+	new_val = ((((u8)val) - 1) | (x & FIFO_MODE_MASK));
+
+	err = prs->tf->write(prs, FIFO_CTRL, 1, &new_val);
+	if (err < 0) {
+		mutex_unlock(&prs->lock);
+		return err;
+	} else
+		prs->resume_state[RES_FIFO_CTRL] = new_val;
+
+	mutex_unlock(&prs->lock);
+
+	return size;
+}
+
+#ifdef DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	u8 reg, data;
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&prs->lock);
+	reg = prs->reg_addr;
+	mutex_unlock(&prs->lock);
+	data = (u8)val;
+	rc = prs->tf->write(prs, reg, 1, &data);
+	if (rc < 0)
+		return rc;
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	int rc;
+	u8 reg, data;
+
+	mutex_lock(&prs->lock);
+	reg = prs->reg_addr;
+	mutex_unlock(&prs->lock);
+	rc = prs->tf->read(prs, reg, 1, &data);
+	if (rc < 0)
+		return rc;
+
+	return sprintf(buf, "0x%02x\n", data);
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 16, &val))
+		return -EINVAL;
+	mutex_lock(&prs->lock);
+	prs->reg_addr = val;
+	mutex_unlock(&prs->lock);
+
+	return size;
+}
+
+static ssize_t attr_reg_dump(struct device *dev, struct device_attribute *attr,char *buf)
+{
+	ssize_t ret;
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	int err;
+	u8 data = 0;
+	u8 addr;
+
+	printk("\r\n");
+	mutex_lock(&prs->lock);
+	for(addr = 0x0B; addr <= 0x2C;addr++) {
+		err = prs->tf->read(prs, addr, 1, snsdata);
+		if (err < 0) {
+			printk("Error reading from register %02x \r\n",addr);
+		} else {
+			printk("register addr: %02x value: %02x \r\n",addr,snsdata[0]);
+			if (addr == 0x0F)
+				data = snsdata[0];
+		}
+	}
+
+	mutex_unlock(&prs->lock);
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static ssize_t attr_set_logout_decimation(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t size)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	mutex_lock(&prs->lock);
+	logout_decimation = val;
+	mutex_unlock(&prs->lock);
+
+	return size;
+}
+
+static ssize_t attr_set_hex_measr_log(struct device *dev, struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	struct lps22_prs_data *prs = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	if ((val != 0) && (val!=1))
+		goto exit;
+
+	mutex_lock(&prs->lock);
+	hex_measr_logging = val;
+	mutex_unlock(&prs->lock);
+
+exit:
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(poll_period_ms, 0664, attr_get_polling_rate,attr_set_polling_rate),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(pressure_reference_level, 0664, attr_get_press_ref,attr_set_press_ref),
+	__ATTR(pressure_threshold, 0664, attr_get_pthreshold, attr_set_pthreshold),
+	__ATTR(enable_pthreshold_detection, 0664, attr_get_pthreshold_enable, attr_set_pthreshold_enable),
+	__ATTR(enable_lc_mode, 0664, attr_get_lc_mode_enable, attr_set_lc_mode_enable),
+	__ATTR(enable_lpf, 0664, attr_get_lpf_enable, attr_set_lpf_enable),
+	__ATTR(lpf_cutoff_freq, 0664, attr_get_lpf_cutoff_freq, attr_set_lpf_cutoff_freq),
+	__ATTR(enable_watermark, 0664, attr_get_watermark_enable, attr_set_watermark_enable),
+	__ATTR(enable_autozero, 0220, NULL, attr_set_autozero),
+	__ATTR(reset_autozero, 0220, NULL, attr_reset_autozero),
+	__ATTR(enable_autorifp, 0220, NULL, attr_set_autorifp),
+	__ATTR(reset_autorifp, 0220, NULL, attr_reset_autorifp),
+	__ATTR(fifo_status, 0444, attr_get_fifo_status, NULL),
+	__ATTR(status, 0444, attr_get_status, NULL),
+	__ATTR(int_source, 0444, attr_get_interrupt_source, NULL),
+	__ATTR(enable_fifo, 0220, NULL, attr_set_fifo),
+	__ATTR(num_samples_fifo, 0220, NULL, attr_set_samples_fifo),
+	__ATTR(fifo_mode, 0220, NULL, attr_fifo_mode),
+#ifdef DEBUG
+	__ATTR(reg_value, 0664, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0220, NULL, attr_addr_set),
+	__ATTR(reg_dump, 0444, attr_reg_dump, NULL),
+	__ATTR(dmesg_decimation, 0220, NULL,attr_set_logout_decimation),
+	__ATTR(hex_measr_log, 0220, NULL,attr_set_hex_measr_log),
+#endif
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		ret = device_create_file(dev, attributes + i);
+		if (ret < 0)
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return ret;
+}
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static void lps22_prs_input_work_func(struct work_struct *work)
+{
+	struct lps22_prs_data *prs = container_of((struct work_struct *)work,
+						  struct lps22_prs_data,
+						  input_work);
+	struct outputdata output;
+	int err;
+
+	mutex_lock(&prs->lock);
+	err = lps22_prs_get_presstemp_data(prs, &output);
+	if (err < 0)
+		dev_err(prs->dev, "get_pressure_data failed\n");
+	else
+		lps22_prs_report_values(prs, &output);
+
+	mutex_unlock(&prs->lock);
+
+	hrtimer_start(&prs->hr_timer, prs->delta_ts, HRTIMER_MODE_REL);
+}
+
+static enum hrtimer_restart lps22_prs_poll_function_read(struct hrtimer *timer)
+{
+	struct lps22_prs_data *prs;
+
+	prs = container_of((struct hrtimer *)timer, struct lps22_prs_data,
+			   hr_timer);
+
+	queue_work(prs->workqueue, &prs->input_work);
+
+	return HRTIMER_NORESTART;
+}
+
+#ifdef LPS22_EN_ON_OPEN
+int lps22_prs_input_open(struct input_dev *input)
+{
+	struct lps22_prs_data *prs = input_get_drvdata(input);
+
+	return lps22_prs_enable(prs);
+}
+
+void lps22_prs_input_close(struct input_dev *dev)
+{
+	lps22_prs_disable(input_get_drvdata(dev));
+}
+#endif
+
+static int lps22_prs_validate_pdata(struct lps22_prs_data *prs)
+{
+	/* checks for correctness of minimal polling period */
+	prs->pdata->min_interval = (unsigned int)LPS22_PRS_MIN_POLL_PERIOD_MS;
+	prs->pdata->poll_interval = max(prs->pdata->poll_interval,
+					prs->pdata->min_interval);
+
+	/* Checks polling interval relative to minimum polling interval */
+	if (prs->pdata->poll_interval < prs->pdata->min_interval) {
+		dev_err(prs->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lps22_prs_input_init(struct lps22_prs_data *prs)
+{
+	int err;
+
+	prs->workqueue = create_workqueue(prs->name);
+	if (!prs->workqueue)
+		return -ENOMEM;
+
+	INIT_WORK(&prs->input_work, lps22_prs_input_work_func);
+	hrtimer_init(&prs->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	prs->hr_timer.function = &lps22_prs_poll_function_read;
+
+	prs->input_dev_pres = input_allocate_device();
+	if (!prs->input_dev_pres) {
+		dev_err(prs->dev, "input device allocate failed\n");
+
+		return -ENOMEM;
+	}
+
+#ifdef LPS22_EN_ON_OPEN
+	prs->input_dev_pres->open = lps22_prs_input_open;
+	prs->input_dev_pres->close = lps22_prs_input_close;
+#endif
+	prs->input_dev_pres->name = prs->name;
+	prs->input_dev_pres->id.bustype = prs->bustype;
+	prs->input_dev_pres->dev.parent = prs->dev;
+	input_set_drvdata(prs->input_dev_pres, prs);
+
+	__set_bit(INPUT_EVENT_TYPE, prs->input_dev_pres->evbit);
+	__set_bit(INPUT_EVENT_X, prs->input_dev_pres->mscbit);
+	__set_bit(INPUT_EVENT_Y, prs->input_dev_pres->mscbit);
+
+	err = input_register_device(prs->input_dev_pres);
+	if (err) {
+		dev_err(prs->dev,
+			"unable to register input polled device %s\n",
+			prs->input_dev_pres->name);
+		input_free_device(prs->input_dev_pres);
+
+		return err;
+	}
+
+	return 0;
+}
+
+static void lps22_prs_input_cleanup(struct lps22_prs_data *prs)
+{
+	input_unregister_device(prs->input_dev_pres);
+	input_free_device(prs->input_dev_pres);
+}
+
+int lps22hb_common_probe(struct lps22_prs_data *prs)
+{
+	int err = -1;
+	u8 buf[5];
+ 
+	pr_info("%s: probe start.\n", LPS22_PRS_DEV_NAME);
+
+	mutex_init(&prs->lock);
+	mutex_init(&prs->tb.buf_lock);
+	mutex_lock(&prs->lock);
+
+	prs->pdata = kzalloc(sizeof(*prs->pdata), GFP_KERNEL);
+	if(prs->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(prs->dev,
+			"failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlockfreedata;
+	}
+
+	if (prs->dev->platform_data == NULL) {	
+		memcpy(prs->pdata, &default_lps22_pdata,
+		       sizeof(struct lps22_prs_platform_data));
+		dev_info(prs->dev, "using default plaform_data for lps22\n");
+	} else {
+		memcpy(prs->pdata, prs->dev->platform_data,
+		       sizeof(struct lps22_prs_platform_data));
+		dev_info(prs->dev, "using user plaform_data for lps22\n");
+        }
+
+	if (prs->pdata->init) {
+		err = prs->pdata->init();
+		if (err < 0) {
+			dev_err(prs->dev, "lps pdata init failed: %d\n", err);
+			goto err_pdata_init;
+		}
+	}
+
+	/* read chip id */
+	err = prs->tf->read(prs, WHO_AM_I, 1, buf);
+	if (err < 0) {
+		dev_warn(prs->dev, "Error reading WHO_AM_I: is device "
+			 "available/working?\n");
+		goto err_mutexunlockfreedata;
+	} else
+		prs->hw_working = 1;
+
+	if (buf[0] != WHOAMI_LPS22_PRS) {
+		dev_err(prs->dev, "device unknown. Expected: 0x%02x,"
+			" Replies: 0x%02x\n", WHOAMI_LPS22_PRS, buf[0]);
+		err = -1;
+		goto err_mutexunlockfreedata;
+	}
+
+	pr_info("%s ID Chip OK \n", LPS22_PRS_DEV_NAME);
+
+	err = lps22_prs_validate_pdata(prs);
+	if (err < 0) {
+		dev_err(prs->dev, "failed to validate platform data\n");
+		goto err_exit_kfree_pdata;
+	}
+
+	if (prs->pdata->init) {
+		err = prs->pdata->init();
+		if (err < 0) {
+			dev_err(prs->dev, "init failed: %d\n", err);
+			goto err_exit_pointer;
+		}
+	}
+
+	memset(prs->resume_state, 0, ARRAY_SIZE(prs->resume_state));
+
+	/* init registers which need values different from zero */
+	prs->resume_state[RES_CTRL_REG1] = (ODR_MASK & ODR_1_1) | (BDU_MASK);
+
+	err = lps22_prs_device_power_on(prs);
+	if (err < 0) {
+		dev_err(prs->dev, "power on failed: %d\n", err);
+		goto err_exit_pointer;
+	}
+
+	atomic_set(&prs->enabled, 1);
+
+	err = lps22_prs_update_odr(prs, prs->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(prs->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = lps22_prs_input_init(prs);
+	if (err < 0) {
+		dev_err(prs->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(prs->dev);
+	if (err < 0) {
+		dev_err(prs->dev,
+			"device LPS22_PRS_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lps22_prs_device_power_off(prs);
+
+	/* As default, do not report information */
+	atomic_set(&prs->enabled, 0);
+
+	mutex_unlock(&prs->lock);
+
+	dev_info(prs->dev, "%s: probed\n", LPS22_PRS_DEV_NAME);
+
+	buf[0] = 0x10;
+	err = prs->tf->write(prs, CTRL_REG2, 1, buf);
+	if (err < 0)
+		return err;
+
+	return 0;
+
+err_input_cleanup:
+	lps22_prs_input_cleanup(prs);
+err_power_off:
+	lps22_prs_device_power_off(prs);
+err_exit_pointer:
+	if (prs->pdata->exit)
+		prs->pdata->exit();
+err_pdata_init:
+	if (prs->pdata->exit)
+		prs->pdata->exit();
+err_exit_kfree_pdata:
+	kfree(prs->pdata);
+
+err_mutexunlockfreedata:
+	mutex_unlock(&prs->lock);
+	pr_err("%s: Driver Init failed\n", LPS22_PRS_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lps22hb_common_probe);
+
+int lps22hb_common_remove(struct lps22_prs_data *prs)
+{
+	lps22_prs_disable(prs);
+	lps22_prs_input_cleanup(prs);
+	lps22_prs_device_power_off(prs);
+	remove_sysfs_interfaces(prs->dev);
+
+	if (prs->workqueue) {
+		flush_workqueue(prs->workqueue);
+		destroy_workqueue(prs->workqueue);
+		prs->workqueue = NULL;
+	}
+
+	if (prs->pdata->exit)
+		prs->pdata->exit();
+	kfree(prs->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(lps22hb_common_remove);
+
+#ifdef CONFIG_PM
+int lps22hb_common_resume(struct lps22_prs_data *prs)
+{
+	if (prs->on_before_suspend)
+		return lps22_prs_enable(prs);
+
+	return 0;
+}
+EXPORT_SYMBOL(lps22hb_common_resume);
+
+int lps22hb_common_suspend(struct lps22_prs_data *prs)
+{
+	prs->on_before_suspend = atomic_read(&prs->enabled);
+
+	return lps22_prs_disable(prs);
+}
+EXPORT_SYMBOL(lps22hb_common_suspend);
+#endif
+
+MODULE_DESCRIPTION("STMicrolelectronics lps22 pressure sensor driver");
+MODULE_AUTHOR("HESA BU, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
+
diff -uNr a/drivers/input/misc/st/pressure/lps22hb/lps22hb.h b/drivers/input/misc/st/pressure/lps22hb/lps22hb.h
--- a/drivers/input/misc/st/pressure/lps22hb/lps22hb.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps22hb/lps22hb.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,135 @@
+/*
+* STMicroelectronics lps22hb driver
+*
+* Copyright 2016 STMicroelectronics Inc.
+*
+* Authors: HESA BU - Application Team
+*        : Adalberto Muhuho (adalberto.muhuho@st.com)
+*        : Mario Tesi (mario.tesi@st.com)
+*
+* The structure of this driver is based on reference code previously delivered
+* by Lorenzo Sarchi
+*
+* Version: 0.0.3
+* Date   : 2016/May/16
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*/
+/******************************************************************************
+ Revision history:
+
+ Revision 0.0.1 2015/Dec/11:
+	first (BETA) release
+
+ Revision 0.0.2 2016/Apr/19:
+	Revision 0.0.2 downgrades previous License to GPLv2
+
+ Revision 0.0.3 2016/May/16:
+	Added SPI support
+******************************************************************************/
+#ifndef	__LPS22_H__
+#define	__LPS22_H__
+
+#define LPS22_PRS_MIN_POLL_PERIOD_MS	13
+#define	LPS22_PRS_DEV_NAME		"lps22hb"
+
+/* input define mappings */
+#define ABS_PR		ABS_PRESSURE
+#define ABS_TEMP	ABS_GAS
+
+/* Output conversion factors */
+#define	LPS22HB_SENSITIVITY_T	100	/* = LSB/degrC */
+#define	LPS22HB_SENSITIVITY_P	4096	/* = LSB/mbar */
+
+#define	LPS22HB_TEMPERATURE_OFFSET	0
+
+#define LPS22HB_RX_MAX_LENGTH	500
+#define LPS22HB_TX_MAX_LENGTH	500
+
+#define	RESUME_ENTRIES		16
+
+//#define	DEBUG
+
+#ifdef __KERNEL__
+struct lps22_prs_data;
+
+struct lps22_prs_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+};
+
+struct lps22_prs_transfer_buffer {
+	struct mutex buf_lock;
+	u8 rx_buf[LPS22HB_RX_MAX_LENGTH];
+	u8 tx_buf[LPS22HB_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lps22_prs_transfer_function {
+	int (*write) (struct lps22_prs_data *cdata, u8 reg_addr, int len, u8 *data);
+	int (*read) (struct lps22_prs_data *cdata, u8 reg_addr, int len, u8 *data);
+};
+
+struct lps22_prs_data {
+	const char *name;
+	struct lps22_prs_platform_data *pdata;
+
+	struct mutex lock;
+	struct workqueue_struct *workqueue;
+	struct hrtimer hr_timer;
+	ktime_t delta_ts;
+	struct work_struct input_work;
+	struct input_dev *input_dev_pres;
+
+	struct device *dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	u16 bustype;
+	int irq;
+	atomic_t enabled;
+	int on_before_suspend;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+	const struct lps22_prs_transfer_function *tf;
+	struct lps22_prs_transfer_buffer tb;
+};
+
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+#define INPUT_EVENT_Z		MSC_GESTURE
+#define INPUT_EVENT_TIME_MSB	MSC_SCAN
+#define INPUT_EVENT_TIME_LSB	MSC_MAX
+
+int lps22hb_common_probe(struct lps22_prs_data *prs);
+int lps22hb_common_remove(struct lps22_prs_data *prs);
+
+#ifdef CONFIG_PM
+int lps22hb_common_resume(struct lps22_prs_data *prs);
+int lps22hb_common_suspend(struct lps22_prs_data *prs);
+#endif /* CONFIG_PM */
+#endif /* __KERNEL__ */
+
+#endif  /* __LPS22_H__ */
diff -uNr a/drivers/input/misc/st/pressure/lps22hb/lps22hb_i2c.c b/drivers/input/misc/st/pressure/lps22hb/lps22hb_i2c.c
--- a/drivers/input/misc/st/pressure/lps22hb/lps22hb_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps22hb/lps22hb_i2c.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,169 @@
+/*
+ * STMicroelectronics lps22hb i2c driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "lps22hb.h"
+
+static int lps22hb_i2c_read(struct lps22_prs_data *cdata, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	return (err == 2) ? 0 : 1;
+}
+
+static int lps22hb_i2c_write(struct lps22_prs_data *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+
+	return (err == 1) ? 0 : 1;
+}
+
+static const struct lps22_prs_transfer_function lps22hb_tf_i2c = {
+	.write = lps22hb_i2c_write,
+	.read = lps22hb_i2c_read,
+};
+
+static int lps22hb_i2c_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int err;
+	struct lps22_prs_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &client->dev;
+	cdata->irq = client->irq;
+	cdata->tf = &lps22hb_tf_i2c;
+	cdata->bustype = BUS_I2C;
+	cdata->name = client->name;
+	i2c_set_clientdata(client, cdata);
+
+	err = lps22hb_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+	return err;
+}
+
+static int lps22hb_i2c_remove(struct i2c_client *client)
+{
+	struct lps22_prs_data *cdata = i2c_get_clientdata(client);
+
+	lps22hb_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", LPS22_PRS_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lps22hb_suspend(struct device *dev)
+{
+	struct lps22_prs_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lps22hb_common_suspend(cdata);
+}
+
+static int lps22hb_resume(struct device *dev)
+{
+	struct lps22_prs_data *cdata = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lps22hb_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lps22hb_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lps22hb_suspend, lps22hb_resume)
+};
+
+#define LPS22HB_PM_OPS		(&lps22hb_pm_ops)
+#else /* CONFIG_PM */
+#define LPS22HB_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lps22hb_ids[] = {
+	{ LPS22_PRS_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lps22hb_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lps22hb_id_table[] = {
+	{ .compatible = "st,lps22hb", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lps22hb_id_table);
+#endif
+
+static struct i2c_driver lps22hb_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LPS22_PRS_DEV_NAME,
+		.pm = LPS22HB_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lps22hb_id_table),
+#endif
+	},
+	.probe    = lps22hb_i2c_probe,
+	.remove   = lps22hb_i2c_remove,
+	.id_table = lps22hb_ids,
+};
+
+module_i2c_driver(lps22hb_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lps22hb i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/pressure/lps22hb/lps22hb_spi.c b/drivers/input/misc/st/pressure/lps22hb/lps22hb_spi.c
--- a/drivers/input/misc/st/pressure/lps22hb/lps22hb_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps22hb/lps22hb_spi.c	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,191 @@
+/*
+ * STMicroelectronics lps22hb spi driver
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ *
+ * Mario Tesi <mario.tesi@st.com>
+ * v 1.2.2
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/hrtimer.h>
+#include <linux/input.h>
+#include <linux/types.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#endif
+
+#include "lps22hb.h"
+
+#define SENSORS_SPI_READ 0x80
+
+static int lps22hb_spi_read(struct lps22_prs_data *cdata, u8 reg_addr, int len,
+			    u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	if (!err)
+		memcpy(data, cdata->tb.rx_buf, len);
+		
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static int lps22hb_spi_write(struct lps22_prs_data *cdata, u8 reg_addr, int len,
+			     u8 *data)
+{
+	int err;
+	struct spi_message msg;
+
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LPS22HB_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	mutex_lock(&cdata->tb.buf_lock);
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+	err = spi_sync(to_spi_device(cdata->dev), &msg);
+	mutex_unlock(&cdata->tb.buf_lock);
+
+	return err;
+}
+
+static const struct lps22_prs_transfer_function lps22hb_tf_spi = {
+	.write = lps22hb_spi_write,
+	.read = lps22hb_spi_read,
+};
+
+static int lps22hb_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lps22_prs_data *cdata;
+
+	cdata = kmalloc(sizeof(*cdata), GFP_KERNEL);
+	if (!cdata)
+		return -ENOMEM;
+
+	cdata->dev = &spi->dev;
+	cdata->irq = spi->irq;
+	cdata->tf = &lps22hb_tf_spi;
+	cdata->name = spi->modalias;
+	cdata->bustype = BUS_SPI;
+	spi_set_drvdata(spi, cdata);
+
+	err = lps22hb_common_probe(cdata);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(cdata);
+
+	return err;
+}
+
+static int lps22hb_spi_remove(struct spi_device *spi)
+{
+	/* TODO: check the function */
+	struct lps22_prs_data *cdata = spi_get_drvdata(spi);
+
+	lps22hb_common_remove(cdata);
+	dev_info(cdata->dev, "%s: removed\n", LPS22_PRS_DEV_NAME);
+	kfree(cdata);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lps22hb_suspend(struct device *dev)
+{
+	struct lps22_prs_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lps22hb_common_suspend(cdata);
+}
+
+static int lps22hb_resume(struct device *dev)
+{
+	struct lps22_prs_data *cdata = spi_get_drvdata(to_spi_device(dev));
+
+	return lps22hb_common_resume(cdata);
+}
+
+static const struct dev_pm_ops lps22hb_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lps22hb_suspend, lps22hb_resume)
+};
+
+#define LPS22HB_PM_OPS		(&lps22hb_pm_ops)
+#else /* CONFIG_PM */
+#define LPS22HB_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lps22hb_ids[] = {
+	{ LPS22_PRS_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lps22hb_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lps22hb_id_table[] = {
+	{ .compatible = "st,lps22hb", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lps22hb_id_table);
+#endif
+
+static struct spi_driver lps22hb_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LPS22_PRS_DEV_NAME,
+		.pm = LPS22HB_PM_OPS,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(lps22hb_id_table),
+#endif
+	},
+	.probe    = lps22hb_spi_probe,
+	.remove   = lps22hb_spi_remove,
+	.id_table = lps22hb_ids,
+};
+
+module_spi_driver(lps22hb_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lps22hb spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/pressure/lps22hb/Makefile b/drivers/input/misc/st/pressure/lps22hb/Makefile
--- a/drivers/input/misc/st/pressure/lps22hb/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps22hb/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,8 @@
+#
+# Makefile for the input misc lps22hb driver.
+#
+
+lps22hb-core-y += lps22hb_core.o
+obj-$(CONFIG_INPUT_LPS22HB) += lps22hb-core.o
+obj-$(CONFIG_INPUT_LPS22HB_I2C) += lps22hb_i2c.o
+obj-$(CONFIG_INPUT_LPS22HB_SPI) += lps22hb_spi.o
diff -uNr a/drivers/input/misc/st/pressure/lps25h/Kconfig b/drivers/input/misc/st/pressure/lps25h/Kconfig
--- a/drivers/input/misc/st/pressure/lps25h/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps25h/Kconfig	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_LPS25H
+	tristate "STMicroelectronics LPS25H sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_LPS25H_I2C if (I2C)
+	select INPUT_LPS25H_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics LPS25H sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called lps25h.
+
+config INPUT_LPS25H_I2C
+	tristate
+	depends on INPUT_LPS25H
+	depends on I2C
+
+config INPUT_LPS25H_SPI
+	tristate
+	depends on INPUT_LPS25H
+	depends on SPI
diff -uNr a/drivers/input/misc/st/pressure/lps25h/lps25h_core.c b/drivers/input/misc/st/pressure/lps25h/lps25h_core.c
--- a/drivers/input/misc/st/pressure/lps25h/lps25h_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps25h/lps25h_core.c	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,1081 @@
+/*
+* Copyright (C) 2016 STMicroelectronics
+*
+* AMS - Motion Mems Division - Application Team
+* Matteo Dameno (matteo.dameno@st.com)
+* Mario Tesi (mario.tesi@st.com)
+*
+* Authors is willing to be considered the contact and update points for
+* the driver.
+*
+* Read pressures and temperatures output can be converted in units of
+* measurement by dividing them respectively for SENSITIVITY_P and SENSITIVITY_T.
+* Temperature values must then be added by the constant float TEMPERATURE_OFFSET
+* expressed as Celsius degrees.
+*
+* Obtained values are then expessed as
+* mbar (=0.1 kPa) and Celsius degrees (T(C) = 42.5 + (TEMP_OUT / 480)).
+*
+* To use autozero feature you can write 0 zero or 1 to its corresponding sysfs
+* file. This lets you to write current temperature and pressure into reference
+* registers or to reset them.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301 USA
+*
+*/
+/******************************************************************************
+ Revision 1.0.0 2012/Nov/21:
+	first release
+ Revision 1.0.0 2016/May/20:
+	add spi support
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include "lps25h.h"
+
+#define	PR_ABS_MAX	8388607		/* 24 bit 2'compl */
+#define	PR_ABS_MIN	-8388608
+
+#ifdef SHRT_MAX
+#define	TEMP_MAX	SHRT_MAX
+#define TEMP_MIN	SHRT_MIN
+#else
+#define	TEMP_MAX	SHORT_MAX
+#define TEMP_MIN	SHORT_MIN
+#endif
+
+#ifdef SHRT_MAX
+#define PRESS_OFFSET_MAX	SHRT_MAX
+#define PRESS_OFFSET_MIN	SHRT_MIN
+#else
+#define PRESS_OFFSET_MAX	SHORT_MAX
+#define PRESS_OFFSET_MIN	SHORT_MIN
+#endif
+
+#define	WHOAMI_LPS25H_PRS	0xBD	/*	Expctd content for WAI	*/
+
+/*	CONTROL REGISTERS	*/
+#define	REF_P_XL	0x08		/*	pressure reference	*/
+#define	REF_P_L		0x09		/*	pressure reference	*/
+#define	REF_P_H		0x0A		/*	pressure reference	*/
+
+#define	WHO_AM_I_REG	0x0F		/*	WhoAmI register		*/
+#define	RESOL_CONF	0x10		/*	Pres Temp resolution set*/
+
+#define	CTRL_REG1	0x20		/*	power / ODR control reg	*/
+#define	CTRL_REG2	0x21		/*	boot reg		*/
+#define	CTRL_REG3	0x22		/*	interrupt control reg	*/
+#define	CTRL_REG4	0x23		/*	interrupt control reg	*/
+#define	INT_CFG_REG	0x24		/*	interrupt config reg	*/
+#define	INT_SRC_REG	0x25		/*	interrupt source reg	*/
+
+#define	STATUS_REG	0x27		/*	status reg		*/
+
+#define	PRESS_OUT_XL	0x28		/*	press output (3 regs)	*/
+#define	TEMP_OUT_L	0x2B		/*	temper output (2 regs)	*/
+
+#define	FIFO_CTRL	0x2E		/*				*/
+#define	FIFO_STAT	0x2F		/*				*/
+
+#define	THS_P_L		0x30		/*	pressure threshold	*/
+#define	THS_P_H		0x31		/*	pressure threshold	*/
+
+#define	RPDS_TRIM_L	0x39		/*	pressure offset		*/
+#define	RPDS_TRIM_H	0x3A		/*	pressure offset		*/
+
+/*	REGISTERS ALIASES	*/
+#define	P_REF_INDATA_REG	REF_P_XL
+#define	P_OFFSET_INDATA_REG	RPDS_TRIM_L
+#define	P_THS_INDATA_REG	THS_P_L
+#define	P_OUTDATA_REG		PRESS_OUT_XL
+#define	T_OUTDATA_REG		TEMP_OUT_L
+#define	OUTDATA_REG		PRESS_OUT_XL
+
+/* */
+#define	ENABLE_MASK		0x80	/*  ctrl_reg1 */
+#define	ODR_MASK		0x70	/*  ctrl_reg1 */
+#define	DIFF_MASK		0x08	/*  ctrl_reg1 */
+#define	BDU_MASK		0x04	/*  ctrl_reg1 */
+#define	RESET_AZ		0x02	/*  ctrl_reg1 */
+
+#define	AUTOZ_MASK		0x02	/*  ctrl_reg2 */
+
+#define	PM_NORMAL		0x80	/* Power Normal Mode*/
+#define	PM_OFF			0x00	/* Power Down */
+
+#define	AUTOZ_ON		0x02	/* Enab AutoZero Function */
+#define	AUTOZ_OFF		0x00	/* Disab Difference Function */
+
+#define	BDU_ON			0x04	/* En BDU Block Data Upd */
+
+
+#define	RES_AVGTEMP_064		0x0C
+#define	RES_AVGTEMP_032		0x08
+
+#define	RES_AVGPRES_512		0x03
+#define	RES_AVGPRES_128		0x02
+
+#define	RES_MAX	(RES_AVGTEMP_064 | RES_AVGPRES_512)	/* Max Resol. */
+
+#define	FUZZ			0
+#define	FLAT			0
+
+#define	I2C_AUTO_INCREMENT	0x80
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+
+/* RESUME STATE INDICES */
+#define	RES_REF_P_XL		0
+#define	RES_REF_P_L		1
+#define	RES_REF_P_H		2
+#define	RES_RESOL_CONF		5
+#define	RES_CTRL_REG1		6
+#define	RES_CTRL_REG2		7
+#define	RES_CTRL_REG3		8
+#define	RES_CTRL_REG4		9
+#define	RES_INT_CFG_REG		10
+#define	RES_FIFO_CTRL		11
+#define	RES_THS_P_L		12
+#define	RES_THS_P_H		13
+#define	RES_RPSD_TRIM_L		14
+#define	RES_RPSD_TRIM_H		15
+
+/* end RESUME STATE INDICES */
+
+/* Pressure Sensor Operating Mode */
+#define	AUTOZ_ENABLE	1
+#define	AUTOZ_DISABLE	0
+
+/* Barometer and Termometer output data rate ODR */
+#define	ODR_ONESH	0x00	/* one shot both		*/
+#define	ODR_1_1		0x10	/*  1  Hz baro,  1  Hz term ODR	*/
+#define	ODR_7_7		0x20	/*  7  Hz baro,  7  Hz term ODR	*/
+#define	ODR_12_12	0x30	/* 12.5Hz baro, 12.5Hz term ODR	*/
+#define	ODR_25_25	0x40	/* 25  Hz baro, 25  Hz term ODR	*/
+
+static const struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} lps25h_prs_odr_table[] = {
+	{   40, ODR_25_25 },
+	{   80, ODR_12_12 },
+	{  143, ODR_7_7   },
+	{ 1000, ODR_1_1   },
+};
+
+static struct lps25h_prs_platform_data default_lps25h_prs_pdata = {
+	.poll_interval = 1000,
+	.min_interval = LPS25H_PRS_MIN_POLL_PERIOD_MS,
+};
+
+struct outputdata {
+	s32 press;
+	s16 temperature;
+};
+
+static int lps25h_prs_register_write(struct lps25h_prs_data *stat, u8 *buf,
+				     u8 reg_address, u8 new_value)
+{
+	/* Sets configuration register at reg_address
+	 *  NOTE: this is a straight overwrite  */
+	return stat->tf->write(stat, reg_address, 1, &new_value);
+}
+
+static int lps25h_prs_register_read(struct lps25h_prs_data *stat, u8 *buf,
+				    u8 reg_address)
+{
+	return stat->tf->read(stat, reg_address, 1, buf);
+}
+
+static int lps25h_prs_register_update(struct lps25h_prs_data *stat, u8 *buf,
+				      u8 reg_address, u8 mask, u8 new_bit_values)
+{
+	int err;
+	u8 init_val;
+	u8 updated_val;
+	err = lps25h_prs_register_read(stat, buf, reg_address);
+	if (!(err < 0)) {
+		init_val = buf[0];
+		updated_val = ((mask & new_bit_values) | ((~mask) & init_val));
+		err = lps25h_prs_register_write(stat, buf, reg_address, updated_val);
+	}
+	return err;
+}
+
+static int lps25h_prs_hw_init(struct lps25h_prs_data *stat)
+{
+	int err;
+	u8 buf[6];
+
+	dev_dbg(stat->dev, "%s: hw init start\n", LPS25H_PRS_DEV_NAME);
+
+	buf[0] = stat->resume_state[RES_REF_P_XL];
+	buf[1] = stat->resume_state[RES_REF_P_L];
+	buf[2] = stat->resume_state[RES_REF_P_H];
+	err = stat->tf->write(stat, P_REF_INDATA_REG, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_RESOL_CONF];
+	err = stat->tf->write(stat, RESOL_CONF, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_THS_P_L];
+	buf[1] = stat->resume_state[RES_THS_P_H];
+	err = stat->tf->write(stat, P_THS_INDATA_REG, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	buf[2] = stat->resume_state[RES_CTRL_REG4];
+	err = stat->tf->write(stat, CTRL_REG2, 3, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG_REG];
+	err = stat->tf->write(stat, INT_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	dev_dbg(stat->dev, "%s: hw init done\n", LPS25H_PRS_DEV_NAME);
+	return 0;
+
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+			buf[1], err);
+	return err;
+}
+
+static void lps25h_prs_device_power_off(struct lps25h_prs_data *stat)
+{
+	int err;
+	u8 buf = PM_OFF;
+
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	if (stat->pdata->power_off)
+		stat->pdata->power_off();
+
+	stat->hw_initialized = 0;
+}
+
+static int lps25h_prs_device_power_on(struct lps25h_prs_data *stat)
+{
+	int err = -1;
+
+	if (stat->pdata->power_on) {
+		err = stat->pdata->power_on();
+		if (err < 0) {
+			dev_err(stat->dev, "power_on failed: %d\n", err);
+			return err;
+		}
+	}
+
+	if (!stat->hw_initialized) {
+		err = lps25h_prs_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			lps25h_prs_device_power_off(stat);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+int lps25h_prs_update_odr(struct lps25h_prs_data *stat, int poll_period_ms)
+{
+	int err = -1;
+	int i;
+	u8 init_val, updated_val;
+	u8 curr_val, new_val;
+	u8 mask = ODR_MASK;
+	u8 resol = RES_MAX;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (longest period) backward (shortest
+	 * period), to support the poll_interval requested by the system.
+	 * It must be the longest period shorter then the set poll period.*/
+	for (i = ARRAY_SIZE(lps25h_prs_odr_table) - 1; i >= 0; i--) {
+		if ((lps25h_prs_odr_table[i].cutoff_ms <= poll_period_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	new_val = lps25h_prs_odr_table[i].mask;
+
+	/* before to change the ODR it is mandatory to power down the device */
+	err = stat->tf->read(stat, CTRL_REG1, 1, &init_val);
+	if (err < 0)
+		goto error;
+
+	/* work on all but ENABLE bits power down */
+	stat->resume_state[RES_CTRL_REG1] = init_val ;
+	curr_val = ((ENABLE_MASK & PM_OFF) | ((~ENABLE_MASK) & init_val));
+	err = stat->tf->write(stat, CTRL_REG1, 1, &curr_val);
+	if (err < 0)
+		goto error;
+
+	/* set new ODR*/
+	updated_val = ((mask & new_val) | ((~mask) & curr_val));
+	err = stat->tf->write(stat, CTRL_REG1, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	/* power up */
+	curr_val = ((ENABLE_MASK & PM_NORMAL) |
+		    ((~ENABLE_MASK) & updated_val));
+	err = stat->tf->write(stat, CTRL_REG1, 1, &curr_val);
+	if (err < 0)
+		goto error;
+
+	err = stat->tf->write(stat, RESOL_CONF, 1, &resol);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG1] = curr_val;
+	stat->resume_state[RES_RESOL_CONF] = resol;
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed: %d\n", err);
+
+	return err;
+}
+
+static int lps25h_prs_set_press_reference(struct lps25h_prs_data *stat,
+					  s32 new_reference)
+{
+	int err;
+	u8 bit_valuesXL, bit_valuesL, bit_valuesH;
+	u8 buf[4];
+
+	bit_valuesXL = (u8) (new_reference & 0x0000FF);
+	bit_valuesL = (u8)((new_reference & 0x00FF00) >> 8);
+	bit_valuesH = (u8)((new_reference & 0xFF0000) >> 16);
+
+	buf[0] = bit_valuesXL;
+	buf[1] = bit_valuesL;
+	buf[2] = bit_valuesH;
+
+	err = stat->tf->write(stat, P_REF_INDATA_REG, 3, buf);
+	if (err < 0)
+		return err;
+
+	stat->resume_state[RES_REF_P_XL] = bit_valuesXL;
+	stat->resume_state[RES_REF_P_L] = bit_valuesL;
+	stat->resume_state[RES_REF_P_H] = bit_valuesH;
+
+	return err;
+}
+
+static int lps25h_prs_get_press_reference(struct lps25h_prs_data *stat,
+					  s32 *buf32)
+{
+	int err;
+	u8 bit_valuesXL, bit_valuesL, bit_valuesH;
+	u8 buf[3];
+	u16 temp = 0;
+
+	err = stat->tf->read(stat, P_REF_INDATA_REG, 3, buf);
+	if (err < 0)
+		return err;
+
+	bit_valuesXL = buf[0];
+	bit_valuesL = buf[1];
+	bit_valuesH = buf[2];
+
+	temp = ((bit_valuesH) << 8) | bit_valuesL;
+	*buf32 = (s32)((((s16) temp) << 8) | bit_valuesXL);
+
+	dev_dbg(stat->dev, "pressure_reference val: %+d", *buf32);
+
+	return err;
+}
+
+static int lps25h_prs_set_press_offset(struct lps25h_prs_data *stat,
+				       s16 new_offset)
+{
+	int err;
+	u8 bit_valuesL, bit_valuesH;
+	u8 buf[3];
+
+	bit_valuesL = (u8)(new_offset & 0x00FF);
+	bit_valuesH = (u8)((new_offset & 0xFF00) >> 8);
+
+	buf[0] = bit_valuesL;
+	buf[1] = bit_valuesH;
+	err = stat->tf->write(stat, P_OFFSET_INDATA_REG, 2, buf);
+
+	if (err < 0)
+		return err;
+
+	stat->resume_state[RES_RPSD_TRIM_L] = bit_valuesL;
+	stat->resume_state[RES_RPSD_TRIM_L] = bit_valuesH;
+
+	return err;
+}
+
+static int lps25h_prs_get_press_offset(struct lps25h_prs_data *stat,
+				       s16 *buf16)
+{
+	int err;
+	u8 bit_valuesL, bit_valuesH;
+	u8 buf[2] = {0};
+	u16 offset_pres = 0;
+
+	err = stat->tf->read(stat, P_OFFSET_INDATA_REG, 2, buf);
+	if (err < 0)
+		return err;
+
+	bit_valuesL = buf[0];
+	bit_valuesH = buf[1];
+
+	offset_pres = (((u16)bit_valuesH) << 8);
+	*buf16 = (s16)(offset_pres | ((u16)bit_valuesL));
+
+	return err;
+}
+
+static int lps25h_prs_autozero_manage(struct lps25h_prs_data *stat,
+				      u8 control)
+{
+	int err;
+	u8 buf[5];
+	u8 bit_values = AUTOZ_OFF;
+	u8 init_val;
+
+	if (control >= AUTOZ_ENABLE) {
+		bit_values = AUTOZ_ON;
+		buf[0] = CTRL_REG2;
+		err = stat->tf->read(stat, CTRL_REG2, 1, &init_val);
+		if (err < 0)
+			return err;
+
+		stat->resume_state[RES_CTRL_REG2] = init_val;
+		err = lps25h_prs_register_update(stat, buf, CTRL_REG2,
+						 AUTOZ_MASK, bit_values);
+		if (err < 0)
+			return err;
+	} else {
+		buf[0] = 0;
+		buf[1] = 0;
+		buf[2] = 0;
+		buf[3] = 0;
+		buf[4] = 0;
+		err = stat->tf->write(stat, P_REF_INDATA_REG, 3, buf);
+		if (err < 0)
+			return err;
+
+		stat->resume_state[RES_REF_P_XL] = 0;
+		stat->resume_state[RES_REF_P_L] = 0;
+		stat->resume_state[RES_REF_P_H] = 0;
+	}
+
+	return 0;
+}
+
+static int lps25h_prs_get_presstemp_data(struct lps25h_prs_data *stat,
+					 struct outputdata *out)
+{
+	int err;
+	u8 prs_data[5];
+	s32 pressure;
+	s16 temperature;
+
+	err = stat->tf->read(stat, OUTDATA_REG, 5, prs_data);
+	if (err < 0)
+		return err;
+
+	dev_dbg(stat->dev, "temp out tH = 0x%02x, tL = 0x%02x."
+		"press_out: pH = 0x%02x, pL = 0x%02x, pXL= 0x%02x\n",
+		prs_data[4], prs_data[3], prs_data[2], prs_data[1],
+		prs_data[0]);
+
+	pressure = (s32)((((s8)prs_data[2]) << 16) |
+			 (prs_data[1] << 8) | (prs_data[0]));
+	temperature = (s16)((((s8) prs_data[4]) << 8) | prs_data[3]);
+
+	dev_dbg(stat->dev, "temp out pressure = %d, temperature = %d\n",
+		pressure, temperature);
+
+	out->press = pressure;
+	out->temperature = temperature;
+
+	return err;
+}
+
+static void lps25h_prs_report_values(struct lps25h_prs_data *stat,
+				     struct outputdata *out)
+{
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_X,
+		    out->press);
+	input_event(stat->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_Y,
+		    out->temperature);
+	input_sync(stat->input_dev);
+}
+
+static int lps25h_prs_enable(struct lps25h_prs_data *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = lps25h_prs_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			return err;
+		}
+		schedule_delayed_work(&stat->input_work,
+			msecs_to_jiffies(stat->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int lps25h_prs_disable(struct lps25h_prs_data *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&stat->input_work);
+		lps25h_prs_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int val;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms, stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	lps25h_prs_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val)
+		lps25h_prs_enable(stat);
+	else
+		lps25h_prs_disable(stat);
+
+	return size;
+}
+
+static ssize_t attr_get_press_ref(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int err;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	s32 val = 0;
+
+	mutex_lock(&stat->lock);
+	err = lps25h_prs_get_press_reference(stat, &val);
+	mutex_unlock(&stat->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_press_ref(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	int err = -1;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	long val = 0;
+
+	if (strict_strtol(buf, 10, &val))
+		return -EINVAL;
+
+	if (val < PR_ABS_MIN || val > PR_ABS_MAX) {
+		dev_err(stat->dev, " Value discarded: pressure_reference %+li"
+			" is outside the valid interval: %+i , %+i.\n",
+			val, (PR_ABS_MIN), (PR_ABS_MAX));
+		return -EINVAL;
+	}
+
+	mutex_lock(&stat->lock);
+	err = lps25h_prs_set_press_reference(stat, val);
+	mutex_unlock(&stat->lock);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+static ssize_t attr_get_press_offset(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int err;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	s16 val = 0;
+
+	mutex_lock(&stat->lock);
+	err = lps25h_prs_get_press_offset(stat, &val);
+	mutex_unlock(&stat->lock);
+	if (err < 0)
+		return err;
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_press_offset(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int err = -1;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	long val = 0;
+
+	if (strict_strtol(buf, 10, &val))
+		return -EINVAL;
+
+	if (val < PRESS_OFFSET_MIN || val > PRESS_OFFSET_MAX) {
+		dev_err(stat->dev, " Value discarded: pressure_offset %+li"
+			" is outside the valid interval: %+i , %+i.\n",
+			val, (PRESS_OFFSET_MIN), (PRESS_OFFSET_MAX));
+		return -EINVAL;
+	}
+
+	mutex_lock(&stat->lock);
+	err = lps25h_prs_set_press_offset(stat, val);
+	mutex_unlock(&stat->lock);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+static ssize_t attr_set_autozero(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int err;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	err = lps25h_prs_autozero_manage(stat, (u8) val);
+	mutex_unlock(&stat->lock);
+	if (err < 0)
+		return err;
+
+	return size;
+}
+
+#ifdef DEBUG
+static ssize_t attr_reg_set(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	int rc;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	u8 reg, data;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	reg = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	data = val;
+	rc = stat->tf->write(stat, &reg, 1), &data;
+
+	return size;
+}
+
+static ssize_t attr_reg_get(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	ssize_t ret;
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	int rc;
+	u8 reg, data;
+
+	mutex_lock(&stat->lock);
+	data = stat->reg_addr;
+	mutex_unlock(&stat->lock);
+	rc = stat->tf->read(stat, &reg, 1, &data);
+	ret = sprintf(buf, "0x%02x\n", data);
+
+	return ret;
+}
+
+static ssize_t attr_addr_set(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+	struct lps25h_prs_data *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 16, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	stat->reg_addr = val;
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+#endif
+
+static struct device_attribute attributes[] = {
+	__ATTR(poll_period_ms, 0664, attr_get_polling_rate,
+	       attr_set_polling_rate),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+	__ATTR(pressure_reference_level, 0664, attr_get_press_ref,
+	       attr_set_press_ref),
+	__ATTR(pressure_offset, 0660, attr_get_press_offset,
+	       attr_set_press_offset),
+	__ATTR(enable_autozero, 0220, NULL, attr_set_autozero),
+#ifdef DEBUG
+	__ATTR(reg_value, 0664, attr_reg_get, attr_reg_set),
+	__ATTR(reg_addr, 0220, NULL, attr_addr_set),
+#endif
+};
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		ret = device_create_file(dev, attributes + i);
+		if (ret < 0)
+			goto error;
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s:Unable to create interface\n", __func__);
+
+	return ret;
+}
+
+static void lps25h_prs_input_work_func(struct work_struct *work)
+{
+	struct lps25h_prs_data *stat = container_of(
+			(struct delayed_work *)work,
+			struct lps25h_prs_data,
+			input_work);
+
+	static struct outputdata output;
+	int err;
+
+	mutex_lock(&stat->lock);
+	err = lps25h_prs_get_presstemp_data(stat, &output);
+	if (err < 0)
+		dev_err(stat->dev, "get_pressure_data failed\n");
+	else
+		lps25h_prs_report_values(stat, &output);
+
+	schedule_delayed_work(&stat->input_work,
+			      msecs_to_jiffies(stat->pdata->poll_interval));
+	mutex_unlock(&stat->lock);
+}
+
+int lps25h_prs_input_open(struct input_dev *input)
+{
+	struct lps25h_prs_data *stat = input_get_drvdata(input);
+
+	return lps25h_prs_enable(stat);
+}
+
+void lps25h_prs_input_close(struct input_dev *dev)
+{
+	lps25h_prs_disable(input_get_drvdata(dev));
+}
+
+static int lps25h_prs_validate_pdata(struct lps25h_prs_data *stat)
+{
+	/* checks for correctness of minimal polling period */
+	stat->pdata->min_interval = max((unsigned int)LPS25H_PRS_MIN_POLL_PERIOD_MS,
+					stat->pdata->min_interval);
+
+	stat->pdata->poll_interval = max(stat->pdata->poll_interval,
+					 stat->pdata->min_interval);
+
+	/* Checks polling interval relative to minimum polling interval */
+	if (stat->pdata->poll_interval < stat->pdata->min_interval) {
+		dev_err(stat->dev, "minimum poll interval violated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lps25h_prs_input_init(struct lps25h_prs_data *stat)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&stat->input_work, lps25h_prs_input_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		dev_err(stat->dev, "input device allocate failed\n");
+		return -ENOMEM;
+	}
+
+	stat->input_dev->open = lps25h_prs_input_open;
+	stat->input_dev->close = lps25h_prs_input_close;
+	stat->input_dev->name = stat->name;
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	__set_bit(INPUT_EVENT_TYPE, stat->input_dev->evbit);
+	__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	__set_bit(INPUT_EVENT_Y, stat->input_dev->mscbit);
+
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static void lps25h_prs_input_cleanup(struct lps25h_prs_data *stat)
+{
+	input_unregister_device(stat->input_dev);
+}
+
+int lps25h_common_probe(struct lps25h_prs_data *stat)
+{
+	int err = -1;
+	u8 tempvalue;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_lock(&stat->lock);
+
+	/* read chip WHO_AM_I_REG */
+	err = lps25h_prs_register_read(stat, &tempvalue, WHO_AM_I_REG);
+	if (tempvalue == WHOAMI_LPS25H_PRS) {
+		dev_info(stat->dev, "device recognized\n");
+	} else {
+			/* TODO: discriminate between errors */
+			err = -ENODEV;
+			dev_err(stat->dev, "Not replying or not recognized\n");
+			goto err_mutexunlock;
+	}
+
+	stat->pdata = kzalloc(sizeof(*stat->pdata), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(stat->dev,
+			"failed to allocate memory for pdata: %d\n",
+			err);
+		goto err_mutexunlock;
+	}
+
+	/* select default or custom platform_data */
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata, &default_lps25h_prs_pdata,
+		       sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default platform_data\n");
+	} else {
+		memcpy(stat->pdata, stat->dev->platform_data,
+		       sizeof(*stat->pdata));
+	}
+
+	err = lps25h_prs_validate_pdata(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "failed to validate platform data\n");
+		goto err_exit_kfree_pdata;
+	}
+
+	if (stat->pdata->init) {
+		err = stat->pdata->init();
+		if (err < 0) {
+			dev_err(stat->dev, "init failed: %d\n", err);
+			goto err_exit_pointer;
+		}
+	}
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+	/* init registers which need values different from zero */
+	stat->resume_state[RES_CTRL_REG1] = ((ENABLE_MASK & PM_NORMAL) |
+		(ODR_MASK & ODR_1_1) | (BDU_MASK & BDU_ON));
+
+	stat->resume_state[RES_RESOL_CONF] = RES_MAX;
+	err = lps25h_prs_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_exit_pointer;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = lps25h_prs_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = lps25h_prs_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device LPS25H_PRS_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	lps25h_prs_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", LPS25H_PRS_DEV_NAME);
+
+	return 0;
+
+err_input_cleanup:
+	lps25h_prs_input_cleanup(stat);
+err_power_off:
+	lps25h_prs_device_power_off(stat);
+err_exit_pointer:
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+err_exit_kfree_pdata:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+
+	pr_err("%s: Driver Init failed\n", LPS25H_PRS_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(lps25h_common_probe);
+
+int lps25h_common_remove(struct lps25h_prs_data *stat)
+{
+	lps25h_prs_input_cleanup(stat);
+	lps25h_prs_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+
+	if (stat->pdata->exit)
+		stat->pdata->exit();
+	kfree(stat->pdata);
+	kfree(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lps25h_common_remove);
+
+#ifdef CONFIG_PM
+int lps25h_common_resume(struct lps25h_prs_data *stat)
+{
+	if (stat->on_before_suspend)
+		return lps25h_prs_enable(stat);
+
+	return 0;
+}
+EXPORT_SYMBOL(lps25h_common_resume);
+
+int lps25h_common_suspend(struct lps25h_prs_data *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	return lps25h_prs_disable(stat);
+}
+EXPORT_SYMBOL(lps25h_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicrolelectronics lps25h pressure sensor driver");
+MODULE_AUTHOR("Matteo Dameno, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/pressure/lps25h/lps25h.h b/drivers/input/misc/st/pressure/lps25h/lps25h.h
--- a/drivers/input/misc/st/pressure/lps25h/lps25h.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps25h/lps25h.h	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,142 @@
+/*
+* drivers/misc/lps25h.h
+*
+* STMicroelectronics LPS25H Pressure / Temperature Sensor module driver
+*
+* Copyright (C) 2012 STMicroelectronics
+* AMS - Motion Mems Division - Application Team
+* Matteo Dameno (matteo.dameno@st.com)
+* Mario Tesi (mario.tesi@st.com)
+*
+* Authors is willing to be considered the contact and update points for
+* the driver.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301 USA
+*
+*/
+/******************************************************************************
+ Revision 1.0.0 2012/Nov/21:
+	first release
+	moved to input/misc
+ Revision 1.0.1 2016/May/21:
+	Added spi support
+******************************************************************************/
+
+#ifndef	__LPS25H_H__
+#define	__LPS25H_H__
+
+//#define DEBUG 0
+
+#define	LPS25H_PRS_DEV_NAME	"lps25h_prs"
+#define HAS_IF_AUTO_INCREMENT
+
+/* Output conversion factors */
+#define	SENSITIVITY_T		480	/* =	480 digit/degrC	*/
+#define	SENSITIVITY_P		4096	/* =	digit/mbar	*/
+#define	SENSITIVITY_P_SHIFT	12	/* =	4096 digit/mbar	*/
+#define	TEMPERATURE_OFFSET	42.5f	/* =	42.5 degrC	*/
+
+/* input define mappings */
+#define ABS_PR		ABS_PRESSURE
+#define ABS_TEMP	ABS_GAS
+#define ABS_DLTPR	ABS_MISC
+
+#ifdef __KERNEL__
+/* Pressure Sensor Operating Mode */
+#define	LPS25H_PRS_ENABLE	0x01
+#define	LPS25H_PRS_DISABLE	0x00
+
+
+#define LPS25H_PRS_MIN_POLL_PERIOD_MS	1
+
+#define	LPS25H_PRS_SAD0L	0x00
+#define	LPS25H_PRS_SAD0H	0x01
+#define	LPS25H_PRS_I2C_SADROOT	0x2E
+#define	LPS25H_PRS_I2C_SAD_L	((LPS25H_PRS_I2C_SADROOT<<1)| \
+				 LPS25H_PRS_SAD0L)
+#define	LPS25H_PRS_I2C_SAD_H	((LPS25H_PRS_I2C_SADROOT<<1)| \
+				 LPS25H_PRS_SAD0H)
+
+#define	RESUME_ENTRIES		16
+
+#define LPS25H_RX_MAX_LENGTH	500
+#define LPS25H_TX_MAX_LENGTH	500
+
+struct lps25h_prs_transfer_buffer {
+	u8 rx_buf[LPS25H_RX_MAX_LENGTH];
+	u8 tx_buf[LPS25H_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct lps25h_prs_data;
+
+struct lps25h_prs_platform_data {
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(void);
+	int (*power_off)(void);
+
+	unsigned int poll_interval;
+	unsigned int min_interval;
+};
+
+/* specific bus I/O functions */
+struct lps25h_prs_transfer_function {
+	int (*write)(struct lps25h_prs_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct lps25h_prs_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct lps25h_prs_data {
+	const char *name;
+	struct lps25h_prs_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct device *dev;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	/* hw_working=-1 means not tested yet */
+	int hw_working;
+	u16 bustype;
+
+	atomic_t enabled;
+	int on_before_suspend;
+
+	u8 resume_state[RESUME_ENTRIES];
+
+#ifdef DEBUG
+	u8 reg_addr;
+#endif
+	struct lps25h_prs_transfer_buffer tb;
+	struct lps25h_prs_transfer_function *tf;
+};
+
+/* Input Event Type */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+#define INPUT_EVENT_Y		MSC_PULSELED
+
+int lps25h_common_probe(struct lps25h_prs_data *stat);
+int lps25h_common_remove(struct lps25h_prs_data *stat);
+
+#ifdef CONFIG_PM
+int lps25h_common_resume(struct lps25h_prs_data *stat);
+int lps25h_common_suspend(struct lps25h_prs_data *stat);
+#endif /* CONFIG_PM */
+#endif /* __KERNEL__ */
+
+#endif  /* __LPS25H_H__ */
diff -uNr a/drivers/input/misc/st/pressure/lps25h/lps25h_i2c.c b/drivers/input/misc/st/pressure/lps25h/lps25h_i2c.c
--- a/drivers/input/misc/st/pressure/lps25h/lps25h_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps25h/lps25h_i2c.c	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,210 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lps25h_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "lps25h.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define	I2C_AUTO_INCREMENT	0x80
+#endif
+
+static int lps25h_i2c_read(struct lps25h_prs_data *stat, u8 reg_addr,
+			   int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int lps25h_i2c_write(struct lps25h_prs_data *stat, u8 reg_addr,
+			    int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct lps25h_prs_transfer_function lps25h_tf_i2c = {
+	.write = lps25h_i2c_write,
+	.read = lps25h_i2c_read,
+};
+
+static int lps25h_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct lps25h_prs_data *stat;
+
+	stat = kzalloc(sizeof(struct lps25h_prs_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &lps25h_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = lps25h_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lps25h_i2c_remove(struct i2c_client *client)
+{
+	struct lps25h_prs_data *stat = i2c_get_clientdata(client);
+
+	lps25h_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lps25h_suspend(struct device *dev)
+{
+	struct lps25h_prs_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lps25h_common_suspend(stat);
+}
+
+static int lps25h_resume(struct device *dev)
+{
+	struct lps25h_prs_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return lps25h_common_resume(stat);
+}
+
+static const struct dev_pm_ops lps25h_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lps25h_suspend, lps25h_resume)
+};
+
+#define LPS25H_PM_OPS	(&lps25h_pm_ops)
+#else /* CONFIG_PM */
+#define LPS25H_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id lps25h_ids[] = {
+	{ LPS25H_PRS_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, lps25h_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lps25h_id_table[] = {
+	{ .compatible = "st,lps25h", },
+	{ .compatible = "st,lps25hb", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lps25h_id_table);
+#endif
+
+static struct i2c_driver lps25h_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LPS25H_PRS_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LPS25H_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lps25h_id_table,
+#endif
+	},
+	.remove = lps25h_i2c_remove,
+	.probe    = lps25h_i2c_probe,
+	.id_table = lps25h_ids,
+};
+
+module_i2c_driver(lps25h_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lps25h i2c driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/pressure/lps25h/lps25h_spi.c b/drivers/input/misc/st/pressure/lps25h/lps25h_spi.c
--- a/drivers/input/misc/st/pressure/lps25h/lps25h_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps25h/lps25h_spi.c	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,204 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: lps25h_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "lps25h.h"
+
+#define SENSORS_SPI_READ	0x80
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define SPI_AUTO_INCREMENT	0x40
+#endif
+
+static int lps25h_spi_read(struct lps25h_prs_data *stat, u8 reg_addr, int len,
+			   u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len);
+
+	return len;
+}
+
+static int lps25h_spi_write(struct lps25h_prs_data *stat, u8 reg_addr, int len,
+			    u8 *data)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= LPS25H_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	memcpy(&stat->tb.tx_buf[1], data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(to_spi_device(stat->dev), &msg);
+}
+
+static struct lps25h_prs_transfer_function lps25h_tf_spi = {
+	.write = lps25h_spi_write,
+	.read = lps25h_spi_read,
+};
+
+static int lps25h_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct lps25h_prs_data *stat;
+
+	stat = kzalloc(sizeof(struct lps25h_prs_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &lps25h_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = lps25h_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int lps25h_spi_remove(struct spi_device *spi)
+{
+	struct lps25h_prs_data *stat = spi_get_drvdata(spi);
+
+	lps25h_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lps25h_suspend(struct device *dev)
+{
+	struct lps25h_prs_data *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return lps25h_common_suspend(stat);
+}
+
+static int lps25h_resume(struct device *dev)
+{
+	struct lps25h_prs_data *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return lps25h_common_resume(stat);
+}
+
+static const struct dev_pm_ops lps25h_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(lps25h_suspend, lps25h_resume)
+};
+
+#define LPS25H_PM_OPS	(&lps25h_pm_ops)
+#else /* CONFIG_PM */
+#define LPS25H_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id lps25h_ids[] = {
+	{ LPS25H_PRS_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, lps25h_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id lps25h_id_table[] = {
+	{ .compatible = "st,lps25h", },
+	{ .compatible = "st,lps25hb", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lps25h_id_table);
+#endif
+
+static struct spi_driver lps25h_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LPS25H_PRS_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = LPS25H_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = lps25h_id_table,
+#endif
+	},
+	.remove = lps25h_spi_remove,
+	.probe    = lps25h_spi_probe,
+	.id_table = lps25h_ids,
+};
+
+module_spi_driver(lps25h_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lps25h spi driver");
+MODULE_AUTHOR("Giuseppe Barba");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/pressure/lps25h/Makefile b/drivers/input/misc/st/pressure/lps25h/Makefile
--- a/drivers/input/misc/st/pressure/lps25h/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/lps25h/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM acc lps25h driver
+#
+lps25h-core-y += lps25h_core.o
+obj-$(CONFIG_INPUT_LPS25H) += lps25h-core.o
+obj-$(CONFIG_INPUT_LPS25H_I2C) += lps25h_i2c.o
+obj-$(CONFIG_INPUT_LPS25H_SPI) += lps25h_spi.o
diff -uNr a/drivers/input/misc/st/pressure/Makefile b/drivers/input/misc/st/pressure/Makefile
--- a/drivers/input/misc/st/pressure/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/pressure/Makefile	2017-07-06 19:48:50.154213000 +0200
@@ -0,0 +1,2 @@
+obj-$(CONFIG_INPUT_LPS22HB) += lps22hb/
+obj-$(CONFIG_INPUT_LPS25H) += lps25h/
diff -uNr a/drivers/input/misc/st/uv/Kconfig b/drivers/input/misc/st/uv/Kconfig
--- a/drivers/input/misc/st/uv/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/Kconfig	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,8 @@
+menuconfig INPUT_UV
+	tristate "Ultraviolet"
+
+if INPUT_UV
+
+source "drivers/input/misc/st/uv/uvis25/Kconfig"
+
+endif # INPUT_UV
diff -uNr a/drivers/input/misc/st/uv/Makefile b/drivers/input/misc/st/uv/Makefile
--- a/drivers/input/misc/st/uv/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/Makefile	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_INPUT_UVIS25) += uvis25/
diff -uNr a/drivers/input/misc/st/uv/uvis25/Kconfig b/drivers/input/misc/st/uv/uvis25/Kconfig
--- a/drivers/input/misc/st/uv/uvis25/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/uvis25/Kconfig	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,20 @@
+config INPUT_UVIS25
+	tristate "STMicroelectronics UVIS25 sensor"
+	depends on (I2C || SPI) && SYSFS
+	select INPUT_UVIS25_I2C if (I2C)
+	select INPUT_UVIS25_SPI if (SPI)
+	help
+	   This driver support the STMicroelectronics UVIS25 sensor.
+
+	   To compile this driver as a module, choose M here. The module
+	   will be called uvis25.
+
+config INPUT_UVIS25_I2C
+	tristate
+	depends on INPUT_UVIS25
+	depends on I2C
+
+config INPUT_UVIS25_SPI
+	tristate
+	depends on INPUT_UVIS25
+	depends on SPI
diff -uNr a/drivers/input/misc/st/uv/uvis25/Makefile b/drivers/input/misc/st/uv/uvis25/Makefile
--- a/drivers/input/misc/st/uv/uvis25/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/uvis25/Makefile	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,7 @@
+#
+# Makefile for the input misc STM UV uvis25 driver
+#
+uvis25-core-y += uvis25_core.o
+obj-$(CONFIG_INPUT_UVIS25) += uvis25-core.o
+obj-$(CONFIG_INPUT_UVIS25_I2C) += uvis25_i2c.o
+obj-$(CONFIG_INPUT_UVIS25_SPI) += uvis25_spi.o
diff -uNr a/drivers/input/misc/st/uv/uvis25/uvis25_core.c b/drivers/input/misc/st/uv/uvis25/uvis25_core.c
--- a/drivers/input/misc/st/uv/uvis25/uvis25_core.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/uvis25/uvis25_core.c	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,549 @@
+/*
+* Copyright (C) 2016 STMicroelectronics
+*
+* Authors: Mario Tesi (mario.tesi@st.com)
+*
+* Authors is willing to be considered the contact and update points for
+* the driver.
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License
+* version 2 as published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+* 02110-1301 USA
+*
+*/
+/******************************************************************************
+ Revision 1.0.0 2016/May/20:
+	first release
+******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include "uvis25.h"
+
+/* Expected device */
+#define	WHOAMI_UVIS25	0xCA
+
+/* REGISTERS */
+#define	WHO_AM_I_REG	0x0F	/* Who Am I register */
+#define	CTRL_REG1	0x20	/* ODR control reg */
+#define	CTRL_REG2	0x21	/* boot reg */
+#define	CTRL_REG3	0x22	/* interrupt control reg */
+#define	INT_CFG_REG	0x23	/* interrupt config reg */
+#define	INT_SRC_REG	0x24	/* interrupt source reg */
+#define THS_UV 		0x25	/* Threshold register */
+#define	STATUS_REG	0x27	/* status reg */
+#define	UV_OUT_REG 	0x28	/* 8 bit output */
+
+/* Masks */
+#define	ODR_MASK	0x01	/* ctrl_reg1 */
+#define	BDU_MASK	0x02	/* ctrl_reg1 */
+#define	ONESH_MASK	0x01	/* ctrl_reg2 */
+
+/* Usefull data */
+#define	BDU_ON		BDU_MASK /* En BDU Block Data Upd */
+
+/* RESUME STATE INDICES */
+#define	RES_CTRL_REG1	0
+#define	RES_CTRL_REG2	1
+#define	RES_CTRL_REG3	2
+#define	RES_INT_CFG_REG	3
+#define	RES_THS_UV	4
+
+/* Output data rate ODR */
+#define	ODR_ONESH	0x00	/* one shot */
+#define	ODR_1_1		0x01	/* 1 Hz ODR */
+
+#define PM_OFF (ODR_MASK & ODR_ONESH)
+
+static const struct {
+	unsigned int cutoff_ms;
+	unsigned int mask;
+} uvis25_odr_table[] = {
+	{ 1000, ODR_1_1 },
+};
+
+/* Default platform data value */
+static struct uvis25_platform_data default_uvis25_pdata = {
+	.poll_interval = 1000,
+	.min_interval = UVIS25_MIN_POLL_PERIOD_MS,
+	.ev_type = INPUT_EVENT_TYPE,
+};
+
+static int uvis25_hw_init(struct uvis25_data *stat)
+{
+	int err;
+	u8 buf[2];
+
+	dev_dbg(stat->dev, "%s: hw init start\n", UVIS25_DEV_NAME);
+
+	buf[0] = stat->resume_state[RES_THS_UV];
+	err = stat->tf->write(stat, THS_UV, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG2];
+	buf[1] = stat->resume_state[RES_CTRL_REG3];
+	err = stat->tf->write(stat, CTRL_REG2, 2, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_INT_CFG_REG];
+	err = stat->tf->write(stat, INT_CFG_REG, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	buf[0] = stat->resume_state[RES_CTRL_REG1];
+	err = stat->tf->write(stat, CTRL_REG1, 1, buf);
+	if (err < 0)
+		goto err_resume_state;
+
+	stat->hw_initialized = 1;
+	dev_dbg(stat->dev, "%s: hw init done\n", UVIS25_DEV_NAME);
+
+	return 0;
+
+err_resume_state:
+	stat->hw_initialized = 0;
+	dev_err(stat->dev, "hw init error 0x%02x,0x%02x: %d\n", buf[0],
+			buf[1], err);
+
+	return err;
+}
+
+static void uvis25_device_power_off(struct uvis25_data *stat)
+{
+	int err;
+	u8 buf;
+
+	/* Power off: set ODR to 0, one shoot must be cleared but it shoul be yet
+	 * in any case set to zero and never touch more time */
+	if (stat->resume_state[RES_CTRL_REG2] & ONESH_MASK) {
+		buf = stat->resume_state[RES_CTRL_REG2] & (~ONESH_MASK);
+		err = stat->tf->write(stat, CTRL_REG2, 1, &buf);
+		if (err < 0) {
+			dev_err(stat->dev, "soft power off failed: %d\n", err);
+			
+			return;
+		}
+		stat->resume_state[RES_CTRL_REG2] = buf;
+	}
+	
+	buf = PM_OFF;
+	err = stat->tf->write(stat, CTRL_REG1, 1, &buf);
+	if (err < 0)
+		dev_err(stat->dev, "soft power off failed: %d\n", err);
+
+	stat->hw_initialized = 0;
+}
+
+static int uvis25_device_power_on(struct uvis25_data *stat)
+{
+	int err = -1;
+
+	if (!stat->hw_initialized) {
+		err = uvis25_hw_init(stat);
+		if (stat->hw_working == 1 && err < 0) {
+			uvis25_device_power_off(stat);
+
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int uvis25_update_odr(struct uvis25_data *stat, int poll_period_ms)
+{
+	int err = -1;
+	int i;
+	u8 init_val, updated_val;
+	u8 new_val;
+
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (longest period) backward (shortest
+	 * period), to support the poll_interval requested by the system.
+	 * It must be the longest period shorter then the set poll period.*/
+	for (i = ARRAY_SIZE(uvis25_odr_table) - 1; i >= 0; i--) {
+		if ((uvis25_odr_table[i].cutoff_ms <= poll_period_ms) ||
+		    (i == 0))
+			break;
+	}
+
+	new_val = uvis25_odr_table[i].mask;
+
+	/* read actual value */
+	err = stat->tf->read(stat, CTRL_REG1, 1, &init_val);
+	if (err < 0)
+		goto error;
+
+	stat->resume_state[RES_CTRL_REG1] = init_val;
+
+	/* set new ODR */
+	updated_val = (init_val & ~ODR_MASK) | new_val;
+	err = stat->tf->write(stat, CTRL_REG1, 1, &updated_val);
+	if (err < 0)
+		goto error;
+
+	/* Save new status */
+	stat->resume_state[RES_CTRL_REG1] = updated_val;
+	stat->pdata->poll_interval = uvis25_odr_table[i].cutoff_ms;
+
+	return err;
+
+error:
+	dev_err(stat->dev, "update odr failed: %d\n", err);
+
+	return err;
+}
+
+static int uvis25_get_uv_data(struct uvis25_data *stat, unsigned char *out)
+{
+	int err;
+
+	err = stat->tf->read(stat, UV_OUT_REG, 1, out);
+	if (err < 0)
+		return err;
+
+	dev_dbg(stat->dev, "UV %d = \n", *out);
+
+	return err;
+}
+
+static void uvis25_report_values(struct uvis25_data *stat, unsigned char out)
+{
+	input_event(stat->input_dev, stat->pdata->ev_type, INPUT_EVENT_X, out);
+	input_sync(stat->input_dev);
+}
+
+static int uvis25_enable(struct uvis25_data *stat)
+{
+	int err;
+
+	if (!atomic_cmpxchg(&stat->enabled, 0, 1)) {
+		err = uvis25_device_power_on(stat);
+		if (err < 0) {
+			atomic_set(&stat->enabled, 0);
+			return err;
+		}
+
+		schedule_delayed_work(&stat->input_work,
+			msecs_to_jiffies(stat->pdata->poll_interval));
+	}
+
+	return 0;
+}
+
+static int uvis25_disable(struct uvis25_data *stat)
+{
+	if (atomic_cmpxchg(&stat->enabled, 1, 0)) {
+		cancel_delayed_work_sync(&stat->input_work);
+		uvis25_device_power_off(stat);
+	}
+
+	return 0;
+}
+
+static ssize_t attr_get_polling_rate(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct uvis25_data *stat = dev_get_drvdata(dev);
+
+	mutex_lock(&stat->lock);
+	val = stat->pdata->poll_interval;
+	mutex_unlock(&stat->lock);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_polling_rate(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct uvis25_data *stat = dev_get_drvdata(dev);
+	unsigned long interval_ms;
+
+	if (strict_strtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max((unsigned int)interval_ms,
+			  stat->pdata->min_interval);
+	mutex_lock(&stat->lock);
+	stat->pdata->poll_interval = interval_ms;
+	uvis25_update_odr(stat, interval_ms);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_enable(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct uvis25_data *stat = dev_get_drvdata(dev);
+	int val = atomic_read(&stat->enabled);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t attr_set_enable(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct uvis25_data *stat = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	mutex_lock(&stat->lock);
+	if (val)
+		uvis25_enable(stat);
+	else
+		uvis25_disable(stat);
+	mutex_unlock(&stat->lock);
+
+	return size;
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(poll_period_ms, 0664, attr_get_polling_rate,
+	       attr_set_polling_rate),
+	__ATTR(enable_device, 0664, attr_get_enable, attr_set_enable),
+};
+
+static void remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		ret = device_create_file(dev, attributes + i);
+		if (ret < 0)
+			goto error;
+
+	return 0;
+
+error:
+	for ( ; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s: Unable to create interface\n", __func__);
+
+	return ret;
+}
+
+static void uvis25_input_work_func(struct work_struct *work)
+{
+	struct uvis25_data *stat = container_of((struct delayed_work *)work,
+						struct uvis25_data,
+						input_work);
+
+	unsigned char output;
+	int err;
+
+	err = uvis25_get_uv_data(stat, &output);
+	if (err < 0)
+		dev_err(stat->dev, "get data failed\n");
+	else
+		uvis25_report_values(stat, output);
+
+	schedule_delayed_work(&stat->input_work,
+			      msecs_to_jiffies(stat->pdata->poll_interval));
+}
+
+static int uvis25_input_init(struct uvis25_data *stat)
+{
+	int err;
+
+	INIT_DELAYED_WORK(&stat->input_work, uvis25_input_work_func);
+	stat->input_dev = input_allocate_device();
+	if (!stat->input_dev) {
+		dev_err(stat->dev, "input device allocate failed\n");
+		return -ENOMEM;
+	}
+
+	stat->input_dev->name = stat->name;
+	stat->input_dev->id.bustype = stat->bustype;
+	stat->input_dev->dev.parent = stat->dev;
+	input_set_drvdata(stat->input_dev, stat);
+
+	__set_bit(stat->pdata->ev_type, stat->input_dev->evbit);
+	if (stat->pdata->ev_type == EV_MSC) {
+		dev_info(stat->dev, "%s: Init event type EV_REL\n", UVIS25_DEV_NAME);
+		__set_bit(INPUT_EVENT_X, stat->input_dev->mscbit);
+	} else {
+		dev_info(stat->dev, "%s: Init event type EV_ABS\n", UVIS25_DEV_NAME);
+		__set_bit(ABS_X, stat->input_dev->absbit);
+		input_set_abs_params(stat->input_dev, ABS_X, UVIS25_MIN_UV, UVIS25_MAX_UV, 
+						     0, 0);
+	}
+		
+	err = input_register_device(stat->input_dev);
+	if (err) {
+		dev_err(stat->dev,
+			"unable to register input polled device %s\n",
+			stat->input_dev->name);
+		input_free_device(stat->input_dev);
+
+		return err;
+	}
+
+	return 0;
+}
+
+static void uvis25_input_cleanup(struct uvis25_data *stat)
+{
+	input_unregister_device(stat->input_dev);
+}
+
+int uvis25_common_probe(struct uvis25_data *stat)
+{
+	int err = -1;
+	u8 wai;
+
+	dev_info(stat->dev, "probe start.\n");
+
+	mutex_init(&stat->lock);
+	mutex_lock(&stat->lock);
+
+	/* read chip WHO_AM_I_REG */
+	err = stat->tf->read(stat, WHO_AM_I_REG, 1, &wai);
+	if (wai != WHOAMI_UVIS25) {
+		err = -ENODEV;
+		dev_err(stat->dev, "Not replying or not recognized\n");
+		goto err_mutexunlock;
+	}
+
+	stat->pdata = kzalloc(sizeof(struct uvis25_platform_data), GFP_KERNEL);
+	if (stat->pdata == NULL) {
+		err = -ENOMEM;
+		dev_err(stat->dev, "failed to allocate memory for pdata: %d\n", err);
+		goto err_mutexunlock;
+	}
+
+	/* select default or custom platform_data */
+	if (stat->dev->platform_data == NULL) {
+		memcpy(stat->pdata, &default_uvis25_pdata, sizeof(*stat->pdata));
+		dev_info(stat->dev, "using default platform_data\n");
+	} else
+		memcpy(stat->pdata, stat->dev->platform_data, sizeof(*stat->pdata));
+
+	memset(stat->resume_state, 0, ARRAY_SIZE(stat->resume_state));
+
+	/* init registers which need values different from zero */
+	stat->resume_state[RES_CTRL_REG1] = ((ODR_MASK & ODR_1_1) |
+					     (BDU_MASK & BDU_ON));
+
+	err = uvis25_device_power_on(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "power on failed: %d\n", err);
+		goto err_exit_pointer;
+	}
+
+	atomic_set(&stat->enabled, 1);
+
+	err = uvis25_update_odr(stat, stat->pdata->poll_interval);
+	if (err < 0) {
+		dev_err(stat->dev, "update_odr failed\n");
+		goto err_power_off;
+	}
+
+	err = uvis25_input_init(stat);
+	if (err < 0) {
+		dev_err(stat->dev, "input init failed\n");
+		goto err_power_off;
+	}
+
+	err = create_sysfs_interfaces(stat->dev);
+	if (err < 0) {
+		dev_err(stat->dev,
+			"device UVIS25_DEV_NAME sysfs register failed\n");
+		goto err_input_cleanup;
+	}
+
+	uvis25_device_power_off(stat);
+
+	/* As default, do not report information */
+	atomic_set(&stat->enabled, 0);
+
+	mutex_unlock(&stat->lock);
+
+	dev_info(stat->dev, "%s: probed\n", UVIS25_DEV_NAME);
+
+	return 0;
+
+err_input_cleanup:
+	uvis25_input_cleanup(stat);
+err_power_off:
+	uvis25_device_power_off(stat);
+err_exit_pointer:
+	kfree(stat->pdata);
+err_mutexunlock:
+	mutex_unlock(&stat->lock);
+
+	pr_err("%s: Driver Init failed\n", UVIS25_DEV_NAME);
+
+	return err;
+}
+EXPORT_SYMBOL(uvis25_common_probe);
+
+int uvis25_common_remove(struct uvis25_data *stat)
+{
+	cancel_delayed_work_sync(&stat->input_work);
+	uvis25_input_cleanup(stat);
+	uvis25_device_power_off(stat);
+	remove_sysfs_interfaces(stat->dev);
+	kfree(stat->pdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(uvis25_common_remove);
+
+#ifdef CONFIG_PM
+int uvis25_common_resume(struct uvis25_data *stat)
+{
+	if (stat->on_before_suspend)
+		return uvis25_enable(stat);
+		
+	pr_err("%s: Resuming Driver\n", UVIS25_DEV_NAME);
+
+	return 0;
+}
+EXPORT_SYMBOL(uvis25_common_resume);
+
+int uvis25_common_suspend(struct uvis25_data *stat)
+{
+	stat->on_before_suspend = atomic_read(&stat->enabled);
+
+	pr_err("%s: Sunspendig Driver\n", UVIS25_DEV_NAME);
+
+	return uvis25_disable(stat);
+}
+EXPORT_SYMBOL(uvis25_common_suspend);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicrolelectronics uvis25 sensor driver");
+MODULE_AUTHOR("Mario Tesi, STMicroelectronics");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/uv/uvis25/uvis25.h b/drivers/input/misc/st/uv/uvis25/uvis25.h
--- a/drivers/input/misc/st/uv/uvis25/uvis25.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/uvis25/uvis25.h	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,106 @@
+/* 
+ Copyright (C) 2016 STMicroelectronics
+ 
+ AMS - Motion Mems Division - Application Team
+
+ Mario Tesi (mario.tesi@st.com)
+
+ Authors is willing to be considered the contact and update points for
+ the driver.
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License
+ version 2 as published by the Free Software Foundation.
+
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ 02110-1301 USA
+*/
+/******************************************************************************
+ Revision 1.0.0 2016/May/21:
+	first release
+******************************************************************************/
+
+#ifndef	__UVIS25_H__
+#define	__UVIS25_H__
+
+//#define DEBUG 0
+
+#define	UVIS25_DEV_NAME		"uvis25"
+#define HAS_IF_AUTO_INCREMENT
+
+#ifdef __KERNEL__
+
+/* Sensor Operating Mode */
+#define UVIS25_MIN_POLL_PERIOD_MS	1000
+#define UVIS25_MIN_UV		0
+#define UVIS25_MAX_UV		15
+
+
+#define	RESUME_ENTRIES		5
+
+#define UVIS25_RX_MAX_LENGTH	100
+#define UVIS25_TX_MAX_LENGTH	100
+
+struct uvis25_data;
+
+struct uvis25_transfer_buffer {
+	u8 rx_buf[UVIS25_RX_MAX_LENGTH];
+	u8 tx_buf[UVIS25_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct uvis25_platform_data {
+	unsigned int poll_interval;
+	unsigned int min_interval;
+	unsigned int ev_type;
+};
+
+/* specific bus I/O functions */
+struct uvis25_transfer_function {
+	int (*write)(struct uvis25_data *stat, u8 reg_addr, int len,
+		     u8 *data);
+	int (*read)(struct uvis25_data *stat, u8 reg_addr, int len,
+		    u8 *data);
+};
+
+struct uvis25_data {
+	const char *name;
+	struct uvis25_platform_data *pdata;
+
+	struct mutex lock;
+	struct delayed_work input_work;
+	struct device *dev;
+	struct input_dev *input_dev;
+
+	int hw_initialized;
+	int hw_working;
+	u16 bustype;
+
+	atomic_t enabled;
+	int on_before_suspend;
+
+	u8 resume_state[RESUME_ENTRIES];
+	struct uvis25_transfer_buffer tb;
+	struct uvis25_transfer_function *tf;
+};
+
+/* Input Event Type */
+#define INPUT_EVENT_TYPE	EV_MSC
+#define INPUT_EVENT_X		MSC_SERIAL
+
+int uvis25_common_probe(struct uvis25_data *stat);
+int uvis25_common_remove(struct uvis25_data *stat);
+
+#ifdef CONFIG_PM
+int uvis25_common_resume(struct uvis25_data *stat);
+int uvis25_common_suspend(struct uvis25_data *stat);
+#endif /* CONFIG_PM */
+#endif /* __KERNEL__ */
+
+#endif  /* __UVIS25_H__ */
diff -uNr a/drivers/input/misc/st/uv/uvis25/uvis25_i2c.c b/drivers/input/misc/st/uv/uvis25/uvis25_i2c.c
--- a/drivers/input/misc/st/uv/uvis25/uvis25_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/uvis25/uvis25_i2c.c	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,208 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: uvis25_i2c.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+
+#include "uvis25.h"
+
+#define	I2C_RETRY_DELAY		5
+#define	I2C_RETRIES		5
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define	I2C_AUTO_INCREMENT	0x80
+#endif
+
+static int uvis25_i2c_read(struct uvis25_data *stat, u8 reg_addr,
+			   int len, u8 *data)
+{
+	int err = 0;
+	struct i2c_msg msg[2];
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	do {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 2) && (++tries < I2C_RETRIES));
+
+	return err;
+}
+
+static int uvis25_i2c_write(struct uvis25_data *stat, u8 reg_addr,
+			    int len, u8 *data)
+{
+	int err = 0;
+	u8 send[len + 1];
+	struct i2c_msg msg;
+	int tries = 0;
+	struct i2c_client *client = to_i2c_client(stat->dev);
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	reg_addr |= ((len > 1) ? I2C_AUTO_INCREMENT : 0);
+#endif
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	do {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err != 1)
+			msleep_interruptible(I2C_RETRY_DELAY);
+	} while ((err != 1) && (++tries < I2C_RETRIES));
+
+	if (err != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static struct uvis25_transfer_function uvis25_tf_i2c = {
+	.write = uvis25_i2c_write,
+	.read = uvis25_i2c_read,
+};
+
+static int uvis25_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int err;
+	struct uvis25_data *stat;
+
+	stat = kzalloc(sizeof(struct uvis25_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &client->dev;
+	stat->name = client->name;
+	stat->bustype = BUS_I2C;
+	stat->tf = &uvis25_tf_i2c;
+	i2c_set_clientdata(client, stat);
+
+	err = uvis25_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int uvis25_i2c_remove(struct i2c_client *client)
+{
+	struct uvis25_data *stat = i2c_get_clientdata(client);
+
+	uvis25_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int uvis25_suspend(struct device *dev)
+{
+	struct uvis25_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return uvis25_common_suspend(stat);
+}
+
+static int uvis25_resume(struct device *dev)
+{
+	struct uvis25_data *stat = i2c_get_clientdata(to_i2c_client(dev));
+
+	return uvis25_common_resume(stat);
+}
+
+static const struct dev_pm_ops uvis25_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(uvis25_suspend, uvis25_resume)
+};
+
+#define UVIS25_PM_OPS	(&uvis25_pm_ops)
+#else /* CONFIG_PM */
+#define UVIS25_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id uvis25_ids[] = {
+	{ UVIS25_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, uvis25_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id uvis25_id_table[] = {
+	{ .compatible = "st,uvis25", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, uvis25_id_table);
+#endif
+
+static struct i2c_driver uvis25_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = UVIS25_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = UVIS25_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = uvis25_id_table,
+#endif
+	},
+	.remove = uvis25_i2c_remove,
+	.probe    = uvis25_i2c_probe,
+	.id_table = uvis25_ids,
+};
+
+module_i2c_driver(uvis25_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics uvis25 i2c driver");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
diff -uNr a/drivers/input/misc/st/uv/uvis25/uvis25_spi.c b/drivers/input/misc/st/uv/uvis25/uvis25_spi.c
--- a/drivers/input/misc/st/uv/uvis25/uvis25_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/input/misc/st/uv/uvis25/uvis25_spi.c	2017-07-06 19:48:50.158213000 +0200
@@ -0,0 +1,202 @@
+/******************** (C) COPYRIGHT 2016 STMicroelectronics ********************
+*
+* File Name	: uvis25_spi.c
+* Authors	: AMS - Motion Mems Division - Application Team - Application Team
+*		: Giuseppe Barba <giuseppe.barba@st.com>
+*		: Mario Tesi <mario.tesi@st.com>
+*		: Author is willing to be considered the contact and update
+* Version	: V.1.0.14
+* Date		: 2016/Apr/26
+*
+********************************************************************************
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* THE PRESENT SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
+* OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, FOR THE SOLE
+* PURPOSE TO SUPPORT YOUR APPLICATION DEVELOPMENT.
+* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
+* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
+* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
+* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+*
+*******************************************************************************/
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "uvis25.h"
+
+#define SENSORS_SPI_READ	0x80
+
+#ifdef HAS_IF_AUTO_INCREMENT
+#define SPI_AUTO_INCREMENT	0x40
+#endif
+
+static int uvis25_spi_read(struct uvis25_data *stat, u8 reg_addr, int len,
+			   u8 *data)
+{
+	int err;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = stat->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = stat->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | SENSORS_SPI_READ | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	err = spi_sync(to_spi_device(stat->dev), &msg);
+	if (err)
+		return err;
+
+	memcpy(data, stat->tb.rx_buf, len);
+
+	return len;
+}
+
+static int uvis25_spi_write(struct uvis25_data *stat, u8 reg_addr, int len,
+			    u8 *data)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers = {
+		.tx_buf = stat->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= UVIS25_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+#ifdef HAS_IF_AUTO_INCREMENT
+	stat->tb.tx_buf[0] = reg_addr | ((len > 1) ? SPI_AUTO_INCREMENT : 0);
+#else
+	stat->tb.tx_buf[0] = reg_addr;
+#endif
+	memcpy(&stat->tb.tx_buf[1], data, len);
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers, &msg);
+
+	return spi_sync(to_spi_device(stat->dev), &msg);
+}
+
+static struct uvis25_transfer_function uvis25_tf_spi = {
+	.write = uvis25_spi_write,
+	.read = uvis25_spi_read,
+};
+
+static int uvis25_spi_probe(struct spi_device *spi)
+{
+	int err;
+	struct uvis25_data *stat;
+
+	stat = kzalloc(sizeof(struct uvis25_data), GFP_KERNEL);
+	if (!stat)
+		return -ENOMEM;
+
+	stat->dev = &spi->dev;
+	stat->name = spi->modalias;
+	stat->bustype = BUS_SPI;
+	stat->tf = &uvis25_tf_spi;
+	spi_set_drvdata(spi, stat);
+
+	err = uvis25_common_probe(stat);
+	if (err < 0)
+		goto free_data;
+
+	return 0;
+
+free_data:
+	kfree(stat);
+
+	return err;
+}
+
+static int uvis25_spi_remove(struct spi_device *spi)
+{
+	struct uvis25_data *stat = spi_get_drvdata(spi);
+
+	uvis25_common_remove(stat);
+	kfree(stat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int uvis25_suspend(struct device *dev)
+{
+	struct uvis25_data *stat= spi_get_drvdata(to_spi_device(dev));
+
+	return uvis25_common_suspend(stat);
+}
+
+static int uvis25_resume(struct device *dev)
+{
+	struct uvis25_data *stat = spi_get_drvdata(to_spi_device(dev));
+
+	return uvis25_common_resume(stat);
+}
+
+static const struct dev_pm_ops uvis25_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(uvis25_suspend, uvis25_resume)
+};
+
+#define UVIS25_PM_OPS	(&uvis25_pm_ops)
+#else /* CONFIG_PM */
+#define UVIS25_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id uvis25_ids[] = {
+	{ UVIS25_DEV_NAME, 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, uvis25_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id uvis25_id_table[] = {
+	{ .compatible = "st,uvis25", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, uvis25_id_table);
+#endif
+
+static struct spi_driver uvis25_spi_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = UVIS25_DEV_NAME,
+#ifdef CONFIG_PM
+		.pm = UVIS25_PM_OPS,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = uvis25_id_table,
+#endif
+	},
+	.remove = uvis25_spi_remove,
+	.probe    = uvis25_spi_probe,
+	.id_table = uvis25_ids,
+};
+
+module_spi_driver(uvis25_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics uvis25 spi driver");
+MODULE_AUTHOR("Mario Tesi");
+MODULE_LICENSE("GPL v2");
